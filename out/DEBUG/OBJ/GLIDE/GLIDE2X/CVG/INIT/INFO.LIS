INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Routines to detect memory size, strapping pin, and other initialization
	     21 ** configuration information.
	     22 **
	     23 */
	     24 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
       X     25 #ifdef _MSC_VER
       X     26 #pragma optimize ("",off)
       X     27 #endif
	     28 #include <stdio.h>
	   1639 #include <stdlib.h>
       X   3734 #ifdef BUILD_FOR_SST1
       X   3735 #include <sst.h>
       X   3736 #else
	   3737 #include <3dfx.h>
	   3868 #include <cvgregs.h>
	   4096 #include <cvgdefs.h>
	   5037 #endif
	   5038 #define FX_DLL_DEFINITION
	   5039 #include <fxdll.h>
	   5160 #include <sst1vid.h>
	   5270 #include <sst1init.h>
	   7908 
	   7909 #define XY_ONE (1<<SST_XY_FRACBITS)
	   7910 
	   7911 static FxBool 
	   7912 readAndSum4x4(FxU32 *sstbase, FxU32 x, FxU32 y, 
	   7913 		FxU32 *r_sum, FxU32 *g_sum, FxU32 *b_sum)
      1	   7914 {
      1	   7915     FxU32 rd_x, rd_y;
      1	   7916     FxU32 rd_col = 0;
      1	   7917     FxU32 rd_r, rd_g, rd_b;
      1	   7918     SstRegs *sst = (SstRegs *) sstbase;
      1	   7919 
      1	   7920     /* wait for idle board */
      1	   7921     ISET(sst->lfbMode, SST_LFB_RGBALANES_ARGB | SST_LFB_READFRONTBUFFER);
      1	   7922     sst1InitIdle(sstbase);
      2	   7923     if (x & 1) {
      2	   7924 	INIT_PRINTF(("ERROR: readAndSum4x4 must have an even X (%d)\n", x));

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      2	   7925 	return(FXFALSE);
      1	   7926     }
      1	   7927 
      1	   7928     /* get 16 pixels (4 x 4 array) from frame buffer and sum the colors */
      1	   7929     *r_sum = 0;
      1	   7930     *g_sum = 0;
      1	   7931     *b_sum = 0;
      1	   7932 
      2	   7933     for (rd_y = 0; rd_y < 4; rd_y++) {		/* read 4 scanlines */
      3	   7934 	for (rd_x = 0; rd_x < 4; rd_x ++) {
      4	   7935 	    if ((rd_x & 1)==0) {		/* read 2 pixels at a time */
      4	   7936 		rd_col =
      4	   7937 		  IGET(sstbase[(SST_LFB_ADDR + (y+rd_y)*2048 + (x+rd_x)*2) >> 2]);
      3	   7938 	    }
      3	   7939 	    else rd_col >>= 16;
      3	   7940 	    rd_r = ((rd_col >> 11) & 0x1f) << 3;
      3	   7941 	    rd_g = ((rd_col >>  5) & 0x3f) << 2;
      3	   7942 	    rd_b = ((rd_col >>  0) & 0x1f) << 3;
      3	   7943 	    *r_sum += rd_r;
      3	   7944 	    *g_sum += rd_g;
      3	   7945 	    *b_sum += rd_b;
      3	   7946 	    INIT_INFO((4,"%d,%d = rd_col: 0x%04x   rgb: %02x %02x %02x\n",
      3	   7947 		    rd_x, rd_y, (rd_col & 0xffff), rd_r, rd_g, rd_b));
      2	   7948 	}
      1	   7949     }
      1	   7950     INIT_INFO((3,"sums:  r_sum=0x%03x  g_sum=0x%03x  b_sum=0x%03x\n",
      1	   7951 		    *r_sum, *g_sum, *b_sum));
      1	   7952     return(FXTRUE);
      1	   7953 }
	   7954 
	   7955 /* xxx - Give these guys some meaningful comments */
	   7956 static FxI32 rb_tbl[0xFFF+1];
	   7957 static FxI32 g_tbl[0xFFF+1];
	   7958 
	   7959 /* draw a right angle triangle */
	   7960 static void
	   7961 drawTriangle(SstRegs *sst, int x, int y, int tSize)
      1	   7962 {
      1	   7963     ISET(sst->vA.x,x);
      1	   7964     ISET(sst->vA.y,y);
      1	   7965     ISET(sst->vB.x,x+XY_ONE*tSize);
      1	   7966     ISET(sst->vB.y,y);
      1	   7967     ISET(sst->vC.x,x);
      1	   7968     ISET(sst->vC.y,y+XY_ONE*tSize);
      1	   7969     ISET(sst->s,0);
      1	   7970     ISET(sst->t,0);
      1	   7971     ISET(sst->w,0);
      1	   7972     ISET(sst->dsdx,1<<SST_ST_FRACBITS);
      1	   7973     ISET(sst->dtdx,0);
      1	   7974     ISET(sst->dwdx,0);
      1	   7975     ISET(sst->dsdy,0);
      1	   7976     ISET(sst->dtdy,1<<SST_ST_FRACBITS);
      1	   7977     ISET(sst->dwdy,0);
      1	   7978     ISET(sst->triangleCMD,0);
      1	   7979 }
	   7980 
	   7981 static FxBool

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	   7982 initSumTables(FxU32 *sstbase)
      1	   7983 {
      1	   7984     int x=0,y=0;
      1	   7985     FxU32 tst_color;
      1	   7986     FxU32 r_sum, g_sum, b_sum;
      1	   7987     SstRegs *sst = (SstRegs *) sstbase;
      1	   7988 
      1	   7989     /* init sum array */
      2	   7990     for (r_sum = 0; r_sum <= 0xfff; r_sum++) {
      2	   7991 	rb_tbl[r_sum] = -1;
      2	   7992 	g_tbl[r_sum] = -1;
      1	   7993     }
      1	   7994 
      1	   7995     ISET(sst->fbzColorPath, SST_RGBSEL_C1 | SST_CC_PASS);
      1	   7996     ISET(sst->fbzMode, SST_DRAWBUFFER_FRONT | SST_RGBWRMASK | SST_ENDITHER);
      1	   7997 
      1	   7998     /* fill sum array */
      2	   7999     for (tst_color = 0; tst_color <= 255; tst_color++) {
      2	   8000 	INIT_INFO((2,"tst_color=0x%02x\n", tst_color));
      2	   8001 	ISET(sst->c1, (tst_color << 16) | (tst_color << 8) | tst_color);
      2	   8002 
      2	   8003 	drawTriangle(sst, x,y,36);
      2	   8004 	if(readAndSum4x4(sstbase, x,y, &r_sum,&g_sum,&b_sum) == FXFALSE)
      2	   8005 		return(FXFALSE);
      2	   8006 
      2	   8007 	/* check sums for uniqueness and then store away */
      3	   8008 	if (r_sum != b_sum) {
      3	   8009 	    INIT_PRINTF(("ERROR:  b_sum=0x%03x  r_sum=0x%03x\n", r_sum, b_sum));
      3	   8010 		return(FXFALSE);
      2	   8011 	}
      3	   8012 	if (rb_tbl[r_sum] != -1) {
      3	   8013 	    INIT_PRINTF(("ERROR:  non-unique r/b_sum=0x%03x\n", r_sum));
      3	   8014 		return(FXFALSE);
      2	   8015 	}
      2	   8016 	rb_tbl[r_sum] = tst_color;
      3	   8017 	if (g_tbl[g_sum] != -1) {
      3	   8018 	    INIT_PRINTF(("ERROR:  non-unique g_sum=0x%03x\n", g_sum));
      3	   8019 		return(FXFALSE);
      2	   8020 	}
      2	   8021 	g_tbl[g_sum] = tst_color;
      1	   8022     }
      1	   8023     return(FXTRUE);
      1	   8024 }
	   8025 
	   8026 /* remove dither to derive actual 24-bit RGB value */
	   8027 static FxBool
	   8028 unDither(FxU32 r_sum, FxU32 g_sum, FxU32 b_sum, FxU32 *result)
      1	   8029 {
      1	   8030     if (rb_tbl[r_sum] == -1 || g_tbl[g_sum] == -1 || rb_tbl[b_sum] == -1)
      2	   8031     {
      2	   8032 	INIT_PRINTF(("ERROR: unDither: invalid color sum\n"));
      2	   8033 	return(FXFALSE);
      1	   8034     }
      1	   8035     *result = (rb_tbl[r_sum] << 16) | (g_tbl[g_sum] << 8) | rb_tbl[b_sum];
      1	   8036     return(FXTRUE);
      1	   8037 }
	   8038 

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	   8039 static FxBool
	   8040 getTmuConfigData(FxU32 *sstbase, sst1DeviceInfoStruct *info)
      1	   8041 {
      1	   8042     int x=0, y=0;
      1	   8043     FxU32 r_sum, g_sum, b_sum;
      1	   8044     SstRegs *sst = (SstRegs *) sstbase;
      1	   8045     FxU32 tmuRevision;
      1	   8046 
      1	   8047     /* set trex's (all 3) to output configuration bits */
      1	   8048     ISET(SST_TREX(sst,0)->trexInit1, info->tmuInit1[0] | (1 << 18));
      1	   8049     ISET(SST_TREX(sst,1)->trexInit1, info->tmuInit1[1] | (1 << 18));
      1	   8050     ISET(SST_TREX(sst,2)->trexInit1, info->tmuInit1[2] | (1 << 18));
      1	   8051 
      1	   8052     /* render into the frame buffer */
      1	   8053     ISET(sst->fbzColorPath,
      1	   8054 	  SST_RGBSEL_TREXOUT | SST_CC_PASS | SST_ENTEXTUREMAP);
      1	   8055     ISET(sst->texBaseAddr, 0);
      1	   8056     ISET(sst->textureMode, SST_AI88 | SST_TC_PASS | SST_TCA_PASS);
      1	   8057     ISET(sst->tLOD, 0);
      1	   8058     drawTriangle(sst,x,y,36);
      1	   8059 
      1	   8060     readAndSum4x4(sstbase, x,y, &r_sum,&g_sum,&b_sum);
      2	   8061     if(GETENV(("SSTV2_TEXMAP_DISABLE"))) {
      2	   8062 	info->tmuConfig = 0x0;
      2	   8063     } else {
      2	   8064 	if(unDither(r_sum,g_sum,b_sum,&info->tmuConfig) == FXFALSE)
      2	   8065 	    return(FXFALSE);
      1	   8066     }
      1	   8067 
      1	   8068 	/////////////////////////
      1	   8069 	// Get new revision...
      1	   8070 	/////////////////////////
      1	   8071     ISET(SST_TREX(sst,0)->trexInit1, info->tmuInit1[0] | (1 << 18) |
      1	   8072 	  (5 << SST_TEX_SEND_CONFIG_SEL_SHIFT));
      1	   8073     ISET(SST_TREX(sst,1)->trexInit1, info->tmuInit1[1] | (1 << 18));
      1	   8074     ISET(SST_TREX(sst,2)->trexInit1, info->tmuInit1[2] | (1 << 18));
      1	   8075 
      1	   8076     /* render into the frame buffer */
      1	   8077     ISET(sst->fbzColorPath,
      1	   8078 	  SST_RGBSEL_TREXOUT | SST_CC_PASS | SST_ENTEXTUREMAP);
      1	   8079     ISET(sst->texBaseAddr, 0);
      1	   8080     ISET(sst->textureMode, SST_AI88 | SST_TC_PASS | SST_TCA_PASS);
      1	   8081     ISET(sst->tLOD, 0);
      1	   8082     drawTriangle(sst,x,y,36);
      1	   8083 
      1	   8084     readAndSum4x4(sstbase, x,y, &r_sum,&g_sum,&b_sum);
      1	   8085     if(unDither(r_sum,g_sum,b_sum,&tmuRevision) == FXFALSE)
      1	   8086 	return(FXFALSE);
      1	   8087 
      1	   8088     info->tmuFab[0] = (tmuRevision >> 4) & 0xf;
      1	   8089     info->tmuFab[1] = (tmuRevision >> 12) & 0xf;
      1	   8090     info->tmuFab[2] = (tmuRevision >> 20) & 0xf;
      1	   8091 
      1	   8092     /* Adjust configuration structure for "new" revision ID */
      1	   8093     info->tmuConfig &= ~(0x7 | (0x7<<7) | (0x7<<14));
      1	   8094     info->tmuConfig |= (((tmuRevision & 0x7) + 3) |
      1	   8095 	  ((((tmuRevision >> 8) & 0x7) + 3) << 7) |

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      1	   8096 	  ((((tmuRevision >> 16) & 0x7) + 3) << 14));
      1	   8097 
      1	   8098     /* reset trex's init registers */
      1	   8099     ISET(SST_TREX(sst,0)->trexInit1, info->tmuInit1[0]);
      1	   8100     ISET(SST_TREX(sst,1)->trexInit1, info->tmuInit1[1]);
      1	   8101     ISET(SST_TREX(sst,2)->trexInit1, info->tmuInit1[2]);
      1	   8102 
      1	   8103     if(GETENV(("SSTV2_TMUCFG")))
      2	   8104     {
      2	   8105 	FxU32 u;
      2	   8106 	if (SSCANF(GETENV(("SSTV2_TMUCFG")), "%u", &u) == 1)
      2	   8107 	    info->tmuConfig = u;
      1	   8108     }
      1	   8109 
      1	   8110     return(FXTRUE);
      1	   8111 }
	   8112 
	   8113 #define SENSE2 0x92F56EB0
	   8114 #define SENSE1 0xF2A916B5
	   8115 #define SENSE0 0xBADBEEF1
	   8116 
	   8117 static FxU32 sense(FxU32 *sstbase, sst1DeviceInfoStruct *info, FxU32 tmu,
	   8118 		   FxU32 mem, FxU32 init)
      1	   8119 {
      1	   8120     SstRegs *sst = (SstRegs *) sstbase;
      1	   8121     FxU32 *texAddr = (tmu<<(21-2)) + (FxU32 *)SST_TEX_ADDRESS(sst);
      1	   8122 
      1	   8123     /* set the Init0 register to enable ? MBytes of memory */
      1	   8124     sst1InitIdle(sstbase);
      1	   8125     ISET(SST_TREX(sst,tmu)->trexInit0, init | (info->tmuInit0[tmu] & ~0x7000));
      1	   8126     sst1InitIdle(sstbase);
      1	   8127 
      1	   8128     ISET(sst->texBaseAddr, 0x200000>>3);	/* set to 2 MB */
      1	   8129     ISET(texAddr[0], SENSE2);		/* write a random value */
      1	   8130 
      1	   8131     ISET(sst->texBaseAddr, 0x100000>>3);	/* set to 1 MB */
      1	   8132     ISET(texAddr[0], SENSE1);		/* write a random value */
      1	   8133 
      1	   8134     ISET(sst->texBaseAddr, 0x000000>>3);	/* set to 0 MB */
      1	   8135     ISET(texAddr[0], SENSE0);		/* write a random value */
      1	   8136 
      1	   8137     ISET(sst->texBaseAddr, mem>>3);		/* reset to 2 MB */
      1	   8138     drawTriangle(sst,0,0,4);		/* draw a 4x4 right triangle */
      1	   8139     sst1InitIdle(sstbase);
      1	   8140 
      1	   8141     mem = IGET(sstbase[SST_LFB_ADDR>>2]);
      1	   8142     INIT_INFO((2,"data=0x%08x\n", mem));
      1	   8143 
      1	   8144     /* reset the Init0 register back to its previous value */
      1	   8145     sst1InitIdle(sstbase);
      1	   8146     ISET(SST_TREX(sst,tmu)->trexInit0, info->tmuInit0[tmu]);
      1	   8147     sst1InitIdle(sstbase);
      1	   8148     return mem;
      1	   8149 }
	   8150 
	   8151 FX_EXPORT FxBool FX_CSTYLE
	   8152 sst1InitGetTmuMemory(FxU32 *sstbase, sst1DeviceInfoStruct *info, FxU32 tmu,

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	   8153 	FxU32 *TmuMemorySize)
      1	   8154 {
      1	   8155     FxU32 i,data;
      1	   8156     SstRegs *sst = (SstRegs *) sstbase;
      1	   8157 
      1	   8158     INIT_INFO((1,"sst1InitGetTmuMemory(0x%x, , %d)\n", sstbase,tmu));
      1	   8159 
      2	   8160     if(GETENV(("SSTV2_TMU_MEMSIZE"))) {
      2	   8161 	*TmuMemorySize = ATOI(GETENV(("SSTV2_TMU_MEMSIZE")));
      2	   8162 	/* If user specifies 2 MBytes on a 4 MBytes board, disable the
      2	   8163 	 * second RAS so that apps which may incorrectly store data in the
      2	   8164 	 * upper 2 Mbytes will not function properly... */
      3	   8165 	if (*TmuMemorySize == 2) {
      3	   8166 	    info->tmuInit0[tmu] &= ~SST_EN_TEX_MEM_SECOND_RAS;
      3	   8167 	    sst1InitIdle(sstbase);
      3	   8168 	    ISET(SST_TREX(sst,tmu)->trexInit0, info->tmuInit0[tmu]);
      3	   8169 	    sst1InitIdle(sstbase);
      2	   8170 	}
      2	   8171 	return(FXTRUE);
      1	   8172     }
      1	   8173 
      1	   8174     ISET(sst->lfbMode, SST_LFB_RGBALANES_ARGB | SST_LFB_READFRONTBUFFER);
      1	   8175     ISET(sst->fbzMode, SST_DRAWBUFFER_FRONT | SST_RGBWRMASK);
      1	   8176     ISET(sst->fbzColorPath,
      1	   8177 	  SST_RGBSEL_TREXOUT | SST_CC_PASS | SST_ENTEXTUREMAP);
      1	   8178     ISET(sst->textureMode, SST_RGB565 | SST_TC_REPLACE | SST_TCA_REPLACE);
      1	   8179     ISET(sst->tLOD, 0);
      1	   8180 
      1	   8181     /* setup all downstream TMUs to be in pass-thru mode */
      1	   8182     for (i=0; i<tmu; i++)
      1	   8183 	ISET(SST_TREX(sst,i)->textureMode, SST_TC_PASS | SST_TCA_PASS);
      1	   8184 
      1	   8185     /* first see if we have 4 Mbytes by writing a texel at 2MB followed by
      1	   8186        a texel at 1MB and 0MB and then rendering using the texel at 2MB
      1	   8187        if we have less memory it should not render correctly since we trash
      1	   8188        the memory locations it would wrap to
      1	   8189     */
      1	   8190 
      1	   8191     data = sense(sstbase,info,tmu,0x200000, 0x5000);
      1	   8192     if (data == SENSE2) {*TmuMemorySize = 4; return(FXTRUE);}
      1	   8193 
      1	   8194     /* set the Init0 register to enable 2 MBytes of memory and repeat test */
      1	   8195     data = sense(sstbase,info,tmu,0x100000, 0x2000);
      1	   8196     if (data == SENSE1) {*TmuMemorySize = 2; return(FXTRUE);}
      1	   8197 
      1	   8198     /* set the Init0 register to enable 1 MBytes of memory and repeat test */
      1	   8199     data = sense(sstbase,info,tmu,0x000000, 0x2000);
      1	   8200     if (data == SENSE0) {*TmuMemorySize = 1; return(FXTRUE);}
      1	   8201 
      1	   8202     INIT_PRINTF(("sst1InitGetTmuMemory() ERROR: Could not detect memory size.\n"));
      1	   8203     return(FXFALSE);
      1	   8204 }
	   8205 
	   8206 /*---------------------------------------------------------------------------
	   8207    NOTES:
	   8208   	assumes that board and registers are initialized
	   8209   	destroys part of the framebuffer

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	   8210   ---------------------------------------------------------------------------*/
	   8211 FX_EXPORT FxBool FX_CSTYLE
	   8212 sst1InitGetTmuInfo(FxU32 *sstbase, sst1DeviceInfoStruct *info)
      1	   8213 {
      1	   8214     FxU32 trev;
      1	   8215 
      1	   8216     if(initSumTables(sstbase) == FXFALSE)
      1	   8217 	return(FXFALSE);
      1	   8218     if(getTmuConfigData(sstbase,info) == FXFALSE)
      1	   8219 	return(FXFALSE);
      1	   8220 
      1	   8221     info->numberTmus = 1;
      2	   8222     if(GETENV(("SSTV2_TEXMAP_DISABLE"))) {
      2	   8223 	info->tmuRevision = 4;
      2	   8224 	sst1InitGetTmuMemory(sstbase, info, 0, &info->tmuMemSize[0]);
      2	   8225 	info->tmuMemSize[0] = 2;
      2	   8226     } else {
      2	   8227 	/* Get TMU memory size */
      2	   8228 	info->tmuRevision = info->tmuConfig & 0x7;
      2	   8229 	if(sst1InitGetTmuMemory(sstbase, info, 0, &info->tmuMemSize[0]) == FXFALSE)
      2	   8230 	  return(FXFALSE);
      1	   8231     }
      1	   8232 
      1	   8233     INIT_INFO((1,"TMU0 memory = %d MB\n", info->tmuMemSize[0]));
      2	   8234     if (info->tmuConfig & FXBIT(6)) {		/* if TMU 1 exists */
      2	   8235 	info->numberTmus++;			/* increment TMU count */
      2	   8236 	trev = (info->tmuConfig>>7) & 0x7;	/* get its revision */
      2X   8237 #if 0 /* Ignore for now... */
      2X   8238 	if (info->tmuRevision != trev) {
      2X   8239 	    INIT_PRINTF(("sst1InitGetDeviceInfo: ERROR, multiple different TMU revision IDs detected\n"));
      2X   8240 	    return(FXFALSE);
      2X   8241 	}
      2X   8242 #endif
      2	   8243 	if (sst1InitGetTmuMemory(sstbase, info, 1, &info->tmuMemSize[1]) == FXFALSE)
      2	   8244 	    return(FXFALSE);
      1	   8245     }
      2	   8246     if (info->tmuConfig & FXBIT(13)) {		/* if TMU 2 exists */
      2	   8247 	info->numberTmus++;			/* increment TMU count */
      2	   8248 	trev = (info->tmuConfig>>14) & 0x7;	/* get its revision */
      2X   8249 #if 0 /* Ignore for now... */
      2X   8250 	if (info->tmuRevision != trev) {
      2X   8251 	    INIT_PRINTF(("sst1InitGetDeviceInfo: ERROR, multiple different TMU revision IDs detected\n"));
      2X   8252 	    return(FXFALSE);
      2X   8253 	}
      2X   8254 #endif
      2	   8255 	if(sst1InitGetTmuMemory(sstbase, info, 2, &info->tmuMemSize[2]) == FXFALSE)
      2	   8256 	    return(FXFALSE);
      1	   8257     }
      1	   8258     if (GETENV(("SSTV2_NUM_TMUS")))
      1	   8259 	info->numberTmus = ATOI(GETENV(("SSTV2_NUM_TMUS")));
      1	   8260 
      1	   8261     INIT_INFO((1,"numberTMus = %d\n", info->numberTmus));
      1	   8262     return(FXTRUE);
      1	   8263 }
	   8264 
	   8265 /*
	   8266 ** fbiMemSize():

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

	   8267 **  Returns size (in MBytes) of FBI frame buffer memory
	   8268 **  Returns 0 on error
	   8269 **  NOTE: fbiMemSize() destroys the contents in memory
	   8270 **
	   8271 */
	   8272 #define LFB_PUTPIXEL(X, Y, DATA)	\
	   8273 	ISET(lfbptr[((SST_LFB_ADDR+(X<<1)+(Y<<11))>>1)], DATA)
	   8274 #define LFB_GETPIXEL(X, Y)			\
	   8275 	IGET(lfbptr[((SST_LFB_ADDR+(X<<1)+(Y<<11))>>1)])
	   8276 
	   8277 static int fbiMemSize(FxU32 *sstbase)
      1	   8278 {
      1	   8279 	SstRegs *sst = (SstRegs *) sstbase;
      1	   8280 	volatile unsigned short *lfbptr = (unsigned short *) sstbase;
      1	   8281 	FxU32 init0Save = IGET(sst->fbiInit0);
      1	   8282 	FxU32 init1Save = IGET(sst->fbiInit1);
      1	   8283 	FxU32 init2Save = IGET(sst->fbiInit2);
      1	   8284 	int retval = 0;
      1	   8285 
      1	   8286 	if(GETENV(("SSTV2_FBI_MEMSIZE")))
      1	   8287 		return(ATOI(GETENV(("SSTV2_FBI_MEMSIZE"))));
      1	   8288 
      1	   8289 	/* Enable dram refresh, disable memory fifo, and setup memory */
      1	   8290 	/* for rendering */
      1	   8291 	ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_MEM_FIFO_EN);
      1	   8292 	ISET(sst->fbiInit2, IGET(sst->fbiInit2) | SST_EN_DRAM_REFRESH);
      1	   8293 	sst1InitIdleFBI(sstbase);
      1	   8294 
      1	   8295 	/* Setup Basic rendering datapath */
      1	   8296 	ISET(sst->fbzColorPath, SST_CC_MONE);
      1	   8297 	ISET(sst->fogMode, 0x0);
      1	   8298 	ISET(sst->fbzMode, SST_RGBWRMASK | SST_ZAWRMASK | SST_DRAWBUFFER_FRONT);
      1	   8299 	sst1InitIdleFBI(sstbase);
      1	   8300 
      1	   8301 	sst1InitSetResolution(sstbase, &SST_VREZ_800X600_60, 1);
      1	   8302 	sst1InitIdleFBI(sstbase);
      1	   8303 
      1	   8304 	ISET(sst->lfbMode, SST_LFB_ZZ | SST_LFB_WRITEFRONTBUFFER |
      1	   8305 		SST_LFB_READDEPTHABUFFER);
      1	   8306 	sst1InitIdleFBI(sstbase);
      1	   8307 
      1	   8308 	/* Check for 4 MBytes... */
      1	   8309 	/* Write to Zbuffer in 800x600 resolution in upper 2 MBytes of memory */
      1	   8310 	LFB_PUTPIXEL(128, 100, 0xdead);	/* maps to row:0x216, col:0x80, bank:0x1 */
      1	   8311 	LFB_PUTPIXEL(0, 0, 0x0);
      1	   8312 	LFB_PUTPIXEL(798, 599, 0xffff);
      1	   8313 	LFB_PUTPIXEL(200, 200, 0x55aa);	/* maps to row:0x23d, col:0x104, bank:0x0 */
      1	   8314 	LFB_PUTPIXEL(20, 20, 0xffff);
      1	   8315 	LFB_PUTPIXEL(400, 400, 0x0);
      1	   8316 	sst1InitIdleFBI(sstbase);
      1	   8317 	if((LFB_GETPIXEL(128, 100) == 0xdead) &&
      2	   8318 	   (LFB_GETPIXEL(200, 200) == 0x55aa)) {
      2	   8319 		retval = 4;
      2	   8320 		ISET(sst->lfbMode, (SST_LFB_565 | SST_LFB_READBACKBUFFER));
      2	   8321 		sst1InitIdleFBI(sstbase);
      2	   8322 		goto fbiMemSizeDone;
      1	   8323 	}

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      1	   8324 
      1	   8325 	/* Check for 2 MBytes... */
      1	   8326 	/* Write to color buffer in 640x480 resolution */
      1	   8327 	sst1InitSetResolution(sstbase, &SST_VREZ_640X480_60, 0);
      1	   8328 	ISET(sst->lfbMode, SST_LFB_565 | SST_LFB_WRITEFRONTBUFFER |
      1	   8329 		SST_LFB_READFRONTBUFFER);
      1	   8330 	sst1InitIdleFBI(sstbase);
      1	   8331 	LFB_PUTPIXEL(50, 100, 0xdead);	/* maps to row:0x1e, col:0x99, bank:0x0 */
      1	   8332 	LFB_PUTPIXEL(0, 0, 0x0);
      1	   8333 	LFB_PUTPIXEL(638, 479, 0xffff);
      1	   8334 	ISET(sst->lfbMode, SST_LFB_565 | SST_LFB_WRITEBACKBUFFER |
      1	   8335 		SST_LFB_READFRONTBUFFER);
      1	   8336 	sst1InitIdleFBI(sstbase);
      1	   8337 	LFB_PUTPIXEL(178, 436, 0xaa55);	/* maps to row:0x11e, col:0x99, bank:0x0 */
      1	   8338 	LFB_PUTPIXEL(20, 20, 0x0);
      1	   8339 	LFB_PUTPIXEL(400, 400, 0xffff);
      1	   8340 	sst1InitIdleFBI(sstbase);
      1	   8341 	if(LFB_GETPIXEL(50, 100) != 0xdead)
      1	   8342 		goto check1MByte;
      1	   8343 	ISET(sst->lfbMode, (SST_LFB_565 | SST_LFB_READBACKBUFFER));
      1	   8344 	sst1InitIdleFBI(sstbase);
      2	   8345 	if(LFB_GETPIXEL(178, 436) == 0xaa55) {
      2	   8346 		retval = 2;
      2	   8347 		goto fbiMemSizeDone;
      1	   8348 	}
      1	   8349 
      1	   8350 check1MByte:
      1	   8351 	ISET(sst->lfbMode, SST_LFB_565 | SST_LFB_WRITEFRONTBUFFER |
      1	   8352 		SST_LFB_READFRONTBUFFER);
      1	   8353 	sst1InitIdleFBI(sstbase);
      1	   8354 	LFB_PUTPIXEL(10, 10, 0xdead);	/* maps to row:0x0, col:0x145, bank:0x0 */
      1	   8355 	LFB_PUTPIXEL(8, 8, 0x0);
      1	   8356 	LFB_PUTPIXEL(340, 340, 0xffff);
      1	   8357 	LFB_PUTPIXEL(100, 200, 0x5a5a);	/* maps to row:0x3c, col:0x112, bank:0x1 */
      1	   8358 	LFB_PUTPIXEL(66, 0, 0x0);
      1	   8359 	LFB_PUTPIXEL(360, 360, 0xffff);
      1	   8360 	sst1InitIdleFBI(sstbase);
      1	   8361 	if((LFB_GETPIXEL(10, 10) == 0xdead) &&
      1	   8362 	   (LFB_GETPIXEL(100, 200) == 0x5a5a))
      1	   8363 		retval = 1;
      1	   8364 
      1	   8365 fbiMemSizeDone:
      1	   8366 	/* Restore init registers to original state */
      1	   8367 	ISET(sst->fbiInit0, init0Save);
      1	   8368 	ISET(sst->fbiInit1, init1Save);
      1	   8369 	ISET(sst->fbiInit2, init2Save);
      1	   8370 	sst1InitIdleFBI(sstbase);
      1	   8371 
      1	   8372 	return(retval);
      1	   8373 }
	   8374 
	   8375 FX_EXPORT FxBool FX_CSTYLE
	   8376 sst1InitGetFbiInfo(FxU32 *sstbase, sst1DeviceInfoStruct *info)
      1	   8377 {
      1	   8378 	FxU32 u;
      1	   8379 	SstRegs *sst = (SstRegs *) sstbase;
      1	   8380 

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      1	   8381 	info->fbiMemSize = fbiMemSize(sstbase);
      1	   8382 
      1	   8383 	/* Detect board identification and memory speed */
      1	   8384 	if(GETENV(("SSTV2_FBICFG")) &&
      1	   8385 	   (SSCANF(GETENV(("SSTV2_FBICFG")), "%u", &u) == 1))
      1	   8386 		info->fbiConfig = u;
      1	   8387 	else
      1	   8388 	  info->fbiConfig = (IGET(sst->fbiInit3) & SST_FBI_MEM_TYPE) >>
      1	   8389 			SST_FBI_MEM_TYPE_SHIFT;
      1	   8390 
      1	   8391 	info->fbiBoardID = (IGET(sst->fbiInit5) >> 5) & 0xf;
      1	   8392 	if(IGET(sst->fbiInit7) & BIT(0))
      1	   8393 		info->fbiBoardID |= 0x10;
      1	   8394 
      1	   8395 	/* Detect scanline interleaving */
      1	   8396 	info->sliPaired   = sst1InitSliPaired(sstbase);
      1	   8397 	info->sliDetected = sst1InitSliDetect(sstbase);
      1	   8398 
      1	   8399 	return FXTRUE;
      1	   8400 }
	   8401 
	   8402 /*
	   8403 ** sst1InitGetDeviceInfo():
	   8404 **  Read device specific information
	   8405 **  NOTE: info pointer must point to an Info structure which has already
	   8406 **        been allocated
	   8407 **
	   8408 */
	   8409 FX_EXPORT FxBool FX_CSTYLE sst1InitGetDeviceInfo(FxU32 *sstbase, sst1DeviceInfoStruct *info)
      1	   8410 {
      1	   8411     FxBool retval;
      1	   8412 
      1	   8413     if((retval = sst1InitCheckBoard(sstbase)) == FXTRUE)
      1	   8414         *info = *sst1CurrentBoard;
      1	   8415     return(retval);
      1	   8416 }
	   8417 
	   8418 /*
	   8419 ** sst1InitFillDeviceInfo():
	   8420 **  Fill in device information
	   8421 **  NOTE: This routine destroys current contents in frame buffer memory
	   8422 **
	   8423 **
	   8424 */
	   8425 FxBool sst1InitFillDeviceInfo(FxU32 *sstbase, sst1DeviceInfoStruct *info)
      1	   8426 {
      1	   8427     FxU32 u;
      1	   8428 
      1	   8429     if(!sstbase)
      1	   8430         return(FXFALSE);
      1	   8431 
      1	   8432     if(info->tmuRevision != 0xdead)
      1	   8433         return FXTRUE;  /* if already got it, return */
      1	   8434 
      2	   8435     if(GETENV(("SSTV2_NODEVICEINFO"))) {
      2	   8436         /* fill device info struct with sane values... */
      2	   8437 	INIT_PRINTF(("sst1DeviceInfo: Filling info Struct with default values...\n"));

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      2	   8438 
      2	   8439 	if(GETENV(("SSTV2_FBICFG")) &&
      2	   8440 	   (SSCANF(GETENV(("SSTV2_FBICFG")), "%u", &u) == 1))
      2	   8441 	  info->fbiConfig = u;
      2	   8442 	else
      2	   8443 	  info->fbiConfig = 0x0;
      2	   8444 
      2	   8445 	if(GETENV(("SSTV2_TMUCFG")) &&
      2	   8446 	   (SSCANF(GETENV(("SSTV2_TMUCFG")), "%u", &u) == 1))
      2	   8447 	  info->tmuConfig = u;
      2	   8448 	else
      2	   8449 	  info->tmuConfig = 0x0;
      2	   8450 
      2	   8451 	info->numberTmus = 1;
      2	   8452 	if (info->tmuConfig & FXBIT(6)) /* if TMU 1 exists */
      2	   8453 	  info->numberTmus++;
      2	   8454 	if (info->tmuConfig & FXBIT(13)) /* if TMU 2 exists */
      2	   8455 	  info->numberTmus++;
      2	   8456 
      2	   8457 	info->tmuRevision = info->tmuConfig & 0x7;
      2	   8458 
      2	   8459 	if(GETENV(("SSTV2_FBI_MEMSIZE")))
      2	   8460 	  info->fbiMemSize = ATOI(GETENV(("SSTV2_FBI_MEMSIZE")));
      2	   8461 	else
      2	   8462 	  info->fbiMemSize = 2;
      2	   8463 
      2	   8464 	if(GETENV(("SSTV2_TMU_MEMSIZE")))
      2	   8465 	  info->tmuMemSize[0] = ATOI(GETENV(("SSTV2_TMU_MEMSIZE")));
      2	   8466 	else
      2	   8467 	  info->tmuMemSize[0] = 2;
      2	   8468 	info->tmuMemSize[1] = info->tmuMemSize[0];
      2	   8469 	info->tmuMemSize[2] = info->tmuMemSize[0];
      1	   8470     }
      2	   8471     else {
      2	   8472 	int i;
      2	   8473 
      3	   8474 	for (i=0; i<5; i++) {
      3	   8475 	  if (i)
      3	   8476 	    INIT_PRINTF(("sst1InitFillDeviceInfo(): Retry #%d for chip GetInfo()...\n", i));
      3	   8477 	  /* GetFbiInfo() must be called before GetTmuInfo() */
      3	   8478 	  if (sst1InitGetFbiInfo(sstbase, info) == FXFALSE)
      3	   8479 	    continue;
      3	   8480 	  /* get the revision ID of each TMU and verify that they are all the
      3	   8481 	     same */
      3	   8482 	  if (sst1InitGetTmuInfo(sstbase, info) == FXFALSE)
      3	   8483 	    continue;
      3	   8484 	  break;
      2	   8485 	}
      2	   8486 	if (i == 5)
      2	   8487 	  return(FXFALSE);
      1	   8488     }
      1	   8489     /* Measure silicon performance */
      1	   8490     sst1InitMeasureSiProcess(sstbase, 0); /* measure NAND-tree */
      1	   8491     sst1InitMeasureSiProcess(sstbase, 1); /* measure NOR-tree  */
      1	   8492 
      1	   8493     INIT_PRINTF(("sst1DeviceInfo: Board ID: %d\n", info->fbiBoardID));
      1	   8494     INIT_PRINTF(("sst1DeviceInfo: FbiConfig:0x%x, TmuConfig:0x%x\n",

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

      1	   8495 	        info->fbiConfig, info->tmuConfig));
      1	   8496     INIT_PRINTF(("sst1DeviceInfo: FBI Revision:%d, TMU Revison:%d, Num TMUs:%d\n",
      1	   8497 	        info->fbiRevision, info->tmuRevision, info->numberTmus));
      1	   8498     INIT_PRINTF(("sst1DeviceInfo: FBI Memory:%d, TMU[0] Memory:%d",
      1	   8499 	        info->fbiMemSize, info->tmuMemSize[0]));
      1	   8500     if (info->numberTmus > 1)
      1	   8501         INIT_PRINTF((", TMU[1] Memory:%d", info->tmuMemSize[1]));
      1	   8502     if (info->numberTmus > 2)
      1	   8503         INIT_PRINTF((", TMU[2] Memory:%d", info->tmuMemSize[2]));
      1	   8504     INIT_PRINTF(("\n"));
      2	   8505     if (sst1InitUseVoodooFile == FXTRUE) {
      2	   8506         if(iniDac == NULL)
      2	   8507 	  INIT_PRINTF(("sst1DeviceInfo: Dac Type: Unknown"));
      2	   8508 	else
      2	   8509 	  INIT_PRINTF(("sst1DeviceInfo: Dac Type: %s %s\n", 
      2	   8510 			  iniDac->dacManufacturer, iniDac->dacDevice));
      1	   8511     }
      2	   8512     else {
      2	   8513       INIT_PRINTF(("sst1DeviceInfo: Dac Type: "));
      2	   8514       if(info->fbiVideoDacType == SST_FBI_DACTYPE_ATT)
      2	   8515 	INIT_PRINTF(("AT&T ATT20C409\n"));
      2	   8516       else if(info->fbiVideoDacType == SST_FBI_DACTYPE_ICS)
      2	   8517 	INIT_PRINTF(("ICS ICS5342\n"));
      2	   8518       else if(info->fbiVideoDacType == SST_FBI_DACTYPE_TI)
      2	   8519 	INIT_PRINTF(("TI TVP3409\n"));
      2	   8520       else if(info->fbiVideoDacType == SST_FBI_DACTYPE_PROXY)
      2	   8521 	INIT_PRINTF(("(SLI PROXY)\n"));
      2	   8522       else
      2	   8523 	INIT_PRINTF(("Unknown\n"));
      1	   8524     }
      1	   8525     INIT_PRINTF(("sst1DeviceInfo: SLI Detected:%d\n", info->sliDetected));
      1	   8526 
      1	   8527     return(FXTRUE);
      1	   8528 }
	   8529 
       X   8530 #ifdef _MSC_VER
       X   8531 #pragma optimize ("",on)
       X   8532 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]INFO/OBJECT=[.OUT.DEB
UG.OBJ.GLIDE.GLIDE2X.CVG.INIT]INFO.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC
],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CV
G.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_H
W_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE
.GLIDE2X.CVG.INIT]INFO.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 

INFO                            Source Listing                   9-MAY-2021 23:43:17  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  info.c;1

 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:17"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


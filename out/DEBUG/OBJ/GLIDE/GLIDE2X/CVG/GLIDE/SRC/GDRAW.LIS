GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

	      1 /*
	      2  ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3  ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4  ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5  ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6  ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7  ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8  ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9  ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10  ** 
	     11  ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12  ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13  ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14  ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15  ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16  ** THE UNITED STATES.  
	     17  ** 
	     18  ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19  **
	     20  ** Revision 1.4.2.4  2005/04/25 23:53:59  koolsmoky
	     21  ** Fix grDrawTriangle calling convention for Linux.
	     22  ** Thanks to Ozkan Sezer <sezeroz@gmail.com>.
	     23  **
	     24  ** Revision 1.4.2.3  2005/04/23 18:27:26  koolsmoky
	     25  ** fixed grDrawTriangle triangle dispatch code
	     26  **
	     27  ** Revision 1.4.2.2  2005/01/22 14:52:01  koolsmoky
	     28  ** enabled packed argb for cmd packet type 3
	     29  **
	     30  ** Revision 1.4.2.1  2004/12/23 20:45:56  koolsmoky
	     31  ** converted to nasm syntax
	     32  ** added x86 asm, 3dnow! triangle and mmx, 3dnow! texture download optimizations
	     33  **
	     34  ** Revision 1.4  2000/01/28 20:52:17  joseph
	     35  ** Changes to support building shared libraries with PIC support.
	     36  **
	     37  ** Revision 1.3  2000/01/17 22:18:41  joseph
	     38  ** A nicer, cleaner fix than the evil hack.
	     39  **
	     40  ** Revision 1.2  2000/01/15 00:08:22  joseph
	     41  ** Evil nasty hack to fix dispatch code using binutils 2.9.5.
	     42  **
	     43  ** Revision 1.1.1.1  1999/12/07 21:49:10  joseph
	     44  ** Initial checkin into SourceForge.
	     45  **
	     46 ** 
	     47 ** 98    6/02/98 8:03p Peter
	     48 ** Mmmmm.... points
	     49 ** 
	     50 ** 97    6/01/98 6:44p Peter
	     51 ** snapped/unsnapped points
	     52 ** 
	     53 ** 96    5/20/98 3:51p Peter
	     54 ** no fifo glide
	     55 ** 
	     56 ** 95    5/18/98 12:14p Peter
	     57 ** better point code

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

	     58 ** 
	     59 ** 94    2/20/98 11:00a Peter
	     60 ** removed glide3 from glid2 tree
	     61 ** 
	     62 ** 93    2/11/98 5:23p Peter
	     63 ** workaround for tombraider rgb > 255.0
	     64  * 
	     65  * 92    1/15/98 2:46p Atai
	     66  * fixed grDrawPoint and grDrawLine in aa mode
	     67  * 
	     68  * 90    12/17/97 4:45p Peter
	     69  * groundwork for CrybabyGlide
	     70  * 
	     71  * 89    12/15/97 5:52p Atai
	     72  * disable obsolete glide2 api for glide3
	     73  * 
	     74  * 85    12/08/97 12:06p Atai
	     75  * change prototype for grDrawPoint, grDrawLine, grDrawTriangel
	     76  * 
	     77  * 83    11/21/97 6:05p Atai
	     78  * use one datalist (tsuDataList) in glide3
	     79  * 
	     80  * 82    11/21/97 3:20p Peter
	     81  * direct writes tsu registers
	     82  * 
	     83  * 81    11/19/97 4:33p Atai
	     84  * make vSize debug variable
	     85  * 
	     86  * 80    11/18/97 4:36p Peter
	     87  * chipfield stuff cleanup and w/ direct writes
	     88  * 
	     89  * 79    11/17/97 4:55p Peter
	     90  * watcom warnings/chipfield stuff
	     91  * 
	     92  * 78    11/16/97 2:20p Peter
	     93  * cleanup
	     94  * 
	     95  * 77    11/15/97 7:43p Peter
	     96  * more comdex silliness
	     97  * 
	     98  */
	     99 #include <memory.h>
	   1133 
	   1134 #include <3dfx.h>
	   1265 
	   1266 #define FX_DLL_DEFINITION
	   1267 #include <fxdll.h>
	   1388 #include <glide.h>
	   3330 #include "fxglide.h"
	  14674 
       X  14675 #if GLIDE_DISPATCH_SETUP
       X  14676 #include "fxinline.h"
       X  14677 #endif
	  14678 
	  14679 #define SST_XY_HALF      (1 << (SST_XY_FRACBITS - 1))
	  14680 #define SST_XY_ONE       (1 << SST_XY_FRACBITS)
	  14681 

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

	  14682 #define OUTBOUNDSX(a) ((a->x < 0.f ? 1 : 0) || (a->x > gc->state.screen_width ? 1 : 0))
	  14683 #define OUTBOUNDSY(a) ((a->y < 0.f ? 1 : 0) || (a->y > gc->state.screen_height ? 1 : 0))
	  14684 #define OUTBOUNDS(a) (OUTBOUNDSX(a) || OUTBOUNDSY(a))
	  14685 
	  14686 /*---------------------------------------------------------------------------
	  14687 ** grDrawPoint
	  14688 */
	  14689 GR_ENTRY(grDrawPoint, void, (const GrVertex *p))
      1	  14690 {
      1	  14691 #define FN_NAME "grDrawPoint"
      1	  14692   FxU32 x, y;
      1	  14693   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
      1	  14694   GDBG_INFO_MORE(gc->myLevel, "(0x%X) : (%f %f)\n", p, p->x, p->y);
      1	  14695 
      1	  14696   GR_FLUSH_STATE();
      1	  14697 
      1	  14698   /* we snap to an integer by adding a large enough number that it
      1	  14699    * shoves all fraction bits off the right side of the mantissa.
      1	  14700    *
      1	  14701    * NB: IEEE rounds to nearest integer by default, but applications
      1	  14702    * can change the rounding mode so that it is difficult to get the
      1	  14703    * correct truncation/ceiling operation w/ a simple adjustment to
      1	  14704    * the bias. 
      1	  14705    *
      1	  14706    * NB: The constant kNumMantissaBits defines how many bits of
      1	  14707    * integer precision a coordinate can have. This needs to be atleast
      1	  14708    * as large as the maximum hw screen resolution. We later use this
      1	  14709    * to compute a logical 1/2 value to fill an entire pixel.
      1	  14710    */
      1	  14711 #define kNumMantissaBits 18UL
      2	  14712   {
      2	  14713     const float bias  = (const float)(3UL << kNumMantissaBits);
      2	  14714 
      2	  14715     /* Convert to 32-bit representation */
      2	  14716 #define FP_TRUNC_BIAS(__fpVal, __fpBias) \
      2	  14717     ((__fpVal) < (__fpBias) ? (float)((__fpVal) + (__fpBias)) : (__fpVal))
      2	  14718     _GlideRoot.pool.ftemp1 = FP_TRUNC_BIAS(p->x, bias);
      2	  14719     _GlideRoot.pool.ftemp2 = FP_TRUNC_BIAS(p->y, bias);
      2	  14720 
      2	  14721     /* Mask off the real fractional bits from the mantissa */
      2	  14722     x = ((*(FxU32*)&_GlideRoot.pool.ftemp1 & (0xFFFFFFFFUL << (22UL - kNumMantissaBits))) +
      2	  14723          (0x01UL << (22UL - kNumMantissaBits)));
      2	  14724     y = ((*(FxU32*)&_GlideRoot.pool.ftemp2 & (0xFFFFFFFFUL << (22UL - kNumMantissaBits))) +
      2	  14725          (0x01UL << (22UL - kNumMantissaBits)));
      1	  14726   }
      1	  14727 
      1	  14728   /* draw a little triangle, with the lower left corner at pixel center. */
      1X  14729 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1	  14730   /* The approach here is to split the triangle into two packets, one
      1	  14731    * that sends just the coordinates of the last two points of the
      1	  14732    * triangle w/ no other parameter information, and then the
      1	  14733    * centered point w/ all of the parameter information. The first
      1	  14734    * packet is has a BDD command, but is incomplete, so nothing
      1	  14735    * draws, the next packet has a DDD command so will complete the
      1	  14736    * triangle from the first packet sent.
      1X  14737    */
      1X  14738   GR_SET_EXPECTED_SIZE((sizeof(FxU32) << 2) +     /* Size of Initial coordinate packet */

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  14739                        _GlideRoot.curVertexSize,  /* The full coordinate vertex */
      1X  14740                        2);                        /* We do two split packets */
      1X  14741   TRI_PACKET_BEGIN(kSetupStrip | kSetupCullDisable, 0x00,
      1X  14742                    0x02, sizeof(FxU32) << 1, SSTCP_PKT3_BDDDDD);
      1X  14743   {
      1X  14744     /* Lower right corner */
      1X  14745     TRI_SET(x);
      1X  14746     TRI_SET(y);
      1X  14747 
      1X  14748     /* Upper right corner. */
      1X  14749     y -= (0x01UL << (21UL - kNumMantissaBits));
      1X  14750     TRI_SET(x);
      1X  14751     TRI_SET(y);
      1X  14752 
      1X  14753     /* Upper Left corner */
      1X  14754     x -= (0x01UL << (21UL - kNumMantissaBits));
      1X  14755   }
      1X  14756   TRI_END;
      1X  14757 
      1X  14758   /* Packet w/ actual point coordinate and parameter data */
      1X  14759   TRI_PACKET_BEGIN(kSetupStrip | kSetupCullDisable, gc->cmdTransportInfo.paramMask, 
      1X  14760                    1, _GlideRoot.curVertexSize, SSTCP_PKT3_DDDDDD);
      1X  14761   {
      1X  14762     TRI_SET(x);
      1X  14763     TRI_SET(y);
      1X  14764             
      1X  14765     /* Vertex parameters */
      1X  14766     {
      1X  14767       const int* dataList = gc->tsuDataList;
      1X  14768 
      1X  14769 #if GLIDE_PACKED_RGB
      1X  14770       if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  14771         FxU32 packedColor = 0x00;
      1X  14772             
      1X  14773         if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  14774           packedColor = (RGBA_COMP_CLAMP(FARRAY(p, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  14775                          RGBA_COMP_CLAMP(FARRAY(p, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  14776                          RGBA_COMP_CLAMP(FARRAY(p, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  14777               
      1X  14778           dataList++;
      1X  14779         }
      1X  14780             
      1X  14781         if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  14782           packedColor |= RGBA_COMP_CLAMP(FARRAY(p, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  14783           dataList++;
      1X  14784         }
      1X  14785             
      1X  14786         TRI_SET(packedColor);
      1X  14787       }
      1X  14788 #endif /* GLIDE_PACKED_RGB */
      1X  14789 
      1X  14790 #if GLIDE_FP_CLAMP_TEX
      1X  14791       while(*dataList != 0) {
      1X  14792         TRI_SETF(FARRAY(p, *dataList));
      1X  14793         dataList++;
      1X  14794       }
      1X  14795 

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  14796       dataList++;
      1X  14797 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  14798                
      1X  14799       while(*dataList != 0) {
      1X  14800         TRI_SETF_CLAMP(FARRAY(p, *dataList));
      1X  14801         dataList++;
      1X  14802       }
      1X  14803     }
      1X  14804   }
      1X  14805   TRI_END;
      1X  14806   GR_CHECK_SIZE();
      1X  14807       
      1X  14808   _GlideRoot.stats.pointsDrawn++;
      1X  14809 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  14810   /* GMT: gross overestimate of fifo requirements */   
      1	  14811   GR_SET_EXPECTED_SIZE(_GlideRoot.curTriSize, _GlideRoot.curTriSize >> 2);
      2	  14812   {
      2	  14813     const struct dataList_s* dlp = gc->regDataList;
      2	  14814     int i;
      2	  14815          
      2X  14816 #ifdef GLIDE_USE_ALT_REGMAP
      2X  14817     hw = SST_WRAP(hw,128);                /* use alternate register mapping */
      2X  14818 #endif
      2	  14819          
      2	  14820     GR_SET(BROADCAST_ID, hw, FvA.x, x);
      2	  14821     GR_SET(BROADCAST_ID, hw, FvA.y, y);
      2	  14822      
      2	  14823     x += (0x01UL << (22UL - kNumMantissaBits));
      2	  14824     GR_SET(BROADCAST_ID, hw, FvB.x, x);
      2	  14825     GR_SET(BROADCAST_ID, hw, FvB.y, y);
      2	  14826 
      2	  14827     y += (0x01UL << (22UL - kNumMantissaBits));
      2	  14828     GR_SET(BROADCAST_ID, hw, FvC.x, x);
      2	  14829     GR_SET(BROADCAST_ID, hw, FvC.y, y);
      2	  14830 
      2	  14831     i = _GlideRoot.stats.pointsDrawn++;
      2	  14832     _GlideRoot.stats.pointsDrawn = ++i;
      2	  14833       
      2	  14834     dlp = gc->regDataList;
      2	  14835     i = dlp->i;      
      2	  14836          
      2	  14837     /* we don't care what the slopes are because the pixel center that is drawn */
      2	  14838     /* is exactly at vertex A - isn't that wonderful */
      3	  14839     while (i) {
      3	  14840       GR_SETF_INDEX(BROADCAST_ID, hw, ((FxU32*)dlp->addr - (FxU32*)hw), FARRAY(p,i));
      3	  14841       dlp++;
      3	  14842       i = dlp->i;
      2	  14843     }
      2	  14844 
      2	  14845     GR_SET(BROADCAST_ID, hw, triangleCMD, 1);
      1	  14846   }
      1	  14847   GR_CHECK_SIZE();
      1	  14848 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  14849    
      1	  14850   GR_END();
      1	  14851 #undef FN_NAME
      1	  14852 } /* grDrawPoint */

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

	  14853 
	  14854 /*---------------------------------------------------------------------------
	  14855  ** grDrawLine
	  14856  **
	  14857  ** NOTE: 1. this will not fill the last pixel in line because
	  14858  **          B2 or C is on the right edge and the right edge is not
	  14859  **          drawn.
	  14860  ** (0,0)
	  14861  **
	  14862  **  A(x1,y1-0.5)+
	  14863  **              |  \
	  14864  **              |  \  \
	  14865  **       (x1,y1)*         \
	  14866  **              |  *           \
	  14867  **              |     *\           \
	  14868  ** B1(x1,y1+0.5)+         *             \
	  14869  **                 \        \ *            +B2(x2,y2-0.5)
	  14870  **                     \          *        |
	  14871  **                        \       \    *   |
	  14872  **                             \     \     +  (x2,y2)
	  14873  **                                 \       |
	  14874  **                                      \  |
	  14875  **                                         +C(x2,y2+0.5)
	  14876  */
	  14877 
	  14878 GR_ENTRY(grDrawLine, void, (const GrVertex *a, const GrVertex *b))
      1	  14879 {
      1	  14880 #define FN_NAME "grDrawLine"
      1	  14881   int i, j;
      1	  14882 
      1	  14883 #define  DX _GlideRoot.pool.ftemp1
      1	  14884 #define ADY _GlideRoot.pool.ftemp2
      1	  14885 
      1	  14886   GR_BEGIN_NOFIFOCHECK("grDrawLine", 91);
      1	  14887   GDBG_INFO_MORE(gc->myLevel, "A: (%f %f) B: (%f %f)\n", 
      1	  14888                  a->x, a->y, b->x, b->y);
      1	  14889 
      1	  14890   GR_FLUSH_STATE();
      1	  14891 
      1	  14892   /*
      1	  14893   ** compute absolute deltas and draw from low Y to high Y
      1	  14894   */
      1	  14895   ADY = b->y - a->y;
      1	  14896   i = *(long *)&ADY;
      2	  14897   if (i < 0) {
      2	  14898     const GrVertex *tv;
      2	  14899     tv = a; a = b; b = tv;
      2	  14900     i ^= 0x80000000;            /* ady = -ady; */
      2	  14901     (*(long *)&ADY) = i;
      1	  14902   }
      1	  14903 
      1	  14904   DX = b->x - a->x;
      1	  14905   j = *(long *)&DX;
      2	  14906   if (j < 0) {
      2	  14907     j ^= 0x80000000;            /* adx = -adx; */
      1	  14908   }
      1	  14909   

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1	  14910   /* check for zero-length lines */
      1	  14911   if ((j >= i) && (j == 0)) goto all_done;
      1	  14912 
      1X  14913 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  14914   /* One packet w/ 4 vertices */
      1X  14915   GR_SET_EXPECTED_SIZE((_GlideRoot.curVertexSize << 2), 1);
      1X  14916   {
      1X  14917     const float* const fa = (float*)a;
      1X  14918     const float* const fb = (float*)b;
      1X  14919     
      1X  14920     /* Draw the triangle pair as a strip of 4 vertices.
      1X  14921      * We can skip all of the gradient calculation stuff.
      1X  14922      *
      1X  14923      * NB: There are two cases, x/y major lines, and each of these
      1X  14924      * loops are unrolled to send one set of endpoints of the 'line'
      1X  14925      * per iteration since we can use the same bias per iteration.
      1X  14926      */
      1X  14927     TRI_PACKET_BEGIN(kSetupCullDisable | kSetupStrip, gc->cmdTransportInfo.paramMask,
      1X  14928                          0x04UL, _GlideRoot.curVertexSize, SSTCP_PKT3_BDDDDD);
      1X  14929     {
      1X  14930       float fBias = - _GlideRoot.pool.fHalf;
      1X  14931       int vIndex;
      1X  14932 
      1X  14933       /* x macjor */
      1X  14934       if (j >= i) {
      1X  14935         for(vIndex = 0; vIndex < 2; vIndex++) {
      1X  14936           TRI_SETF(fb[GR_VERTEX_X_OFFSET]);
      1X  14937           TRI_SETF(fb[GR_VERTEX_Y_OFFSET] + fBias);
      1X  14938 
      1X  14939           {
      1X  14940             const int* dataList = gc->tsuDataList;
      1X  14941 
      1X  14942 #if GLIDE_PACKED_RGB
      1X  14943           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  14944             FxU32 packedColor = 0x00;
      1X  14945             
      1X  14946             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  14947               packedColor = (RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  14948                              RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  14949                              RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  14950               
      1X  14951               dataList++;
      1X  14952             }
      1X  14953             
      1X  14954             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  14955               packedColor |= RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  14956               dataList++;
      1X  14957             }
      1X  14958             
      1X  14959             TRI_SET(packedColor);
      1X  14960           }
      1X  14961 #endif /* GLIDE_PACKED_RGB */
      1X  14962 
      1X  14963 #if GLIDE_FP_CLAMP_TEX
      1X  14964             while(*dataList != 0) {       
      1X  14965               TRI_SETF(FARRAY(fb, *dataList));
      1X  14966               dataList++;

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  14967             }
      1X  14968             
      1X  14969             dataList++;
      1X  14970 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  14971           
      1X  14972             while(*dataList != 0) {
      1X  14973               TRI_SETF_CLAMP(FARRAY(fb, *dataList));
      1X  14974               dataList++;
      1X  14975             }
      1X  14976           }
      1X  14977 
      1X  14978           TRI_SETF(fa[GR_VERTEX_X_OFFSET]);
      1X  14979           TRI_SETF(fa[GR_VERTEX_Y_OFFSET] + fBias);
      1X  14980 
      1X  14981           {
      1X  14982             const int* dataList = gc->tsuDataList;
      1X  14983 
      1X  14984 #if GLIDE_PACKED_RGB
      1X  14985           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  14986             FxU32 packedColor = 0x00;
      1X  14987             
      1X  14988             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  14989               packedColor = (RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  14990                              RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  14991                              RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  14992               
      1X  14993               dataList++;
      1X  14994             }
      1X  14995             
      1X  14996             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  14997               packedColor |= RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  14998               dataList++;
      1X  14999             }
      1X  15000             
      1X  15001             TRI_SET(packedColor);
      1X  15002           }
      1X  15003 #endif /* GLIDE_PACKED_RGB */
      1X  15004 
      1X  15005 #if GLIDE_FP_CLAMP_TEX
      1X  15006             while(*dataList != 0) {       
      1X  15007               TRI_SETF(FARRAY(fa, *dataList));
      1X  15008               dataList++;
      1X  15009             }
      1X  15010 
      1X  15011             dataList++;
      1X  15012 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  15013           
      1X  15014             while (*dataList != 0) {
      1X  15015               TRI_SETF_CLAMP(FARRAY(fa, *dataList));
      1X  15016               dataList++;
      1X  15017             }
      1X  15018           }
      1X  15019 
      1X  15020           fBias *= -1.0f;       
      1X  15021         }
      1X  15022       } else { /* y major */
      1X  15023         for(vIndex = 0; vIndex < 2; vIndex++) {

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15024           TRI_SETF(fb[GR_VERTEX_X_OFFSET] + fBias);
      1X  15025           TRI_SETF(fb[GR_VERTEX_Y_OFFSET]);
      1X  15026 
      1X  15027           {
      1X  15028             const int* dataList = gc->tsuDataList;
      1X  15029 
      1X  15030 #if GLIDE_PACKED_RGB
      1X  15031           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  15032             FxU32 packedColor = 0x00;
      1X  15033             
      1X  15034             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  15035               packedColor = (RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  15036                              RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  15037                              RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  15038               
      1X  15039               dataList++;
      1X  15040             }
      1X  15041             
      1X  15042             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  15043               packedColor |= RGBA_COMP_CLAMP(FARRAY(fb, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  15044               dataList++;
      1X  15045             }
      1X  15046             
      1X  15047             TRI_SET(packedColor);
      1X  15048           }
      1X  15049 #endif /* GLIDE_PACKED_RGB */
      1X  15050 
      1X  15051 #if GLIDE_FP_CLAMP_TEX
      1X  15052             while(*dataList != 0) {       
      1X  15053               TRI_SETF(FARRAY(fb, *dataList));
      1X  15054               dataList++;
      1X  15055             }
      1X  15056 
      1X  15057             dataList++;
      1X  15058 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  15059           
      1X  15060             while (*dataList != 0) {
      1X  15061               TRI_SETF_CLAMP(FARRAY(fb, *dataList));
      1X  15062               dataList++;
      1X  15063             }
      1X  15064           }
      1X  15065         
      1X  15066           TRI_SETF(fa[GR_VERTEX_X_OFFSET] + fBias);
      1X  15067           TRI_SETF(fa[GR_VERTEX_Y_OFFSET]);
      1X  15068 
      1X  15069           {
      1X  15070             const int* dataList = gc->tsuDataList;
      1X  15071 
      1X  15072 #if GLIDE_PACKED_RGB
      1X  15073           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  15074             FxU32 packedColor = 0x00;
      1X  15075             
      1X  15076             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  15077               packedColor = (RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  15078                              RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  15079                              RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  15080               

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15081               dataList++;
      1X  15082             }
      1X  15083             
      1X  15084             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  15085               packedColor |= RGBA_COMP_CLAMP(FARRAY(fa, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  15086               dataList++;
      1X  15087             }
      1X  15088             
      1X  15089             TRI_SET(packedColor);
      1X  15090           }
      1X  15091 #endif /* GLIDE_PACKED_RGB */
      1X  15092 
      1X  15093 #if GLIDE_FP_CLAMP_TEX
      1X  15094             while(*dataList != 0) {       
      1X  15095               TRI_SETF(FARRAY(fa, *dataList));
      1X  15096               dataList++;
      1X  15097             }
      1X  15098 
      1X  15099             dataList++;
      1X  15100 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  15101           
      1X  15102             while (*dataList != 0) {
      1X  15103               TRI_SETF_CLAMP(FARRAY(fa, *dataList));
      1X  15104               dataList++;
      1X  15105             }
      1X  15106           }
      1X  15107         
      1X  15108           fBias *= -1.0f;
      1X  15109         }
      1X  15110       }
      1X  15111     }
      1X  15112     TRI_END;
      1X  15113   }
      1X  15114   GR_CHECK_SIZE();
      1X  15115 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1X  15116 #ifdef GLIDE_USE_ALT_REGMAP
      1X  15117   hw = SST_WRAP(hw,128);        /* use alternate register mapping */
      1X  15118 #endif
      1	  15119 
      1	  15120   GR_SET_EXPECTED_SIZE(12 + _GlideRoot.curTriSize, (_GlideRoot.curTriSize + 12) >> 2);  
      2	  15121   {
      2	  15122     float    m, dp;
      2	  15123     struct dataList_s* dlp;
      2	  15124 
      2	  15125     /*
      2	  15126     ** X major line
      2	  15127     */
      3	  15128     if (j >= i) {               /* if (adx > ady) */
      3	  15129       if (j == 0) goto all_done; /* check for zero-length lines */
      3	  15130       /* start up divide and overlap with as much integer stuff as possible*/
      3	  15131       m = _GlideRoot.pool.f1 / DX;
      3	  15132       dlp = gc->regDataList;
      3	  15133       GR_SETF(BROADCAST_ID, hw, FvA.x, a->x);
      3	  15134       dp = b->x;
      3	  15135       GR_SETF(BROADCAST_ID, hw, FvB.x, dp);
      3	  15136       GR_SETF(BROADCAST_ID, hw, FvC.x, dp);
      3	  15137       

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      3	  15138       GR_SETF(BROADCAST_ID, hw, FvA.y, a->y - _GlideRoot.pool.fHalf);
      3	  15139 
      3	  15140       dp = b->y;
      3	  15141       GR_SETF(BROADCAST_ID, hw, FvB.y, dp - _GlideRoot.pool.fHalf);
      3	  15142 
      3	  15143       i = dlp->i;
      3	  15144       GR_SETF(BROADCAST_ID, hw, FvC.y, dp + _GlideRoot.pool.fHalf);
      3	  15145 
      4	  15146       while (i) {
      4	  15147         dp = FARRAY(a,i);
      4	  15148         GR_SETF_INDEX(BROADCAST_ID, hw, 
      4	  15149                       ((FxU32*)dlp->addr - (FxU32*)hw), dp);
      4	  15150 
      4	  15151         dp = FARRAY(b,i) - dp;
      4	  15152         GR_SETF_INDEX(BROADCAST_ID, hw, 
      4	  15153                       ((FxU32*)&dlp->addr[DPDX_OFFSET >> 2] - (FxU32*)hw), dp * m);
      4	  15154 
      4	  15155         dlp++;
      4	  15156         i = dlp->i;
      4	  15157         GR_SETF_INDEX(BROADCAST_ID, hw, 
      4	  15158                       ((FxU32*)&dlp->addr[DPDY_OFFSET >> 2] - (FxU32*)hw), _GlideRoot.pool.f0);
      3	  15159       }
      3	  15160       GR_SETF(BROADCAST_ID, hw, FtriangleCMD,_GlideRoot.pool.ftemp1);
      3	  15161 
      3	  15162       GR_SETF(BROADCAST_ID, hw, FvB.x,a->x);
      3	  15163       GR_SETF(BROADCAST_ID, hw, FvB.y,a->y + _GlideRoot.pool.fHalf);
      3	  15164       GR_SETF(BROADCAST_ID, hw, FtriangleCMD,-_GlideRoot.pool.ftemp1);
      2	  15165     }
      2	  15166 
      2	  15167     /*
      2	  15168     ** Y major line
      2	  15169     */
      3	  15170     else {
      3	  15171       m = _GlideRoot.pool.f1 / ADY;
      3	  15172       dlp = gc->regDataList;
      3	  15173       GR_SETF(BROADCAST_ID, hw, FvA.y,a->y);
      3	  15174       dp = b->y;
      3	  15175       GR_SETF(BROADCAST_ID, hw, FvB.y,dp);
      3	  15176       GR_SETF(BROADCAST_ID, hw, FvC.y,dp);
      3	  15177      
      3	  15178       GR_SETF(BROADCAST_ID, hw, FvA.x,a->x - _GlideRoot.pool.fHalf);
      3	  15179 
      3	  15180       dp = b->x;
      3	  15181       GR_SETF(BROADCAST_ID, hw, FvB.x,dp - _GlideRoot.pool.fHalf);
      3	  15182 
      3	  15183       i = dlp->i;
      3	  15184       GR_SETF(BROADCAST_ID, hw, FvC.x,dp + _GlideRoot.pool.fHalf);
      3	  15185        
      4	  15186       while (i) {
      4	  15187         dp = FARRAY(a,i);
      4	  15188         GR_SETF_INDEX(BROADCAST_ID, hw, ((FxU32*)dlp->addr - (FxU32*)hw), dp);
      4	  15189 
      4	  15190         dp = FARRAY(b,i) - dp;
      4	  15191         GR_SETF_INDEX(BROADCAST_ID, hw,
      4	  15192                       ((FxU32*)&dlp->addr[DPDX_OFFSET >> 2] - (FxU32*)hw), _GlideRoot.pool.f0);
      4	  15193 
      4	  15194         dlp++;

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      4	  15195         i = dlp->i;
      4	  15196         GR_SETF_INDEX(BROADCAST_ID, hw, 
      4	  15197                       ((FxU32*)&dlp->addr[DPDY_OFFSET >> 2] - (FxU32*)hw), dp * m);
      3	  15198       }
      3	  15199       GR_SET(BROADCAST_ID, hw, triangleCMD, 0xFFFFFFFF);
      3	  15200      
      3	  15201       GR_SETF(BROADCAST_ID, hw, FvB.x, a->x + _GlideRoot.pool.fHalf);
      3	  15202       GR_SETF(BROADCAST_ID, hw, FvB.y, a->y);
      3	  15203       GR_SET(BROADCAST_ID, hw, triangleCMD, 1);
      2	  15204     }
      1	  15205   }
      1	  15206   GR_CHECK_SIZE();
      1	  15207 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15208 
      1	  15209 all_done:                       /* come here on degenerate lines */
      1	  15210   _GlideRoot.stats.linesDrawn++;
      1	  15211 
      1	  15212   GR_END();
      1	  15213 #undef FN_NAME
      1	  15214 } /* grDrawLine */
	  15215 
	  15216 /*---------------------------------------------------------------------------
	  15217  ** grDrawTriangle
	  15218  */
	  15219 #ifndef HAVE_XDRAWTRI_ASM	/* grDrawTriangle() not in asm */
       X  15220 #if defined(_MSC_VER) && !GLIDE_USE_C_TRISETUP && !defined(GLIDE_DEBUG)
       X  15221 __declspec(naked)
       X  15222 #endif
	  15223 GR_ENTRY(grDrawTriangle, void, (const GrVertex *a, const GrVertex *b, const GrVertex *c))
      1	  15224 {
      1	  15225 #define FN_NAME grDrawTriangle
      1	  15226 #if defined(GLIDE_USE_C_TRISETUP) || defined(__WATCOMC__) || defined(GLIDE_DEBUG)
      1	  15227   GR_BEGIN_NOFIFOCHECK("grDrawTriangle",92);
      1	  15228   GDBG_INFO_MORE(gc->myLevel,"(0x%x,0x%x,0x%x)\n",a,b,c);
      1	  15229   GR_CHECK_F(myName, !a || !b || !c, "NULL pointer passed");
      1	  15230 
      1	  15231   GR_FLUSH_STATE();
      1	  15232 
      1	  15233   /* Silly warning killer */
      1	  15234   if (0) goto all_done;
      1	  15235 
      1X  15236 #ifdef GLIDE_DEBUG
      1X  15237   if (_GlideRoot.environment.triBoundsCheck) {
      1X  15238     if (OUTBOUNDS(a) || OUTBOUNDS(b) || OUTBOUNDS(c)) {
      1X  15239       GDBG_PRINTF("Triangle out of bounds:\n");
      1X  15240       GDBG_PRINTF("a->x = %3.2f, a->y = %3.2f\n", a->x, a->y);
      1X  15241       GDBG_PRINTF("b->x = %3.2f, b->y = %3.2f\n", b->x, b->y);
      1X  15242       GDBG_PRINTF("c->x = %3.2f, c->y = %3.2f\n", c->x, c->y);
      1X  15243       GDBG_PRINTF("Culling triangle based on these bogus values.\n");
      1X  15244       goto all_done;
      1X  15245     }
      1X  15246   }
      1X  15247 #endif /* GLIDE_DEBUG */
      1	  15248 
      1	  15249   /* _trisetup and _trisetup_asm return 0 if culled, 1 if drawn */ 
      1X  15250 #if GLIDE_DEBUG && !GLIDE_USE_C_TRISETUP
      1	  15251   /* HackAlert: Nuke the fifo ptr checking stuff here if we're just

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1	  15252    * debugging teh asm tri code.
      1X  15253    */
      1X  15254   if (TRISETUP(a, b, c) != 0) {
      1X  15255     gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr;
      1X  15256     gc->checkCounter = 0;
      1X  15257   }
      1X  15258 #else
      1	  15259   TRISETUP(a, b, c);
      1	  15260 #endif
      1	  15261 
      1	  15262 all_done:
      1	  15263   GR_END();
      1	  15264 
      1X  15265 #elif defined(_MSC_VER)
      1X  15266   {
      1X  15267     __asm {
      1X  15268       mov edx, [_GlideRoot + kCurGCOffset];
      1X  15269       mov eax, [edx + kTriProcOffset];
      1X  15270       jmp eax;
      1X  15271     }
      1X  15272   }
      1X  15273 
      1X  15274 #else
      1X  15275 #error "Write triangle proc dispatch for this compiler"
      1X  15276 #endif
      1	  15277 #undef FN_NAME
      1	  15278 } /* grDrawTriangle */
	  15279 #endif /* HAVE_XDRAWTRI_ASM */
	  15280 
	  15281 /*---------------------------------------------------------------------------
	  15282  ** grDrawPlanarPolygon
	  15283  **
	  15284  ** Brute force "triangle-fan" implementation of a convex polygon drawer.
	  15285  */
	  15286 GR_ENTRY(grDrawPlanarPolygon,
	  15287          void,
	  15288          (int nVerts, const int iList[], const GrVertex vList[]))
      1	  15289 {
      1	  15290   GR_BEGIN_NOFIFOCHECK("grDrawPlanarPolygon",93);
      1	  15291   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x,0x%x)\n",nVerts,iList,vList);
      1	  15292   GR_CHECK_F(myName, !iList || !vList, "NULL pointer passed");
      1	  15293 
      1	  15294   GR_FLUSH_STATE();
      1	  15295 
      1X  15296 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  15297   grDrawPolygon(nVerts, iList, vList);
      1X  15298 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      2	  15299   {
      2	  15300     int n,i = nVerts-2;
      2	  15301     const GrVertex *firstv = &vList[iList[0]];
      2	  15302 
      3	  15303     for (i = 1; i < nVerts - 1; i++) {
      3	  15304       n = TRISETUP(firstv, &vList[iList[i]], &vList[iList[i+1]]);
      3	  15305       if (n > 0) break;         /* stop after 1st non-zero-area triangle */
      3	  15306       if (n < 0) goto all_done;
      2	  15307     }
      2	  15308     /* now all the gradients are loaded into the chip, so we just have to */

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      2	  15309     /* draw all the rest of the triangles */
      3	  15310     for (i = i+1; i < nVerts - 1; i++) {
      3	  15311       _trisetup_nogradients(firstv, &vList[iList[i]], &vList[iList[i+1]]);
      2	  15312     }
      1	  15313   }
      1	  15314 all_done:
      1	  15315 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15316 
      1	  15317   GR_END();
      1	  15318 } /* grDrawPlanarPolygon */
	  15319 
	  15320 /*---------------------------------------------------------------------------
	  15321  ** grDrawPlanarPolygonVertexList
	  15322  **
	  15323  ** Brute force "triangle-fan" implementation of a convex polygon drawer.
	  15324  */
	  15325 
	  15326 GR_ENTRY(grDrawPlanarPolygonVertexList, void, (int nVerts, const GrVertex vList[]))
      1	  15327 {
      1	  15328   GR_BEGIN_NOFIFOCHECK("grDrawPlanarPolygonVertexList",93);
      1	  15329   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x)\n",nVerts,vList);
      1	  15330   GR_CHECK_F(myName, !vList, "NULL pointer passed");
      1	  15331    
      1	  15332   GR_FLUSH_STATE();
      1	  15333 
      1X  15334 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  15335   grDrawPolygonVertexList(nVerts, vList);
      1X  15336 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      2	  15337   {
      2	  15338     int n,i = nVerts-2;
      2	  15339     const GrVertex *firstv = &vList[0];
      2	  15340       
      3	  15341     for (i = 1; i < nVerts - 1; i++) {
      3	  15342       n = TRISETUP(firstv, &vList[i], &vList[i+1]);
      3	  15343       if (n > 0) break;         /* stop after 1st non-zero-area triangle */
      3	  15344       if (n < 0) goto all_done;
      2	  15345     }
      2	  15346     /* now all the gradients are loaded into the chip, so we just have to */
      2	  15347     /* draw all the rest of the triangles */
      3	  15348     for (i = i+1; i < nVerts - 1; i++) {
      3	  15349       _trisetup_nogradients(firstv, &vList[i], &vList[i+1]);
      2	  15350     }
      2	  15351       
      2	  15352 all_done:
      2	  15353     ;
      1	  15354   }
      1	  15355 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15356 
      1	  15357   GR_END();
      1	  15358 } /* grDrawPlanarPolygonVertexList */
	  15359 
       X  15360 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
       X  15361 #define kMaxPacket3Vertex 0x0FUL
       X  15362 
       X  15363 /* Packet 3 requires at least one vertex, if there isn't enough room
       X  15364  * in the fifo then force a wrap now and write up to the max.  
       X  15365  */

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

       X  15366 #define FIFO_VERT(__vertSize, __polyVerts) \
       X  15367    ((gc->cmdTransportInfo.fifoRoom  < (FxI32)(sizeof(FxU32) + (__vertSize))) \
       X  15368     ? (__polyVerts) \
       X  15369     : MIN((__polyVerts), ((gc->cmdTransportInfo.fifoRoom - sizeof(FxU32)) / (__vertSize))))
       X  15370 
       X  15371 #define FIFO_MAX_VERT(__polyVerts) MIN(kMaxPacket3Vertex, (__polyVerts))
       X  15372 #endif /* GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP */
	  15373 
	  15374 /*---------------------------------------------------------------------------
	  15375  ** grDrawPolygon
	  15376  **
	  15377  ** Brute force "triangle-fan" implementation of a convex polygon drawer.
	  15378  */
	  15379 
	  15380 GR_ENTRY(grDrawPolygon, void, (int nVerts, const int iList[], const GrVertex vList[]))
      1	  15381 {
      1	  15382 #define FN_NAME "grDrawPolygon"
      1	  15383   GR_BEGIN_NOFIFOCHECK("grDrawPolygon",93);
      1	  15384   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x,0x%x)\n",nVerts,iList,vList);
      1	  15385   GR_CHECK_F(myName, !iList || !vList, "NULL pointer passed");
      1	  15386 
      1	  15387   GR_FLUSH_STATE();
      1	  15388 
      1	  15389   /* Zero length vertex lists are allowed, but we can't send them to
      1	  15390    * the hw.
      1	  15391    */
      1	  15392   if (nVerts <= 0) goto __exitNoVerts;
      1	  15393    
      1X  15394 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  15395   {
      1X  15396     const FxU32 vertexParamOffset = _GlideRoot.curVertexSize;
      1X  15397     const int* vertexIndexP = iList;
      1X  15398     FxU32 packVertMax = FIFO_MAX_VERT(nVerts);                   /* Max possible verts for this packet */
      1X  15399     FxU32 packVerts = FIFO_VERT(vertexParamOffset, packVertMax); /* # verts for this packet */
      1X  15400     FxU32 packType = SSTCP_PKT3_BDDDDD;
      1X  15401 
      1X  15402 __doPolyVertexSend:
      1X  15403     {
      1X  15404       const FxU32 packSize = packVerts * vertexParamOffset;
      1X  15405       FxU32 vertexOffset;
      1X  15406 
      1X  15407       GR_ASSERT((packSize % vertexParamOffset) == 0);
      1X  15408       GR_ASSERT(packSize >= vertexParamOffset);
      1X  15409 
      1X  15410       GR_SET_EXPECTED_SIZE(packSize, 1);
      1X  15411       TRI_STRIP_BEGIN(kSetupFan,
      1X  15412                       packSize / vertexParamOffset, vertexParamOffset,
      1X  15413                       packType);
      1X  15414       for(vertexOffset = 0; vertexOffset < packSize; vertexOffset += vertexParamOffset) {
      1X  15415         const float* vertex = (const float*)(vList + *vertexIndexP++);
      1X  15416         
      1X  15417         TRI_SETF(vertex[GR_VERTEX_X_OFFSET]);
      1X  15418         TRI_SETF(vertex[GR_VERTEX_Y_OFFSET]);
      1X  15419 
      1X  15420         {
      1X  15421           const int* dataList = gc->tsuDataList;
      1X  15422 

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15423 #if GLIDE_PACKED_RGB
      1X  15424           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0)
      1X  15425           {
      1X  15426             FxU32 packedColor = 0x00;
      1X  15427           
      1X  15428             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  15429               packedColor = (RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  15430                              RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  15431                              RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  15432               dataList++;
      1X  15433             }
      1X  15434             
      1X  15435             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  15436               packedColor |= RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  15437               dataList++;
      1X  15438             }
      1X  15439             
      1X  15440             TRI_SET(packedColor);
      1X  15441           }
      1X  15442 #endif /* GLIDE_PACKED_RGB */
      1X  15443 
      1X  15444 #if GLIDE_FP_CLAMP_TEX
      1X  15445           while(*dataList != 0) {       
      1X  15446             TRI_SETF(FARRAY(vertex, *dataList));
      1X  15447             dataList++;
      1X  15448           }
      1X  15449 
      1X  15450           dataList++;
      1X  15451 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  15452           
      1X  15453           while (*dataList != 0) {
      1X  15454             TRI_SETF_CLAMP(FARRAY(vertex, *dataList));
      1X  15455             dataList++;
      1X  15456           }
      1X  15457         }
      1X  15458       }
      1X  15459       TRI_END;
      1X  15460       GR_CHECK_SIZE();
      1X  15461     }
      1X  15462 
      1X  15463     /* Are there more vertices that need to be sent for this
      1X  15464      * polygon? Reset the parameters and do the rest of them.
      1X  15465      */
      1X  15466     if (vertexIndexP < iList + nVerts) {
      1X  15467       /* Reset the # of verts maxing out the send based on the
      1X  15468        * space left in the fifo and the max packet size.
      1X  15469        */
      1X  15470       nVerts -= packVerts;
      1X  15471       packVertMax = FIFO_MAX_VERT(nVerts);                   /* Max possible verts for this packet */
      1X  15472       packVerts = FIFO_VERT(vertexParamOffset, packVertMax); /* # verts for this packet */
      1X  15473 
      1X  15474       packType = SSTCP_PKT3_DDDDDD;
      1X  15475          
      1X  15476       GDBG_INFO(120, "\tSending continueing polygon data (0x%X : 0x%X)\n", nVerts, packVerts);
      1X  15477         
      1X  15478       goto __doPolyVertexSend;
      1X  15479     }

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15480   }
      1X  15481 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      2	  15482   {
      2	  15483     int i;
      3	  15484     for (i = 1; i < nVerts - 1; i++) {
      3	  15485       grDrawTriangle(&vList[iList[0]], &vList[iList[i]], &vList[iList[i+1]]);
      2	  15486     }
      1	  15487   }
      1	  15488 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15489 
      1	  15490 __exitNoVerts:
      1	  15491   GR_END();
      1	  15492 #undef FN_NAME
      1	  15493 } /* grDrawPolygon */
	  15494 
	  15495 /*---------------------------------------------------------------------------
	  15496  ** grDrawPolygonVertexList
	  15497  **
	  15498  ** Brute force "triangle-fan" implementation of a convex polygon drawer.
	  15499  */
	  15500 
	  15501 GR_ENTRY(grDrawPolygonVertexList, void, (int nVerts, const GrVertex vList[]))
      1	  15502 {
      1	  15503 #define FN_NAME "grDrawPolygonVertexList"
      1	  15504   GR_BEGIN_NOFIFOCHECK("grDrawPolygonVertexList", 92);
      1	  15505   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x)\n",nVerts,vList);
      1	  15506   GR_CHECK_F(myName, !vList, "NULL pointer passed");
      1	  15507 
      1	  15508   GR_FLUSH_STATE();
      1	  15509 
      1	  15510   /* Zero length vertex lists are allowed, but we can't send them to
      1	  15511    * the hw.
      1	  15512    */
      1	  15513   if (nVerts <= 0) goto __exitNoVerts;
      1	  15514    
      1X  15515 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  15516   {
      1X  15517     const FxU32 vertexParamOffset = _GlideRoot.curVertexSize;
      1X  15518     const GrVertex* vertexListP = vList;
      1X  15519     FxU32 packVertMax = FIFO_MAX_VERT(nVerts);                   /* Max possible verts for this packet */
      1X  15520     FxU32 packVerts = FIFO_VERT(vertexParamOffset, packVertMax); /* # verts for this packet */
      1X  15521     FxU32 packType = SSTCP_PKT3_BDDDDD;
      1X  15522 
      1X  15523 __doPolyVertexSend:
      1X  15524     GR_ASSERT(packVerts > 0);
      1X  15525     GR_ASSERT(packVerts <= kMaxPacket3Vertex);
      1X  15526 
      1X  15527     {
      1X  15528       const FxU32 packSize = packVerts * vertexParamOffset;
      1X  15529       FxU32 vertexOffset;
      1X  15530       
      1X  15531       GR_SET_EXPECTED_SIZE(packSize, 1);
      1X  15532       TRI_STRIP_BEGIN(kSetupFan, packVerts, vertexParamOffset, packType);
      1X  15533 
      1X  15534       for(vertexOffset = 0; vertexOffset < packSize; vertexOffset += vertexParamOffset) {
      1X  15535         const float* vertex = (const float*)vertexListP++;
      1X  15536         

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15537         TRI_SETF(vertex[GR_VERTEX_X_OFFSET]);
      1X  15538         TRI_SETF(vertex[GR_VERTEX_Y_OFFSET]);
      1X  15539 
      1X  15540         {
      1X  15541           const int* dataList = gc->tsuDataList;
      1X  15542 
      1X  15543 #if GLIDE_PACKED_RGB
      1X  15544           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0)
      1X  15545           {
      1X  15546             FxU32 packedColor = 0x00;
      1X  15547           
      1X  15548             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  15549               packedColor = (RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_B_OFFSET << 2)), B) | 
      1X  15550                              RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  15551                              RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  15552               dataList++;
      1X  15553             }
      1X  15554             
      1X  15555             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      1X  15556               packedColor |= RGBA_COMP_CLAMP(FARRAY(vertex, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  15557               dataList++;
      1X  15558             }
      1X  15559             
      1X  15560             TRI_SET(packedColor);
      1X  15561           }
      1X  15562 #endif /* GLIDE_PACKED_RGB */
      1X  15563 
      1X  15564 #if GLIDE_FP_CLAMP_TEX
      1X  15565           while(*dataList != 0) {
      1X  15566             TRI_SETF(FARRAY(vertex, *dataList));
      1X  15567             dataList++;
      1X  15568           }
      1X  15569 
      1X  15570           dataList++;
      1X  15571 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  15572           
      1X  15573           while (*dataList != 0) {
      1X  15574             TRI_SETF_CLAMP(FARRAY(vertex, *dataList));
      1X  15575             dataList++;
      1X  15576           }
      1X  15577         }
      1X  15578       }
      1X  15579       TRI_END;
      1X  15580       GR_CHECK_SIZE();
      1X  15581     }
      1X  15582 
      1X  15583     /* More verts? */
      1X  15584     if (vertexListP < vList + nVerts) {
      1X  15585       /* Reset the # of verts maxing out the send based on the
      1X  15586        * space left in the fifo and the max packet size.
      1X  15587        */
      1X  15588       nVerts -= packVerts;
      1X  15589       packVertMax = FIFO_MAX_VERT(nVerts);                   /* Max possible verts for this packet */
      1X  15590       packVerts = FIFO_VERT(vertexParamOffset, packVertMax); /* # verts for this packet */
      1X  15591 
      1X  15592       /* Packet type to continue strip */
      1X  15593       packType = SSTCP_PKT3_DDDDDD;

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

      1X  15594          
      1X  15595       GDBG_INFO(120, "\tSending continueing polygon data (0x%X : 0x%X)\n", packVerts, nVerts);
      1X  15596         
      1X  15597       goto __doPolyVertexSend;
      1X  15598     }
      1X  15599   }
      1X  15600 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      2	  15601   {
      2	  15602     int i;
      2	  15603     
      3	  15604     for (i = 1; i < nVerts - 1; i++) {
      3	  15605       grDrawTriangle(&vList[0], &vList[i], &vList[i+1]);
      2	  15606     }
      1	  15607   }
      1	  15608 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15609 
      1	  15610 __exitNoVerts:
      1	  15611   GR_END();
      1	  15612 #undef FN_NAME
      1	  15613 } /* grDrawPolygonVertexList */
	  15614 
	  15615 /*---------------------------------------------------------------------------
	  15616  ** _grColorCombineDelta0Mode
	  15617  **
	  15618  ** GMT: when we are in delta0 mode, color comes from the RGB iterators
	  15619  **      but the slopes are 0.0.  So when we enter delta0 mode we set
	  15620  **      the iterators up and then we leave them alone during primitive
	  15621  **      rendering
	  15622  */
	  15623 
	  15624 GR_DDFUNC(_grColorCombineDelta0Mode, void, (FxBool delta0mode))
      1	  15625 {
      1	  15626 #define FN_NAME "_grColorCombineDelta0Mode"
      1	  15627   GR_BEGIN_NOFIFOCHECK("_grColorCombineDelta0Mode",85);
      1	  15628   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",delta0mode);
      1	  15629 
      2	  15630   if (delta0mode) {
      2	  15631     GR_SET_EXPECTED_SIZE(9 << 2, 9);
      3	  15632     {
      3	  15633       GR_SETF(BROADCAST_ID, hw, Fr, gc->state.r);
      3	  15634       GR_SETF(BROADCAST_ID, hw, Fg, gc->state.g);
      3	  15635       GR_SETF(BROADCAST_ID, hw, Fb, gc->state.b);
      3	  15636       GR_SET(BROADCAST_ID, hw, drdx, 0);
      3	  15637       GR_SET(BROADCAST_ID, hw, drdy, 0);
      3	  15638       GR_SET(BROADCAST_ID, hw, dgdx, 0);
      3	  15639       GR_SET(BROADCAST_ID, hw, dgdy, 0);
      3	  15640       GR_SET(BROADCAST_ID, hw, dbdx, 0);
      3	  15641       GR_SET(BROADCAST_ID, hw, dbdy, 0);
      2	  15642     } 
      2	  15643     GR_CHECK_SIZE();
      1	  15644   }
      1	  15645 
      1	  15646   gc->state.cc_delta0mode = delta0mode;
      1	  15647   GR_END();
      1	  15648 #undef FN_NAME
      1	  15649 } /* _grColorCombineDeltaMode */
	  15650 

GDRAW                           Source Listing                   9-MAY-2021 23:42:54  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             8-MAY-2021 19:17:33  gdraw.c;2

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GDRAW/OBJECT=[.O
UT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GDRAW.OBJ/INCLUDE_DIRECTORY=([.GLIDE.S
WLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLID
E.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRIS
ETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LI
B=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GDRAW.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:54"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


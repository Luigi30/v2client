FX64                            Source Listing                   9-MAY-2021 23:43:25  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  fx64.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 */
	     20 
	     21 #include <stdlib.h>
	   2664 #include <stdio.h>
	   3727 
	   3728 #include <fx64.h>
	   4136 
       X   4137 #ifndef NATIVE_64_SUPPORT
       X   4138 
       X   4139 FxI64  i64_one  = { 0, 1 };
       X   4140 FxI64  i64_zero = { 0, 0 };
       X   4141 
       X   4142 static FxBool fx64_cf;
       X   4143 
       X   4144 FxBool __FX_ADD32( FxU32 a, FxU32 b );
       X   4145 #pragma aux __FX_ADD32 = \
       X   4146    "mov fx64_cf, 0" \
       X   4147    "add eax, edx"   \
       X   4148    "adc fx64_cf, 0" \
       X   4149    parm [eax] [edx] \
       X   4150    value [eax];
       X   4151 
       X   4152 FxI64 __FX_AND64( FxI64 a, FxI64 b )
       X   4153 {
       X   4154    FxI64 result;
       X   4155 
       X   4156    result.hi = a.hi & b.hi;
       X   4157    result.lo = a.lo & b.lo;
       X   4158 
       X   4159    return result;
       X   4160 }
       X   4161 
       X   4162 FxI64 __FX_CREATE64( FxI32 a, FxU32 b )
       X   4163 {
       X   4164    FxI64 result;
       X   4165 
       X   4166    result.hi = a;
       X   4167    result.lo = b;
       X   4168 

FX64                            Source Listing                   9-MAY-2021 23:43:25  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  fx64.c;1

       X   4169    return result;
       X   4170 }
       X   4171 
       X   4172 /*
       X   4173 ** __FX_MUL64
       X   4174 **
       X   4175 ** The following code is NOT a full 64-bit multiply.  It only computes
       X   4176 ** the low order 64-bits of the product since this is all our hardware
       X   4177 ** needs.
       X   4178 */
       X   4179 FxI64 __FX_MUL64( FxI64 a, FxI64 b )
       X   4180 {
       X   4181    FxI64 result = { 0, 0 };
       X   4182 
       X   4183    FXUNUSED( a );
       X   4184    FXUNUSED( b );
       X   4185 
       X   4186    puts( "__FX_MUL64:  not implemented" );
       X   4187    exit( 1 );
       X   4188    return result;
       X   4189 }
       X   4190 
       X   4191 FxI64 __FX_OR64( FxI64 a, FxI64 b )
       X   4192 {
       X   4193    FxI64 result;
       X   4194 
       X   4195    result.hi = a.hi | b.hi;
       X   4196    result.lo = a.lo | b.lo;
       X   4197 
       X   4198    return result;
       X   4199 }
       X   4200 
       X   4201 FxI64 __FX_COMP64( FxI64 a )
       X   4202 {
       X   4203    FxI64 result;
       X   4204 
       X   4205    result.hi = ~a.hi;
       X   4206    result.lo = ~a.lo;
       X   4207 
       X   4208    return result;
       X   4209 }
       X   4210 
       X   4211 float __FX_64TOFLOAT( FxI64 a )
       X   4212 {
       X   4213    double hi, lo;
       X   4214 
       X   4215    hi = a.hi * 4294967296.0;	// 2**32
       X   4216    lo = ( float ) a.lo;
       X   4217    return (float)(hi + lo);
       X   4218 }
       X   4219 
       X   4220 FxI64 __FX_FLOATTO64( float f )
       X   4221 {
       X   4222     int n;
       X   4223     FxU32 data;
       X   4224     FxI64 result;
       X   4225 

FX64                            Source Listing                   9-MAY-2021 23:43:25  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  fx64.c;1

       X   4226     data = *(FxU32 *)&f;		// get into integer register
       X   4227     n = (data>>23) & 0xFF;		// peel off exponent
       X   4228     n = 150 - n;			// compute shift amount
       X   4229     data |= 0x800000;			// add in the hidden bit
       X   4230     result.hi = 0;
       X   4231     result.lo = (data&0xFFFFFF);
       X   4232     if (n > 0) {			// need to shift right, < 2**23
       X   4233 	if (n > 31) n = 31;
       X   4234 	result.lo >>= n;
       X   4235     }
       X   4236     else {
       X   4237 	n = -n;
       X   4238 	if (n > 63) n = 63;
       X   4239         result = FX_SHL64( result, n );
       X   4240     }
       X   4241     // negate after shift, this rounds down instead of to zero
       X   4242     if (data & 0x80000000)
       X   4243       result = FX_NEG64(result);
       X   4244     return result;
       X   4245 }
       X   4246 
       X   4247 
       X   4248 int __FX_CMP64( FxI64 a, FxI64 b )
       X   4249 {
       X   4250    if ( a.hi < b.hi )
       X   4251       return -1;
       X   4252    if ( a.hi > b.hi )
       X   4253       return 1;
       X   4254    if ( a.lo < b.lo )
       X   4255       return -1;
       X   4256    else if ( a.lo > b.lo )
       X   4257       return 1;
       X   4258    return 0;
       X   4259 }
       X   4260 
       X   4261 #endif
	   4262 


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.SWLIBS.FXMISC]FX64/OBJECT=[.OUT.DEBUG.
OBJ.GLIDE.SWLIBS.FXMISC]FX64.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC],[.GL
IDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CVG.INIT
],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_HW_TRI_
SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE.SWLIB
S.FXMISC]FX64.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 

FX64                            Source Listing                   9-MAY-2021 23:43:25  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  fx64.c;1

 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:25"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


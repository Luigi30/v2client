GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 ** 
	     20 ** 75    6/23/98 5:38p Peter
	     21 ** lfb hinting
	     22 ** 
	     23 ** 74    4/29/98 2:49p Peter
	     24 ** fixed debug build
	     25 ** 
	     26 ** 73    4/16/98 3:54p Peter
	     27 ** removed cruft
	     28 ** 
	     29 ** 72    4/01/98 1:51p Peter
	     30 ** sli origin thing vs grRenderBuffer
	     31 ** 
	     32 ** 71    3/31/98 6:09p Peter
	     33 ** sli origin everywhere (I think) and grLfbReadRegion/grRenderBuffer vs
	     34 ** triple buffering
	     35 ** 
	     36 ** 70    3/29/98 1:07p Peter
	     37 ** yet another sli origin thing
	     38 ** 
	     39 ** 69    3/23/98 5:57p Peter
	     40 ** warning cleanup
	     41 ** 
	     42 ** 68    3/18/98 3:04p Peter
	     43 ** cleaner origin swapping hacks
	     44 ** 
	     45 ** 67    3/13/98 1:56p Peter
	     46 ** more sli origin swapping
	     47 ** 
	     48 ** 66    3/13/98 1:27p Peter
	     49 ** grLfbReadRegion vs triple buffering
	     50 ** 
	     51 ** 65    3/09/98 2:24p Peter
	     52 ** change for new pci passthrough interface
	     53 ** 
	     54 ** 63    3/02/98 7:23p Peter
	     55 ** clear slop on sli systems when changing y origin
	     56 ** 
	     57 ** 62    2/20/98 11:00a Peter

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

	     58 ** removed glide3 from glid2 tree
	     59 ** 
	     60 ** 61    2/11/98 5:26p Peter
	     61 ** new write edge stuff
	     62 ** 
	     63 ** 60    2/01/98 7:52p Peter
	     64 ** grLfbWriteRegion byte count problems
	     65 ** 
	     66 ** 59    1/30/98 4:31p Peter
	     67 ** general clenaup
	     68  * 
	     69  * 58    1/16/98 4:18p Atai
	     70  * fixed lfb and grLoadGammaTable
	     71  * 
	     72  * 57    1/06/98 3:53p Atai
	     73  * remove grHint, modify grLfbWriteRegion and grGet
	     74  * 
	     75  * 56    12/17/97 4:45p Peter
	     76  * groundwork for CrybabyGlide
	     77  * 
	     78  * 55    12/15/97 6:04p Atai
	     79  * disable obsolete glide2 api for glide3
	     80  * 
	     81  * 54    12/15/97 5:54p Peter
	     82  * swizzle reads too
	     83  * 
	     84  * 53    12/11/97 4:15p Peter
	     85  * mac lfb write region
	     86  * 
	     87  * 52    12/01/97 5:18p Peter
	     88  * 
	     89  * 51    11/25/97 12:09p Peter
	     90  * nested calls to grLfbLock vs init code locking on v2
	     91  * 
	     92  * 50    11/18/97 4:36p Peter
	     93  * chipfield stuff cleanup and w/ direct writes
	     94  * 
	     95  * 49    11/17/97 4:55p Peter
	     96  * watcom warnings/chipfield stuff
	     97  * 
	     98  * 48    11/06/97 3:38p Dow
	     99  * More banshee stuff
	    100  * 
	    101  * 47    11/04/97 5:04p Peter
	    102  * cataclysm part deux
	    103  * 
	    104  * 46    11/03/97 3:43p Peter
	    105  * h3/cvg cataclysm
	    106  * 
	    107  * 45    10/27/97 11:10a Peter
	    108  * starting cleanup
	    109  * 
	    110  * 44    10/09/97 8:02p Dow
	    111  * State Monster 1st Cut
	    112  * 
	    113  * 43    10/08/97 5:18p Peter
	    114  * fixed grLfbLock wrt writemode_any

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

	    115  * 
	    116  * 42    10/08/97 11:33a Peter
	    117  * hmmmm....
	    118  * 
	    119  * 41    9/30/97 1:03p Peter
	    120  * more debugging code
	    121  * 
	    122  * 40    9/25/97 1:35p Peter
	    123  * 
	    124  * 39    9/24/97 4:09p Peter
	    125  * lfb/idle fixes
	    126  * 
	    127  * 38    9/24/97 1:31p Peter
	    128  * assert if grXX call inside lock/unlock
	    129  * 
	    130  * 37    9/20/97 10:54a Peter
	    131  * naked lfb writes
	    132  * 
	    133  * 36    9/15/97 7:31p Peter
	    134  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	    135  * place, lfb's are on, Hmmmm.. probably more
	    136  * 
	    137  * 35    9/10/97 10:13p Peter
	    138  * fifo logic from GaryT, non-normalized fp first cut
	    139  * 
	    140 **
	    141 */
	    142 
	    143 #include <3dfx.h>
	    274 #define FX_DLL_DEFINITION
	    275 #include <fxdll.h>
	    396 #include <glide.h>
	   2338 #include "fxglide.h"
	  14230 
	  14231 /*---------------------------------------------------------------------------
	  14232 ** grLfbConstantAlpha
	  14233 */
	  14234 GR_ENTRY(grLfbConstantAlpha, void, (GrAlpha_t alpha))
      1	  14235 {
      1	  14236   GR_BEGIN_NOFIFOCHECK("grLfbConstantAlpha",82);
      1	  14237   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",alpha);
      1	  14238 
      1	  14239   gc->state.lfb_constant_alpha = alpha;
      1	  14240   GR_END();
      1	  14241 } /* grLfbConstantAlpha */
	  14242 
	  14243 /*---------------------------------------------------------------------------
	  14244 ** grLfbConstantDepth
	  14245 */
	  14246 GR_ENTRY(grLfbConstantDepth, void, (FxU16 depth))
      1	  14247 {
      1	  14248   GR_BEGIN_NOFIFOCHECK("grLfbConstantDepth",82);
      1	  14249   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",depth);
      1	  14250 
      1	  14251   gc->state.lfb_constant_depth = depth;
      1	  14252   GR_END();
      1	  14253 } /* grLfbConstantDepth */

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

	  14254 
	  14255 
	  14256 /*-------------------------------------------------------------------
	  14257   Function: grLfbLock
	  14258   Date: 2/19
	  14259   Implementor(s): jdt
	  14260   Library: Glide
	  14261   Description:
	  14262   Secures a pointer to a requested frame buffer and guarantees ordered
	  14263   access to that buffer.
	  14264 
	  14265   Arguments:
	  14266   type - type of lock, one of:
	  14267   GR_LOCK_WRITE_ONLY
	  14268   GR_LOCK_READ_ONLY
	  14269   buffer - which buffer to lock, one of:
	  14270   GR_BUFFER_FRONTBUFFER
	  14271   GR_BUFFER_BACKBUFFER
	  14272   GR_BUFFER_AUXBUFFER
	  14273   writeMode - desired destination color format
	  14274   origin - desired lfb origin
	  14275   pixelPipeline - flag whether to process through pixpipe
	  14276   info   - pointer to info structure
	  14277   Return:
	  14278   FXTRUE  - lock is successful
	  14279   FXFALSE - lock fails
	  14280   -------------------------------------------------------------------*/
	  14281 
	  14282 GR_ENTRY(grLfbLock, FxBool,(GrLock_t type, GrBuffer_t buffer, 
	  14283                             GrLfbWriteMode_t writeMode, GrOriginLocation_t origin, 
	  14284                             FxBool pixelPipeline, GrLfbInfo_t *info)) 
      1	  14285 {
      1	  14286 #define FN_NAME "grLfbLock"
      1	  14287   FxBool rv = FXTRUE;
      1	  14288   FxU32 lfbMode = 0, zaColor = 0, fbzMode = 0;
      1	  14289   const FxBool idleLockP = ((type & GR_LFB_NOIDLE) == 0);
      1X  14290 #if (GLIDE_PLATFORM & GLIDE_OS_MACOS) && SET_BSWAP
      1X  14291   FxBool swizzleByteP = FXFALSE;
      1X  14292 #endif /* (GLIDE_PLATFORM & GLIDE_OS_MACOS) && SET_BSWAP */
      1	  14293   
      1	  14294   GR_BEGIN_NOFIFOCHECK("grLfbLock", 87);
      1	  14295   GDBG_INFO_MORE(gc->myLevel,"(%d, %d, %d, %d, %d)\n", 
      1	  14296                  type, buffer, writeMode, origin, pixelPipeline);
      1	  14297 
      1	  14298   GR_CHECK_COMPATABILITY(FN_NAME, !info,
      1	  14299              "Null info structure passed.");
      1	  14300   /* there is only one revision extant */
      1	  14301   GR_CHECK_COMPATABILITY(FN_NAME, info->size != sizeof(GrLfbInfo_t),
      1	  14302                          "uninitialized info structure passed.");
      1	  14303 
      1	  14304   type = type & ~(GR_LFB_NOIDLE);
      2	  14305   switch(type) {
      2	  14306   case GR_LFB_READ_ONLY:
      3	  14307   {
      4	  14308     if (gc->lockPtrs[type] != (FxU32)-1) {
      4	  14309       GDBG_INFO(83, "Read lock failure due to existing lock");
      4	  14310       rv = FXFALSE;

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      4	  14311     } else {
      4	  14312       lfbMode = gc->state.fbi_config.lfbMode;
      4	  14313       lfbMode &= ~(SST_LFB_READBUFSELECT | 
      4	  14314                    SST_LFB_YORIGIN);
      4	  14315                     
      5	  14316       switch(buffer) {
      5	  14317       case GR_BUFFER_FRONTBUFFER:
      5	  14318         lfbMode |= SST_LFB_READFRONTBUFFER;
      5	  14319         break;
      5	  14320 
      5	  14321       case GR_BUFFER_BACKBUFFER:
      5	  14322         lfbMode |= SST_LFB_READBACKBUFFER;
      5	  14323         break;
      5	  14324 
      5	  14325       case GR_BUFFER_AUXBUFFER:
      5	  14326         lfbMode |= SST_LFB_READAUXBUFFER;
      5	  14327         break;
      5	  14328 
      5	  14329       default:
      5	  14330         GR_CHECK_F(myName, 
      5	  14331                    1, 
      5	  14332                    "illegal buffer parameter passed");
      5	  14333         rv = FXFALSE;
      5	  14334         break;
      4	  14335       }
      4	  14336 
      4	  14337       lfbMode |= (origin ? SST_LFB_YORIGIN : 0);
      4	  14338       gc->state.fbi_config.lfbMode = lfbMode;
      4	  14339 
      4X  14340 #if (GLIDE_PLATFORM & GLIDE_OS_MACOS) && SET_BSWAP
      4X  14341       if (!gc->cmdTransportInfo.fifoLfbP) lfbMode |= (SST_LFB_READ_SWAP16 |
      4X  14342                                                       SST_LFB_READ_BYTESWAP);
      4X  14343 #endif /* (GLIDE_PLATFORM & GLIDE_OS_MACOS) */
      4	  14344 
      4	  14345       info->strideInBytes = gc->fbStride * 2;
      4	  14346       info->origin        = origin;
      4	  14347       info->lfbPtr        = gc->lfb_ptr;
      3	  14348     }
      2	  14349   }
      2	  14350   break;
      2	  14351 
      2	  14352   case GR_LFB_WRITE_ONLY:
      3	  14353   {           
      4	  14354     if (gc->lockPtrs[type] != (FxU32)-1) {
      4	  14355       GDBG_INFO(83, "Write failure due to existing lock");
      4	  14356       rv = FXFALSE;
      4	  14357     } else {
      4	  14358       /* Set up the constant depth register because it may have
      4	  14359        * been trashed by a call to grDepthBiasLevel
      4	  14360        * (depthbiaslevel and constant depth use the same register) 
      4	  14361        */
      4	  14362       zaColor = gc->state.fbi_config.zaColor;
      4	  14363       zaColor = (((FxU32) gc->state.lfb_constant_depth) << SST_ZACOLOR_DEPTH_SHIFT);
      4	  14364       zaColor |= (gc->state.lfb_constant_alpha << SST_ZACOLOR_ALPHA_SHIFT);
      4	  14365 
      4	  14366       /* disable depth biasing */
      4	  14367       fbzMode = gc->state.fbi_config.fbzMode;

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      4	  14368       fbzMode &= ~(SST_ENZBIAS);
      4	  14369           
      4	  14370       lfbMode = gc->state.fbi_config.lfbMode;
      4	  14371       lfbMode &= ~(SST_LFB_WRITEBUFSELECT |
      4	  14372                    SST_LFB_YORIGIN        |
      4	  14373                    SST_LFB_FORMAT         |
      4	  14374                    SST_LFB_ENPIXPIPE);
      4	  14375           
      5	  14376       switch(writeMode) {
      5	  14377       case GR_LFBWRITEMODE_RESERVED1:
      5	  14378       case GR_LFBWRITEMODE_RESERVED2:
      5	  14379       case GR_LFBWRITEMODE_RESERVED3:
      5	  14380       case GR_LFBWRITEMODE_RESERVED4:
      5	  14381       case GR_LFBWRITEMODE_RESERVED5:
      5	  14382       case GR_LFBWRITEMODE_RESERVED6:
      5	  14383       case GR_LFBWRITEMODE_RESERVED7:
      5	  14384         rv = FXFALSE;
      4	  14385       }
      4	  14386 
      4	  14387       /* Default to hw */
      5	  14388       if (writeMode == GR_LFBWRITEMODE_ANY) {
      5	  14389         writeMode = ((buffer == GR_BUFFER_AUXBUFFER)
      5	  14390                      ? GR_LFBWRITEMODE_ZA16
      5	  14391                      : GR_LFBWRITEMODE_565);
      4	  14392       }
      4	  14393           
      5	  14394       switch(buffer) {
      5	  14395       case GR_BUFFER_FRONTBUFFER:
      6	  14396         if (writeMode == GR_LFBWRITEMODE_ZA16) {
      6	  14397           rv = FXFALSE;
      5	  14398         }
      5	  14399         lfbMode |= SST_LFB_WRITEFRONTBUFFER;
      5	  14400         break;
      5	  14401 
      5	  14402       case GR_BUFFER_BACKBUFFER:
      6	  14403         if (writeMode == GR_LFBWRITEMODE_ZA16) {
      6	  14404           rv = FXFALSE;
      5	  14405         }
      5	  14406         lfbMode |= SST_LFB_WRITEBACKBUFFER;
      5	  14407         break;
      5	  14408 
      5	  14409       case GR_BUFFER_AUXBUFFER:
      6	  14410         if (writeMode != GR_LFBWRITEMODE_ZA16) {
      6	  14411           rv = FXFALSE;
      5	  14412         }
      5	  14413         lfbMode |= SST_LFB_WRITEFRONTBUFFER;
      5	  14414         break;
      5	  14415 
      5	  14416       default:
      5	  14417         GR_CHECK_F(myName, 1, "illegal buffer parameter passed");
      5	  14418         break;
      4	  14419       }
      4	  14420 
      4	  14421       lfbMode |= (writeMode << SST_LFB_FORMAT_SHIFT);
      4	  14422       lfbMode |= (origin ? SST_LFB_YORIGIN : 0);
      4	  14423 
      5	  14424       if (pixelPipeline) {

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      5	  14425         lfbMode |= SST_LFB_ENPIXPIPE;
      5	  14426 
      5	  14427         fbzMode &= ~SST_YORIGIN;
      5	  14428         fbzMode |= (origin ? SST_YORIGIN : 0);
      4	  14429       }
      4	  14430       gc->state.fbi_config.lfbMode = lfbMode;
      4	  14431                         
      4	  14432       info->origin    = origin;
      4	  14433       info->writeMode = writeMode;
      4	  14434 
      4X  14435 #if (GLIDE_PLATFORM & GLIDE_OS_MACOS) && SET_BSWAP
      4	  14436       /* Turn on word swizzling by default.
      4	  14437        *
      4	  14438        * NB: This state does not get shadowed because it is only
      4	  14439        * relevant if the app is doing its own lfb writes. When coming
      4	  14440        * through grLfbWriteRegion we take care of doing this when
      4	  14441        * putting the data in the fifo so the actual rendering state
      4	  14442        * in lfbMode is all we care about.
      4X  14443        */
      4X  14444       if (!gc->cmdTransportInfo.fifoLfbP) lfbMode |= SST_LFB_WRITE_SWAP16;
      4X  14445 #endif /* (GLIDE_PLATFORM & GLIDE_OS_MACOS) */
      4	  14446                     
      5	  14447       switch(lfbMode & SST_LFB_FORMAT) {
      5	  14448       case SST_LFB_565:
      5	  14449       case SST_LFB_555:
      5	  14450       case SST_LFB_1555:
      5	  14451       case SST_LFB_ZZ:
      5	  14452         info->strideInBytes = gc->fbStride << 1;
      5	  14453 
      5X  14454 #if (GLIDE_PLATFORM & GLIDE_OS_MACOS) && SET_BSWAP
      5X  14455         if (!gc->cmdTransportInfo.fifoLfbP) lfbMode |= SST_LFB_WRITE_BYTESWAP;
      5X  14456 #endif /* (GLIDE_PLATFORM & GLIDE_OS_MACOS) */
      5	  14457         break;
      5	  14458 
      5	  14459       case SST_LFB_888:
      5	  14460       case SST_LFB_8888:
      5	  14461       case SST_LFB_Z565:
      5	  14462       case SST_LFB_Z555:
      5	  14463       case SST_LFB_Z1555:
      5	  14464         info->strideInBytes = gc->fbStride << 2;
      5	  14465         break;
      4	  14466       }
      4	  14467 
      4	  14468       info->lfbPtr    = gc->lfb_ptr;
      3	  14469     }
      2	  14470   }
      2	  14471   break;
      2	  14472   default:
      2	  14473     rv = FXFALSE;
      2	  14474     GDBG_INFO(gc->myLevel,  "Lock failed because of invalid lock type.");
      2	  14475     break;
      1	  14476   }
      1	  14477 
      2	  14478   if (rv) {
      2	  14479     const FxU32 lfbLockCount = gc->cmdTransportInfo.lfbLockCount;
      2	  14480 
      2	  14481     gc->lockPtrs[type] = buffer;

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      2	  14482 
      2	  14483 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL
      2	  14484     /* If the cmd fifo has been turned off before then make sure its
      2	  14485      * on again before trying to dork w/ the modes etc.  
      2	  14486      */
      3	  14487     if (lfbLockCount > 0) {
      3	  14488       GR_ASSERT(!gc->cmdTransportInfo.fifoLfbP);
      3	  14489 
      3	  14490       /* Hack to allow the register writes below to be happy.
      3	  14491        *
      3	  14492        * NB: This *MUST* come before the unlock call since that
      3	  14493        * is going to write a nopCmd via the init code callback.
      3	  14494        */
      3	  14495       gc->cmdTransportInfo.lfbLockCount = 0;
      3	  14496 
      3X  14497 #if GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY
      3X  14498       grHints(GR_HINT_LFB_RESET, 0UL);
      3X  14499 #endif /* GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY */
      3	  14500 
      3	  14501       sst1InitLfbUnlock((FxU32*)hw);
      2	  14502     }
      2	  14503 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL */
      2	  14504 
      2	  14505     /* Setup the hw w/ the settings computed above. */
      3	  14506     switch(type) {
      3	  14507     case GR_LFB_READ_ONLY:
      3	  14508       GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      3	  14509       GR_SET(BROADCAST_ID, hw, lfbMode, lfbMode);
      3	  14510       GR_CHECK_SIZE();
      3	  14511       break;
      3	  14512 
      3	  14513     case GR_LFB_WRITE_ONLY:
      4	  14514       REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 3, 0x103);
      5	  14515       {          
      5	  14516         REG_GROUP_SET(hw, fbzMode, fbzMode);
      5	  14517         REG_GROUP_SET(hw, lfbMode, lfbMode);
      5	  14518         REG_GROUP_SET(hw, zaColor, zaColor);
      4	  14519       }
      3	  14520       REG_GROUP_END();
      3	  14521 
      3	  14522 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      3	  14523       /* Sli has an 'interesting' feature where the physical scanlines
      3	  14524        * that are being rendered is dependent on the location of the y
      3	  14525        * origin. We always clear the overlap bit to black here so that
      3	  14526        * no one ever notices. This needs to be done for all of the allocated
      3	  14527        * color buffers that could have possibly have been rendered to since
      3	  14528        * the last origin swap. Rather than beeing really tricky I just do
      3	  14529        * it for every allocated color buffer.
      3	  14530        *
      3	  14531        * Origin_Lower_Left: 0:Black [1 .. screenRezY]:Rendered screenRez+1:Black
      3	  14532        * Origin_Upper_Left: [0 .. screenRezY - 1]:Rendered [screenRez-screenRez+1]:Black
      3	  14533        */
      3	  14534       if (gc->scanline_interleaved) gc->hwDep.cvgDep.sliOriginBufCount = gc->grColBuf;
      3	  14535 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      3	  14536       break;
      2	  14537     }
      2	  14538 

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      3	  14539     if (!gc->cmdTransportInfo.fifoLfbP && idleLockP) {
      3	  14540       /* This is required to flush the write buffers before the
      3	  14541        * actual LFB accesses.
      3	  14542        */
      3	  14543       P6FENCE;
      3	  14544 
      3	  14545       /* Must idle to get things in the right order. */
      3	  14546       grSstIdle();
      2	  14547     }
      2	  14548 
      2	  14549     /* If we're not coming through grLfbWriteRegion then we need to
      2	  14550      * temporarily turn off the command fifo so that the accesses are
      2	  14551      * processed correctly by the hw.
      2	  14552      */
      3	  14553     if (!gc->cmdTransportInfo.fifoLfbP) {
      3	  14554 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL
      3	  14555       sst1InitLfbLock((FxU32*)hw);
      3	  14556       
      3X  14557 #if GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY
      3X  14558       grHints(GR_HINT_LFB_PROTECT, info->strideInBytes);
      3X  14559 #endif /* GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY */
      3	  14560 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL */
      3	  14561       
      3	  14562       /* Increment lock count */
      3	  14563       gc->cmdTransportInfo.lfbLockCount = lfbLockCount + 1;
      2	  14564     }
      1	  14565   }
      1	  14566 
      1	  14567   GR_RETURN(rv);
      1	  14568 #undef FN_NAME
      1	  14569 } /* grLfbLock */
	  14570     
	  14571 /*-------------------------------------------------------------------
	  14572   Function: grLfbUnlock
	  14573   Date: 2/21
	  14574   Implementor(s): jdt
	  14575   Library: Glide
	  14576   Description:
	  14577   Unlock a previously locked buffer
	  14578   Arguments:
	  14579   type - type of lock (read only/write only)
	  14580   buffer - which buffer to unlock 
	  14581   Return:
	  14582   FXTRUE  - success
	  14583   FXFALSE - failure
	  14584   -------------------------------------------------------------------*/
	  14585 
	  14586 GR_ENTRY(grLfbUnlock, FxBool, (GrLock_t type, GrBuffer_t buffer))
      1	  14587 {
      1	  14588 #define FN_NAME "grLfbUnlock"
      1	  14589   FxBool rval = FXFALSE;
      1	  14590   
      1	  14591   GR_BEGIN_NOFIFOCHECK("grLfbUnLock", 87);
      1	  14592   GDBG_INFO_MORE(gc->myLevel,"(%d, %d)\n", type, buffer);
      1	  14593 
      1	  14594   type = type & ~(GR_LFB_NOIDLE);
      1	  14595   

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      1	  14596   GR_CHECK_COMPATABILITY(FN_NAME, 
      1	  14597                          type != GR_LFB_WRITE_ONLY &&
      1	  14598                          type != GR_LFB_READ_ONLY,
      1	  14599                          "Bad type");
      1	  14600   
      1	  14601   GR_CHECK_COMPATABILITY(FN_NAME, 
      1	  14602                          buffer != GR_BUFFER_FRONTBUFFER &&
      1	  14603                          buffer != GR_BUFFER_BACKBUFFER  &&
      1	  14604                          buffer != GR_BUFFER_AUXBUFFER,
      1	  14605                          "Bad buffer");
      1	  14606 
      1	  14607 #if ((GLIDE_PLATFORM & GLIDE_HW_SST1) || (GLIDE_PLATFORM & GLIDE_HW_CVG)) 
      2	  14608   if (gc->lockPtrs[type] == (FxU32)buffer) {
      2	  14609     rval = FXTRUE;
      2	  14610     gc->lockPtrs[type] = (FxU32)-1;
      2	  14611 
      2	  14612     /* Is this a direct lfb access? */
      3	  14613     if (!gc->cmdTransportInfo.fifoLfbP) {
      3	  14614       /* Flush the write buffers */
      3	  14615       if (type != GR_LFB_READ_ONLY) P6FENCE;
      3	  14616 
      3	  14617       /* If there are no more outstanding lfb locks, then turn the
      3	  14618        * fifo back on before we do anything else otherwise just
      3	  14619        * return w/ the new lock count.  
      3	  14620        */
      3	  14621       gc->cmdTransportInfo.lfbLockCount--;
      4	  14622       if (gc->cmdTransportInfo.lfbLockCount == 0) {
      4	  14623 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL
      4X  14624 #if GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY
      4X  14625         grHints(GR_HINT_LFB_PROTECT, 0UL);
      4X  14626 #endif /* GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY */
      4	  14627 
      4	  14628         sst1InitLfbUnlock((FxU32*)hw);
      4	  14629 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL */
      4	  14630       } else {
      4	  14631         return FXTRUE;
      3	  14632       }
      2	  14633     }
      2	  14634     
      2	  14635     GR_SET_EXPECTED_SIZE(8 + MaskSelect(gc->scanline_interleaved, sizeof(FxU32)),
      2	  14636                          2 + gc->scanline_interleaved);
      3	  14637     {
      3	  14638       /* Restore depth bias level */
      3	  14639       GR_SET(BROADCAST_ID, hw, zaColor, gc->state.fbi_config.zaColor);
      3	  14640       
      3	  14641       /* turn back on depth biasing */
      3	  14642       GR_SET(BROADCAST_ID, hw, fbzMode, gc->state.fbi_config.fbzMode);
      3	  14643       
      3	  14644       if (gc->scanline_interleaved) GR_SET(BROADCAST_ID, hw, nopCMD, 0x0);
      2	  14645     }
      2	  14646     GR_CHECK_SIZE();
      2	  14647   } else {
      2	  14648     GDBG_INFO(gc->myLevel, "Unlock failed because there was no matching lock");
      2	  14649     rval = FXFALSE;
      1	  14650   }
      1	  14651 #endif
      1	  14652 

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      1	  14653   GR_RETURN(rval);
      1	  14654 #undef FN_NAME
      1	  14655 } /* grLfbUnlock */
	  14656 
	  14657 
	  14658 /*---------------------------------------------------------------------------
	  14659 ** grLfbWriteColorFormat
	  14660 **
	  14661 */
	  14662 
	  14663 GR_STATE_ENTRY(grLfbWriteColorFormat, void, (GrColorFormat_t colorFormat))
      1	  14664 {
      1	  14665 #define FN_NAME "grLfbWriteColorFormat"
      1	  14666   FxU32 lfbMode;
      1	  14667 
      1	  14668   GR_BEGIN_NOFIFOCHECK("grLfbWriteColorFormat",82);
      1	  14669   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",colorFormat);
      1	  14670 
      1	  14671   GR_CHECK_F(myName,
      1	  14672              colorFormat < 0 || colorFormat > 0x3,
      1	  14673              "invalid color format");
      1	  14674 
      1	  14675   lfbMode = gc->state.fbi_config.lfbMode;
      1	  14676   lfbMode &= ~SST_LFB_RGBALANES;
      1	  14677   lfbMode |= (colorFormat << SST_LFB_RGBALANES_SHIFT);
      1	  14678 
      2	  14679   {
      2	  14680     const FxBool sliP = gc->scanline_interleaved;
      2	  14681 
      2	  14682     GR_SET_EXPECTED_SIZE(sizeof(FxU32) + MaskSelect(sliP, sizeof(FxU32)),
      2	  14683                          1 + sliP);
      3	  14684     {
      3	  14685       GR_SET(BROADCAST_ID, hw, lfbMode, lfbMode);
      3	  14686       gc->state.fbi_config.lfbMode = lfbMode;
      3	  14687       
      3	  14688       if (sliP) GR_SET(BROADCAST_ID, hw, nopCMD, 0x0);
      2	  14689     }
      2	  14690     GR_CHECK_SIZE();
      1	  14691   }
      1	  14692 
      1	  14693   GR_END();
      1	  14694 #undef FN_NAME
      1	  14695 } /* grLfbWriteColorFormat */
	  14696 
	  14697 
	  14698 /*---------------------------------------------------------------------------
	  14699 **  grLfbWriteColorSwizzle  - set up SST for byte swizzling and word swapping
	  14700 **
	  14701 **  Registers/Bits Affected:
	  14702 **  lfbMode:  bit(11), bit(12)
	  14703 **
	  14704 **  WARNING:  GMT: SST_LFB_WRITE_SWAP16 changes pixel addressing!!!
	  14705 */
	  14706 GR_STATE_ENTRY(grLfbWriteColorSwizzle, void, (FxBool swizzleBytes, FxBool swapWords))
      1	  14707 {
      1	  14708 #define FN_NAME "grLfbWriteColorSwizzle"
      1	  14709   FxU32 lfbMode;

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      1	  14710 
      1	  14711   GR_BEGIN_NOFIFOCHECK("grLfbWriteColorSwizzle",82);
      1	  14712   GDBG_INFO_MORE(gc->myLevel,"(%d,%d)\n",swizzleBytes,swapWords);
      1	  14713 
      1	  14714   /* Clear out the bits we'll set back if appropriate */
      1	  14715   lfbMode = gc->state.fbi_config.lfbMode;
      1	  14716   lfbMode &= ~(SST_LFB_WRITE_SWAP16 | SST_LFB_WRITE_BYTESWAP);
      1	  14717 
      1	  14718   if (swizzleBytes)
      1	  14719     lfbMode |= SST_LFB_WRITE_BYTESWAP;
      1	  14720 
      1	  14721   if (swapWords)
      1	  14722     lfbMode |= SST_LFB_WRITE_SWAP16;
      1	  14723 
      2	  14724   {
      2	  14725     const FxBool sliP = gc->scanline_interleaved;
      2	  14726 
      2	  14727     GR_SET_EXPECTED_SIZE(sizeof(FxU32) + MaskSelect(sliP, sizeof(FxU32)),
      2	  14728                          1 + sliP);
      3	  14729     {
      3	  14730       GR_SET(BROADCAST_ID, hw, lfbMode, lfbMode);
      3	  14731       gc->state.fbi_config.lfbMode = lfbMode;
      3	  14732       
      3	  14733       if (sliP) GR_SET(BROADCAST_ID, hw, nopCMD, 0x0);
      2	  14734     }
      2	  14735     GR_CHECK_SIZE();
      1	  14736   }
      1	  14737 
      1	  14738   GR_END();
      1	  14739 #undef FN_NAME
      1	  14740 } /* grLfbWriteColorSwizzle */
	  14741 
	  14742 FxBool
	  14743 _grLfbWriteRegion(FxBool pixPipelineP,
	  14744                   GrBuffer_t dst_buffer, FxU32 dst_x, FxU32 dst_y, 
	  14745                   GrLfbSrcFmt_t src_format, 
	  14746                   FxU32 src_width, FxU32 src_height, 
	  14747                   FxI32 src_stride, void *src_data)
      1	  14748 {
      1	  14749 #define FN_NAME "_grLfbWriteRegion"
      1	  14750   FxBool           rv = FXTRUE;
      1	  14751   GrLfbInfo_t      info;
      1	  14752   GrLfbWriteMode_t writeMode;
      1	  14753   
      1	  14754   GR_BEGIN_NOFIFOCHECK("_grLfbWriteRegion", 82);
      1	  14755   GDBG_INFO_MORE(gc->myLevel,
      1	  14756                  "(0x%x, %s, %d, %d, %d, %d, %d, %d, 0x%x)\n", 
      1	  14757                  dst_buffer,
      1	  14758                  (pixPipelineP ? "Enable" : "Disable"),
      1	  14759                  dst_x, dst_y, 
      1	  14760                  src_format, src_width, src_height,
      1	  14761                  src_stride, src_data);
      1	  14762   
      1	  14763   if (src_format == GR_LFB_SRC_FMT_RLE16) 
      1	  14764     writeMode = GR_LFBWRITEMODE_565;
      1	  14765   else 
      1	  14766     writeMode = src_format;

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      1	  14767   
      1	  14768   gc->cmdTransportInfo.fifoLfbP = FXTRUE;
      1	  14769   info.size = sizeof(info);
      1	  14770   
      1	  14771   if (grLfbLock(GR_LFB_WRITE_ONLY | GR_LFB_NOIDLE, 
      1	  14772                 dst_buffer, 
      1	  14773                 writeMode,
      1	  14774                 GR_ORIGIN_UPPER_LEFT,
      1	  14775                 pixPipelineP,
      2	  14776                 &info)) {
      2	  14777     FxU32 *srcData;             /* Tracking Source Pointer */
      2	  14778     FxU32 *dstData;             /* Tracking Destination Pointer */
      2	  14779     FxU32 *end;                 /* Demarks End of each Scanline */
      2	  14780     FxI32 srcJump;              /* bytes to next scanline */
      2	  14781     FxU32 dstJump;              /* bytes to next scanline */
      2	  14782     FxU32 length;               /* bytes to copy in scanline */
      2	  14783     FxU32 scanline;             /* scanline number */
      2	  14784     int   aligned;              /* word aligned? */
      2	  14785 
      2	  14786     /* When writing to the fifo we give an offset from the
      2	  14787      * start of the lfb so we don't need to add it in here.
      2	  14788      */
      2X  14789 #if USE_PACKET_FIFO
      2X  14790     dstData = (FxU32*)(dst_y * info.strideInBytes);
      2X  14791 #else
      2	  14792     dstData = (FxU32*)(((FxU8*)info.lfbPtr) + (dst_y * info.strideInBytes));
      2	  14793 #endif
      2	  14794       
      2	  14795     srcData = (FxU32*)src_data;
      2	  14796     scanline = src_height;
      2	  14797     
      3	  14798     switch(src_format) {
      3	  14799       /* 16-bit aligned */
      3	  14800     case GR_LFB_SRC_FMT_565:
      3	  14801     case GR_LFB_SRC_FMT_555:
      3	  14802     case GR_LFB_SRC_FMT_1555:
      3	  14803     case GR_LFB_SRC_FMT_ZA16:
      3	  14804       dstData = (FxU32*)(((FxU16*)dstData) + dst_x);
      3	  14805       length  = src_width * 2;
      3	  14806       aligned = !((int)dstData & 0x2);
      3	  14807       srcJump = src_stride - length;
      3	  14808       dstJump = info.strideInBytes - length;
      3	  14809 
      4	  14810       if (aligned) {
      5	  14811         while(scanline--) {
      5	  14812           GR_ASSERT(((FxU32)dstData & 0x03UL) == 0);
      5	  14813           end = (FxU32*)((char*)srcData + length - 2);
      5	  14814                
      6	  14815           if (srcData < end) {
      7	  14816             LINEAR_WRITE_BEGIN(length >> 2, kLinearWriteLFB, dstData, 0x00, 0x00);
      8	  14817             while(srcData < end) {
      8	  14818               LINEAR_WRITE_SET_16((FxU32)dstData, srcData[0]);
      8	  14819               dstData++;
      8	  14820               srcData++;
      7	  14821             }
      6	  14822             LINEAR_WRITE_END();
      5	  14823           }

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      5	  14824                   
      6	  14825           if ((length & 0x3) != 0x00) {
      6	  14826             LINEAR_WRITE_EDGE(kLinearWriteLFB, dstData, *(FxU16*)srcData, sizeof(FxU16));
      6	  14827             dstData = (FxU32*)(((FxU16*)dstData) + 1);
      6	  14828             srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  14829           }
      5	  14830                   
      5	  14831           dstData = (FxU32*)(((char*)dstData) + dstJump);
      5	  14832           srcData = (FxU32*)(((char*)srcData) + srcJump);
      4	  14833         }
      4	  14834       } else {
      5	  14835         while(scanline--) {
      5	  14836           GR_ASSERT(((FxU32)dstData & 0x03UL) != 0);
      5	  14837           end = (FxU32*)((char*)srcData + length);
      5	  14838 
      5	  14839           LINEAR_WRITE_EDGE(kLinearWriteLFB, dstData, 
      5	  14840                             *(FxU16*)srcData, sizeof(FxU16));
      5	  14841           dstData = (FxU32*)(((FxU16*)dstData) + 1);
      5	  14842           srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  14843                   
      6	  14844           if (srcData < end) {
      6	  14845             const FxU32 numWords = (((FxU32)end - (FxU32)srcData) >> 2);
      6	  14846             FxU32 i;
      6	  14847 
      7	  14848             LINEAR_WRITE_BEGIN(numWords, kLinearWriteLFB, dstData, 0x00, 0x00);
      8	  14849             for(i = 0; i < numWords; i++) {
      8	  14850               LINEAR_WRITE_SET_16((FxU32)dstData, srcData[0]);
      8	  14851               dstData++;
      8	  14852               srcData++;
      7	  14853             }
      6	  14854             LINEAR_WRITE_END();
      5	  14855           }
      5	  14856                   
      6	  14857           if ((length & 0x03) == 0) {
      6	  14858             LINEAR_WRITE_EDGE(kLinearWriteLFB, dstData, 
      6	  14859                               *(FxU16*)srcData, sizeof(FxU16));
      6	  14860             dstData = (FxU32*)(((FxU16*)dstData) + 1);
      6	  14861             srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  14862           }
      5	  14863                   
      5	  14864           dstData = (FxU32*)(((char*)dstData) + dstJump);
      5	  14865           srcData = (FxU32*)(((char*)srcData) + srcJump);
      4	  14866         }
      3	  14867       }
      3	  14868       break;
      3	  14869 
      3	  14870       /* 32-bit aligned */
      3	  14871     case GR_LFB_SRC_FMT_888:
      3	  14872     case GR_LFB_SRC_FMT_8888:
      3	  14873     case GR_LFB_SRC_FMT_565_DEPTH:
      3	  14874     case GR_LFB_SRC_FMT_555_DEPTH:
      3	  14875     case GR_LFB_SRC_FMT_1555_DEPTH:
      3	  14876       dstData = ((FxU32*)dstData) + dst_x;
      3	  14877       length  = src_width * 4;
      3	  14878       srcJump = src_stride - length;
      3	  14879       dstJump = info.strideInBytes - length;
      4	  14880       while(scanline--) {

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      4	  14881         end = (FxU32*)((char*)srcData + length);
      4	  14882             
      5	  14883         LINEAR_WRITE_BEGIN(src_width,
      5	  14884                            kLinearWriteLFB,
      5	  14885                            (FxU32)dstData,
      5	  14886                            0x00, 0x00);
      6	  14887         while(srcData < end) {
      6	  14888           LINEAR_WRITE_SET((FxU32)dstData, srcData[0]);
      6	  14889           dstData++;
      6	  14890           srcData++;
      5	  14891         }
      4	  14892         LINEAR_WRITE_END();
      4	  14893             
      4	  14894         dstData = (FxU32*)(((char*)dstData)+dstJump);
      4	  14895         srcData = (FxU32*)(((char*)srcData)+srcJump);
      3	  14896       }
      3	  14897       break;
      3	  14898     case GR_LFB_SRC_FMT_RLE16:
      3	  14899       /* needs to be implemented */
      3	  14900       rv = FXFALSE;
      3	  14901       break;
      2	  14902     }
      2	  14903     grLfbUnlock(GR_LFB_WRITE_ONLY, dst_buffer);
      2	  14904   } else {
      2	  14905     rv = FXFALSE;
      1	  14906   }
      1	  14907   gc->cmdTransportInfo.fifoLfbP = FXFALSE;
      1	  14908   GR_RETURN(rv);
      1	  14909 #undef FN_NAME
      1	  14910 } /* grLfbWriteRegion */
	  14911 
	  14912 /*-------------------------------------------------------------------
	  14913   Function: grLfbWriteRegion
	  14914   Date: 3/5
	  14915   Implementor(s): jdt
	  14916   Library: Glide
	  14917   Description:
	  14918   Write a pixel rectangle to the frame buffer as efficiently as possible
	  14919   Arguments:
	  14920   dst_buffer  - buffer to which to copy data
	  14921   dst_x,dst_y - destination image start coordinates
	  14922   src_format  - data format of source image
	  14923   src_width, src_height 
	  14924               - dimensions of source image
	  14925   src_stride  - stride of source image in bytes, not meaningful
	  14926                 for RLE images
	  14927   src_data    - pointer to source data memory           
	  14928   Return:
	  14929   FXTRUE  succeed
	  14930   FXFALSE fail
	  14931   -------------------------------------------------------------------*/
	  14932 GR_ENTRY(grLfbWriteRegion, FxBool, (GrBuffer_t dst_buffer, 
	  14933                                     FxU32 dst_x, FxU32 dst_y, 
	  14934                                     GrLfbSrcFmt_t src_format, 
	  14935                                     FxU32 src_width, FxU32 src_height, 
	  14936                                     FxI32 src_stride, void *src_data))
      1	  14937 {

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      1	  14938   FxBool           rv = FXTRUE;
      1	  14939   
      1	  14940   GR_BEGIN_NOFIFOCHECK("grLfbWriteRegion",82);
      1	  14941   GDBG_INFO_MORE(gc->myLevel,
      1	  14942                  "(0x%x,%d,%d,%d,%d,%d,%d,0x%x)\n", 
      1	  14943                  dst_buffer, dst_x, dst_y, 
      1	  14944                  src_format, src_width, src_height,
      1	  14945                  src_stride, src_data);
      1	  14946   
      1	  14947   rv = _grLfbWriteRegion(FXFALSE, dst_buffer, dst_x, dst_y,
      1	  14948                          src_format, src_width, src_height,
      1	  14949                          src_stride, src_data);
      1	  14950 
      1	  14951   GR_RETURN(rv);
      1	  14952 } /* grLfbWriteRegion */
	  14953 
	  14954 /*-------------------------------------------------------------------
	  14955   Function: grLfbReadRegion
	  14956   Date: 3/12
	  14957   Implementor(s): jdt
	  14958   Library: Glide
	  14959   Description:
	  14960   Grab a rectangle from the frame buffer into user supplied memory
	  14961   Arguments:
	  14962   src_buffer - buffer to read from 
	  14963   src_x      - x coordinate of upper left corner rectangle to read
	  14964   src_y      - y coordinate of upper left corner of rectangle to read
	  14965   src_width  - width of rectangle to read
	  14966   src_height - height of rectangle to read
	  14967   dst_stride - distance between scanlines in destination buffer
	  14968   dst_data   - pointer to user memory in which to place image
	  14969   Return:
	  14970   FXTRUE - success
	  14971   FXFALSE - failure
	  14972   -------------------------------------------------------------------*/
	  14973 GR_ENTRY(grLfbReadRegion, FxBool, (GrBuffer_t src_buffer, 
	  14974                                    FxU32 src_x, FxU32 src_y, 
	  14975                                    FxU32 src_width, FxU32 src_height, 
	  14976                                    FxU32 dst_stride, void *dst_data))
      1	  14977 {
      1	  14978 #define FN_NAME "grLfbReadRegion"
      1	  14979   FxBool rv = FXTRUE;
      1	  14980   GrLfbInfo_t info;
      1	  14981   
      1	  14982   GR_BEGIN_NOFIFOCHECK("grLfbReadRegion", 82);
      1	  14983   GDBG_INFO_MORE(gc->myLevel,
      1	  14984                  "(0x%x,%d,%d,%d,%d,%d,0x%x)\n",
      1	  14985                  src_buffer, src_x, src_y,
      1	  14986                  src_width, src_height, dst_stride, dst_data);
      1	  14987 
      1	  14988 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) 
      1	  14989 #define kTileSize (32 * sizeof(FxU16))
      1	  14990 #define kTileMask (kTileSize - 1)
      1	  14991 #define kPageMask ((kTileSize << 1) - 1)
      1	  14992 
      2	  14993   {
      2	  14994     const FxBool swapP = ((gc->grColBuf >= 3) &&

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      2	  14995                           (((src_buffer == GR_BUFFER_BACKBUFFER) && (gc->hwDep.cvgDep.backBuf == 2)) ||
      2	  14996                            ((src_buffer == GR_BUFFER_FRONTBUFFER) && (gc->hwDep.cvgDep.frontBuf == 2))));
      2	  14997 
      2	  14998     if (swapP && (gc->grAuxBuf > 0)) sst1InitAllocBuffers(gc->base_ptr, 
      2	  14999                                                           gc->grColBuf, 
      2	  15000                                                           0);
      2	  15001 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      2	  15002   
      2	  15003     info.size = sizeof(info);
      2	  15004     if (grLfbLock(GR_LFB_READ_ONLY,
      2	  15005                   src_buffer,
      2	  15006                   GR_LFBWRITEMODE_ANY,
      2	  15007                   GR_ORIGIN_UPPER_LEFT,
      2	  15008                   FXFALSE,
      3	  15009                   &info)) {
      3	  15010       const FxU32 *srcData;       /* Tracking Source Pointer */
      3	  15011       FxU32 *dstData;             /* Tracking Destination Pointer */
      3	  15012       FxU32 srcJump;              /* bytes to next scanline */
      3	  15013       FxU32 dstJump;              /* bytes to next scanline */
      3	  15014       FxU32 length;               /* bytes to copy in scanline */
      3	  15015       FxU32 scanline;             /* scanline number */
      3	  15016      
      3	  15017       dstData = (FxU32*)dst_data;
      3	  15018       srcData = (const FxU32*)((FxU8*)info.lfbPtr +
      3	  15019                                (src_y * info.strideInBytes) +
      3	  15020                                (src_x << 1));
      3	  15021       scanline = src_height;
      3	  15022       length   = src_width * 2;
      3	  15023       dstJump  = dst_stride - length;
      3	  15024       srcJump  = info.strideInBytes - length;
      3	  15025 
      3	  15026 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) 
      3	  15027       /* Voodoo2 has a problem reading from the frame buffer if we are
      3	  15028        * triple buffering and the triple buffer is the currently
      3	  15029        * active lfb buffer. The problem is that the 32 pixel screen
      3	  15030        * tiles are reversed such that the logical tiling 0101 comes
      3	  15031        * back as 1010. We do the 'swapping' here for the app, but
      3	  15032        * if they use direct lfb accesses they are screwed.
      3	  15033        */
      4	  15034       if (swapP) {
      5	  15035         while(scanline--) {
      5	  15036           FxU32* const dstEnd = (FxU32*)((FxU8*)dstData + length);
      5	  15037           const FxU32* end = (const FxU32*)((FxU8*)srcData + length);
      5	  15038           const FxU32* tilePtr;
      5	  15039           const FxU32* tileEnd;
      5	  15040           const FxU32* tileEndAlign;
      5	  15041 
      5	  15042           /* Leading slop up to the start of a logical 0 tile */
      6	  15043           if (((FxU32)srcData & kPageMask) != 0) {
      6	  15044             FxU32 tileSlopMask = 0xFFFFFFFFUL;
      6	  15045             FxU32 tileSlopAdjust = kTileSize;
      6	  15046 
      6	  15047             /* Do we have a partial 0 tile? */
      7	  15048             if (((FxU32)srcData & kTileSize) == 0) {
      7	  15049               tilePtr      = (const FxU32*)((FxU32)srcData + kTileSize);
      7	  15050               tileEnd      = (const FxU32*)(((FxU32)end <= ((FxU32)tilePtr & ~kTileMask))
      7	  15051                                             ? ((FxU32)end + kTileSize)

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      7	  15052                                             : (((FxU32)tilePtr + kTileSize) & ~kTileMask));
      7	  15053               tileEndAlign = (const FxU32*)((FxU32)tileEnd & ~0x03UL);
      7	  15054 
      7	  15055               /* Are we aligned in the hw lfb? */
      8	  15056               if (((FxU32)tilePtr & 0x03UL) != 0) {
      8	  15057                 *(FxU16*)dstData = GR_GET16(*tilePtr);
      8	  15058                 dstData = (FxU32*)((FxU8*)dstData + sizeof(FxU16));
      8	  15059                 tilePtr = (const FxU32*)((FxU8*)tilePtr + sizeof(FxU16));
      7	  15060               }
      7	  15061 
      7	  15062               /* Copy the remainder of the 0 tile */
      7	  15063               while(tilePtr < tileEndAlign) *dstData++ = GR_GET(*tilePtr++);
      7	  15064               if (tileEnd != tileEndAlign) *(FxU16*)dstData = GR_GET16(*tilePtr);
      7	  15065 
      7	  15066               tileSlopMask = ~kTileMask;
      7	  15067               tileSlopAdjust = 0;
      6	  15068             }
      6	  15069 
      6	  15070             /* Copying the logical 1 tile. This may require us to go
      6	  15071              * 'backwards' in physical memory if there was no logical
      6	  15072              * 0 tile in the current read.  
      6	  15073              */
      6	  15074             tilePtr      = (const FxU32*)(((FxU32)srcData - tileSlopAdjust) & tileSlopMask);
      6	  15075             tileEnd      = (const FxU32*)MIN((((FxU32)tilePtr + kTileSize) & ~kTileMask), 
      6	  15076                                              (FxU32)end - kTileSize - sizeof(FxU16));
      6	  15077             tileEndAlign = (const FxU32*)((FxU32)tileEnd & ~0x03UL);
      6	  15078 
      7	  15079             if (tilePtr < tileEnd) {
      7	  15080               /* Are we aligned in the hw lfb? */
      8	  15081               if (((FxU32)tilePtr & 0x03UL) != 0) {
      8	  15082                 *(FxU16*)dstData = GR_GET16(*tilePtr);
      8	  15083                 dstData = (FxU32*)((FxU8*)dstData + sizeof(FxU16));
      8	  15084                 tilePtr = (const FxU32*)((FxU8*)tilePtr + sizeof(FxU16));
      7	  15085               }
      7	  15086               
      7	  15087               /* Copy the remainder of the logical 1 tile */
      7	  15088               while(tilePtr < tileEndAlign) *dstData++ = GR_GET(*tilePtr++);
      7	  15089               if (tileEnd != tileEndAlign) 
      7	  15090                 *(FxU16*)dstData = GR_GET16(*tilePtr);
      6	  15091             }
      6	  15092               
      6	  15093             srcData = (const FxU32*)(((FxU32)srcData + (kTileSize << 1)) & ~kPageMask);
      5	  15094           }
      5	  15095 
      5	  15096           /* Loop over complete logical 01 tile groups */
      6	  15097           {
      6	  15098             const FxU32* endTileAddr = (const FxU32*)((FxU32)end & ~kPageMask);
      6	  15099 
      7	  15100             while(srcData < endTileAddr) {
      7	  15101               tilePtr     = (const FxU32*)((FxU32)srcData + kTileSize);
      7	  15102               tileEnd     = (const FxU32*)((FxU32)tilePtr + kTileSize);
      7	  15103               while(tilePtr < tileEnd) *dstData++ = GR_GET(*tilePtr++);
      7	  15104               
      7	  15105               tilePtr = srcData;
      7	  15106               tileEnd = (const FxU32*)((FxU32)tilePtr + kTileSize);
      7	  15107               while(tilePtr < tileEnd) *dstData++ = GR_GET(*tilePtr++);
      7	  15108 

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      7	  15109               srcData = (const FxU32*)((FxU8*)srcData + (kTileSize << 1));
      6	  15110             }
      5	  15111           }
      5	  15112 
      5	  15113           /* Slop 01 tile group */
      6	  15114           if (srcData < end) {
      6	  15115             const FxU32* startTileAddr = (const FxU32*)((FxU32)srcData + kTileSize);
      6	  15116             
      6	  15117             tilePtr      = startTileAddr;
      6	  15118             tileEnd      = (const FxU32*)((FxU32)startTileAddr + 
      6	  15119                                           MIN(kTileSize, ((FxU32)end - (FxU32)srcData)));
      6	  15120             tileEndAlign = (const FxU32*)((FxU32)tileEnd & ~0x3);
      6	  15121 
      6	  15122             while(tilePtr < tileEndAlign) *dstData++ = GR_GET(*tilePtr++);
      6	  15123             if (tileEnd != tileEndAlign) 
      6	  15124               *(FxU16*)dstData = GR_GET16(*tilePtr);
      6	  15125 
      7	  15126             if (startTileAddr < end) {
      7	  15127               tilePtr      = srcData;
      7	  15128               tileEnd      = (const FxU32*)((FxU8*)tilePtr + kTileSize - 
      7	  15129                                             ((FxU32)tileEndAlign - (FxU32)end));
      7	  15130               tileEndAlign = (const FxU32*)((FxU32)tileEnd & ~0x3);
      7	  15131 
      7	  15132               while(tilePtr < tileEndAlign) *dstData++ = GR_GET(*tilePtr++);
      7	  15133               if (tileEnd != tileEndAlign) 
      7	  15134                 *(FxU16*)dstData = GR_GET16(*tilePtr);
      6	  15135             }
      5	  15136           }
      5	  15137 
      5	  15138           /* Adjust pointers */
      5	  15139           dstData = (FxU32*)((FxU8*)dstEnd + dstJump);
      5	  15140           srcData = (const FxU32*)((FxU8*)end + srcJump);
      4	  15141         }
      3	  15142       } else
      3	  15143 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */     
      3	  15144       /* If the source data is aligned for 4 byte pci reads */
      4	  15145       if (((FxU32)srcData & 0x02UL) == 0) {
      5	  15146         while(scanline--) {
      5	  15147           const FxU32* end = (const FxU32*)((char*)srcData + length - 2);
      5	  15148           
      6	  15149           while(srcData < end) {
      6	  15150             *dstData++ = GR_GET(*srcData++);
      5	  15151           }
      5	  15152           
      6	  15153           if (((int)length) & 0x2) {
      6	  15154             (*(FxU16*)dstData) = GR_GET16(*srcData);
      6	  15155             dstData = (FxU32*)(((FxU16*)dstData) + 1);
      6	  15156             srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  15157           }
      5	  15158           
      5	  15159           dstData = (FxU32*)(((char*)dstData)+dstJump);
      5	  15160           srcData = (FxU32*)(((char*)srcData)+srcJump);
      4	  15161         }
      4	  15162       } else {
      5	  15163         while(scanline--) {
      5	  15164           const FxU32* end = (const FxU32*)((char*)srcData + length - 2);
      5	  15165 

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

      5	  15166           (*(FxU16*)dstData) = (FxU16)GR_GET16(*srcData);
      5	  15167           dstData = (FxU32*)(((FxU16*)dstData) + 1);
      5	  15168           srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  15169 
      6	  15170           while(srcData < end) {
      6	  15171             *dstData++ = GR_GET(*srcData++);
      5	  15172           }
      5	  15173 
      6	  15174           if (!(((int)length) & 0x2)) {
      6	  15175             (*(FxU16*)dstData) = GR_GET16(*srcData);
      6	  15176             dstData = (FxU32*)(((FxU16*)dstData) + 1);
      6	  15177             srcData = (FxU32*)(((FxU16*)srcData) + 1);
      5	  15178           }
      5	  15179                 
      5	  15180           dstData = (FxU32*)(((char*)dstData)+dstJump);
      5	  15181           srcData = (FxU32*)(((char*)srcData)+srcJump);
      4	  15182         }
      3	  15183       }
      3	  15184 
      3	  15185       grLfbUnlock(GR_LFB_READ_ONLY, src_buffer);
      3	  15186     } else {
      3	  15187       rv = FXFALSE;
      2	  15188     }
      2	  15189 
      2	  15190 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) 
      2	  15191     if (swapP && (gc->grAuxBuf > 0)) sst1InitAllocBuffers(gc->base_ptr, 
      2	  15192                                                           gc->grColBuf, 
      2	  15193                                                           gc->grAuxBuf);
      1	  15194   }
      1	  15195 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG)  */
      1	  15196 
      1	  15197   GR_RETURN(rv);
      1	  15198 #undef FN_NAME
      1	  15199 }/* grLfbReadRegion */
	  15200 


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GLFB/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GLFB.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GLFB.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 

GLFB                            Source Listing                   9-MAY-2021 23:42:57  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  glfb.c;1

 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:58"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19  * 
	     20  * 14    1/08/98 4:58p Atai
	     21  * tex table broadcast, grVertexLayout enable/disable, stq, and some
	     22  * defines
	     23  * 
	     24  * 13    12/12/97 10:59a Atai
	     25  * clip space and viewport
	     26  * 
	     27  * 12    12/08/97 10:42a Atai
	     28  * added grDrawVertexArrayLinear()
	     29  * 
	     30  * 11    11/21/97 6:05p Atai
	     31  * use one datalist (tsuDataList) in glide3
	     32  * 
	     33  * 10    11/18/97 6:11p Peter
	     34  * fixed glide3 muckage
	     35  * 
	     36  * 9     11/18/97 3:24p Atai
	     37  * change grParameterData to grVertexLayout
	     38  * define GR_PARAM_*
	     39  * 
	     40  * 8     11/07/97 11:22a Atai
	     41  * remove GR_*_SMOOTH. use GR_SMOOTH
	     42  * 
	     43  * 7     11/06/97 6:10p Atai
	     44  * update GrState size
	     45  * rename grDrawArray to grDrawVertexArray
	     46  * update _grDrawPoint and _grDrawVertexList
	     47  * 
	     48  * 6     10/21/97 8:36p Atai
	     49  * added gr_lines routines
	     50  * use dword offset
	     51  * 
	     52  * 5     10/17/97 2:11p Atai
	     53  * added grContinueArray. We only support non aa mode for now.
	     54  * 
	     55  * 4     10/14/97 4:34p Atai
	     56  * filled out the calls to different drawarray routines
	     57  * 

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

	     58  * 3     9/29/97 1:26p Dow
	     59  * Fixed packed color strips/fans
	     60  * 
	     61  * 2     9/26/97 10:24a Dow
	     62  * Fixed state muckage in Glide3 parameter data
	     63  * 
	     64  * 1     9/23/97 2:04p Dow
	     65  * DI code for strips
	     66 **
	     67 */
	     68 
	     69 int x; // make the compiler happy on VMS
	     70 
       X     71 #ifdef GLIDE3
       X     72 
       X     73 #include <3dfx.h>
       X     74 #include <glidesys.h>
       X     75 
       X     76 #define FX_DLL_DEFINITION
       X     77 #include <fxdll.h>
       X     78 #include <glide.h>
       X     79 #include "fxglide.h"
       X     80 
       X     81 /*-------------------------------------------------------------------
       X     82   Function: grVertexLayout
       X     83   Date: 17-Sep-97
       X     84   Implementor(s): dow
       X     85   Library: Init Code for 
       X     86   Description:
       X     87     This routine defines the format for vertex arrays.
       X     88 
       X     89   Arguments:
       X     90     param       -  Type of date-i.e. vertex, color, or texture info:
       X     91                    GR_COLOR, GR_VERTEX, GR_TEXTURE0, GR_TEXTURE1
       X     92     components  -  Which components are specified
       X     93                    Valid Components:
       X     94 
       X     95 
       X     96         So, this table summarizes the legal combinations:
       X     97         Param           Type            Size    Description 
       X     98         =======================================================================================================
       X     99         GR_PARAM_XY     FxFloat         8       X and Y coordinates.  Offset must be zero.
       X    100         GR_PARAM_Z      FxFloat         4       Z coordinate.
       X    101         GR_PARAM_A      FxFloat         4       Alpha value.
       X    102         GR_PARAM_RGB    FxFloat         12      RGB triplet.
       X    103         GR_PARAM_PARGB  FxU32           4       Packed ARGB.  High-order byte is A, followed by R, G, and B.
       X    104         GR_PARAM_STn    FxFloat         8       S and T coordinates for TMU , where n is in the range [0, TBD]
       X    105         GR_PARAM_Wn     FxFloat         4       
       X    106 
       X    107   Return:
       X    108   Nothing ever.
       X    109   -------------------------------------------------------------------*/
       X    110 GR_DIENTRY(grVertexLayout, void , (FxU32 param, FxI32 offset, FxU32 mode) )
       X    111 {
       X    112 #define FN_NAME "grParameterData"
       X    113   GR_BEGIN_NOFIFOCHECK(FN_NAME, 85);
       X    114 

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    115   GDBG_INFO_MORE(gc->myLevel, "(0x%x, 0x%x)\n", param, offset);
       X    116 
       X    117   gc->state.vData.vertexInfo.param = param;
       X    118 
       X    119   switch (param) {
       X    120   case GR_PARAM_XY:
       X    121     GR_CHECK_F(myName,
       X    122                (offset != 0), 
       X    123                "Offset must be zero.");
       X    124 
       X    125     gc->state.vData.vertexInfo.offset = offset;
       X    126     gc->state.vData.vertexInfo.mode = mode;
       X    127     break;
       X    128 
       X    129   case GR_PARAM_Z:
       X    130 
       X    131     gc->state.vData.zInfo.offset = offset;
       X    132     gc->state.vData.zInfo.mode = mode;
       X    133 
       X    134     break;
       X    135 
       X    136   case GR_PARAM_W:
       X    137 
       X    138     gc->state.vData.wInfo.offset = offset;
       X    139     gc->state.vData.wInfo.mode = mode;
       X    140 
       X    141     break;
       X    142 
       X    143   case GR_PARAM_A:
       X    144 
       X    145     gc->state.vData.aInfo.offset = offset;
       X    146     gc->state.vData.colorType = GR_FLOAT;
       X    147     gc->state.vData.aInfo.mode = mode;
       X    148 
       X    149     break;
       X    150   case GR_PARAM_RGB:
       X    151 
       X    152     gc->state.vData.rgbInfo.offset = offset;
       X    153     gc->state.vData.colorType = GR_FLOAT;
       X    154     gc->state.vData.rgbInfo.mode = mode;
       X    155 
       X    156     break;
       X    157   case GR_PARAM_PARGB:
       X    158 
       X    159     gc->state.vData.pargbInfo.offset = offset;
       X    160     gc->state.vData.colorType = GR_U8;
       X    161     gc->state.vData.pargbInfo.mode = mode;
       X    162 
       X    163     break;
       X    164   case GR_PARAM_ST0:
       X    165 
       X    166     gc->state.vData.st0Info.offset = offset;
       X    167     gc->state.vData.st0Info.mode = mode;
       X    168 
       X    169     break;
       X    170   case GR_PARAM_ST1:
       X    171 

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    172     gc->state.vData.st1Info.offset = offset;
       X    173     gc->state.vData.st1Info.mode = mode;
       X    174 
       X    175     break;
       X    176   case GR_PARAM_Q:
       X    177 
       X    178     gc->state.vData.qInfo.offset = offset;
       X    179     gc->state.vData.qInfo.mode = mode;
       X    180 
       X    181     break;
       X    182   case GR_PARAM_Q0:
       X    183 
       X    184     gc->state.vData.q0Info.offset = offset;
       X    185     gc->state.vData.q0Info.mode = mode;
       X    186 
       X    187     break;
       X    188   case GR_PARAM_Q1:
       X    189 
       X    190     gc->state.vData.q1Info.offset = offset;
       X    191     gc->state.vData.q1Info.mode = mode;
       X    192 
       X    193     break;
       X    194   }
       X    195 
       X    196 #if !GLIDE3_VERTEX_LAYOUT
       X    197   switch (param) {
       X    198   case GR_VERTEX:
       X    199     GR_CHECK_F(myName,
       X    200                !((components == GR_VERTEX_XYZ) ||
       X    201                 (components == GR_VERTEX_XYZW)), 
       X    202                "Bad Component for Vertex Parameter");
       X    203     gc->state.vData.vertexInfo.components = components;
       X    204 
       X    205     GR_CHECK_F(myName, !(type == GR_FLOAT), "Bad Type for Vertex Parameter"); 
       X    206     gc->state.vData.vertexInfo.type = type;
       X    207 
       X    208     gc->state.vData.vertexInfo.offset = offset;
       X    209 
       X    210     GDBG_INFO(gc->myLevel, "%s:  Vertex Offset = %d\n", FN_NAME,
       X    211               gc->state.vData.vertexInfo.offset);
       X    212     
       X    213     break;
       X    214 
       X    215   case GR_COLOR:
       X    216     GR_CHECK_F(myName,
       X    217                !((components == GR_COLOR_RGB) || (components == GR_COLOR_RGBA)),
       X    218                "Bad Component for Color Parameter");
       X    219     gc->state.vData.colorInfo.components = components;
       X    220 
       X    221     GR_CHECK_F(myName, !((type == GR_FLOAT) || (type == GR_U8)), 
       X    222                "Bad Type for Color Parameter");
       X    223     gc->state.vData.colorInfo.type = type;
       X    224 
       X    225     gc->state.vData.colorInfo.offset = offset;
       X    226     GDBG_INFO(gc->myLevel, "%s:  Color Offset = %d\n", FN_NAME,
       X    227               gc->state.vData.colorInfo.offset);
       X    228     

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    229     break;
       X    230     
       X    231   case GR_TEXTURE0:
       X    232     GR_CHECK_F(myName,
       X    233                !((components == GR_TEX_NONE) || (components == GR_TEX_ST) ||
       X    234                 (components == GR_TEX_STW)),
       X    235                "Bad Component for Texture Parameter");
       X    236     gc->state.vData.tex0Info.components = components;
       X    237 
       X    238     GR_CHECK_F(myName, !(type == GR_FLOAT), "Bad Type for Texture Parameter");
       X    239     gc->state.vData.tex0Info.type == type;
       X    240 
       X    241     gc->state.vData.tex0Info.offset = offset;
       X    242     GDBG_INFO(gc->myLevel, "%s:  Tex0 Offset = %d\n", FN_NAME,
       X    243               gc->state.vData.tex0Info.offset);
       X    244     
       X    245     break;
       X    246 
       X    247   case GR_TEXTURE1:
       X    248     GR_CHECK_F(myName,
       X    249                !((components == GR_TEX_NONE) || (components == GR_TEX_ST) ||
       X    250                 (components == GR_TEX_STW)),
       X    251                "Bad Component for Texture Parameter");
       X    252     gc->state.vData.tex1Info.components = components;
       X    253 
       X    254     GR_CHECK_F(myName, !(type == GR_FLOAT), "Bad Type for Texture Parameter");
       X    255     gc->state.vData.tex1Info.type == type;
       X    256 
       X    257     gc->state.vData.tex1Info.offset = offset;
       X    258     GDBG_INFO(gc->myLevel, "%s:  Tex1 Offset = %d\n", FN_NAME,
       X    259               gc->state.vData.tex1Info.offset);
       X    260     break;
       X    261     
       X    262   default:
       X    263     GR_CHECK_F(myName, 0, "Invalid Parameter");
       X    264     break;
       X    265 
       X    266   }
       X    267 #endif /* !GLIDE3_VERTEX_LAYOUT */
       X    268 
       X    269   _grRebuildDataList();
       X    270 
       X    271   GR_END();
       X    272 #undef FN_NAME
       X    273 } /* grParameterData */
       X    274 
       X    275 /*-------------------------------------------------------------------
       X    276   Function: grDrawVertexArray
       X    277   Date: 18-Sep-97
       X    278   Implementor(s): dow
       X    279   Description:
       X    280   
       X    281   Arguments:
       X    282         mode:   GR_POINTS, GR_LINE_STRIP, GR_POLYGON, GR_TRIANLGE_STRIP,
       X    283                 GR_TRIANGLE_FAN, GR_TRIANGLES
       X    284   
       X    285   Return:

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    286         Nothing ever
       X    287   -------------------------------------------------------------------*/
       X    288 GR_DIENTRY(grDrawVertexArray, void , (FxU32 mode, FxU32 Count, void *pointers) )
       X    289 {
       X    290 #define FN_NAME "grDrawVertexArray"
       X    291   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
       X    292 
       X    293   GDBG_INFO_MORE(gc->myLevel, "(0x%x, 0x%x, 0x%x)\n",
       X    294                  mode, Count, pointers);
       X    295 
       X    296 #ifdef GDBG_INFO_ON
       X    297   {
       X    298     FxU32 i;
       X    299     for (i = 0; i < Count; i++)
       X    300       GDBG_INFO(110, "%s:  pointers[%d] = 0x%x\n",
       X    301                 FN_NAME, i, ((float **)pointers)[i]);
       X    302   }
       X    303 #endif
       X    304 
       X    305   switch (mode) {
       X    306   case GR_POINTS:
       X    307     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    308       _grAADrawPoints(GR_VTX_PTR_ARRAY, Count, pointers);
       X    309     else
       X    310       _grDrawPoints(GR_VTX_PTR_ARRAY, Count, pointers);
       X    311     break;
       X    312   case GR_LINE_STRIP:
       X    313     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    314       _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINE_STRIP, Count, pointers);
       X    315     else
       X    316       _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINE_STRIP, Count, pointers);
       X    317     break;
       X    318   case GR_LINES:
       X    319     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    320       _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, Count, pointers);
       X    321     else
       X    322       _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, Count, pointers);
       X    323     break;
       X    324   case GR_POLYGON:
       X    325     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    326       _grAADrawVertexList(kSetupFan, GR_VTX_PTR_ARRAY, Count, pointers);
       X    327     else
       X    328       _grDrawVertexList(kSetupFan, GR_VTX_PTR_ARRAY, Count, pointers);
       X    329     break;
       X    330     
       X    331   case GR_TRIANGLE_STRIP:
       X    332     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    333       _grAADrawVertexList(kSetupStrip, GR_VTX_PTR_ARRAY, Count, pointers);
       X    334     else
       X    335       _grDrawVertexList(kSetupStrip, GR_VTX_PTR_ARRAY, Count, pointers);
       X    336     break;
       X    337 
       X    338   case GR_TRIANGLE_FAN:
       X    339     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    340       _grAADrawVertexList(kSetupFan, GR_VTX_PTR_ARRAY, Count, pointers);
       X    341     else
       X    342       _grDrawVertexList(kSetupFan, GR_VTX_PTR_ARRAY, Count, pointers);

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    343     break;
       X    344       
       X    345   case GR_TRIANGLES:
       X    346     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    347       if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS)
       X    348         _grAADrawTriangles(GR_VTX_PTR_ARRAY, GR_TRIANGLES, Count, pointers);
       X    349       else
       X    350         _grAAVpDrawTriangles(GR_VTX_PTR_ARRAY, GR_TRIANGLES, Count, pointers);
       X    351     else 
       X    352       _grDrawTriangles(GR_VTX_PTR_ARRAY, Count, pointers);
       X    353     break;
       X    354 
       X    355   }
       X    356 #undef FN_NAME
       X    357 } /* grDrawVertexArray */
       X    358 
       X    359 
       X    360 /*-------------------------------------------------------------------
       X    361   Function: grDrawVertexArrayLinear
       X    362   Date: 04-Dec-97
       X    363   Implementor(s): atai
       X    364   Description:
       X    365   
       X    366   Arguments:
       X    367         mode:   GR_POINTS, GR_LINE_STRIP, GR_POLYGON, GR_TRIANLGE_STRIP,
       X    368                 GR_TRIANGLE_FAN, GR_TRIANGLES
       X    369   
       X    370   Return:
       X    371         Nothing ever
       X    372   -------------------------------------------------------------------*/
       X    373 GR_DIENTRY(grDrawVertexArrayLinear, void , (FxU32 mode, FxU32 Count, void *pointers, FxU32 stride) )
       X    374 {
       X    375 #define FN_NAME "grDrawVertexArrayLinear"
       X    376   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
       X    377 
       X    378   GDBG_INFO_MORE(gc->myLevel, "(0x%x, 0x%x, 0x%x)\n",
       X    379                  mode, Count, pointers);
       X    380 
       X    381 #ifdef GDBG_INFO_ON
       X    382   {
       X    383     FxU32 i;
       X    384     for (i = 0; i < Count; i++)
       X    385       GDBG_INFO(110, "%s:  pointers[%d] = 0x%x\n",
       X    386                 FN_NAME, i, (int)pointers + gc->state.vData.vStride * i);
       X    387   }
       X    388 #endif
       X    389 
       X    390   gc->state.vData.vStride = stride >> 2;
       X    391   switch (mode) {
       X    392   case GR_POINTS:
       X    393     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    394       _grAADrawPoints(GR_VTX_PTR, Count, pointers);
       X    395     else
       X    396       _grDrawPoints(GR_VTX_PTR, Count, pointers);
       X    397     break;
       X    398   case GR_LINE_STRIP:
       X    399     if (gc->state.grEnableArgs.primitive_smooth_mode)

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

       X    400       _grAADrawLineStrip(GR_VTX_PTR, GR_LINE_STRIP, Count, pointers);
       X    401     else
       X    402       _grDrawLineStrip(GR_VTX_PTR, GR_LINE_STRIP, Count, pointers);
       X    403     break;
       X    404   case GR_LINES:
       X    405     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    406       _grAADrawLineStrip(GR_VTX_PTR, GR_LINES, Count, pointers);
       X    407     else
       X    408       _grDrawLineStrip(GR_VTX_PTR, GR_LINES, Count, pointers);
       X    409     break;
       X    410   case GR_POLYGON:
       X    411     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    412       _grAADrawVertexList(kSetupFan, GR_VTX_PTR, Count, pointers);
       X    413     else
       X    414       _grDrawVertexList(kSetupFan, GR_VTX_PTR, Count, pointers);
       X    415     break;
       X    416     
       X    417   case GR_TRIANGLE_STRIP:
       X    418     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    419       _grAADrawVertexList(kSetupStrip, GR_VTX_PTR, Count, pointers);
       X    420     else
       X    421       _grDrawVertexList(kSetupStrip, GR_VTX_PTR, Count, pointers);
       X    422     break;
       X    423 
       X    424   case GR_TRIANGLE_FAN:
       X    425     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    426       _grAADrawVertexList(kSetupFan, GR_VTX_PTR, Count, pointers);
       X    427     else
       X    428       _grDrawVertexList(kSetupFan, GR_VTX_PTR, Count, pointers);
       X    429     break;
       X    430       
       X    431   case GR_TRIANGLES:
       X    432     if (gc->state.grEnableArgs.primitive_smooth_mode)
       X    433       if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS)
       X    434         _grAADrawTriangles(GR_VTX_PTR, GR_TRIANGLES, Count, pointers);
       X    435       else
       X    436         _grAAVpDrawTriangles(GR_VTX_PTR, GR_TRIANGLES, Count, pointers);
       X    437     else 
       X    438       _grDrawTriangles(GR_VTX_PTR, Count, pointers);
       X    439     break;
       X    440 
       X    441   }
       X    442 #undef FN_NAME
       X    443 } /* grDrawVertexArrayLinear */
       X    444 
       X    445 #endif /* GLIDE3 */  


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DISTRIP/OBJECT=[
.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DISTRIP.OBJ/INCLUDE_DIRECTORY=([.GLI
DE.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.
GLIDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_
TRISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLID
E_LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DISTRIP.C

DISTRIP                         Source Listing                   9-MAY-2021 23:42:47  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             8-MAY-2021 19:12:02  distrip.c;2

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC
These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:47"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


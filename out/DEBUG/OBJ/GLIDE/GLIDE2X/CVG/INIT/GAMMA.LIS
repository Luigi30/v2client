GAMMA                           Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gamma.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Initialization code for loading SST-1 gamma tables
	     21 **
	     22 */
	     23 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
       X     24 #ifdef _MSC_VER
       X     25 #pragma optimize ("",off)
       X     26 #endif
	     27 #include <stdio.h>
	   1638 #include <stdlib.h>
	   3733 #include <math.h>
       X   4625 #ifdef BUILD_FOR_SST1
       X   4626 #include <sst.h>
       X   4627 #else
	   4628 #include <3dfx.h>
	   4759 #include <cvgregs.h>
	   4987 #include <cvgdefs.h>
	   5928 #endif
	   5929 #define FX_DLL_DEFINITION
	   5930 #include <fxdll.h>
	   6051 #include <sst1vid.h>
	   6161 #include <sst1init.h>
	   8799 
	   8800 /* OK, so this should be 1.7, but sometime during the
	   8801  * late stages of the original v2 release hell we changed
	   8802  * it to 1.3 to make id (or someone happy).
	   8803  */
	   8804 #define kDefaultVoodoo2Gamma 1.3
	   8805 
	   8806 /*
	   8807 ** sst1InitGamma():
	   8808 **  Load the video color-lookup tables with the specified gamma function
	   8809 **
	   8810 **    Returns:
	   8811 **      FXTRUE if successfully initializes SST-1 gamma tables
	   8812 **      FXFALSE if cannot initialize SST-1 gamma tables
	   8813 **
	   8814 */
	   8815 FX_EXPORT FxBool FX_CSTYLE sst1InitGamma(FxU32 *sstbase, double gamma)

GAMMA                           Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gamma.c;1

      1	   8816 {
      1	   8817   if(sstbase == NULL) return(FXFALSE);
      1	   8818   if(!sst1InitCheckBoard(sstbase)) return(FXFALSE);
      1	   8819 
      1	   8820   return sst1InitGammaRGB(sstbase, gamma, gamma, gamma);
      1	   8821 }
	   8822 
	   8823 FX_EXPORT FxBool FX_CSTYLE sst1InitGammaRGB(FxU32 *sstbase, 
	   8824                                             double gammaR,
	   8825                                             double gammaG, 
	   8826                                             double gammaB)
      1	   8827 {
      1	   8828   FxU32 
      1	   8829     x,
      1	   8830     gammaTableR[256],
      1	   8831     gammaTableG[256],
      1	   8832     gammaTableB[256];
      1	   8833   FxBool 
      1	   8834     sstVideoIsReset;
      1	   8835   SstRegs *
      1	   8836     sst = (SstRegs *) sstbase;
      1	   8837   static FxBool 
      1	   8838     calledBefore = FXFALSE;
      1	   8839   static double 
      1	   8840     userGammaR = kDefaultVoodoo2Gamma, 
      1	   8841     userGammaG = kDefaultVoodoo2Gamma, 
      1	   8842     userGammaB = kDefaultVoodoo2Gamma;
      1	   8843 
      1	   8844   if(sstbase == NULL) return(FXFALSE);
      1	   8845   if(!sst1InitCheckBoard(sstbase)) return(FXFALSE);
      1	   8846   
      1	   8847   if(!sst1CurrentBoard->fbiInitGammaDone)
      1	   8848     INIT_PRINTF(("sst1InitGammaRGB(): Setting GammaRGB = (%.2f,%.2f,%.2f)\n",
      1	   8849                  gammaR, gammaG, gammaB));
      1	   8850 
      1	   8851   /* Get the user set definitions (cp or environment) */
      2	   8852   if(!calledBefore) {
      2	   8853     calledBefore = FXTRUE;
      2	   8854     
      3	   8855     if(GETENV(("SSTV2_RGAMMA"))) {
      3	   8856       userGammaR = (double) ATOF(GETENV(("SSTV2_RGAMMA")));
      2	   8857     }
      3	   8858     if(GETENV(("SSTV2_GGAMMA"))) {
      3	   8859       userGammaG = (double) ATOF(GETENV(("SSTV2_GGAMMA")));
      2	   8860     }
      3	   8861     if(GETENV(("SSTV2_BGAMMA"))) {
      3	   8862       userGammaB = (double) ATOF(GETENV(("SSTV2_BGAMMA")));
      2	   8863     }
      3	   8864     if(GETENV(("SSTV2_GAMMA"))) {
      3	   8865       userGammaR = (double) ATOF(GETENV(("SSTV2_GAMMA")));
      3	   8866       userGammaG = userGammaR;
      3	   8867       userGammaB = userGammaR;
      2	   8868     }
      1	   8869   }
      1	   8870 
      1	   8871   gammaR *= (userGammaR / kDefaultVoodoo2Gamma);
      1	   8872   gammaG *= (userGammaG / kDefaultVoodoo2Gamma);

GAMMA                           Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gamma.c;1

      1	   8873   gammaB *= (userGammaB / kDefaultVoodoo2Gamma);
      1	   8874   
      1	   8875   // Initialize the gamma table
      2	   8876   for(x=0; x<256; x++) {
      2	   8877     gammaTableR[x] = FTOL (POW(x/255.0F, 1.0F/gammaR) * 255.0F + 0.5F);
      2	   8878     gammaTableG[x] = FTOL (POW(x/255.0F, 1.0F/gammaG) * 255.0F + 0.5F);
      2	   8879     gammaTableB[x] = FTOL (POW(x/255.0F, 1.0F/gammaB) * 255.0F + 0.5F);
      1	   8880   }
      1	   8881   
      1	   8882   // Store gamma values in board info structure
      1	   8883   sst1CurrentBoard->fbiGammaRed = gammaR;
      1	   8884   sst1CurrentBoard->fbiGammaGreen = gammaG;
      1	   8885   sst1CurrentBoard->fbiGammaBlue = gammaB;
      1	   8886 
      1	   8887   // SST-1 video reset must be inactive to load gamma tables
      2	   8888   if(IGET(sst->fbiInit1) & SST_VIDEO_RESET) {
      2	   8889     sstVideoIsReset = FXTRUE;
      2	   8890     sst1InitIdleFBINoNOP(sstbase);
      2	   8891     ISET(sst->fbiInit1, IGET(sst->fbiInit1) & ~SST_VIDEO_RESET);
      2	   8892     // wait for video reset to be deasserted
      2	   8893     sst1InitIdleFBINoNOP(sstbase);
      2	   8894   } else {
      2	   8895     sstVideoIsReset = FXFALSE;
      1	   8896   }
      1	   8897 
      1	   8898   // SST-1 requires every eighth entry of the gamma table to be loaded,
      1	   8899   // so only 32 basic writes are required.  A 33rd write is used to load
      1	   8900   // the top entry of the gamma table.  The 33rd entry is necessary because
      1	   8901   // SST-1 performs linear interpolation between each gamma table entry to
      1	   8902   // generate 256 unique gamma-corrected values.
      2	   8903   for(x=0; x<32; x++) {
      2	   8904     FxU32 gcR = gammaTableR[(x<<3)];
      2	   8905     FxU32 gcG = gammaTableG[(x<<3)];
      2	   8906     FxU32 gcB = gammaTableB[(x<<3)];
      2	   8907     ISET(sst->clutData, ((x<<SST_CLUTDATA_INDEX_SHIFT) | 
      2	   8908                          (gcR<<SST_CLUTDATA_RED_SHIFT) |
      2	   8909                          (gcG<<SST_CLUTDATA_GREEN_SHIFT) |
      2	   8910                          (gcB<<SST_CLUTDATA_BLUE_SHIFT)));
      1	   8911   }
      1	   8912 
      1	   8913   // Last entry in the gamma table is stored as 0x0 to perform proper
      1	   8914   // linear interpolation of the last 8 entries
      1	   8915   //
      1	   8916   // BUG Fix: Last entry in table needs to be 0xffffff for proper linear
      1	   8917   //  interpolation
      1	   8918   //
      1	   8919   // YABF: Unconditionally using 0xFFFFFF to max out the interpolation
      1	   8920   // causes a problem if the component gamma value is 0 (some
      1	   8921   // developer wants this).   Anyway, we now special case 0 (or close to 0) 
      1	   8922   // so that   // this looks right.
      1	   8923 #define GAMMA_COMP_FLOOR(__val) (~(((__val) == 0x00UL) - 0x01UL) & 0xFFUL)
      1	   8924   ISET(sst->clutData, ((32 << SST_CLUTDATA_INDEX_SHIFT) | 
      1	   8925                        (GAMMA_COMP_FLOOR(gammaTableR[255]) << SST_CLUTDATA_RED_SHIFT) |
      1	   8926                        (GAMMA_COMP_FLOOR(gammaTableG[255]) << SST_CLUTDATA_RED_SHIFT) |
      1	   8927                        (GAMMA_COMP_FLOOR(gammaTableB[255]) << SST_CLUTDATA_RED_SHIFT)));
      1	   8928 #undef GAMMA_COMP_FLOOR
      1	   8929   

GAMMA                           Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gamma.c;1

      2	   8930   if(sstVideoIsReset) {
      2	   8931     // wait for gamma table writes to complete
      2	   8932     sst1InitIdleFBINoNOP(sstbase);
      2	   8933     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      2	   8934     sst1InitIdleFBINoNOP(sstbase);
      1	   8935   }
      1	   8936 
      2	   8937   if(!sst1CurrentBoard->fbiInitGammaDone) {
      2	   8938     sst1CurrentBoard->fbiInitGammaDone = 1;
      2	   8939     INIT_PRINTF(("sst1InitGammaRGB() exiting with status %d...\n", FXTRUE));
      1	   8940   }
      1	   8941   
      1	   8942   return FXTRUE;
      1	   8943 }
	   8944 
	   8945 FX_EXPORT FxBool FX_CSTYLE sst1InitGammaTable(FxU32 *sstbase, FxU32 nentries, FxU32 *r, FxU32 *g, FxU32 *b)
      1	   8946 {
      1	   8947     FxU32 x;
      1	   8948     FxU32 gammaTableR[256];
      1	   8949     FxU32 gammaTableG[256];
      1	   8950     FxU32 gammaTableB[256];
      1	   8951     FxBool sstVideoIsReset;
      1	   8952     SstRegs *sst = (SstRegs *) sstbase;
      1	   8953 
      1	   8954     if(!sstbase)
      1	   8955         return(FXFALSE);
      1	   8956 
      1	   8957     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8958         return(FXFALSE);
      1	   8959 
      1	   8960     // Initialize the gamma table
      2	   8961     for(x=0; x < nentries; x++) {
      2	   8962       gammaTableR[x] = *r;
      2	   8963       gammaTableG[x] = *g;
      2	   8964       gammaTableB[x] = *b;
      2	   8965       r++; g++; b++;
      1	   8966     }
      1	   8967 
      1	   8968     // SST-1 video reset must be inactive to load gamma tables
      2	   8969     if(IGET(sst->fbiInit1) & SST_VIDEO_RESET) {
      2	   8970         sstVideoIsReset = FXTRUE;
      2	   8971         sst1InitIdleFBINoNOP(sstbase);
      2	   8972         ISET(sst->fbiInit1, IGET(sst->fbiInit1) & ~SST_VIDEO_RESET);
      2	   8973         // wait for video reset to be deasserted
      2	   8974         sst1InitIdleFBINoNOP(sstbase);
      1	   8975     } else
      1	   8976         sstVideoIsReset = FXFALSE;
      1	   8977 
      1	   8978     // SST-1 requires every eighth entry of the gamma table to be loaded,
      1	   8979     // so only 32 basic writes are required.  A 33rd write is used to load
      1	   8980     // the top entry of the gamma table.  The 33rd entry is necessary because
      1	   8981     // SST-1 performs linear interpolation between each gamma table entry to
      1	   8982     // generate 256 unique gamma-corrected values.
      2	   8983     for(x=0; x < nentries; x++) {
      2	   8984         FxU32 gcR = gammaTableR[(x)];
      2	   8985         FxU32 gcG = gammaTableG[(x)];
      2	   8986         FxU32 gcB = gammaTableB[(x)];

GAMMA                           Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gamma.c;1

      2	   8987         ISET(sst->clutData, ((x<<SST_CLUTDATA_INDEX_SHIFT) | 
      2	   8988                          (gcR<<SST_CLUTDATA_RED_SHIFT) |
      2	   8989                          (gcG<<SST_CLUTDATA_GREEN_SHIFT) |
      2	   8990                          (gcB<<SST_CLUTDATA_BLUE_SHIFT)));
      1	   8991     }
      1	   8992     // Last entry in the gamma table is stored as 0x0 to perform proper
      1	   8993     // linear interpolation of the last 8 entries
      1	   8994     // BUG Fix: Last entry in table needs to be 0xffffff for proper linear
      1	   8995     //  interpolation
      1	   8996     ISET(sst->clutData, (32<<SST_CLUTDATA_INDEX_SHIFT) | 0xffffff);
      1	   8997 
      2	   8998     if(sstVideoIsReset == FXTRUE) {
      2	   8999         // wait for gamma table writes to complete
      2	   9000         sst1InitIdleFBINoNOP(sstbase);
      2	   9001         ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      2	   9002         sst1InitIdleFBINoNOP(sstbase);
      1	   9003     }
      1	   9004 
      1	   9005     return(FXTRUE);
      1	   9006 }
	   9007 
       X   9008 #ifdef _MSC_VER
       X   9009 #pragma optimize ("",on)
       X   9010 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]GAMMA/OBJECT=[.OUT.DE
BUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]GAMMA.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMI
SC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.
CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE
_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLI
DE.GLIDE2X.CVG.INIT]GAMMA.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:16"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


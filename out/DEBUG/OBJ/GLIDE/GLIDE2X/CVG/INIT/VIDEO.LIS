VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Initialization code for initializing SST-1 video unit
	     21 **
	     22 */
	     23 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
       X     24 #ifdef _MSC_VER
       X     25 #pragma optimize ("",off)
       X     26 #endif
	     27 #include <stdio.h>
	   1638 #include <stdlib.h>
	   3733 #include <math.h>
       X   4625 #ifdef BUILD_FOR_SST1
       X   4626 #include <sst.h>
       X   4627 #else
	   4628 #include <3dfx.h>
	   4759 #include <cvgregs.h>
	   4987 #include <cvgdefs.h>
	   5928 #endif
	   5929 #define FX_DLL_DEFINITION
	   5930 #include <fxdll.h>
	   6051 #define SST1INIT_VIDEO_ALLOCATE // allocate data structures for video timing
	   6052 #include <sst1vid.h>
	   6162 #include <sst1init.h>
	   8800 
       X   8801 #ifdef H3D
       X   8802 #include <h3dglide.h>
       X   8803 #endif
	   8804 
	   8805 #include "canopus.h"
	   8845 
	   8846 /*
	   8847 ** sst1InitVideo():
	   8848 **  Initialize video (including DAC setup) for the specified resolution
	   8849 **
	   8850 **  Note: sst1InitVideo() is included for compatibility with SST-1 apps only
	   8851 **  and should not be used for Voodoo2.  Use sst1InitVideoBuffers() instead.
	   8852 **
	   8853 */
	   8854 FX_EXPORT FxBool FX_CSTYLE sst1InitVideo(FxU32 *sstbase,

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

	   8855   GrScreenResolution_t screenResolution, GrScreenRefresh_t screenRefresh,
	   8856   void *placeHolder)
      1	   8857 {
      1	   8858     FxU32 memSizeInPages;
      1	   8859     sst1VideoTimingStruct *videoTiming;
      1	   8860     FxU32 colorBuffs, auxBuffs;
      1	   8861 
      1	   8862     if(!sstbase)
      1	   8863         return(FXFALSE);
      1	   8864 
      1	   8865     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8866         return(FXFALSE);
      1	   8867 
      2	   8868     if(GETENV(("SSTV2_IGNORE_INIT_VIDEO"))) {
      2	   8869         INIT_PRINTF(("WARNING: Ignoring sst1InitVideo()...\n"));
      2	   8870         sst1InitIdleFBINoNOP(sstbase);
      2	   8871         return(FXTRUE);
      1	   8872     }
      1	   8873 
      1	   8874     if(!(videoTiming = sst1InitFindVideoTimingStruct(screenResolution,
      1	   8875       screenRefresh)))
      1	   8876         return(FXFALSE);
      1	   8877 
      1	   8878     if(sst1CurrentBoard->fbiMemSize == 1)
      1	   8879       memSizeInPages = 256;
      1	   8880     else if(sst1CurrentBoard->fbiMemSize == 2)
      1	   8881       memSizeInPages = 512;
      1	   8882     else
      1	   8883       memSizeInPages = 1024;
      1	   8884     if(sst1CurrentBoard->sliDetected) 
      1	   8885       memSizeInPages <<= 1;
      1	   8886 
      1	   8887     // Do we have enough memory for the desired resolution?
      2	   8888     if(memSizeInPages > (3 * videoTiming->memOffset)) {
      2	   8889       colorBuffs = 2;
      2	   8890       auxBuffs = 1;
      2	   8891     } else if(memSizeInPages > (2 * videoTiming->memOffset)) {
      2	   8892       colorBuffs = 2;
      2	   8893       auxBuffs = 0;
      2	   8894     } else {
      2	   8895       INIT_PRINTF(("sst1InitVideo(): Insufficient memory available for desired resolution...\n"));
      2	   8896       return(FXFALSE);
      1	   8897     }
      1	   8898 
      1	   8899     return(sst1InitVideoBuffers(sstbase, screenResolution, screenRefresh,
      1	   8900       colorBuffs, auxBuffs, (sst1VideoTimingStruct *) NULL, FXTRUE));
      1	   8901 }
	   8902 
	   8903 /*
	   8904 ** sst1InitVideoBuffers():
	   8905 **  Initialize video (including DAC setup) for the specified resolution
	   8906 **
	   8907 **    Returns:
	   8908 **      FXTRUE if successfully initializes specified SST-1 video resolution
	   8909 **      FXFALSE if cannot initialize SST-1 to specified video resolution
	   8910 **
	   8911 */

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

	   8912 FX_EXPORT FxBool FX_CSTYLE sst1InitVideoBuffers(FxU32 *sstbase,
	   8913   GrScreenResolution_t screenResolution, GrScreenRefresh_t screenRefresh,
	   8914   FxU32 nColorBuffs, FxU32 nAuxBuffs, sst1VideoTimingStruct *altVideoTiming,
	   8915   FxBool switchPassThru)
      1	   8916 {
      1	   8917     FxU32 n, vtmp;
      1	   8918     SstRegs *sst = (SstRegs *) sstbase;
      1	   8919     sst1VideoTimingStruct *sstVideoRez;
      1	   8920     FxU32 video16BPP;
      1	   8921     FxU32 memFifoLwm, memFifoHwm, pciFifoLwm;
      1	   8922     FxU32 vInClkDel, vOutClkDel;
      1	   8923     FxU32 tf0_clkdel, tf1_clkdel, tf2_clkdel;
      1	   8924     FxU32 ft_clkdel, memSizeInPages;
      1	   8925     FxU32 nCol, nAux, miscCtrl;
      1	   8926     int memFifoEntries;
      1	   8927 #ifndef DIRECTX
      1	   8928     float vidClkFreq;
      1	   8929 #endif
      1	   8930 
      1	   8931     if(!sst)
      1	   8932         return(FXFALSE);
      1	   8933 
      1	   8934     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8935         return(FXFALSE);
      1	   8936 
      2	   8937     if(GETENV(("SSTV2_IGNORE_INIT_VIDEO"))) {
      2	   8938         INIT_PRINTF(("WARNING: Ignoring sst1InitVideo()...\n"));
      2	   8939         sst1InitIdleFBINoNOP(sstbase);
      2	   8940         return(FXTRUE);
      1	   8941     }
      1	   8942 
      1	   8943     if(altVideoTiming && !GETENV(("SSTV2_SCREENREZ")) &&
      1	   8944        !GETENV(("SSTV2_SCREENREFRESH")))
      1	   8945          sstVideoRez = altVideoTiming;
      2	   8946     else {
      2	   8947        if(!(sstVideoRez = sst1InitFindVideoTimingStruct(screenResolution,
      2	   8948          screenRefresh)))
      2	   8949            return(FXFALSE);
      1	   8950     }
      1	   8951 
      1	   8952     nCol = nColorBuffs;
      1	   8953     nAux = nAuxBuffs;
      1	   8954 
      1	   8955     // Disallow unsupported buffer combinations...
      1	   8956     if(nCol < 2 || nCol > 3 || nAux > 1)
      1	   8957       return(FXFALSE);
      1	   8958 
      1	   8959     if(sst1CurrentBoard->fbiMemSize == 1)
      1	   8960       memSizeInPages = 256;
      1	   8961     else if(sst1CurrentBoard->fbiMemSize == 2)
      1	   8962       memSizeInPages = 512;
      1	   8963     else
      1	   8964       memSizeInPages = 1024;
      1	   8965     if(sst1CurrentBoard->sliDetected)
      1	   8966       memSizeInPages <<= 1;
      1	   8967 
      1	   8968     // To be compatible with Voodoo1, if there is enough memory to 

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   8969     // allocate an aux buffer, then do it...
      2	   8970     if(nCol == 2 && nAux == 0) {
      3	   8971        if(memSizeInPages > (3 * sstVideoRez->memOffset)) {
      3	   8972           INIT_PRINTF(("sst1InitVideo(): Allocating 1 Aux Buffer for SST-1 Compatibility...\n"));
      3	   8973           nAux++;
      2	   8974        }
      1	   8975     }
      1	   8976 
      1	   8977     if(GETENV(("SSTV2_ALLOC_COLOR")))
      1	   8978       nCol = ATOI(GETENV(("SSTV2_ALLOC_COLOR")));
      1	   8979     if(GETENV(("SSTV2_ALLOC_AUX")))
      1	   8980       nAux = ATOI(GETENV(("SSTV2_ALLOC_AUX")));
      1	   8981 
      1	   8982     // Disallow unsupported buffer combinations (from environment vars)...
      1	   8983     if(nCol < 2 || nCol > 3 || nAux > 1)
      1	   8984       return(FXFALSE);
      1	   8985 
      1	   8986     //
      1	   8987     // Do we have enough memory for the desired resolution?
      1	   8988     //
      2	   8989     if(memSizeInPages < ((nCol + nAux) * sstVideoRez->memOffset)) {
      2	   8990       INIT_PRINTF(("sst1InitVideo(): Insufficient memory available for desired resolution.\n"));
      2	   8991       return(FXFALSE);
      1	   8992     }
      1	   8993     if(GETENV(("SSTV2_VIDEO_24BPP")))
      1	   8994         sst1CurrentBoard->fbiVideo16BPP =
      1	   8995             (ATOI(GETENV(("SSTV2_VIDEO_24BPP")))) ^ 0x1;
      2	   8996     else {
      2	   8997         sst1CurrentBoard->fbiVideo16BPP = 0;
      2	   8998 
      2	   8999         if(sst1CurrentBoard->fbiVideo16BPP && (sstVideoRez->video16BPPIsOK ==
      2	   9000            FXFALSE))
      2	   9001                sst1CurrentBoard->fbiVideo16BPP = 0;
      2	   9002         if(!sst1CurrentBoard->fbiVideo16BPP && (sstVideoRez->video24BPPIsOK ==
      2	   9003            FXFALSE))
      2	   9004                sst1CurrentBoard->fbiVideo16BPP = 1;
      2	   9005 
      3	   9006         if(altVideoTiming == (sst1VideoTimingStruct *) NULL) {
      3	   9007             // Determine when cannot output 24bpp video...
      3	   9008             // Cannot run at high frequencies across SLI connector...
      3	   9009             if(sst1CurrentBoard->sliDetected &&
      3	   9010               sstVideoRez->clkFreq24bpp > 90.0F)
      3	   9011                sst1CurrentBoard->fbiVideo16BPP = 1;
      2	   9012         }
      1	   9013     }
      1	   9014     video16BPP = sst1CurrentBoard->fbiVideo16BPP;
      1	   9015 
      1	   9016     // Reset Video Refresh Unit
      1	   9017     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9018     
      1	   9019     // Setup SST video timing registers
      1	   9020     if(GETENV(("SSTV2_HSYNC")) &&
      2	   9021        (SSCANF(GETENV(("SSTV2_HSYNC")), "%i", &vtmp) == 1) ) {
      2	   9022         INIT_PRINTF(("sst1InitVideo(): Using SST_HSYNC=0x%x\n", vtmp));
      2	   9023         ISET(sst->hSync, vtmp);
      1	   9024     } else
      1	   9025         ISET(sst->hSync, ((sstVideoRez->hSyncOff << SST_VIDEO_HSYNC_OFF_SHIFT) |

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9026                       (sstVideoRez->hSyncOn << SST_VIDEO_HSYNC_ON_SHIFT)));
      1	   9027     if(GETENV(("SSTV2_VSYNC")) &&
      2	   9028        (SSCANF(GETENV(("SSTV2_VSYNC")), "%i", &vtmp) == 1) ) {
      2	   9029         INIT_PRINTF(("sst1InitVideo(): Using SST_VSYNC=0x%x\n", vtmp));
      2	   9030         ISET(sst->vSync, vtmp);
      1	   9031     } else
      1	   9032         ISET(sst->vSync, ((sstVideoRez->vSyncOff << SST_VIDEO_VSYNC_OFF_SHIFT) |
      1	   9033                       (sstVideoRez->vSyncOn << SST_VIDEO_VSYNC_ON_SHIFT)));
      1	   9034     if(GETENV(("SSTV2_BACKPORCH")) &&
      2	   9035        (SSCANF(GETENV(("SSTV2_BACKPORCH")), "%i", &vtmp) == 1) ) {
      2	   9036         INIT_PRINTF(("sst1InitVideo(): Using SST_BACKPORCH=0x%x\n", vtmp));
      2	   9037         ISET(sst->backPorch, vtmp);
      1	   9038     } else
      1	   9039         ISET(sst->backPorch,
      1	   9040                      ((sstVideoRez->vBackPorch << SST_VIDEO_VBACKPORCH_SHIFT) |
      1	   9041                       (sstVideoRez->hBackPorch << SST_VIDEO_HBACKPORCH_SHIFT)));
      1	   9042     if(GETENV(("SSTV2_DIMENSIONS")) &&
      2	   9043        (SSCANF(GETENV(("SSTV2_DIMENSIONS")), "%i", &vtmp) == 1) ) {
      2	   9044         INIT_PRINTF(("sst1InitVideo(): Using SST_DIMENSIONS=0x%x\n", vtmp));
      2	   9045         sstVideoRez->yDimension = (vtmp >>  SST_VIDEO_YDIM_SHIFT) & 0x3ff;
      2	   9046         sstVideoRez->xDimension = vtmp & 0x3ff;
      1	   9047     }
      1	   9048     ISET(sst->videoDimensions,
      1	   9049                      ((sstVideoRez->yDimension << SST_VIDEO_YDIM_SHIFT) |
      1	   9050                       ((sstVideoRez->xDimension-1) << SST_VIDEO_XDIM_SHIFT)));
      1	   9051     if(GETENV(("SSTV2_MEMOFFSET")) &&
      2	   9052        (SSCANF(GETENV(("SSTV2_MEMOFFSET")), "%i", &vtmp) == 1) ) {
      2	   9053         INIT_PRINTF(("sst1InitVideo(): Using video memOffset=0x%x\n", vtmp));
      2	   9054         sstVideoRez->memOffset = vtmp;
      1	   9055     }
      1	   9056     if(GETENV(("SSTV2_TILESINX")) &&
      2	   9057        (SSCANF(GETENV(("SSTV2_TILESINX")), "%i", &vtmp) == 1) ) {
      2	   9058         INIT_PRINTF(("sst1InitVideo(): Using video tilesInX=0x%x\n", vtmp));
      2	   9059         sstVideoRez->tilesInX = vtmp;
      1	   9060     }
      1	   9061 
      1	   9062     // Update info structure
      1	   9063     sst1CurrentBoard->fbiVideoWidth = sstVideoRez->xDimension;
      1	   9064     sst1CurrentBoard->fbiVideoHeight = sstVideoRez->yDimension;
      1	   9065     sst1CurrentBoard->fbiVideoRefresh = sstVideoRez->refreshRate;
      1	   9066     sst1CurrentBoard->fbiVideoColBuffs = nCol;
      1	   9067     sst1CurrentBoard->fbiVideoAuxBuffs = nAux;
      1	   9068     sst1CurrentBoard->fbiVideoMemOffset = sstVideoRez->memOffset;
      1	   9069     sst1CurrentBoard->fbiVideoTilesInX = sstVideoRez->tilesInX;
      1	   9070     sst1CurrentBoard->fbiVideoStruct = sstVideoRez;
      1	   9071 
      1	   9072     // Setup SST memory mapper for desired resolution
      1	   9073     if(sst1CurrentBoard->fbiMemSize == 4)
      1	   9074         sst1InitSetResolution(sstbase, sstVideoRez, 1); 
      1	   9075     else
      1	   9076         sst1InitSetResolution(sstbase, sstVideoRez, 0); 
      1	   9077 
      1	   9078     // Calculate graphics clock frequency
      1	   9079     if(sst1InitCalcGrxClk(sstbase) == FXFALSE)
      1	   9080         return(FXFALSE);
      1	   9081 
      1	   9082     // Setup video fifo

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9083     // NOTE: Lower values for the video fifo threshold improve video fifo
      1	   9084     // underflow problems
      2	   9085     if(GETENV(("SSTV2_VFIFO_THRESH"))) {
      2	   9086         INIT_PRINTF(("sst1InitVideo(): Overriding Default Video Fifo Threshold %d and Storing %d\n",
      2	   9087             sstVideoRez->vFifoThreshold, ATOI(GETENV(("SSTV2_VFIFO_THRESH")))));
      2	   9088         ISET(sst->fbiInit3, (IGET(sst->fbiInit3) & ~SST_VIDEO_FIFO_THRESH) |
      2	   9089 
      2	   9090             ((ATOI(GETENV(("SSTV2_VFIFO_THRESH"))))
      2	   9091              << SST_VIDEO_FIFO_THRESH_SHIFT));
      2	   9092     } else {
      2	   9093         FxU32 vFifoThresholdVal = sstVideoRez->vFifoThreshold;
      2	   9094 
      2	   9095         if(sst1CurrentBoard->fbiGrxClkFreq < 45)
      2	   9096             // Lower threshold value for slower graphics clocks
      2	   9097             vFifoThresholdVal = sstVideoRez->vFifoThreshold - 4;
      2	   9098 
      2	   9099         ISET(sst->fbiInit3, (IGET(sst->fbiInit3) & ~SST_VIDEO_FIFO_THRESH) |
      2	   9100             (vFifoThresholdVal << SST_VIDEO_FIFO_THRESH_SHIFT));
      1	   9101     }
      1	   9102 
      1	   9103     INIT_PRINTF(("sst1InitVideo() Setting up video for resolution (%d, %d), Refresh:%d Hz...\n",
      1	   9104         sstVideoRez->xDimension, sstVideoRez->yDimension,
      1	   9105         sstVideoRez->refreshRate));
      1	   9106     INIT_PRINTF(("sst1InitVideo(): Video Fifo Threshold = %d\n",
      1	   9107         (IGET(sst->fbiInit3) & SST_VIDEO_FIFO_THRESH) >>
      1	   9108          SST_VIDEO_FIFO_THRESH_SHIFT));
      1	   9109 
      1	   9110     // Initialize Y-Origin
      1	   9111     sst1InitIdleFBINoNOP(sstbase);
      1	   9112     ISET(sst->fbiInit3, (IGET(sst->fbiInit3) & ~SST_YORIGIN_TOP) |
      1	   9113         ((sstVideoRez->yDimension - 1) << SST_YORIGIN_TOP_SHIFT));
      1	   9114 
      1	   9115     sst1InitIdleFBINoNOP(sstbase);
      1	   9116 
      1	   9117     memFifoLwm = 23;
      1	   9118     if(GETENV(("SSTV2_MEMFIFO_LWM")) &&
      1	   9119        (SSCANF(GETENV(("SSTV2_MEMFIFO_LWM")), "%i", &vtmp) == 1))
      1	   9120       memFifoLwm = vtmp;
      1	   9121     memFifoHwm = 54;
      1	   9122     if(GETENV(("SSTV2_MEMFIFO_HWM")) &&
      1	   9123        (SSCANF(GETENV(("SSTV2_MEMFIFO_HWM")), "%i", &vtmp) == 1))
      1	   9124       memFifoHwm = vtmp;
      1	   9125     pciFifoLwm = 13;
      1	   9126     if(GETENV(("SSTV2_PCIFIFO_LWM")) &&
      1	   9127        (SSCANF(GETENV(("SSTV2_PCIFIFO_LWM")), "%i", &vtmp) == 1))
      1	   9128       pciFifoLwm = vtmp;
      1	   9129     INIT_PRINTF(("sst1InitVideo(): pciFifoLwm:%d  memFifoLwm:%d  memFifoHwm:%d\n",
      1	   9130         pciFifoLwm, memFifoLwm, memFifoHwm));
      1	   9131 
      1	   9132     // Setup Memory FIFO
      1	   9133     sst1InitIdleFBINoNOP(sstbase);
      1	   9134     ISET(sst->fbiInit4, IGET(sst->fbiInit4) &
      1	   9135       ~(SST_MEM_FIFO_ROW_BASE | SST_MEM_FIFO_ROW_ROLL | SST_MEM_FIFO_LWM));
      1	   9136     sst1InitIdleFBINoNOP(sstbase);
      1	   9137     if(sst1CurrentBoard->fbiMemSize == 1)
      1	   9138         ISET(sst->fbiInit4, IGET(sst->fbiInit4) |
      1	   9139           (0xff << SST_MEM_FIFO_ROW_ROLL_SHIFT));

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9140     else if (sst1CurrentBoard->fbiMemSize == 2)
      1	   9141         ISET(sst->fbiInit4, IGET(sst->fbiInit4) |
      1	   9142           (0x1ff << SST_MEM_FIFO_ROW_ROLL_SHIFT));
      1	   9143     else
      1	   9144         // 4 MBytes frame buffer memory...
      1	   9145         ISET(sst->fbiInit4, IGET(sst->fbiInit4) |
      1	   9146           (0x3ff << SST_MEM_FIFO_ROW_ROLL_SHIFT));
      1	   9147     sst1InitIdleFBINoNOP(sstbase);
      1	   9148 
      1	   9149     // Setup buffer management...
      1	   9150     if(sst1InitAllocBuffers(sstbase, nCol, nAux) == FXFALSE)
      1	   9151        return(FXFALSE);
      1	   9152    
      1	   9153     INIT_PRINTF(("sst1InitVideo(): Allocating %d Color Buffers and %d Aux Buffer(s)...\n", 
      1	   9154                  sst1CurrentBoard->fbiVideoColBuffs, sst1CurrentBoard->fbiVideoAuxBuffs));
      1	   9155     ISET(sst->fbiInit4, IGET(sst->fbiInit4) |
      1	   9156         (((nCol+nAux)*sstVideoRez->memOffset) << SST_MEM_FIFO_ROW_BASE_SHIFT));
      1	   9157     sst1InitIdleFBINoNOP(sstbase);
      1	   9158     ISET(sst->fbiInit4, IGET(sst->fbiInit4) |
      1	   9159       (memFifoLwm << SST_MEM_FIFO_LWM_SHIFT));
      1	   9160     sst1InitIdleFBINoNOP(sstbase);
      1	   9161 
      1	   9162     // Set PCI FIFO LWM
      1	   9163     ISET(sst->fbiInit0, (IGET(sst->fbiInit0) & ~SST_PCI_FIFO_LWM) |
      1	   9164             (pciFifoLwm << SST_PCI_FIFO_LWM_SHIFT));
      1	   9165     sst1InitIdleFBINoNOP(sstbase);
      1	   9166 
      1	   9167     // Enable Memory Fifo...
      1	   9168     if(GETENV(("SSTV2_MEMFIFO")))
      1	   9169         n = ATOI(GETENV(("SSTV2_MEMFIFO")));
      1	   9170     else
      1	   9171         n = 1;
      1	   9172 
      2	   9173     if(n) {
      2	   9174         sst1CurrentBoard->fbiMemoryFifoEn = 1;
      2	   9175         memFifoEntries = (65536 - (int)
      2	   9176           (((int) (memSizeInPages - 1) -
      2	   9177             (int) ((nCol+nAux) * sstVideoRez->memOffset)) * 512)) >> 5;
      2	   9178         if(memFifoEntries <= 256)
      2	   9179           memFifoEntries = 0x100; // max. memory fifo size...
      3	   9180         else if(memFifoEntries >= 2048) {
      3	   9181           INIT_PRINTF(("sst1InitVideo(): Invalid memFifoEntries 0x%x\n",
      3	   9182             memFifoEntries));
      3	   9183           return(FXFALSE);
      2	   9184         }
      2	   9185         if(GETENV(("SSTV2_MEMFIFO_ENTRIES")) &&
      2	   9186            (SSCANF(GETENV(("SSTV2_MEMFIFO_ENTRIES")), "%i", &vtmp) == 1))
      2	   9187           memFifoEntries = vtmp;
      2	   9188         INIT_PRINTF(("sst1InitVideo(): Enabling Memory FIFO (Entries=%d)...\n",
      2	   9189             65536 - (memFifoEntries << 5)));
      2	   9190 
      2	   9191         sst1CurrentBoard->memFifoStatusLwm = (memFifoEntries << 5) | 0x1f;
      2	   9192         ISET(sst->fbiInit0, (IGET(sst->fbiInit0) & ~(SST_MEM_FIFO_EN |
      2	   9193             SST_MEM_FIFO_HWM | SST_PCI_FIFO_LWM | SST_MEM_FIFO_BURST_HWM)) |
      2	   9194             (memFifoEntries << SST_MEM_FIFO_HWM_SHIFT) |
      2	   9195             (pciFifoLwm << SST_PCI_FIFO_LWM_SHIFT) |
      2	   9196             (memFifoHwm << SST_MEM_FIFO_BURST_HWM_SHIFT) |

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9197             SST_MEM_FIFO_EN);
      2	   9198         INIT_PRINTF(("sst1InitVideo(): Setting memory FIFO LWM to 0x%x (%d)\n",
      2	   9199             sst1CurrentBoard->memFifoStatusLwm,
      2	   9200             sst1CurrentBoard->memFifoStatusLwm));  
      1	   9201     }
      1	   9202 
      1	   9203     vInClkDel = 1;
      1	   9204     if(GETENV(("SSTV2_VIN_CLKDEL")) &&
      1	   9205        (SSCANF(GETENV(("SSTV2_VIN_CLKDEL")), "%i", &vtmp) == 1))
      1	   9206       vInClkDel = vtmp;
      1	   9207 
      1	   9208     vOutClkDel = 0;
      1	   9209     if(GETENV(("SSTV2_VOUT_CLKDEL")) &&
      1	   9210        (SSCANF(GETENV(("SSTV2_VOUT_CLKDEL")), "%i", &vtmp) == 1))
      1	   9211       vOutClkDel = vtmp;
      1	   9212 
      1	   9213     INIT_PRINTF(("sst1InitVideo(): vInClkDel=0x%x  vOutClkDel=0x%x\n",
      1	   9214 
      1	   9215         vInClkDel, vOutClkDel));
      1	   9216 
      1	   9217     // Setup miscellaneous control
      1	   9218     miscCtrl = 0;
      1	   9219     if(sstVideoRez->miscCtrl & BIT(0))
      1	   9220       miscCtrl |= SST_SCAN_DOUBLE_HORIZ;
      1	   9221     if(sstVideoRez->miscCtrl & BIT(1))
      1	   9222       miscCtrl |= SST_SCAN_DOUBLE_VERT;
      1	   9223     if(sstVideoRez->miscCtrl & BIT(2))
      1	   9224       miscCtrl |= SST_INVERT_HSYNC;
      1	   9225     if(sstVideoRez->miscCtrl & BIT(3))
      1	   9226       miscCtrl |= SST_INVERT_VSYNC;
      1	   9227 
      1	   9228     // Drive dac output signals and select input video clock
      2	   9229     if(video16BPP) {
      2	   9230         INIT_PRINTF(("sst1InitVideo(): Setting 16BPP video mode...\n"));
      2	   9231         ISET(sst->fbiInit1, (IGET(sst->fbiInit1) & ~SST_VIDEO_MASK) |
      2	   9232             (SST_VIDEO_DATA_OE_EN |
      2	   9233              SST_VIDEO_BLANK_OE_EN |
      2	   9234              SST_VIDEO_HVSYNC_OE_EN |
      2	   9235              SST_VIDEO_DCLK_OE_EN |
      2	   9236              SST_VIDEO_VID_CLK_2X |
      2	   9237              (vInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      2	   9238              (vOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2	   9239              SST_VIDEO_VCLK_SEL));
      2	   9240         sst1InitIdleFBINoNOP(sstbase);
      2	   9241         ISET(sst->fbiInit5, IGET(sst->fbiInit5) | miscCtrl);
      2	   9242     } else {
      2	   9243         INIT_PRINTF(("sst1InitVideo(): Setting 24BPP video mode...\n"));
      2X   9244 #if 0
      2X   9245         // Old clock settings -- probably use for true 24-bit dac output
      2X   9246         ISET(sst->fbiInit1, (IGET(sst->fbiInit1) & ~SST_VIDEO_MASK) |
      2X   9247             (SST_VIDEO_DATA_OE_EN |
      2X   9248              SST_VIDEO_BLANK_OE_EN |
      2X   9249              SST_VIDEO_HVSYNC_OE_EN |
      2X   9250              SST_VIDEO_DCLK_OE_EN |
      2X   9251              SST_VIDEO_VID_CLK_2X |
      2X   9252              SST_VIDEO_VCLK_DIV2 |
      2X   9253              (vInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2X   9254              (vOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2X   9255              SST_VIDEO_24BPP_EN));
      2X   9256 #else
      2	   9257         ISET(sst->fbiInit1, (IGET(sst->fbiInit1) & ~SST_VIDEO_MASK) |
      2	   9258             (SST_VIDEO_DATA_OE_EN |
      2	   9259              SST_VIDEO_BLANK_OE_EN |
      2	   9260              SST_VIDEO_HVSYNC_OE_EN |
      2	   9261              SST_VIDEO_DCLK_OE_EN |
      2	   9262              // SST_VIDEO_VID_CLK_2X | // BIT(17)
      2	   9263              // SST_VIDEO_VCLK_DIV2 |  // MUX select 0x1
      2	   9264              (0x0 << SST_VIDEO_VCLK_SEL_SHIFT) | // MUX select 0x0
      2	   9265              (vInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      2	   9266              (vOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2	   9267              SST_VIDEO_24BPP_EN));
      2	   9268         ISET(sst->fbiInit5, IGET(sst->fbiInit5) |
      2	   9269           SST_VIDEO_CLK_SLAVE_OE_EN | SST_VID_CLK_2X_OUT_OE_EN |
      2	   9270           SST_VID_CLK_DAC_DATA16_SEL | miscCtrl);
      2	   9271 #endif
      2	   9272         sst1InitIdleFBINoNOP(sstbase);
      3	   9273         if(!GETENV(("SSTV2_VIDEO_FILTER_DISABLE"))) {
      3	   9274             ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_FILTER_EN);
      3	   9275             if(GETENV(("SSTV2_VIDEO_FILTER_THRESHOLD")) &&
      4	   9276                (SSCANF(GETENV(("SSTV2_VIDEO_FILTER_THRESHOLD")), "%i", &vtmp) == 1)) {
      4	   9277                 INIT_PRINTF(("sst1InitVideo(): Setting Video Filtering Treshold to 0x%x...\n", vtmp));
      4	   9278                 ISET(sst->videoFilterRgbThreshold, vtmp);
      3	   9279             } else
      3	   9280                 // ISET(sst->videoFilterRgbThreshold, 0x180c18);
      3	   9281                 ISET(sst->videoFilterRgbThreshold, 0x080408);
      2	   9282         } else
      2	   9283             INIT_PRINTF(("sst1InitVideo(): Disabling Video Filtering...\n"));
      1	   9284     }
      1	   9285 
      1	   9286     // Setup prelim. clock delay values...
      2	   9287     if(sst1CurrentBoard->fbiBoardID == 0x3) {
      2	   9288        // Early 4-layer 4220 board -- Runs at 83 MHz by default...
      3	   9289        if(sst1CurrentBoard->fbiGrxClkFreq <= 80) {
      3	   9290           ft_clkdel = 0x5;
      3	   9291           tf0_clkdel = 0x7;
      3	   9292           tf1_clkdel = 0x8;
      3	   9293           tf2_clkdel = 0x8;
      3	   9294        } else {
      3	   9295           ft_clkdel = 0x4;
      3	   9296           tf0_clkdel = 0x6;
      3	   9297           tf1_clkdel = 0x7;
      3	   9298           tf2_clkdel = 0x7;
      2	   9299        }
      2	   9300     } else if(sst1CurrentBoard->fbiBoardID == 0x2) {
      2	   9301        // 4400 8-layer bringup board -- Runs at 90 MHz by default...
      2	   9302        ft_clkdel = 0x4;
      2	   9303        tf0_clkdel = 0x6;
      2	   9304        tf1_clkdel = 0x6;
      2	   9305        tf2_clkdel = 0x6;
      2	   9306     } else {
      2	   9307        // Setup basic values...
      2	   9308        ft_clkdel = 0x4;
      2	   9309        tf0_clkdel = 0x6;
      2	   9310        tf1_clkdel = 0x6;

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9311        tf2_clkdel = 0x6;
      1	   9312     }
      1	   9313 
      1	   9314     ISET(sst->fbiInit3, (IGET(sst->fbiInit3) & ~SST_FT_CLK_DEL_ADJ) |
      1	   9315         (ft_clkdel << SST_FT_CLK_DEL_ADJ_SHIFT));
      1	   9316     sst1InitIdleFBINoNOP(sstbase);
      1	   9317 
      1	   9318     sst1CurrentBoard->tmuInit1[0] = (sst1CurrentBoard->tmuInit1[0] &
      1	   9319         ~SST_TEX_TF_CLK_DEL_ADJ) | (tf0_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	   9320     sst1CurrentBoard->tmuInit1[1] = (sst1CurrentBoard->tmuInit1[1] &
      1	   9321         ~SST_TEX_TF_CLK_DEL_ADJ) | (tf1_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	   9322     sst1CurrentBoard->tmuInit1[2] = (sst1CurrentBoard->tmuInit1[2] &
      1	   9323         ~SST_TEX_TF_CLK_DEL_ADJ) | (tf2_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	   9324 
      1	   9325     // Calling sst1InitResetTmus() will put the new trexinit values in the
      1	   9326     // TMUs, as well as reset FBI and TMU...
      1	   9327     sst1InitResetTmus(sstbase);
      1	   9328 
      1	   9329     /* If we're running on a canopus board we now have to calculate
      1	   9330      * the actual final clock delays and set them otherwise the video
      1	   9331      * reset is going to wait forever because the hw is never going to
      1	   9332      * become idle waiting for pixels from the tmu's.  
      1	   9333      */
      2	   9334     if (sst1CurrentBoard->fbiBoardID == CANOPUS_ID) {
      2	   9335       // Setup graphics clock to 90 MHz for clockdelay measurement
      2	   9336       if (!sst1SetGrxClk_Canopus(sstbase, 90))
      2	   9337         return(FXFALSE);
      2	   9338 
      2	   9339       // Calculate final clock delay values...
      3	   9340       if(!sst1InitSetClkDelays(sstbase)) {
      3	   9341         INIT_PRINTF(("sst1InitVideo() ERROR: Could not calculate clock delay values...\n"));
      3	   9342         return(FXFALSE);
      2	   9343       }
      1	   9344     }
      1	   9345 
      1	   9346 
      1	   9347     // Setup graphics clock
      1	   9348     if(sst1InitGrxClk(sstbase) == FXFALSE)
      1	   9349         return(FXFALSE);
      1	   9350 
      1	   9351     // Setup video mode
      1	   9352     if(sst1InitSetVidMode(sstbase, video16BPP) == FXFALSE)
      1	   9353         return(FXFALSE);
      1	   9354 
      1	   9355     // Adjust Video Clock
      1	   9356 #ifndef DIRECTX
      1	   9357     if(GETENV(("SSTV2_VIDCLK2X")) &&
      2	   9358        (SSCANF(GETENV(("SSTV2_VIDCLK2X")), "%f", &vidClkFreq) == 1)) {
      2	   9359         if(sst1InitSetVidClk(sstbase, vidClkFreq) == FXFALSE)
      2	   9360             return(FXFALSE);
      2	   9361     } else {
      2	   9362 #endif
      3	   9363         if(sst1InitUseVoodooFile == FXTRUE) {
      3	   9364             if(sst1InitSetVidClkINI(sstbase, sst1CurrentBoard->fbiVideoWidth,
      3	   9365               sst1CurrentBoard->fbiVideoHeight,
      3	   9366               sst1CurrentBoard->fbiVideoRefresh, video16BPP) == FXFALSE)
      3	   9367                 return(FXFALSE);

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      3	   9368         } else {
      4	   9369             if(video16BPP) {
      4	   9370                 if(sst1InitSetVidClk(sstbase, sstVideoRez->clkFreq16bpp) ==
      4	   9371                   FXFALSE)
      4	   9372                     return(FXFALSE);
      4	   9373             } else {
      4	   9374                 if(sst1InitSetVidClk(sstbase, sstVideoRez->clkFreq24bpp) ==
      4	   9375                   FXFALSE)
      4	   9376                     return(FXFALSE);
      3	   9377             }
      2	   9378         }
      2	   9379 #ifndef DIRECTX
      1	   9380     }
      1	   9381 #endif
      1	   9382 
      1	   9383     // Wait for video clock to stabilize
      1	   9384     for(n=0; n<200000; n++)
      1	   9385         sst1InitReturnStatus(sstbase);
      1	   9386 
      1	   9387     // Run Video Reset Module
      1	   9388     ISET(sst->fbiInit1, IGET(sst->fbiInit1) & ~SST_VIDEO_RESET);
      1	   9389     sst1InitIdleFBINoNOP(sstbase);
      1	   9390 
      1	   9391     ISET(sst->fbiInit2, IGET(sst->fbiInit2) | SST_EN_DRAM_REFRESH);
      1	   9392 
      1	   9393     sst1InitIdleFBINoNOP(sstbase);
      1	   9394 
      1	   9395     // Calculate final clock delay values...
      2	   9396     if(sst1InitSetClkDelays(sstbase) == FXFALSE) {
      2	   9397        INIT_PRINTF(("sst1InitVideo() ERROR: Could not calculate clock delay values...\n"));
      2	   9398        return(FXFALSE);
      1	   9399     }
      1	   9400 
      1	   9401     // Clear memory...
      2	   9402     if(!GETENV(("SSTV2_VIDEO_NOCLEAR"))) {
      2	   9403         FxU32 clearColor = 0x0;
      2	   9404         FxU32 pagesToFill;
      2	   9405 
      2	   9406         if(GETENV(("SSTV2_VIDEO_CLEARCOLOR")) &&
      2	   9407            (SSCANF(GETENV(("SSTV2_VIDEO_CLEARCOLOR")), "%i", &vtmp) == 1))
      2	   9408           clearColor = vtmp;
      2	   9409 
      2	   9410         if(sst1CurrentBoard->fbiMemSize == 1)
      2	   9411            pagesToFill = 256;
      2	   9412         else if(sst1CurrentBoard->fbiMemSize == 2)
      2	   9413           pagesToFill = 512;
      2	   9414         else
      2	   9415           pagesToFill = 1024;
      2	   9416 
      2	   9417         ISET(sst->bltColor, clearColor);
      2	   9418         ISET(sst->bltDstXY, 0x0);
      2	   9419         ISET(sst->bltSize, ((pagesToFill-1)<<16) | 511);
      2	   9420         ISET(sst->bltCommand, SSTG_FRECTFILL | SSTG_GO);
      2	   9421         sst1InitIdle(sstbase);
      1	   9422     } else
      1	   9423         INIT_PRINTF(("sst1InitVideo(): Not Clearing Frame Buffer...\n"));
      1	   9424 

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9425     // Clear fbistat registers after clearing screen
      1	   9426     ISET(sst->nopCMD, 0x3);
      1	   9427 
      1	   9428     // Only switch passthrough and do monitor detection if
      1	   9429     // requested.
      1	   9430     if(switchPassThru == FXTRUE)
      2	   9431     {
      2	   9432       // 3D now owns monitor...
      2	   9433       sst1InitVgaPassCtrl(sstbase, 0);
      2	   9434 
      2	   9435       // Detect presence of monitor...
      2	   9436       sst1InitMonitorDetect(sstbase);
      2	   9437       INIT_PRINTF(("sst1InitVideo(): Monitor Detected:%d\n",
      2	   9438          sst1CurrentBoard->monitorDetected));
      2	   9439 
      2	   9440       // sst1InitMonitorDetect() trashes the gamma table.  Reload to the
      2	   9441       // original value if sst1InitGamma() has already been called -- otherwise
      2	   9442       // load a 1.0 gamma table
      2	   9443       if(sst1CurrentBoard->fbiInitGammaDone)
      2	   9444          sst1InitGammaRGB(sstbase, sst1CurrentBoard->fbiGammaRed,
      2	   9445            sst1CurrentBoard->fbiGammaGreen, sst1CurrentBoard->fbiGammaBlue);
      3	   9446       else {
      3	   9447          // Do not display gamma values when called by sst1InitVideo()...
      3	   9448          sst1CurrentBoard->fbiInitGammaDone = 1;
      3	   9449          sst1InitGammaRGB(sstbase, (double) 1.0, (double) 1.0, (double) 1.0);
      3	   9450          sst1CurrentBoard->fbiInitGammaDone = 0;
      2	   9451       }
      1	   9452     }
      1	   9453 
      2	   9454     if(GETENV(("SSTV2_VIDEO_DISABLE"))) {
      2	   9455         INIT_PRINTF(("sst1InitVideo(): Disabling video timing...\n"));
      2	   9456         ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      2	   9457         sst1InitIdleFBINoNOP(sstbase);
      1	   9458     }
      1	   9459     sst1InitIdle(sstbase);
      1	   9460 
      1	   9461     if(((IGET(sst->status) & SST_SWAPBUFPENDING) >>
      1	   9462       SST_SWAPBUFPENDING_SHIFT) > 0)
      1	   9463         sst1InitClearSwapPending(sstbase);
      1	   9464 
      1	   9465     // Since initVideo() is the last init call, if the user wants to
      1	   9466     // disable idling, do it here.  This way, all the calls to initIdle
      1	   9467     // required within the init code still idle the hardware.
      2	   9468     if(GETENV(("SSTV2_IGNORE_IDLE"))) {
      2	   9469        INIT_PRINTF(("sst1InitVideo(): Ignoring calls to sst1InitIdle()...\n"));
      2	   9470        initIdleEnabled = 0;
      1	   9471     }
      1	   9472 
      1	   9473     // Update info structure for initEnable
      1	   9474     PCICFG_RD(SST1_PCI_INIT_ENABLE, sst1CurrentBoard->fbiInitEnable);
      1	   9475 
      1	   9476     // If this board is SLI-capable, tristate the video output signals so
      1	   9477     // that monitor detection will work properly for the second board.  The
      1	   9478     // video output signals will be re-enabled during SLI initialization for
      1	   9479     // the Master board
      2	   9480     if(sst1CurrentBoard->sliDetected) {
      2	   9481        INIT_PRINTF(("sst1InitVideo(): Disabling video output signals for proper monitor detection...\n"));

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9482        sst1InitVideoShutdown(sstbase, FXFALSE);
      1	   9483     }
      1	   9484 
      1	   9485     INIT_PRINTF(("sst1InitVideo() exiting with status %d...\n", FXTRUE));
      1	   9486     return(FXTRUE);
      1	   9487 }
	   9488 
	   9489 /*
	   9490 ** sst1InitAllocBuffers():
	   9491 **  Initialize video for buffer management
	   9492 **
	   9493 */
	   9494 static FxBool 
	   9495 sst1InitAllocBuffersDirect(FxU32 *sstbase, FxU32 nColorBuffs, FxU32 nAuxBuffs)
      1	   9496 {
      1	   9497    SstRegs *sst = (SstRegs *) sstbase;
      1	   9498    FxU32 nCol = nColorBuffs;
      1	   9499    FxU32 nAux = nAuxBuffs;
      1	   9500 
      1	   9501    if(!sst)
      1	   9502        return(FXFALSE);
      1	   9503 
      1	   9504    // Setup buffer management...
      1	   9505    if(nCol == 2 && nAux == 0)
      1	   9506      ISET(sst->fbiInit5, (IGET(sst->fbiInit5) & ~SST_BUFFER_ALLOC) |
      1	   9507        SST_BUFFER_ALLOC_2C0Z);
      1	   9508    else if(nCol == 2 && nAux == 1)
      1	   9509      ISET(sst->fbiInit5, (IGET(sst->fbiInit5) & ~SST_BUFFER_ALLOC) |
      1	   9510        SST_BUFFER_ALLOC_2C1Z);
      1	   9511    else if(nCol == 3 && nAux == 0)
      1	   9512      ISET(sst->fbiInit5, (IGET(sst->fbiInit5) & ~SST_BUFFER_ALLOC) |
      1	   9513        SST_BUFFER_ALLOC_3C0Z);
      1	   9514    else if(nCol == 3 && nAux == 1)
      1	   9515      ISET(sst->fbiInit5, (IGET(sst->fbiInit5) & ~SST_BUFFER_ALLOC) |
      1	   9516        SST_BUFFER_ALLOC_3C1Z);
      2	   9517    else {
      2	   9518      INIT_PRINTF(("sst1InitAllocBuffers(): Unsupported Color/Aux buffer combination (%d/%d)\n", 
      2	   9519                   nCol, nAux));
      2	   9520      return(FXFALSE);
      1	   9521    }
      1	   9522    sst1InitReturnStatus(sstbase);
      1	   9523 
      1	   9524    return(FXTRUE);
      1	   9525 }
	   9526 
	   9527 FX_EXPORT FxBool FX_CSTYLE 
	   9528 sst1InitAllocBuffers(FxU32 *sstbase, FxU32 nColorBuffs, FxU32 nAuxBuffs)
      1	   9529 {
      1	   9530    SstRegs *sst = (SstRegs *) sstbase;
      1	   9531    FxBool retVal;
      1	   9532 
      1	   9533    if(!sst)
      1	   9534        return(FXFALSE);
      1	   9535 
      1	   9536    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9537        return(FXFALSE);
      1	   9538 

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9539    retVal = sst1InitAllocBuffersDirect(sstbase, 
      1	   9540                                        nColorBuffs, nAuxBuffs);
      1	   9541 
      2	   9542    if (retVal && sst1CurrentBoard->sliDetected) {
      2	   9543      /* NB: When writing to the slave we need to make sure that it does
      2	   9544       * not have a client callback installed.  
      2	   9545       */
      2	   9546      FxSet32Proc saveProc = sst1CurrentBoard->set32;
      2	   9547      sst1CurrentBoard->set32 = NULL;
      2	   9548 
      2	   9549      sst1InitAllocBuffersDirect(sst1CurrentBoard->sliSlaveVirtAddr,
      2	   9550                                 nColorBuffs, nAuxBuffs);
      2	   9551 
      2	   9552      sst1CurrentBoard->set32 = saveProc;
      1	   9553    }
      1	   9554 
      1	   9555    return retVal;
      1	   9556 }
	   9557 
	   9558 /*
	   9559 ** sst1InitVideoShutdown():
	   9560 **  Shutdown video by not driving video outputs
	   9561 **  Do not reset the video engine
	   9562 **
	   9563 */
	   9564 FX_EXPORT FxBool FX_CSTYLE sst1InitVideoShutdown(FxU32 *sstbase,
	   9565                                                  FxBool switchPassThruToVGA)
      1	   9566 {
      1	   9567    SstRegs *sst = (SstRegs *) sstbase;
      1	   9568 
      1	   9569    if(!sst)
      1	   9570       return(FXFALSE);
      1	   9571 
      1	   9572    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9573       return(FXFALSE);
      1	   9574 
      1	   9575    ISET(sst->fbiInit1, (IGET(sst->fbiInit1) & ~(SST_VIDEO_DATA_OE_EN |
      1	   9576       SST_VIDEO_DCLK_OE_EN | SST_VIDEO_HVSYNC_OE_EN)) | SST_VIDEO_BLANK_EN);
      1	   9577    sst1InitReturnStatus(sstbase);
      1	   9578    ISET(sst->fbiInit5, IGET(sst->fbiInit5) & ~(
      1	   9579      SST_VIDEO_CLK_SLAVE_OE_EN | SST_VID_CLK_2X_OUT_OE_EN));
      1	   9580    sst1InitReturnStatus(sstbase);
      1	   9581 
      1	   9582    if(switchPassThruToVGA == FXTRUE)
      1	   9583       // 2D/VGA now owns monitor...
      1	   9584       sst1InitVgaPassCtrl(sstbase, 1);
      1	   9585 
      1	   9586    return(FXTRUE);
      1	   9587 }
	   9588 
	   9589 /*
	   9590 ** sst1InitSetVidMode():
	   9591 **  Set video Mode
	   9592 **
	   9593 */
	   9594 FxBool sst1InitSetVidMode(FxU32 *sstbase, FxU32 video16BPP)
      1	   9595 {

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	   9596     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9597 
      1	   9598     if(helper)
      1	   9599         INIT_PRINTF(("sst1InitSetVidMode(): Entered...\n"));
      1	   9600 
      1	   9601     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9602         return(FXFALSE);
      1	   9603 
      2	   9604     if(sst1InitUseVoodooFile == FXTRUE) {
      2	   9605         return(sst1InitSetVidModeINI(sstbase, video16BPP));
      2	   9606     } else {
      2	   9607         if((sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ATT) ||
      2	   9608            (sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_TI))
      2	   9609            return(sst1InitSetVidModeATT(sstbase, video16BPP));
      2	   9610         else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ICS)
      2	   9611            return(sst1InitSetVidModeICS(sstbase, video16BPP));
      2	   9612         else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_PROXY)
      2	   9613            return(FXTRUE); /* single board SLI - jeske */
      2	   9614         else
      2	   9615             return(FXFALSE);
      1	   9616     }
      1	   9617 }
	   9618 
	   9619 /*
	   9620 ** sst1InitSetResolution():
	   9621 **  Setup FBI video resolution registers
	   9622 **  This routine is used by sst1InitVideo()
	   9623 **
	   9624 **
	   9625 */
	   9626 FX_EXPORT void FX_CSTYLE sst1InitSetResolution(FxU32 *sstbase, 
	   9627                                                sst1VideoTimingStruct *sstVideoRez, 
	   9628                                                FxU32 Banked)
      1	   9629 {
      1	   9630     SstRegs *sst = (SstRegs *) sstbase;
      1	   9631 
      1	   9632     if(Banked)
      1	   9633         ISET(sst->fbiInit2, (IGET(sst->fbiInit2) & ~SST_VIDEO_BUFFER_OFFSET) |
      1	   9634             (sstVideoRez->memOffset << SST_VIDEO_BUFFER_OFFSET_SHIFT) |
      1	   9635             SST_DRAM_BANKING_CONFIG | SST_EN_DRAM_BANKED);
      1	   9636     else
      1	   9637         ISET(sst->fbiInit2, (IGET(sst->fbiInit2) & ~SST_VIDEO_BUFFER_OFFSET) |
      1	   9638             (sstVideoRez->memOffset << SST_VIDEO_BUFFER_OFFSET_SHIFT));
      1	   9639 
      1	   9640     ISET(sst->fbiInit1, (IGET(sst->fbiInit1) & ~SST_VIDEO_TILES_MASK) |
      1	   9641          (((sstVideoRez->tilesInX>>1) & 0xF)<<SST_VIDEO_TILES_IN_X_SHIFT) |
      1	   9642          (((sstVideoRez->tilesInX>>5) & 0x1)<<SST_VIDEO_TILES_IN_X_MSB_SHIFT));
      1	   9643 
      1	   9644     // sst1CurrentBoard must be set previously with a sst1InitCheckBoard()
      1	   9645     // call...
      1	   9646     sst1CurrentBoard->fbiInit6 =
      1	   9647       (sst1CurrentBoard->fbiInit6 & ~SST_VIDEO_TILES_IN_X_LSB) |
      1	   9648       ((sstVideoRez->tilesInX & 0x1)<<SST_VIDEO_TILES_IN_X_LSB_SHIFT);
      1	   9649     ISET(sst->fbiInit6, sst1CurrentBoard->fbiInit6);
      1	   9650 }
	   9651 
	   9652 /*

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

	   9653 ** sst1InitSetVidClk():
	   9654 **  Set video clock
	   9655 **
	   9656 */
	   9657 FX_EXPORT FxBool FX_CSTYLE sst1InitSetVidClk(FxU32 *sstbase, float vidClkFreq)
      1	   9658 {
      1	   9659     sst1ClkTimingStruct vidClkTiming;
      1	   9660     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9661 
      1	   9662     if(helper)
      1	   9663 
      1	   9664         INIT_PRINTF(("sst1InitSetVidClk(): Entered...\n"));
      1	   9665 
      1	   9666     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9667         return(FXFALSE);
      1	   9668 
      1	   9669     if(sst1InitComputeClkParams(vidClkFreq, &vidClkTiming) == FXFALSE)
      1	   9670         return(FXFALSE);
      1	   9671 
      1	   9672     INIT_PRINTF(("sst1InitSetVidClk(): Setting up %.2f MHz Video Clock...\n",
      1	   9673         vidClkFreq));
      1	   9674 
      1	   9675     if((sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ATT) ||
      1	   9676        (sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_TI))
      1	   9677        return(sst1InitSetVidClkATT(sstbase, &vidClkTiming));
      1	   9678     else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ICS)
      1	   9679        return(sst1InitSetVidClkICS(sstbase, &vidClkTiming));
      1	   9680     else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_PROXY)
      1	   9681        return(FXTRUE); /* single board sli - jeske */
      1	   9682     else
      1	   9683         return(FXFALSE);
      1	   9684 }
	   9685 
	   9686 /*
	   9687 ** sst1InitSetGrxClk():
	   9688 **  Set graphics clock
	   9689 **  NOTE: sst1InitSetGrxClk() resets the PCI fifo and the graphics subsystem
	   9690 **  of FBI
	   9691 **
	   9692 */
	   9693 FX_EXPORT FxBool FX_CSTYLE sst1InitSetGrxClk(FxU32 *sstbase,
	   9694                                              sst1ClkTimingStruct *sstGrxClk)
      1	   9695 {
      1	   9696     FxBool retVal = FXFALSE;
      1	   9697     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9698     SstRegs *sst = (SstRegs *) sstbase;
      1	   9699 
      1	   9700     if(helper)
      1	   9701         INIT_PRINTF(("sst1InitSetGrxClk(): Entered...\n"));
      1	   9702 
      1	   9703     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9704         return(FXFALSE);
      1	   9705 
      2	   9706     if(sst1InitUseVoodooFile == FXTRUE) {
      2	   9707         retVal = sst1InitSetGrxClkINI(sstbase, sstGrxClk);
      2	   9708     } else {
      2	   9709         if((sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ATT) ||

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9710            (sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_TI))
      2	   9711            retVal = sst1InitSetGrxClkATT(sstbase, sstGrxClk);
      2	   9712         else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_ICS)
      2	   9713            retVal = sst1InitSetGrxClkICS(sstbase, sstGrxClk);
      3	   9714         else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_PROXY) {
      3	   9715            /* single board SLI - jeske*/
      3	   9716            FxU32 i;
      3	   9717 
      3	   9718            /* Reset graphics unit before we change grx clk */
      3	   9719            ISET(sst->fbiInit0, IGET(sst->fbiInit0) |
      3	   9720                 (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      3	   9721            sst1InitIdleFBINoNOP(sstbase);
      3	   9722 
      3	   9723 
      4	   9724            for (i=0;i<boardsInSystem;i++) {
      5	   9725                if ((i > 0) && (&sst1BoardInfo[i] == sst1CurrentBoard)) {
      5	   9726                   retVal = sst1InitSetGrxClk((FxU32 *)sst1BoardInfo[i-1].virtAddr[0],
      5	   9727                        sstGrxClk);
      5	   9728                   break;
      4	   9729                }
      3	   9730            }
      3	   9731 
      3	   9732            /* Wait for graphics clock to stabilize */
      4	   9733            { int n;
      4	   9734            for(n=0; n<200000; n++)
      4	   9735              sst1InitReturnStatus(sstbase);
      4	   9736            
      4	   9737            /* Unreset PCI FIFO and graphic subsystem */
      4	   9738            ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      4	   9739            sst1InitIdleFBINoNOP(sstbase);
      4	   9740            ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      4	   9741            sst1InitIdleFBINoNOP(sstbase);
      3	   9742            }
      3	   9743            
      2	   9744         }
      1	   9745     }
      1	   9746     if(retVal == FXFALSE)
      1	   9747         return(FXFALSE);
      1	   9748 
      1	   9749     // Always reset TMUs after a clock change...
      1	   9750     return(sst1InitResetTmus(sstbase));
      1	   9751 }
	   9752 
	   9753 /*
	   9754 ** sst1InitVideoBorder():
	   9755 **  Initialize video color border
	   9756 **
	   9757 **  The 'mask' parameter specifies which border(s) to enable:
	   9758 **    SST_COLOR_BORDER_LEFT_EN:     Left edge
	   9759 **    SST_COLOR_BORDER_RIGHT_EN:    Right edge
	   9760 **    SST_COLOR_BORDER_TOP_EN:      Top edge
	   9761 **    SST_COLOR_BORDER_BOTTOM_EN:   Bottom edge
	   9762 **  The 'color' parameter is in XXRRGGBB format
	   9763 **
	   9764 **    Returns:
	   9765 **      FXTRUE if successfully initializes video color border
	   9766 **      FXFALSE if cannot initialize video color border

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

	   9767 **
	   9768 */
	   9769 FX_EXPORT FxBool FX_CSTYLE sst1InitVideoBorder(FxU32 *sstbase,
	   9770                                                FxU32 mask, 
	   9771                                                FxU32 color)
      1	   9772 {
      1	   9773 
      1	   9774     FxU32 fbiInit5;
      1	   9775     SstRegs *sst = (SstRegs *) sstbase;
      1	   9776 
      1	   9777     if(!sst)
      1	   9778         return(FXFALSE);
      1	   9779 
      1	   9780     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9781         return(FXFALSE);
      1	   9782 
      1	   9783     INIT_PRINTF(("sst1InitVideoBorder(): Setting border color to 0x%x...\n",
      1	   9784         color));
      1	   9785 
      1	   9786     fbiInit5 = IGET(sst->fbiInit5) &
      1	   9787       ~(SST_COLOR_BORDER_LEFT_EN | SST_COLOR_BORDER_RIGHT_EN |
      1	   9788         SST_COLOR_BORDER_TOP_EN | SST_COLOR_BORDER_BOTTOM_EN);
      1	   9789     fbiInit5 |=
      1	   9790       (mask & SST_COLOR_BORDER_LEFT_EN) ? SST_COLOR_BORDER_LEFT_EN : 0;
      1	   9791     fbiInit5 |=
      1	   9792       (mask & SST_COLOR_BORDER_RIGHT_EN) ? SST_COLOR_BORDER_RIGHT_EN : 0;
      1	   9793     fbiInit5 |=
      1	   9794       (mask & SST_COLOR_BORDER_TOP_EN) ? SST_COLOR_BORDER_TOP_EN : 0;
      1	   9795     fbiInit5 |=
      1	   9796       (mask & SST_COLOR_BORDER_BOTTOM_EN) ? SST_COLOR_BORDER_BOTTOM_EN : 0;
      1	   9797 
      1	   9798     ISET(sst->borderColor, color);
      1	   9799     ISET(sst->fbiInit5, fbiInit5);
      1	   9800 
      1	   9801     return(FXTRUE);
      1	   9802 }
	   9803 
	   9804 /*
	   9805 ** sst1InitFindVideoTimingStruct():
	   9806 **  Find SST-1 video timing data structure from GrScreenResolution_t and
	   9807 **  GrScreenRefresh_t input params
	   9808 **
	   9809 */
	   9810 
	   9811 FX_EXPORT sst1VideoTimingStruct* FX_CSTYLE
	   9812 sst1InitFindVideoTimingStruct(GrScreenResolution_t screenResolution, 
	   9813                               GrScreenRefresh_t screenRefresh)
      1	   9814 {
      1	   9815     GrScreenResolution_t screenRez = screenResolution;
      1	   9816     GrScreenRefresh_t refreshRate = screenRefresh;
      1	   9817 
      1	   9818     // Override Screen resolution with environment variables
      2	   9819     if(GETENV(("SSTV2_SCREENREZ"))) {
      2	   9820       FxU32 screenRezEnv = ATOI(GETENV(("SSTV2_SCREENREZ")));
      2	   9821 
      3	   9822       switch(screenRezEnv) {
      3	   9823         case 512256:

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      3	   9824           screenRez = GR_RESOLUTION_512x256;
      3	   9825           break;
      3	   9826         case 512:
      3	   9827           screenRez = GR_RESOLUTION_512x384;
      3	   9828           break;
      3	   9829         case 640400:
      3	   9830           screenRez = GR_RESOLUTION_640x400;
      3	   9831           break;
      3	   9832         case 800:
      3	   9833           screenRez = GR_RESOLUTION_800x600;
      3	   9834           break;
      3	   9835         case 856:
      3	   9836           screenRez = GR_RESOLUTION_856x480;
      3	   9837           break;
      3	   9838         case 960:
      3	   9839           screenRez = GR_RESOLUTION_960x720;
      3	   9840           break;
      3	   9841         case 1024:
      3	   9842           screenRez = GR_RESOLUTION_1024x768;
      3	   9843           break;
      3	   9844         default:
      3	   9845           screenRez = GR_RESOLUTION_640x480;
      3	   9846           break;
      2	   9847       }
      1	   9848     }
      1	   9849 
      1	   9850     // Override Screen resolution with environment variables
      2	   9851     if(GETENV(("SSTV2_SCREENREFRESH"))) {
      2	   9852       FxU32 refreshRateEnv = ATOI(GETENV(("SSTV2_SCREENREFRESH")));
      2	   9853 
      3	   9854       switch(refreshRateEnv) {
      3	   9855         case 75:
      3	   9856           refreshRate = GR_REFRESH_75Hz;
      3	   9857           break;
      3	   9858         case 85:
      3	   9859           refreshRate = GR_REFRESH_85Hz;
      3	   9860           break;
      3	   9861         case 120:
      3	   9862           refreshRate = GR_REFRESH_120Hz;
      3	   9863           break;
      3	   9864         default:
      3	   9865           refreshRate = GR_REFRESH_60Hz;
      3	   9866           break;
      2	   9867       }
      1	   9868     }
      1	   9869 
      2	   9870     switch(screenRez) {
      2	   9871 
      2	   9872         case(GR_RESOLUTION_512x256):
      2	   9873           return(&SST_VREZ_512X256_60);
      2	   9874           break;
      2	   9875 
      2	   9876         case(GR_RESOLUTION_512x384):
      2	   9877         
      2	   9878           if( GETENV( ("SSTV2_REFRESH_512x384") ) )
      2	   9879             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_512x384") ) ) );
      2	   9880             

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9881           if(refreshRate == GR_REFRESH_120Hz)
      2	   9882              return(&SST_VREZ_512X384_120);
      3	   9883           else if(refreshRate == GR_REFRESH_85Hz) {
      3	   9884              if(sst1CurrentBoard->sliDetected)
      3	   9885                 return(&SST_VREZ_512X384_85_NOSCANDOUBLE);
      3	   9886              else
      3	   9887                 return(&SST_VREZ_512X384_85);
      3	   9888           } else if(refreshRate == GR_REFRESH_75Hz) {
      3	   9889              if(sst1CurrentBoard->sliDetected)
      3	   9890                 return(&SST_VREZ_512X384_75_NOSCANDOUBLE);
      3	   9891              else
      3	   9892                 return(&SST_VREZ_512X384_75);
      3	   9893           } else {
      3	   9894              if(sst1CurrentBoard->sliDetected)
      3	   9895                 return(&SST_VREZ_512X384_72);
      3	   9896              else
      3	   9897                 return(&SST_VREZ_512X384_60);
      2	   9898           }
      2	   9899           break;
      2	   9900 
      2	   9901         case(GR_RESOLUTION_640x400):
      2	   9902         
      2	   9903           if( GETENV( ("SSTV2_REFRESH_640x400") ) )
      2	   9904             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_640x400") ) ) );
      2	   9905         
      2	   9906           if(refreshRate == GR_REFRESH_120Hz)
      2	   9907              return(&SST_VREZ_640X400_120);
      2	   9908           else if(refreshRate == GR_REFRESH_85Hz)
      2	   9909              return(&SST_VREZ_640X400_85);
      2	   9910           else if(refreshRate == GR_REFRESH_75Hz)
      2	   9911              return(&SST_VREZ_640X400_75);
      2	   9912           else
      2	   9913              return(&SST_VREZ_640X400_70);
      2	   9914           break;
      2	   9915 
      2	   9916         case(GR_RESOLUTION_640x480):
      2	   9917         
      2	   9918           if( GETENV( ("SSTV2_REFRESH_640x480") ) )
      2	   9919             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_640x480") ) ) );
      2	   9920             
      2	   9921           if(refreshRate == GR_REFRESH_120Hz)
      2	   9922              return(&SST_VREZ_640X480_120);
      2	   9923           else if(refreshRate == GR_REFRESH_85Hz)
      2	   9924              return(&SST_VREZ_640X480_85);
      2	   9925           else if(refreshRate == GR_REFRESH_75Hz)
      2	   9926              return(&SST_VREZ_640X480_75);
      2	   9927           else
      2	   9928              return(&SST_VREZ_640X480_60);
      2	   9929           break;
      2	   9930 
      2	   9931         case(GR_RESOLUTION_800x600):
      2	   9932         
      2	   9933           if( GETENV( ("SSTV2_REFRESH_800x600") ) )
      2	   9934             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_800x600") ) ) );
      2	   9935             
      2	   9936           if(refreshRate == GR_REFRESH_120Hz)
      2	   9937              return(&SST_VREZ_800X600_120);

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	   9938           else if(refreshRate == GR_REFRESH_85Hz)
      2	   9939              return(&SST_VREZ_800X600_85);
      2	   9940           else if(refreshRate == GR_REFRESH_75Hz)
      2	   9941              return(&SST_VREZ_800X600_75);
      2	   9942           else
      2	   9943              return(&SST_VREZ_800X600_60);
      2	   9944           break;
      2	   9945 
      2	   9946         case(GR_RESOLUTION_856x480):
      2	   9947           return(&SST_VREZ_856X480_60);
      2	   9948           break;
      2	   9949 
      2	   9950         case(GR_RESOLUTION_960x720):
      2	   9951           if( GETENV( ("SSTV2_REFRESH_960x720") ) )
      2	   9952             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_960x720") ) ) );
      2	   9953             
      2	   9954           if(refreshRate == GR_REFRESH_85Hz)
      2	   9955              return(&SST_VREZ_960X720_85);
      2	   9956           else if(refreshRate == GR_REFRESH_75Hz)
      2	   9957              return(&SST_VREZ_960X720_75);
      2	   9958           else
      2	   9959              return(&SST_VREZ_960X720_60);
      2	   9960           break;
      2	   9961 
      2	   9962         case(GR_RESOLUTION_1024x768):
      2	   9963         
      2	   9964           if( GETENV( ("SSTV2_REFRESH_1024x768") ) )
      2	   9965             refreshRate = sst1InitConvertRefreshRate( ATOI( GETENV( ("SSTV2_REFRESH_1024x768") ) ) );
      2	   9966             
      2	   9967           if(refreshRate == GR_REFRESH_85Hz)
      2	   9968              return(&SST_VREZ_1024X768_85);
      2	   9969           else if(refreshRate == GR_REFRESH_75Hz)
      2	   9970              return(&SST_VREZ_1024X768_75);
      2	   9971           else
      2	   9972              return(&SST_VREZ_1024X768_60);
      2	   9973           break;
      2	   9974 
      2X   9975 #ifdef H3D
      2X   9976         /*  In the following cases, sli can't handle line doubled LD modes  */
      2X   9977         /*  therefore, we need to return a non-line doubled mode if we're   */
      2X   9978         /*  sli-ing                                                         */
      2X   9979       
      2X   9980         case (GR_RESOLUTION_640x240_AUTOFLIPPED):
      2X   9981         case (GR_RESOLUTION_640x480_AUTOFLIPPED):
      2X   9982           if (sst1CurrentBoard->sliDetected)
      2X   9983             return(&SST_VREZ_640X960_60);
      2X   9984           else
      2X   9985             return(&SST_VREZ_640X960LD_60);
      2X   9986           break;
      2X   9987 
      2X   9988         case (GR_RESOLUTION_800x300_AUTOFLIPPED):
      2X   9989         case (GR_RESOLUTION_800x600_AUTOFLIPPED):
      2X   9990           if (sst1CurrentBoard->sliDetected)
      2X   9991             return(&SST_VREZ_800X630_60);
      2X   9992           else
      2X   9993             return(&SST_VREZ_800X1200LD_45);
      2X   9994           break;

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2X   9995 
      2X   9996         case (GR_RESOLUTION_960x360_AUTOFLIPPED):
      2X   9997         case (GR_RESOLUTION_960x720_AUTOFLIPPED):
      2X   9998           if (sst1CurrentBoard->sliDetected)
      2X   9999             return(&SST_VREZ_960X742_60);
      2X  10000           else
      2X  10001             return((sst1VideoTimingStruct *) NULL);             
      2X  10002           break;
      2X  10003 
      2X  10004         case (GR_RESOLUTION_1024x384_AUTOFLIPPED):
      2X  10005         case (GR_RESOLUTION_1024x768_AUTOFLIPPED):
      2X  10006           if (sst1CurrentBoard->sliDetected)
      2X  10007             return(&SST_VREZ_1024X768_60);
      2X  10008           else
      2X  10009             return((sst1VideoTimingStruct *) NULL);             
      2X  10010           break;
      2X  10011 
      2X  10012 #endif
      2	  10013 
      2	  10014         default:
      2	  10015           INIT_PRINTF(("sst1InitFindVideoTimingStruc(): Unsupported Resolution...\n"));
      2	  10016           return((sst1VideoTimingStruct *) NULL);
      2	  10017           break;
      1	  10018     }
      1	  10019 }
	  10020 
	  10021 FxU32 sst1InitConvertRefreshRate( FxU32 refreshRate )
      1	  10022 {
      1	  10023   switch( refreshRate )
      2	  10024   {
      2	  10025     case 75:
      2	  10026       return( GR_REFRESH_75Hz );
      2	  10027     case 85:
      2	  10028       return( GR_REFRESH_85Hz );
      2	  10029     case 120:
      2	  10030       return( GR_REFRESH_120Hz );
      2	  10031     default:
      2	  10032       return( GR_REFRESH_60Hz );
      1	  10033   }
      1	  10034 }
	  10035 
	  10036 /*
	  10037 **
	  10038 ** sst1InitMonitorDetect()
	  10039 ** Detect whether or not a monitor is connected to the board
	  10040 **
	  10041 */
	  10042 
	  10043 FX_EXPORT FxBool FX_CSTYLE sst1InitMonitorDetect(FxU32 *sstbase)
      1	  10044 {
      1	  10045    SstRegs *sst = (SstRegs *) sstbase;
      1	  10046    FxU32 gammaArray[32];
      1	  10047    FxU32 j, k;
      1	  10048    FxU32 gammaCorrectConstant = 0x5c;
      1	  10049 
      1	  10050    if(!sst)
      1	  10051        return(FXFALSE);

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	  10052 
      1	  10053    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	  10054        return(FXFALSE);
      1	  10055 
      1	  10056    /* check to see if we are a single board SLI slave, and if
      1	  10057     * so, then don't detect a monitor - jeske
      1	  10058     */
      1	  10059    //if (sst1CurrentBoard->singleBrdSLISlave) {
      1	  10060    //   sst1CurrentBoard->monitorDetected = 0;
      1	  10061    //   return (FXTRUE);
      1	  10062    // }
      1	  10063 
      1	  10064    if(GETENV(("SSTV2_MDETECT_CONST")) &&
      2	  10065       (SSCANF(GETENV(("SSTV2_MDETECT_CONST")), "%i", &j) == 1)) {
      2	  10066      gammaCorrectConstant = j;
      2	  10067      INIT_PRINTF(("sst1InitMonitorDetect(): Using value 0x%x for constant gamma value...\n", gammaCorrectConstant));
      1	  10068    }
      1	  10069 
      1	  10070    // Force gamma to always output clearColor value...
      1	  10071    for(j=0; j<32; j++)
      1	  10072        gammaArray[j] = gammaCorrectConstant;
      1	  10073        //gammaArray[j] = 0xff; // 0xff never detects monitor...
      1	  10074        //gammaArray[j] = 0x0;  // 0x0 always detects monitor...
      1	  10075    sst1InitGammaTable(sstbase, 32, gammaArray, gammaArray, gammaArray);
      1	  10076 
      1	  10077    // Wait for for monitor to sync...
      1	  10078    sst1InitIdle(sstbase);
      2	  10079    for(k=0; k<(sst1CurrentBoard->fbiVideoRefresh>>2); k++) {
      2	  10080       // Wait for inactive vsync...
      3	  10081       do {
      3	  10082           j = IGET(sst->status);
      2	  10083       } while(!(j & SST_VRETRACE));
      2	  10084   
      2	  10085       // Wait for active vsync
      3	  10086       do {
      3	  10087           j = IGET(sst->status);
      2	  10088       } while(j & SST_VRETRACE);
      1	  10089    }
      1	  10090 
      2	  10091    while(1) {
      2	  10092       FxU32 firstInit6 = IGET(sst->fbiInit6) & SST_GPIO_3;
      2	  10093       FxU32 hvRetrace = IGET(sst->hvRetrace);
      2	  10094       FxU32 vBeam = hvRetrace & 0x1fff;
      2	  10095       FxU32 hBeam = (hvRetrace>>16) & 0x7ff;
      2	  10096       FxU32 secondInit6 = IGET(sst->fbiInit6) & SST_GPIO_3;
      2	  10097 
      2	  10098       if((vBeam > (sst1CurrentBoard->fbiVideoStruct->vBackPorch + 10)) &&
      2	  10099          (vBeam < (sst1CurrentBoard->fbiVideoStruct->vBackPorch +
      2	  10100                    sst1CurrentBoard->fbiVideoHeight - 10)) &&
      2	  10101          (hBeam > (sst1CurrentBoard->fbiVideoStruct->hBackPorch +
      2	  10102                    sst1CurrentBoard->fbiVideoStruct->hSyncOn + 10)) &&
      2	  10103          (hBeam < (sst1CurrentBoard->fbiVideoStruct->hBackPorch +
      2	  10104                    sst1CurrentBoard->fbiVideoStruct->hSyncOn +
      3	  10105                    sst1CurrentBoard->fbiVideoWidth - 10))) {
      4	  10106             if(firstInit6 == secondInit6) {
      4	  10107                if(firstInit6)
      4	  10108                   sst1CurrentBoard->monitorDetected = 1;

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      4	  10109                else
      4	  10110                   sst1CurrentBoard->monitorDetected = 0;
      4	  10111                break;
      3	  10112             }
      2	  10113       }
      1	  10114    }
      1	  10115 
      1	  10116 
      1	  10117    // Override with environment variable...
      1	  10118    if(GETENV(("SSTV2_MDETECT")))
      1	  10119       sst1CurrentBoard->monitorDetected =
      1	  10120          (ATOI(GETENV(("SSTV2_MDETECT")))) ? 1 : 0;
      1	  10121 
      1	  10122    return(FXTRUE);
      1	  10123 }
	  10124 
	  10125 /*
	  10126 **
	  10127 ** sst1InitSetClkDelays():
	  10128 **   Calculate FT, TF0, and TF1 clock delay values...
	  10129 **
	  10130 */
	  10131 FX_EXPORT FxBool FX_CSTYLE sst1InitSetClkDelays(FxU32 *sstbase)
      1	  10132 {
      1	  10133    FxU32 tf0_clkdel, tf1_clkdel, tf2_clkdel, ft_clkdel;
      1	  10134    SstRegs *sst = (SstRegs *) sstbase;
      1	  10135    int i;
      1	  10136 
      2	  10137    if(sst1CurrentBoard->fbiBoardID == 0x3) {
      2	  10138       // Early 4-layer 4220 board -- Runs at 83 MHz by default...
      3	  10139       if(sst1CurrentBoard->fbiGrxClkFreq <= 80) {
      3	  10140          ft_clkdel = 0x5;
      3	  10141          tf0_clkdel = 0x7;
      3	  10142          tf1_clkdel = 0x8;
      3	  10143          tf2_clkdel = 0x8;
      3	  10144       } else {
      3	  10145          ft_clkdel = 0x4;
      3	  10146          tf0_clkdel = 0x6;
      3	  10147          tf1_clkdel = 0x7;
      3	  10148          tf2_clkdel = 0x7;
      2	  10149       }
      2	  10150       goto setDelays;
      1	  10151    }
      1	  10152 
      2	  10153    if(GETENV(("SSTV2_IGNORE_CLKDELAYS"))) {
      2	  10154       INIT_PRINTF(("sst1InitSetClkDelays() WARNING: Bypassing dynamic clock delay detection...\n"));
      2	  10155       ft_clkdel = 0x4;
      2	  10156       tf0_clkdel = 0x6;
      2	  10157       tf1_clkdel = 0x6;
      2	  10158       tf2_clkdel = 0x6;
      2	  10159       goto setDelays;
      1	  10160    }
      1	  10161 
      1	  10162    // FT Clock Delay...
      1	  10163    if(sst1CurrentBoard->fbiNandTree < 5000)
      1	  10164       // Account for very slow processes...
      1	  10165       ft_clkdel = 0x3;

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      1	  10166    else
      1	  10167       ft_clkdel = 0x4;
      1	  10168 
      2	  10169    {
      2	  10170      const char
      2	  10171        *tf2Str = GETENV("SSTV2_INIT_TF2_RESET_DELAY"),
      2	  10172        *tf1Str = GETENV("SSTV2_INIT_TF1_RESET_DELAY"),
      2	  10173        *tf0Str = GETENV("SSTV2_INIT_TF0_RESET_DELAY");
      2	  10174      const FxU32
      2	  10175        tf2 = ((tf2Str == NULL) ? 11 : atoi(tf2Str)),
      2	  10176        tf1 = ((tf1Str == NULL) ? 11 : atoi(tf1Str)),
      2	  10177        tf0 = ((tf0Str == NULL) ?  9 : atoi(tf0Str));
      2	  10178 
      2	  10179      // TF2 Clock Delay...
      3	  10180      if(sst1CurrentBoard->numberTmus > 2) {
      3	  10181        if(sst1InitCalcTClkDelay(sstbase, 2, tf2) == FXTRUE)
      3	  10182          // Test failed.  Fast process TMUs...
      3	  10183          tf2_clkdel = 0x7;
      3	  10184        else
      3	  10185          tf2_clkdel = 0x6;
      2	  10186      } else 
      2	  10187        tf2_clkdel = 0x6;
      2	  10188      
      2	  10189      // TF1 Clock Delay...
      3	  10190      if(sst1CurrentBoard->numberTmus > 1) {
      3	  10191        if(sst1InitCalcTClkDelay(sstbase, 1, tf1) == FXTRUE)
      3	  10192          // Test failed.  Fast process TMUs...
      3	  10193          tf1_clkdel = 0x7;
      3	  10194        else
      3	  10195          tf1_clkdel = 0x6;
      2	  10196      } else 
      2	  10197        tf1_clkdel = 0x6;
      2	  10198      
      2	  10199      // Reset FBI & TMU, and put TF1 clock delay value back to default...
      3	  10200      if(sst1InitResetTmus(sstbase) == FXFALSE) {
      3	  10201        INIT_PRINTF(("sst1InitSetClkDelays() ERROR(1): Could not reset TMUs...\n"));
      3	  10202        return(FXFALSE);
      2	  10203      }
      2	  10204      
      2	  10205      // TF0 Clock Delay...
      2	  10206      if(sst1InitCalcTClkDelay(sstbase, 0, tf0) == FXTRUE)
      2	  10207        // Test failed.  Fast process TMUs...
      2	  10208        tf0_clkdel = 0x7;
      2	  10209      else
      2	  10210        tf0_clkdel = 0x6;
      1	  10211    }
      1	  10212      
      1	  10213    // Reset FBI & TMU, and put TF0 clock delay value back to default...
      2	  10214    if(sst1InitResetTmus(sstbase) == FXFALSE) {
      2	  10215       INIT_PRINTF(("sst1InitSetClkDelays() ERROR(2): Could not reset TMUs...\n"));
      2	  10216       return(FXFALSE);
      1	  10217    }
      1	  10218 
      1	  10219    // Adjust for lower frequencies...
      2	  10220    if(sst1CurrentBoard->fbiGrxClkFreq < 80) {
      2	  10221       ft_clkdel++;
      2	  10222       tf0_clkdel++;

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 26
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

      2	  10223       tf1_clkdel++;
      2	  10224       tf2_clkdel++;
      1	  10225    }
      1	  10226 
      1	  10227 setDelays:
      1	  10228 
      1	  10229    // Override with environment variables
      1	  10230    if(GETENV(("SSTV2_FT_CLKDEL")) &&
      1	  10231       (SSCANF(GETENV(("SSTV2_FT_CLKDEL")), "%i", &i) == 1))
      1	  10232      ft_clkdel = i;
      1	  10233    if(GETENV(("SSTV2_TF0_CLKDEL")) &&
      1	  10234       (SSCANF(GETENV(("SSTV2_TF0_CLKDEL")), "%i", &i) == 1))
      1	  10235      tf0_clkdel = i;
      1	  10236    if(GETENV(("SSTV2_TF1_CLKDEL")) &&
      1	  10237       (SSCANF(GETENV(("SSTV2_TF1_CLKDEL")), "%i", &i) == 1))
      1	  10238      tf1_clkdel = i;
      1	  10239    if(GETENV(("SSTV2_TF2_CLKDEL")) &&
      1	  10240       (SSCANF(GETENV(("SSTV2_TF2_CLKDEL")), "%i", &i) == 1))
      1	  10241      tf2_clkdel = i;
      1	  10242 
      1	  10243    INIT_PRINTF(("sst1InitSetClkDelays(): Setting FBI-to-TREX clock delay to 0x%x...\n", ft_clkdel));
      1	  10244    INIT_PRINTF(("sst1InitSetClkDelays(): Setting TREX#0 TREX-to-FBI clock delay to 0x%x\n",
      1	  10245        tf0_clkdel));
      1	  10246    INIT_PRINTF(("sst1InitSetClkDelays(): Setting TREX#1 TREX-to-FBI clock delay to 0x%x\n",
      1	  10247        tf1_clkdel));
      1	  10248    INIT_PRINTF(("sst1InitSetClkDelays(): Setting TREX#2 TREX-to-FBI clock delay to 0x%x\n",
      1	  10249        tf2_clkdel));
      1	  10250 
      1	  10251    ISET(sst->fbiInit3, (IGET(sst->fbiInit3) & ~SST_FT_CLK_DEL_ADJ) |
      1	  10252        (ft_clkdel << SST_FT_CLK_DEL_ADJ_SHIFT));
      1	  10253    sst1InitIdleFBINoNOP(sstbase);
      1	  10254 
      1	  10255    sst1CurrentBoard->tmuInit1[0] = (sst1CurrentBoard->tmuInit1[0] &
      1	  10256        ~SST_TEX_TF_CLK_DEL_ADJ) | (tf0_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	  10257    sst1CurrentBoard->tmuInit1[1] = (sst1CurrentBoard->tmuInit1[1] &
      1	  10258        ~SST_TEX_TF_CLK_DEL_ADJ) | (tf1_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	  10259    sst1CurrentBoard->tmuInit1[2] = (sst1CurrentBoard->tmuInit1[2] &
      1	  10260        ~SST_TEX_TF_CLK_DEL_ADJ) | (tf2_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	  10261 
      1	  10262     // Calling sst1InitResetTmus() will put the new trexinit values in the
      1	  10263     // TMUs, as well as reset FBI and TMU...
      2	  10264    if(sst1InitResetTmus(sstbase) == FXFALSE) {
      2	  10265       INIT_PRINTF(("sst1InitSetClkDelays() ERROR(3): Could not reset TMUs...\n"));
      2	  10266       return(FXFALSE);
      1	  10267    }
      1	  10268    return(FXTRUE);
      1	  10269 }
	  10270 
       X  10271 #ifdef _MSC_VER
       X  10272 #pragma optimize ("",on)
       X  10273 #endif

VIDEO                           Source Listing                   9-MAY-2021 23:43:24  VSI C V7.4-002-50R2O              Page 27
V1.0                                                             2-FEB-2021 02:11:10  video.c;1

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]VIDEO/OBJECT=[.OUT.DE
BUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]VIDEO.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMI
SC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.
CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE
_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLI
DE.GLIDE2X.CVG.INIT]VIDEO.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:24"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


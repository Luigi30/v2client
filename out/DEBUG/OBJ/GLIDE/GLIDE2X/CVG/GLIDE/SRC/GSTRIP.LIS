GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20  * 
	     21  * 19    12/12/97 12:43p Atai
	     22  * move i and dateElem into the set up loop
	     23  * 
	     24  * 17    12/08/97 10:38a Atai
	     25  * added grDrawVertexArrayLinear()
	     26  * 
	     27  * 16    11/21/97 6:05p Atai
	     28  * use one datalist (tsuDataList) in glide3
	     29  * 
	     30  * 15    11/06/97 6:10p Atai
	     31  * update GrState size
	     32  * rename grDrawArray to grDrawVertexArray
	     33  * update _grDrawPoint and _grDrawVertexList
	     34  * 
	     35  * 14    11/04/97 6:35p Atai
	     36  * 1. sync with data structure changes
	     37  * 2. break up aa triangle routine
	     38  * 
	     39  * 13    11/04/97 4:57p Atai
	     40  * use byte offset
	     41  * 
	     42  * 12    11/03/97 3:43p Peter
	     43  * h3/cvg cataclysm
	     44  * 
	     45  * 11    10/17/97 2:11p Atai
	     46  * added grContinueArray. We only support non aa mode for now.
	     47  * 
	     48  * 10    10/16/97 1:50p Atai
	     49  * fix drawarray bugs
	     50  * 
	     51  * 9     10/14/97 6:16p Atai
	     52  * reverse triangle order in _grAADrawVertexList
	     53  * 
	     54  * 8     10/14/97 5:41p Atai
	     55  * added _grAADrawVertexList()
	     56  * 
	     57  * 7     10/14/97 4:57p Dow

GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

	     58  * Clamping
	     59  * 
	     60  * 6     10/09/97 8:02p Dow
	     61  * State Monster 1st Cut
	     62  * 
	     63  * 5     10/08/97 11:32a Peter
	     64  * pre-computed packet headers for packet 3
	     65  * 
	     66  * 4     9/29/97 1:26p Dow
	     67  * Fixed packed color strips/fans
	     68  * 
	     69  * 3     9/26/97 10:24a Dow
	     70  * Fixed state Muckage in Glide3 parameter data
	     71  * 
	     72  * 2     9/23/97 2:35p Dow
	     73  * One less loop
	     74  * 
	     75  * 1     9/23/97 2:04p Dow
	     76  * DD code for strips
	     77 **
	     78 */
	     79 
	     80 // make VMS compiler happy
	     81 int x;
	     82 
       X     83 #ifdef GLIDE3
       X     84 #include <3dfx.h>
       X     85 #include <glidesys.h>
       X     86 
       X     87 #define FX_DLL_DEFINITION
       X     88 #include <fxdll.h>
       X     89 #include <glide.h>
       X     90 #include "fxglide.h"
       X     91 
       X     92 /*-------------------------------------------------------------------
       X     93   Function: _grDrawVertexList
       X     94   Date: 18-Sep-97
       X     95   Implementor(s): dow
       X     96   Description:
       X     97         Sends a triangle strip to CVG.
       X     98   Arguments:
       X     99   
       X    100   Return:
       X    101   -------------------------------------------------------------------*/
       X    102 void FX_CSTYLE
       X    103 _grDrawVertexList(FxU32 type, FxI32 mode, FxI32 count, void *pointers)
       X    104 {
       X    105 #define FN_NAME "_grDrawVertexList"
       X    106 
       X    107   /*
       X    108   ** simplified code
       X    109   */
       X    110   FxU32
       X    111     vNum = 0,
       X    112     vSize;
       X    113   float
       X    114     **lPtrs = (float **) pointers;

GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

       X    115   FxI32 stride = mode;
       X    116   FxU32
       X    117     sCount = count, set = 0, pktype = SSTCP_PKT3_BDDDDD;
       X    118 
       X    119   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
       X    120 
       X    121   GDBG_INFO_MORE(gc->myLevel, "(type = 0x%x, count = %d, pointers = 0x%x)\n",
       X    122                  type, count, pointers);
       X    123 
       X    124   GR_FLUSH_STATE();
       X    125 
       X    126   vSize = gc->state.vData.vSize;
       X    127   if (stride == 0)
       X    128     stride = gc->state.vData.vStride;
       X    129 
       X    130   /* Draw the first (or possibly only) set.  This is necessary because
       X    131      the packet is 3_BDDDDDD, and in the next set, the packet is
       X    132      3_DDDDDD */
       X    133   /*
       X    134   ** We try to make tstrip code simple to read. We combine the original code
       X    135   ** into a single loop by adding an extra packet type assignment at the end of the loop.
       X    136   ** Also, the debugging code are removed temporarily.
       X    137   */
       X    138   if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
       X    139     while (count > 0) {
       X    140       FxI32 k, vcount = count >= 15 ? 15 : count;
       X    141       GR_SET_EXPECTED_SIZE(vcount * vSize, 1);
       X    142       TRI_STRIP_BEGIN(type, vcount, vSize, pktype);
       X    143       /*
       X    144       ** If we use a while loop, the compiler will increment vNum and store the value back
       X    145       ** to the memory at every loop. In a for loop, vNum data are kept in a register.
       X    146       ** After the loop complete, the vNum data are written back to memory.
       X    147       */
       X    148       for (k = 0; k < vcount; k++) {
       X    149         FxU32 i, dataElem;
       X    150         float *vPtr;
       X    151         
       X    152         vPtr = pointers;
       X    153         if (mode)
       X    154           vPtr = *(float **)vPtr;
       X    155         (float *)pointers += stride;
       X    156         
       X    157         TRI_SETF(FARRAY(vPtr, GR_VERTEX_X_OFFSET << 2));
       X    158         dataElem = 0;
       X    159         TRI_SETF(FARRAY(vPtr, GR_VERTEX_Y_OFFSET << 2));
       X    160         i = gc->tsuDataList[dataElem];
       X    161         while (i != GR_DLIST_END) {
       X    162           TRI_SETF(FARRAY(vPtr, i));
       X    163           dataElem++;
       X    164           i = gc->tsuDataList[dataElem];
       X    165         }
       X    166       }
       X    167       TRI_END;
       X    168       GR_CHECK_SIZE();
       X    169       count -= 15;
       X    170       pktype = SSTCP_PKT3_DDDDDD;
       X    171     }

GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

       X    172   }
       X    173   else {
       X    174     /*
       X    175      * first cut of clip space coordinate code, no optimization.
       X    176      */
       X    177     float oow;
       X    178     
       X    179     while (count > 0) {
       X    180       FxI32 k, vcount = count >= 15 ? 15 : count;
       X    181       GR_SET_EXPECTED_SIZE(vcount * vSize, 1);
       X    182       TRI_STRIP_BEGIN(type, vcount, vSize, pktype);
       X    183       for (k = 0; k < vcount; k++) {
       X    184         float *vPtr;
       X    185         
       X    186         vPtr = pointers;
       X    187         if (mode)
       X    188           vPtr = *(float **)vPtr;
       X    189         oow = 1.0f / FARRAY(vPtr, gc->state.vData.wInfo.offset);
       X    190         /* x, y */
       X    191         TRI_SETF(FARRAY(vPtr, GR_VERTEX_X_OFFSET << 2)
       X    192                  *oow*gc->state.Viewport.hwidth + gc->state.Viewport.ox);
       X    193         TRI_SETF(FARRAY(vPtr, GR_VERTEX_Y_OFFSET << 2)
       X    194                  *oow*gc->state.Viewport.hheight + gc->state.Viewport.oy);
       X    195         (float *)pointers += stride;
       X    196 
       X    197         TRI_VP_SETFS(vPtr, oow);
       X    198       }
       X    199       TRI_END;
       X    200       GR_CHECK_SIZE();
       X    201       count -= 15;
       X    202       pktype = SSTCP_PKT3_DDDDDD;
       X    203     }
       X    204   }
       X    205 
       X    206 #undef FN_NAME
       X    207 } /* _grDrawVertexList */
       X    208 
       X    209 /*-------------------------------------------------------------------
       X    210   Function: _grAADrawVertexList
       X    211   Date: 14-Oct-97
       X    212   Implementor(s): atai
       X    213   Description:
       X    214   Sends an aa triangle strip/fan to CVG.
       X    215   Arguments:
       X    216   
       X    217   Return:
       X    218   -------------------------------------------------------------------*/
       X    219 void FX_CSTYLE
       X    220 _grAADrawVertexList(FxU32 type, FxI32 mode, FxI32 count, void *pointers)
       X    221 {
       X    222 #define FN_NAME "_grAADrawVertexList"
       X    223 
       X    224   GR_DCL_GC;
       X    225   FxU32 vNum = 0;
       X    226   FxU32 sCount = count;
       X    227   float
       X    228     **lPtrs = (float **) pointers;

GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

       X    229   float *v[3];
       X    230   FxBool flip = FXFALSE;
       X    231   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
       X    232   FxI32 stride = mode;
       X    233 
       X    234   if (sCount <= 2) return;
       X    235 
       X    236   _grDrawVertexList(type, mode, count, pointers);
       X    237 
       X    238   fbzModeOld = gc->state.fbi_config.fbzMode;
       X    239   gc->state.fbi_config.fbzMode &= ~(SST_ZAWRMASK);
       X    240   /* gc->state.invalid |= fbzModeBIT; */
       X    241   GR_FLUSH_STATE();
       X    242   if (stride == 0)
       X    243     stride = gc->state.vData.vStride;
       X    244 
       X    245   sCount-=2;
       X    246   if (type == kSetupFan) {
       X    247     v[0] = (mode == 0) ? pointers : *(float **)pointers;
       X    248     while (sCount--) {
       X    249       (float *)pointers += stride;
       X    250       if (mode) {
       X    251         v[1] = *(float **)pointers;
       X    252         v[2] = *((float **)pointers+1);
       X    253       } else {
       X    254         v[1] = pointers;
       X    255         v[2] = (float *)pointers+stride;
       X    256       }
       X    257       if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS)
       X    258         _grAADrawTriangles(1, type, 3, v);
       X    259       else
       X    260         _grAAVpDrawTriangles(1, type, 3, v);    
       X    261     }
       X    262   }
       X    263   else if (type == kSetupStrip){
       X    264     while (sCount--) {
       X    265       if (flip) {
       X    266         if (mode) {
       X    267           v[0] = *((float **)pointers+1);
       X    268           v[1] = *(float **)pointers;
       X    269           v[2] = *((float **)pointers+2);
       X    270         } else {
       X    271           v[0] = (float *)pointers+stride;
       X    272           v[1] = pointers;
       X    273           v[2] = (float *)pointers+(stride<<1);
       X    274         }
       X    275       }
       X    276       else { 
       X    277         if (mode) {
       X    278           v[0] = *(float **)pointers;
       X    279           v[1] = *((float **)pointers+1);
       X    280           v[2] = *((float **)pointers+2);
       X    281         } else {
       X    282           v[0] = pointers;
       X    283           v[1] = (float *)pointers+stride;
       X    284           v[2] = (float *)pointers+(stride<<1);
       X    285         }

GSTRIP                          Source Listing                   9-MAY-2021 23:43:03  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:31:26  gstrip.c;2

       X    286       }
       X    287       if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS)
       X    288         _grAADrawTriangles(1, type, 3, v);
       X    289       else
       X    290         _grAAVpDrawTriangles(1, type, 3, v);    
       X    291       (float *)pointers += stride;
       X    292       flip = ~flip;
       X    293     }
       X    294     flip = ~flip;
       X    295   }
       X    296 
       X    297   gc->state.fbi_config.fbzMode = fbzModeOld;
       X    298   gc->state.invalid |= fbzModeBIT;
       X    299   GR_FLUSH_STATE();
       X    300 
       X    301 #undef FN_NAME
       X    302 } /* _grAADrawVertexList */
       X    303 
       X    304 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSTRIP/OBJECT=[.
OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSTRIP.OBJ/INCLUDE_DIRECTORY=([.GLIDE
.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GL
IDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TR
ISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_
LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSTRIP.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:04"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 ** 
	     20 ** 11    2/20/98 5:31p Peter
	     21 ** crybaby glide
	     22 ** 
	     23 ** 10    2/20/98 11:00a Peter
	     24 ** removed glide3 from glid2 tree
	     25  * 
	     26  * 9     1/08/98 7:09p Peter
	     27  * real hw stuff modulo makefile change
	     28  * 
	     29  * 8     1/06/98 6:47p Atai
	     30  * undo grSplash and remove gu routines
	     31  * 
	     32  * 7     12/15/97 5:51p Atai
	     33  * disable obsolete glide2 api for glide3
	     34  * 
	     35  * 6     5/27/97 1:16p Peter
	     36  * Basic cvg, w/o cmd fifo stuff. 
	     37  * 
	     38  * 5     5/21/97 6:04a Peter
	     39  * 
	     40  * 4     5/05/97 4:24p Pgj
	     41  * Neuter guTexDownloadMipMap error message
	     42  * 
	     43  * 3     3/18/97 9:07p Dow
	     44  * Got rid of #$#%#$ // comments
	     45  * 
	     46  * 2     3/09/97 10:31a Dow
	     47  * Added GR_DIENTRY for di glide functions
	     48  * 
	     49  * 1     12/23/96 1:39p Dow
	     50  * Changes for multiplatform
	     51 **
	     52 */
	     53 
	     54 #include <string.h>
	   1053 #include <3dfx.h>
	   1184 #define FX_DLL_DEFINITION
	   1185 #include <fxdll.h>

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

	   1306 #include <glide.h>
	   3248 #include "fxglide.h"
	  14592 
	  14593 /* externals from ditex.c */
	  14594 extern FxU32 _grMipMapHostSize[][16];
	  14595 extern FxU32 _gr_aspect_index_table[];
	  14596 extern FxU32 _gr_aspect_xlate_table[];
	  14597 extern FxU32 _gr_evenOdd_xlate_table[];
	  14598 
	  14599 
	  14600 /*---------------------------------------------------------------------------
	  14601 ** guTexAllocateMemory
	  14602 */
	  14603 GR_DIENTRY(guTexAllocateMemory, GrMipMapId_t, ( GrChipID_t tmu,
	  14604                     FxU8 odd_even_mask,
	  14605                     int width, int height,
	  14606                     GrTextureFormat_t format,
	  14607                     GrMipMapMode_t mipmap_mode,
	  14608                     GrLOD_t small_lod, GrLOD_t large_lod,
	  14609                     GrAspectRatio_t aspect_ratio,
	  14610                     GrTextureClampMode_t s_clamp_mode,
	  14611                     GrTextureClampMode_t t_clamp_mode,
	  14612                     GrTextureFilterMode_t minfilter_mode,
	  14613                     GrTextureFilterMode_t magfilter_mode,
	  14614                     float lod_bias,
	  14615                     FxBool trilinear
	  14616                     ))
      1	  14617 {
      1	  14618   FxU32
      1	  14619     memrequired,
      1	  14620     memavail,
      1	  14621     baseAddress,
      1	  14622     tLod,
      1	  14623     texturemode,
      1	  14624     filterMode,                 /* filter mode bits */
      1	  14625     clampMode;                  /* clamp mode bits */
      1	  14626 
      1	  14627   GrMipMapId_t
      1	  14628     mmid = (GrMipMapId_t) GR_NULL_MIPMAP_HANDLE;
      1	  14629   int
      1	  14630     int_lod_bias;
      1	  14631   GrTexInfo info;
      1	  14632 
      1	  14633   GR_BEGIN_NOFIFOCHECK("guTexAllocateMemory",99);
      1	  14634   GDBG_INFO_MORE(gc->myLevel,"(%d,%d, %d,%d, %d,%d, %d,%d,%d, %d,%d, %d,%d)\n",
      1	  14635                 tmu,odd_even_mask,width,height,format,mipmap_mode,
      1	  14636                 small_lod,large_lod,aspect_ratio,
      1	  14637                 s_clamp_mode,t_clamp_mode, minfilter_mode,magfilter_mode);
      1	  14638   /*
      1	  14639    ** The constants are actually reverse of each other so the following
      1	  14640    ** test IS valid!
      1	  14641    */
      1	  14642   GR_CHECK_F(myName, small_lod < large_lod, "smallest_lod is larger than large_lod");
      1	  14643   
      1	  14644   info.smallLod = small_lod;
      1	  14645   info.largeLod = large_lod;
      1	  14646   info.aspectRatio = aspect_ratio;

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      1	  14647   info.format = format;
      1	  14648   memrequired = grTexTextureMemRequired(odd_even_mask, &info);
      1	  14649 
      1	  14650   /*
      1	  14651    ** Make sure to not cross 2 MByte texture boundry
      1	  14652    */
      1	  14653   if ((gc->tmu_state[tmu].freemem_base < 0x200000) &&
      1	  14654     (gc->tmu_state[tmu].freemem_base + memrequired > 0x200000))
      1	  14655     gc->tmu_state[tmu].freemem_base = 0x200000;
      1	  14656   
      1	  14657   /*
      1	  14658    ** If we have enough memory and a free mip map handle then go for it
      1	  14659    */
      1	  14660   memavail = guTexMemQueryAvail( tmu );
      1	  14661   
      1	  14662   if ( memavail < memrequired )
      1	  14663     return (GrMipMapId_t) GR_NULL_MIPMAP_HANDLE;
      1	  14664   
      1	  14665   if (gc->mm_table.free_mmid >= MAX_MIPMAPS_PER_SST )
      1	  14666     return (GrMipMapId_t) GR_NULL_MIPMAP_HANDLE;
      1	  14667   
      1	  14668   /*
      1	  14669    ** Allocate the mip map id
      1	  14670    */
      1	  14671   mmid = gc->mm_table.free_mmid++;
      1	  14672 
      1	  14673   /*
      1	  14674    ** calculate baseAddress (where LOD 0 would go)
      1	  14675    */
      1	  14676   baseAddress = _grTexCalcBaseAddress( gc->tmu_state[tmu].freemem_base, 
      1	  14677                                        large_lod, 
      1	  14678                                        aspect_ratio, 
      1	  14679                                        format, 
      1	  14680                                        odd_even_mask );
      1	  14681 
      1	  14682   GDBG_INFO(gc->myLevel,"  baseAddress = 0x%x (in bytes)\n",baseAddress);
      1	  14683   
      1	  14684   /*
      1	  14685    ** reduce available memory to reflect allocation
      1	  14686    */
      1	  14687   gc->tmu_state[tmu].freemem_base += memrequired;
      1	  14688 
      1	  14689   /*
      1	  14690    ** Create the tLOD register value for this mip map
      1	  14691    */
      1	  14692   int_lod_bias = _grTexFloatLODToFixedLOD( lod_bias );
      1	  14693   tLod = mipmap_mode==GR_MIPMAP_DISABLE ? large_lod : small_lod;
      1	  14694   tLod = SST_TLOD_MINMAX_INT(large_lod,tLod);
      1	  14695   tLod |= _gr_evenOdd_xlate_table[odd_even_mask];
      1	  14696   tLod |= _gr_aspect_xlate_table[aspect_ratio];
      1	  14697   tLod |= int_lod_bias << SST_LODBIAS_SHIFT;
      1	  14698   filterMode = (
      1	  14699                 (minfilter_mode == GR_TEXTUREFILTER_BILINEAR ? SST_TMINFILTER : 0) |
      1	  14700                 (magfilter_mode == GR_TEXTUREFILTER_BILINEAR ? SST_TMAGFILTER : 0)
      1	  14701                 );
      1	  14702   
      1	  14703   clampMode = (

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      1	  14704                (s_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPS : 0) |
      1	  14705                (t_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPT : 0)
      1	  14706                );  
      1	  14707   
      1	  14708   /*
      1	  14709    ** Create the tTextureMode register value for this mip map
      1	  14710    */
      1	  14711   texturemode  = ( format << SST_TFORMAT_SHIFT );
      1	  14712   texturemode |= SST_TCLAMPW;
      1	  14713   texturemode |= SST_TPERSP_ST;
      1	  14714   texturemode |= filterMode;
      1	  14715   texturemode |= clampMode;
      1	  14716   
      1	  14717   if ( mipmap_mode == GR_MIPMAP_NEAREST_DITHER )
      1	  14718     texturemode |= SST_TLODDITHER;
      1	  14719   
      2	  14720   if ( trilinear ) {
      2	  14721       texturemode |= SST_TRILINEAR;
      2	  14722 
      2	  14723       if ( odd_even_mask & GR_MIPMAPLEVELMASK_ODD )
      2	  14724         tLod |= SST_LOD_ODD;
      2	  14725 
      2	  14726       if ( odd_even_mask != GR_MIPMAPLEVELMASK_BOTH )
      2	  14727         tLod |= SST_LOD_TSPLIT;
      1	  14728   }
      1	  14729   
      1	  14730   /*
      1	  14731    ** Fill in the mm_table data for this mip map
      1	  14732    */
      1	  14733   gc->mm_table.data[mmid].format         = format;
      1	  14734   gc->mm_table.data[mmid].mipmap_mode    = mipmap_mode;
      1	  14735   gc->mm_table.data[mmid].magfilter_mode = magfilter_mode;
      1	  14736   gc->mm_table.data[mmid].minfilter_mode = minfilter_mode;
      1	  14737   gc->mm_table.data[mmid].s_clamp_mode   = s_clamp_mode;
      1	  14738   gc->mm_table.data[mmid].t_clamp_mode   = t_clamp_mode;
      1	  14739   gc->mm_table.data[mmid].tLOD           = tLod;
      1	  14740   gc->mm_table.data[mmid].tTextureMode   = texturemode;
      1	  14741   gc->mm_table.data[mmid].lod_bias       = int_lod_bias;
      1	  14742   gc->mm_table.data[mmid].lod_min        = small_lod;
      1	  14743   gc->mm_table.data[mmid].lod_max        = large_lod;
      1	  14744   gc->mm_table.data[mmid].tmu            = tmu;
      1	  14745   gc->mm_table.data[mmid].odd_even_mask  = odd_even_mask;
      1	  14746   gc->mm_table.data[mmid].tmu_base_address = baseAddress;
      1	  14747   gc->mm_table.data[mmid].trilinear      = trilinear;
      1	  14748   gc->mm_table.data[mmid].aspect_ratio   = aspect_ratio;
      1	  14749   gc->mm_table.data[mmid].data           = 0;
      1	  14750   /*   gc->mm_table.data[mmid].ncc_table      = 0; */
      1	  14751   gc->mm_table.data[mmid].sst            = _GlideRoot.current_sst;
      1	  14752   gc->mm_table.data[mmid].valid          = FXTRUE;
      1	  14753   gc->mm_table.data[mmid].width          = width;
      1	  14754   gc->mm_table.data[mmid].height         = height;
      1	  14755   
      1	  14756   GR_RETURN(mmid);
      1	  14757 } /* guTexAllocateMemory */
	  14758 
	  14759 static void
	  14760 _guTexRebuildRegisterShadows( GrMipMapId_t mmid )

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      1	  14761 {
      1	  14762   GR_DCL_GC;
      1	  14763   GrMipMapInfo *mminfo = &gc->mm_table.data[mmid];
      1	  14764   int texturemode      = 0;
      1	  14765   int tLod             = 0;
      1	  14766   FxU32 
      1	  14767     filterMode,                 /* filter mode bits of texturemode */
      1	  14768     clampMode;                  /* clamp mode bits of texturemode */
      1	  14769 
      1	  14770   /* build filterMode */
      1	  14771   filterMode = (
      1	  14772                 (mminfo->minfilter_mode == GR_TEXTUREFILTER_BILINEAR ? SST_TMINFILTER : 0) |
      1	  14773                 (mminfo->magfilter_mode == GR_TEXTUREFILTER_BILINEAR ? SST_TMAGFILTER : 0)
      1	  14774                 );
      1	  14775   clampMode = (
      1	  14776                (mminfo->s_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPS : 0) |
      1	  14777                (mminfo->t_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPT : 0)
      1	  14778                );
      1	  14779    
      1	  14780   /*
      1	  14781    ** build up tTextureMode
      1	  14782    */
      1	  14783   texturemode |= ( mminfo->format << SST_TFORMAT_SHIFT );
      1	  14784   texturemode |= SST_TCLAMPW;
      1	  14785   texturemode |= SST_TPERSP_ST;
      1	  14786   texturemode |= filterMode;
      1	  14787   texturemode |= clampMode;
      1	  14788 
      1	  14789   if ( mminfo->mipmap_mode == GR_MIPMAP_NEAREST_DITHER )
      1	  14790     texturemode |= SST_TLODDITHER;
      1	  14791 
      1	  14792   if ( mminfo->trilinear )
      1	  14793     texturemode |= SST_TRILINEAR;
      1	  14794 
      1	  14795   /*
      1	  14796    ** build up tLOD
      1	  14797    */
      1	  14798   tLod = mminfo->mipmap_mode == GR_MIPMAP_DISABLE ? mminfo->lod_max : mminfo->lod_min;
      1	  14799   tLod = SST_TLOD_MINMAX_INT(mminfo->lod_max,tLod);
      1	  14800   tLod |= _gr_evenOdd_xlate_table[mminfo->odd_even_mask];
      1	  14801   tLod |= _gr_aspect_xlate_table[mminfo->aspect_ratio];
      1	  14802   tLod |= mminfo->lod_bias << SST_LODBIAS_SHIFT;
      1	  14803 
      1	  14804   /*
      1	  14805    ** assign them
      1	  14806    */
      1	  14807   mminfo->tTextureMode = texturemode;
      1	  14808   mminfo->tLOD         = tLod;
      1	  14809 } /* guTexRebuildRegisterShadows */
	  14810 
	  14811 
	  14812 /*---------------------------------------------------------------------------
	  14813 **  guTexChangeAttributes 
	  14814 */
	  14815 GR_DIENTRY(guTexChangeAttributes, FxBool, ( GrMipMapId_t mmid,
	  14816                       int width, int height,
	  14817                       GrTextureFormat_t fmt,

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

	  14818                       GrMipMapMode_t mm_mode,
	  14819                       GrLOD_t smallest_lod, GrLOD_t largest_lod,
	  14820                       GrAspectRatio_t aspect,
	  14821                       GrTextureClampMode_t s_clamp_mode,
	  14822                       GrTextureClampMode_t t_clamp_mode,
	  14823                       GrTextureFilterMode_t minFilterMode,
	  14824                       GrTextureFilterMode_t magFilterMode
	  14825                       ))
      1	  14826 {
      1	  14827   GrMipMapInfo *mminfo;
      1	  14828 
      1	  14829   GR_BEGIN_NOFIFOCHECK("guTexChangeAttributes",88);
      1	  14830   GDBG_INFO_MORE(gc->myLevel,"(%d, %d,%d, %d,%d, %d,%d,%d, %d,%d, %d,%d)\n",
      1	  14831                 mmid,width,height,fmt,mm_mode,
      1	  14832                 smallest_lod,largest_lod,aspect,
      1	  14833                 s_clamp_mode,t_clamp_mode, minFilterMode,magFilterMode);
      1	  14834   /*
      1	  14835   ** Make sure that mmid is not NULL
      1	  14836   */
      2	  14837   if ( mmid == GR_NULL_MIPMAP_HANDLE ) {
      2	  14838     GR_RETURN(FXFALSE);
      1	  14839   }
      1	  14840 
      1	  14841   mminfo = &gc->mm_table.data[mmid];
      1	  14842 
      1	  14843   /*
      1	  14844   ** Fill in the mm_table data for this mip map
      1	  14845   */
      1	  14846   if ( fmt != -1 )
      1	  14847      mminfo->format         = fmt;
      1	  14848 
      1	  14849   if ( mm_mode != -1 )
      1	  14850      mminfo->mipmap_mode    = mm_mode;
      1	  14851 
      1	  14852   if ( smallest_lod != -1 )
      1	  14853      mminfo->lod_min        = smallest_lod;
      1	  14854   if ( largest_lod != -1 )
      1	  14855      mminfo->lod_max        = largest_lod;
      1	  14856   if ( minFilterMode != -1 )
      1	  14857      mminfo->minfilter_mode = minFilterMode;
      1	  14858   if ( magFilterMode != -1 )
      1	  14859      mminfo->magfilter_mode = magFilterMode;
      1	  14860   if ( s_clamp_mode != -1 )
      1	  14861      mminfo->s_clamp_mode   = s_clamp_mode;
      1	  14862   if ( t_clamp_mode != -1 )
      1	  14863      mminfo->t_clamp_mode   = t_clamp_mode;
      1	  14864   if ( aspect != -1 )
      1	  14865      mminfo->aspect_ratio   = aspect;
      1	  14866   if ( width != -1 )
      1	  14867      mminfo->width          = width;
      1	  14868   if ( height != -1 )
      1	  14869      mminfo->height         = height;
      1	  14870 
      1	  14871   _guTexRebuildRegisterShadows( mmid );
      1	  14872   GR_RETURN(FXTRUE);
      1	  14873 } /* guTexChangeAttributes */
	  14874 

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

	  14875 /*---------------------------------------------------------------------------
	  14876 ** grTexCombineFunction - obsolete
	  14877 **                              
	  14878 */
	  14879 GR_DIENTRY(grTexCombineFunction, void,
	  14880            (GrChipID_t tmu, GrTextureCombineFnc_t tc)) 
      1	  14881 {
      1	  14882   guTexCombineFunction( tmu, tc );
      1	  14883 }
	  14884 
	  14885 /*---------------------------------------------------------------------------
	  14886 ** guTexCombineFunction
	  14887 **                              
	  14888 ** Sets the texture combine function.  For a dual TMU system this function
	  14889 ** will configure the TEXTUREMODE registers as appropriate.  For a
	  14890 ** single TMU system this function will configure TEXTUREMODE if
	  14891 ** possible, or defer operations until grDrawTriangle() is called.
	  14892 */
	  14893 GR_DIENTRY(guTexCombineFunction, void,
	  14894            (GrChipID_t tmu, GrTextureCombineFnc_t tc))
      1	  14895 {
      1	  14896   GDBG_INFO(99,"guTexCombineFunction(%d,%d)\n",tmu,tc);
      2	  14897   switch ( tc )  {
      2	  14898   case GR_TEXTURECOMBINE_ZERO:
      2	  14899     grTexCombine( tmu, GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  14900                   GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE, FXFALSE, FXFALSE );
      2	  14901     break;
      2	  14902 
      2	  14903   case GR_TEXTURECOMBINE_DECAL:
      2	  14904     grTexCombine( tmu, GR_COMBINE_FUNCTION_LOCAL, GR_COMBINE_FACTOR_NONE,
      2	  14905                   GR_COMBINE_FUNCTION_LOCAL, GR_COMBINE_FACTOR_NONE, FXFALSE, FXFALSE );
      2	  14906     break;
      2	  14907 
      2	  14908   case GR_TEXTURECOMBINE_ONE:
      2	  14909     grTexCombine( tmu, GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  14910                   GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE, FXTRUE, FXTRUE );
      2	  14911     break;
      2	  14912 
      2	  14913   case GR_TEXTURECOMBINE_ADD:
      2	  14914     grTexCombine( tmu, GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL, GR_COMBINE_FACTOR_ONE,
      2	  14915                   GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL, GR_COMBINE_FACTOR_ONE, FXFALSE, FXFALSE );
      2	  14916     break;
      2	  14917 
      2	  14918   case GR_TEXTURECOMBINE_MULTIPLY:
      2	  14919     grTexCombine( tmu, GR_COMBINE_FUNCTION_SCALE_OTHER, GR_COMBINE_FACTOR_LOCAL,
      2	  14920                   GR_COMBINE_FUNCTION_SCALE_OTHER, GR_COMBINE_FACTOR_LOCAL, FXFALSE, FXFALSE );
      2	  14921     break;
      2	  14922 
      2	  14923   case GR_TEXTURECOMBINE_DETAIL:
      2	  14924     grTexCombine( tmu, GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_ONE_MINUS_DETAIL_FACTOR,
      2	  14925                   GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_ONE_MINUS_DETAIL_FACTOR, FXFALSE, FXFALSE );
      2	  14926     break;
      2	  14927 
      2	  14928   case GR_TEXTURECOMBINE_DETAIL_OTHER:
      2	  14929     grTexCombine( tmu, GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_DETAIL_FACTOR,
      2	  14930                   GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_DETAIL_FACTOR, FXFALSE, FXFALSE );
      2	  14931     break;

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      2	  14932 
      2	  14933   case GR_TEXTURECOMBINE_TRILINEAR_ODD:
      2	  14934     grTexCombine( tmu, GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION,
      2	  14935                   GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION, FXFALSE, FXFALSE );
      2	  14936     break;
      2	  14937 
      2	  14938   case GR_TEXTURECOMBINE_TRILINEAR_EVEN:
      2	  14939     grTexCombine( tmu, GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_LOD_FRACTION,
      2	  14940                   GR_COMBINE_FUNCTION_BLEND, GR_COMBINE_FACTOR_LOD_FRACTION, FXFALSE, FXFALSE );
      2	  14941     break;
      2	  14942 
      2	  14943   case GR_TEXTURECOMBINE_SUBTRACT:
      2	  14944     grTexCombine( tmu, GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL, GR_COMBINE_FACTOR_ONE,
      2	  14945                   GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL, GR_COMBINE_FACTOR_ONE, FXFALSE, FXFALSE );
      2	  14946     break;
      2	  14947 
      2	  14948   case GR_TEXTURECOMBINE_OTHER:
      2	  14949     grTexCombine( tmu, GR_COMBINE_FUNCTION_SCALE_OTHER, GR_COMBINE_FACTOR_ONE,
      2	  14950                   GR_COMBINE_FUNCTION_SCALE_OTHER, GR_COMBINE_FACTOR_ONE, FXFALSE, FXFALSE );
      2	  14951     break;
      2	  14952 
      2	  14953   default:
      2	  14954     GrErrorCallback( "guTexCombineFunction:  Unsupported function", FXTRUE );
      2	  14955     break;
      1	  14956   }
      1	  14957 } /* guTexCombineFunction */
	  14958 
	  14959 /*---------------------------------------------------------------------------
	  14960 ** guTexDownloadMipMap
	  14961 **
	  14962 ** Downloads a mip map (previously allocated with guTexAllocateMemory) to
	  14963 ** the hardware using the given data and ncctble.  The "data" is assumed
	  14964 ** to be in row major order from largest mip map to smallest mip map.
	  14965 */
	  14966 GR_DIENTRY(guTexDownloadMipMap, void, 
	  14967            (GrMipMapId_t mmid, const void *src, const GuNccTable
	  14968             *ncc_table ) )
      1	  14969 {
      1	  14970   GR_DCL_GC;
      1	  14971   GrLOD_t     lod;
      1	  14972   const void *ptr = src;
      1	  14973 
      1	  14974   GDBG_INFO(99,"guTexDownloadMipMap(%d,0x%x,0x%x)\n",mmid,src,ncc_table);
      1	  14975   GR_ASSERT(gc != NULL);
      1	  14976   GR_ASSERT(src != NULL);
      1	  14977   GR_CHECK_F("guTexDownloadMipMap",
      1	  14978               ( mmid == GR_NULL_MIPMAP_HANDLE ) || ( mmid >= gc->mm_table.free_mmid ),
      1	  14979               "invalid mip map handle passed");
      1	  14980 
      1X  14981 #if 0 /* Fixme!!! XXX ??? */
      1X  14982   GR_CHECK_F("guTexDownloadMipMap",
      1X  14983               gc->mm_table.data[mmid].format == GR_TEXFMT_P_8,
      1X  14984               "guTex* does not support palletted textures - use grTex* instead");
      1X  14985 #endif /* 0 */
      1	  14986 
      1	  14987   /*
      1	  14988   ** Bind data and ncc table to this mip map

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      1	  14989   */
      1	  14990   gc->mm_table.data[mmid].data      = (void *) ptr;
      1	  14991   if (gc->mm_table.data[mmid].format == GR_TEXFMT_YIQ_422)
      1	  14992     gc->mm_table.data[mmid].ncc_table = *ncc_table;
      1	  14993 
      1	  14994   /*
      1	  14995   ** Start downloading mip map levels, note that ptr is updated by the caller
      1	  14996   */
      2	  14997   for ( lod = gc->mm_table.data[mmid].lod_max; lod <= gc->mm_table.data[mmid].lod_min; lod++ ) {
      2	  14998      guTexDownloadMipMapLevel( mmid, lod, &ptr );
      1	  14999   }
      1	  15000 } /* guTexDownloadMipMap */
	  15001 
	  15002 /*---------------------------------------------------------------------------
	  15003 ** guTexDownloadMipMapLevel
	  15004 **
	  15005 ** Downloads a single mip map level to a mip map.  "src" is considered to be
	  15006 ** row major data of the correct aspect ratio and format.
	  15007 */
	  15008 GR_DIENTRY(guTexDownloadMipMapLevel, void,
	  15009            (GrMipMapId_t mmid, GrLOD_t lod,
	  15010             const void **src_base))
      1	  15011 {
      1	  15012   FxU32 i;
      1	  15013   const  GrMipMapInfo *mminfo;
      1	  15014   GR_DCL_GC;
      1	  15015  
      1	  15016   GDBG_INFO(99,"guTexDownloadMipMapLevel(%d,%d,0x%x)\n",mmid,lod,src_base);
      1	  15017   GR_ASSERT(src_base != NULL);
      1	  15018   mminfo = &gc->mm_table.data[mmid];
      1	  15019   GR_CHECK_F( "guTexDownloadMipMapLevel",
      1	  15020               ( lod > mminfo->lod_min ) || ( lod < mminfo->lod_max ),
      1	  15021               "specified lod is out of range");
      1	  15022 
      1	  15023   /* GMT: replace with array access */
      1	  15024   /* download this level */
      1	  15025   i = _grTexCalcBaseAddress( 0,
      1	  15026                             mminfo->lod_max,
      1	  15027                             mminfo->aspect_ratio,
      1	  15028                             mminfo->format,
      1	  15029                             mminfo->odd_even_mask);
      1	  15030   grTexDownloadMipMapLevel( mminfo->tmu,
      1	  15031                             mminfo->tmu_base_address - i,
      1	  15032                             lod,
      1	  15033                             mminfo->lod_max,
      1	  15034                             mminfo->aspect_ratio,
      1	  15035                             mminfo->format,
      1	  15036                             mminfo->odd_even_mask,
      1	  15037                             (void *)*src_base );
      1	  15038 
      1	  15039   /* update src_base to point to next mipmap level */
      1	  15040   *src_base = (void *) (((FxU32)*src_base) +
      1	  15041                (_grMipMapHostSize[_gr_aspect_index_table[mminfo->aspect_ratio]][lod]
      1	  15042                     << (mminfo->format>=GR_TEXFMT_16BIT)));
      1	  15043 
      1	  15044 } /* guTexDownloadMipmapLevel */
	  15045 

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

	  15046 /*---------------------------------------------------------------------------
	  15047 ** guTexGetCurrentMipMap
	  15048 */
	  15049 GR_DIENTRY(guTexGetCurrentMipMap, GrMipMapId_t, ( GrChipID_t tmu ))
      1	  15050 {
      1	  15051 #define FN_NAME "guTexGetCurrentMipMap"
      1	  15052   GR_BEGIN_NOFIFOCHECK("guTexGetCurrentMipMap",99);
      1	  15053   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",tmu);
      1	  15054   GR_CHECK_TMU(FN_NAME, tmu );
      1	  15055 
      1	  15056   GR_RETURN(gc->state.current_mm[tmu]);
      1	  15057 #undef FN_NAME
      1	  15058 } /* guTexGetCurrentMipMap */
	  15059 
	  15060 /*---------------------------------------------------------------------------
	  15061 ** guTexGetMipMapInfo
	  15062 */
	  15063 GR_DIENTRY(guTexGetMipMapInfo, GrMipMapInfo *, ( GrMipMapId_t mmid ))
      1	  15064 {
      1	  15065   GR_BEGIN_NOFIFOCHECK("guTexGetMipMapInfo",99);
      1	  15066   GDBG_INFO_MORE(gc->myLevel,"(%d) => 0x%x\n",mmid,&gc->mm_table.data[mmid]);
      1	  15067   return &( gc->mm_table.data[mmid] );
      1	  15068 } /* guTexGetMipMapInfo */
	  15069 
	  15070 /*---------------------------------------------------------------------------
	  15071 ** guTexMemQueryAvail
	  15072 **
	  15073 ** returns the amount of available texture memory on a specified TMU.
	  15074 */
	  15075 GR_DIENTRY(guTexMemQueryAvail, FxU32, ( GrChipID_t tmu ))
      1	  15076 {
      1	  15077 #define FN_NAME "guTexMemQueryAvail"
      1	  15078   GR_BEGIN_NOFIFOCHECK("guTexMemQueryAvail",99);
      1	  15079   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",tmu);
      1	  15080   GR_CHECK_TMU(FN_NAME, tmu );
      1	  15081   GR_RETURN(gc->tmu_state[tmu].total_mem - gc->tmu_state[tmu].freemem_base);
      1	  15082 #undef FN_NAME
      1	  15083 } /* guTexQueryMemAvail */
	  15084 
	  15085 /*---------------------------------------------------------------------------
	  15086 ** guTexMemReset
	  15087 **
	  15088 ** Clears out texture buffer memory.
	  15089 */
	  15090 GR_DIENTRY(guTexMemReset, void, ( void ))
      1	  15091 {
      1	  15092   int i;
      1	  15093   
      1	  15094   GR_BEGIN_NOFIFOCHECK("guTexMemReset",99);
      1	  15095   GDBG_INFO_MORE(gc->myLevel,"()\n");
      1	  15096 
      1	  15097   memset( gc->mm_table.data, 0, sizeof( gc->mm_table.data ) );
      1	  15098   gc->mm_table.free_mmid = 0;
      1	  15099   
      2	  15100   for ( i = 0; i < gc->num_tmu; i++ ) {
      2	  15101     gc->state.current_mm[i] = (GrMipMapId_t) GR_NULL_MIPMAP_HANDLE;
      2	  15102     gc->tmu_state[i].freemem_base = 0;

DIGUTEX                         Source Listing                   9-MAY-2021 23:42:44  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  digutex.c;1

      2	  15103     gc->tmu_state[i].ncc_mmids[0] = 
      2	  15104       gc->tmu_state[i].ncc_mmids[1] = GR_NULL_MIPMAP_HANDLE;    
      2	  15105     gc->tmu_state[i].ncc_table[0] = 
      2	  15106       gc->tmu_state[i].ncc_table[1] = 0;
      1	  15107   }
      1	  15108   GR_END();
      1	  15109 } /* guTexMemReset */
	  15110 


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DIGUTEX/OBJECT=[
.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DIGUTEX.OBJ/INCLUDE_DIRECTORY=([.GLI
DE.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.
GLIDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_
TRISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLID
E_LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]DIGUTEX.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:44"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


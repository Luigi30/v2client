UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Utility routines for SST-1 Initialization code
	     21 **
	     22 */
	     23 
	     24 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
	     25 
       X     26 #ifdef _MSC_VER
       X     27 #pragma optimize ("",off)
       X     28 #endif
	     29 #include <stdio.h>
	   1640 #include <stdlib.h>
	   3735 #include <math.h>
       X   4627 #ifdef BUILD_FOR_SST1
       X   4628 #include <sst.h>
       X   4629 #else
	   4630 #include <3dfx.h>
	   4761 #include <cvgregs.h>
	   4989 #include <cvgdefs.h>
	   5930 #endif
	   5931 #define FX_DLL_DEFINITION
	   5932 #include <fxdll.h>
	   6053 #include <sst1vid.h>
	   6163 #include <sst1init.h>
	   8801 
	   8802 #include "canopus.h"
	   8842 
	   8843 /*
	   8844 ** sst1InitIdle():
	   8845 **  Return idle condition of SST-1
	   8846 **
	   8847 **    Returns:
	   8848 **      FXTRUE if SST-1 is idle (fifos are empty, graphics engines are idle)
	   8849 **      FXFALSE if SST-1 has not been mapped
	   8850 **
	   8851 */
	   8852 FX_EXPORT FxBool FX_CSTYLE sst1InitIdle(FxU32 *sstbase)
      1	   8853 {
      1	   8854     if(!sstbase)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   8855         return(FXFALSE);
      1	   8856 
      1	   8857     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8858         return(FXFALSE);
      1	   8859 
      1	   8860     if(!initIdleEnabled)
      1	   8861         return(FXTRUE);
      1	   8862 
      2	   8863     if(sst1CurrentBoard->fbiLfbLocked) {
      2	   8864         if(sst1CurrentBoard->sliSlaveVirtAddr == (FxU32 *) NULL)
      2	   8865             // SLI not enabled...
      2	   8866             sst1InitPciFifoIdleLoop(sstbase);
      3	   8867         else {
      3	   8868             // Check idle for Master...
      3	   8869             sst1InitPciFifoIdleLoop(sstbase);
      3	   8870             // Check idle for Slave...
      3	   8871             sst1InitPciFifoIdleLoop(sst1CurrentBoard->sliSlaveVirtAddr);
      2	   8872         }
      2	   8873     } else {
      2	   8874         if(sst1CurrentBoard->sliSlaveVirtAddr == (FxU32 *) NULL)
      2	   8875             // SLI not enabled...
      2	   8876             sst1InitIdleLoop(sstbase, FXTRUE);
      3	   8877         else {
      3	   8878             // Check idle for Master...
      3	   8879             sst1InitIdleLoop(sstbase, FXTRUE);
      3	   8880 
      3	   8881             // Check idle for Slave...
      3	   8882             // Note that the Slave does not need another NOP command, because
      3	   8883             // it will snoop the NOP command sent to the Master above.
      3	   8884             // Sending a NOP command to the Slave also confuses the callback
      3	   8885             // write routines for the command fifo which are not setup to
      3	   8886             // handle any other base addresses other than the Master's...
      3	   8887             sst1InitIdleLoop(sst1CurrentBoard->sliSlaveVirtAddr, FXFALSE);
      2	   8888         }
      1	   8889     }
      1	   8890     return(FXTRUE);
      1	   8891 }
	   8892 
	   8893 static FxBool
	   8894 sst1InitIdleWithTimeoutLoop(FxU32 *sstbase, FxBool issueNOP, FxU32 timeout)
      1	   8895 {
      1	   8896   FxU32 cntr, loop;
      1	   8897   SstRegs *sst = (SstRegs *) sstbase;
      1	   8898   
      1	   8899   if(issueNOP) ISET(sst->nopCMD, 0x0);
      1	   8900 
      1	   8901   cntr = loop = 0;
      2	   8902   while(++loop < timeout) {
      3	   8903     if(!(sst1InitReturnStatus(sstbase) & SST_BUSY)) {
      3	   8904       if(++cntr >= 3)
      3	   8905         break;
      2	   8906     } else
      2	   8907       cntr = 0;
      1	   8908   }
      1	   8909 
      1	   8910   return (loop < timeout);
      1	   8911 }

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

	   8912 
	   8913 FxBool 
	   8914 sst1InitIdleFBIWithTimeout(FxU32 *sstbase, FxBool issueNop, FxU32 timeout)
      1	   8915 {
      1	   8916   int retVal;
      1	   8917   
      1	   8918   if(!sstbase)
      1	   8919     return(FXFALSE);
      1	   8920   
      1	   8921   if(!sst1InitCheckBoard(sstbase))
      1	   8922     return(FXFALSE);
      1	   8923   
      2	   8924   if(sst1CurrentBoard->sliSlaveVirtAddr == (FxU32 *) NULL) {
      2	   8925     // SLI not enabled...
      2	   8926     retVal = sst1InitIdleWithTimeoutLoop(sstbase, issueNop, timeout);
      2	   8927   } else {
      2	   8928     // Check idle for Master...
      2	   8929     if(!sst1InitIdleWithTimeoutLoop(sstbase, issueNop, timeout))
      2	   8930       return(FXFALSE);
      2	   8931     
      2	   8932     // Check idle for Slave...
      2	   8933     // Note that the Slave does not need another NOP command, because
      2	   8934     // it will snoop the NOP command sent to the Master above.
      2	   8935     // Sending a NOP command to the Slave also confuses the callback
      2	   8936     // write routines for the command fifo which are not setup to
      2	   8937     // handle any other base addresses other than the Master's...
      2	   8938     retVal = sst1InitIdleWithTimeoutLoop(sst1CurrentBoard->sliSlaveVirtAddr,
      2	   8939                                          FXFALSE, 
      2	   8940                                          timeout);
      1	   8941   }
      1	   8942   
      1	   8943   return retVal;
      1	   8944 }
	   8945 
	   8946 FX_EXPORT FxBool FX_CSTYLE sst1InitIdleNoNOP(FxU32 *sstbase)
      1	   8947 {
      1	   8948     if(!sstbase)
      1	   8949         return(FXFALSE);
      1	   8950 
      1	   8951     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8952         return(FXFALSE);
      1	   8953 
      1	   8954     if(!initIdleEnabled)
      1	   8955         return(FXTRUE);
      1	   8956 
      2	   8957     if(sst1CurrentBoard->fbiLfbLocked) {
      2	   8958         if(sst1CurrentBoard->sliSlaveVirtAddr == (FxU32 *) NULL)
      2	   8959             // SLI not enabled...
      2	   8960             sst1InitPciFifoIdleLoop(sstbase);
      3	   8961         else {
      3	   8962             // Check idle for Master...
      3	   8963             sst1InitPciFifoIdleLoop(sstbase);
      3	   8964             // Check idle for Slave...
      3	   8965             sst1InitPciFifoIdleLoop(sst1CurrentBoard->sliSlaveVirtAddr);
      2	   8966         }
      2	   8967     } else {
      2	   8968         if(sst1CurrentBoard->sliSlaveVirtAddr == (FxU32 *) NULL)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      2	   8969             // SLI not enabled...
      2	   8970             sst1InitIdleLoop(sstbase, FXFALSE);
      3	   8971         else {
      3	   8972             // Check idle for Master...
      3	   8973             sst1InitIdleLoop(sstbase, FXFALSE);
      3	   8974             // Check idle for Slave...
      3	   8975             sst1InitIdleLoop(sst1CurrentBoard->sliSlaveVirtAddr, FXFALSE);
      2	   8976         }
      1	   8977     }
      1	   8978     return(FXTRUE);
      1	   8979 }
	   8980 
	   8981 void sst1InitIdleLoop(FxU32 *sstbase, FxBool issueNOP)
      1	   8982 {
      1	   8983     FxU32 cntr;
      1	   8984     SstRegs *sst = (SstRegs *) sstbase;
      1	   8985 
      1	   8986     if(issueNOP)
      1	   8987         ISET(sst->nopCMD, 0x0);
      1	   8988 
      1	   8989     cntr = 0;
      2	   8990     while(1) {
      3	   8991         if(!(sst1InitReturnStatus(sstbase) & SST_BUSY)) {
      3	   8992             if(++cntr >= 3)
      3	   8993                 break;
      2	   8994         } else
      2	   8995             cntr = 0;
      1	   8996     }
      1	   8997 }
	   8998 
	   8999 void sst1InitPciFifoIdleLoop(FxU32 *sstbase)
      1	   9000 {
      1	   9001     FxU32 cntr;
      1	   9002 
      1	   9003     cntr = 0;
      2	   9004     while(1) {
      3	   9005         if(((sst1InitReturnStatus(sstbase) & SST_FIFOLEVEL)) == 0x3f) {
      3	   9006             // Since sst1InitPciFifoIdleLoop is only called when we're trying
      3	   9007             // to "fake" idle during lfb locks, wait for 6 passes to give the
      3	   9008             // hardware time to drain
      3	   9009             if(++cntr >= 6)
      3	   9010                 break;
      2	   9011         } else
      2	   9012             cntr = 0;
      1	   9013     }
      1	   9014 }
	   9015 
	   9016 /*
	   9017 ** sst1InitIdleFBI():
	   9018 **  Return idle condition of FBI (ignoring idle status of TMU)
	   9019 **
	   9020 **    Returns:
	   9021 **      FXTRUE if FBI is idle (fifos are empty, graphics engines are idle)
	   9022 **      FXFALSE if FBI has not been mapped
	   9023 **
	   9024 */
	   9025 FX_EXPORT FxBool FX_CSTYLE sst1InitIdleFBI(FxU32 *sstbase)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9026 {
      1	   9027     FxU32 cntr;
      1	   9028     SstRegs *sst = (SstRegs *) sstbase;
      1	   9029 
      1	   9030     if(!sst)
      1	   9031         return(FXFALSE);
      1	   9032 
      1	   9033     ISET(sst->nopCMD, 0x0);
      1	   9034     cntr = 0;
      2	   9035     while(1) {
      3	   9036         if(!(sst1InitReturnStatus(sstbase) & SST_FBI_BUSY)) {
      3	   9037             if(++cntr >= 3)
      3	   9038                 break;
      2	   9039         } else
      2	   9040             cntr = 0;
      1	   9041     }
      1	   9042     return(FXTRUE);
      1	   9043 }
	   9044 
	   9045 /*
	   9046 ** sst1InitIdleFBINoNOP():
	   9047 **  Return idle condition of FBI (ignoring idle status of TMU)
	   9048 **  sst1InitIdleFBINoNOP() differs from sst1InitIdleFBI() in that no NOP command
	   9049 **  is issued to flush the graphics pipeline.
	   9050 **
	   9051 **    Returns:
	   9052 **      FXTRUE if FBI is idle (fifos are empty, graphics engines are idle)
	   9053 **      FXFALSE if FBI has not been mapped
	   9054 **
	   9055 */
	   9056 FX_EXPORT FxBool FX_CSTYLE sst1InitIdleFBINoNOP(FxU32 *sstbase)
      1	   9057 {
      1	   9058     FxU32 cntr;
      1	   9059     SstRegs *sst = (SstRegs *) sstbase;
      1	   9060 
      1	   9061     if(!sst)
      1	   9062         return(FXFALSE);
      1	   9063 
      1	   9064     // ISET(sst->nopCMD, 0x0);
      1	   9065     cntr = 0;
      2	   9066     while(1) {
      3	   9067         if(!(sst1InitReturnStatus(sstbase) & SST_FBI_BUSY)) {
      3	   9068             if(++cntr > 5)
      3	   9069                 break;
      2	   9070         } else
      2	   9071             cntr = 0;
      1	   9072     }
      1	   9073     return(FXTRUE);
      1	   9074 }
	   9075 
	   9076 // Included so compiler doesn't optimize out loop code waiting on status bits
	   9077 FX_EXPORT FxU32 FX_CSTYLE sst1InitReturnStatus(FxU32 *sstbase)
      1	   9078 {
      1	   9079     SstRegs *sst = (SstRegs *) sstbase;
      1	   9080 
      1	   9081     return(IGET(sst->status));
      1	   9082 }

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

	   9083 
	   9084 
	   9085 /*
	   9086 ** sst1InitClearSwapPending():
	   9087 **  Clear any swaps pending in the status register
	   9088 **  NOTE: The video unit of FBI must be initialized before calling this routine
	   9089 **
	   9090 **    Returns:
	   9091 **      FXTRUE
	   9092 **
	   9093 */
	   9094 FX_ENTRY FxBool FX_CALL sst1InitClearSwapPending(FxU32 *sstbase)
      1	   9095 {
      1	   9096     SstRegs *sst = (SstRegs *) sstbase;
      1	   9097     FxU32 displayedBuffer, i;
      1	   9098 
      1	   9099     INIT_PRINTF(("sst1InitClearSwapPending() WARNING: Clearing pending swapbufferCMDs...\n"));
      1	   9100 
      1	   9101     sst1InitIdle(sstbase);
      1	   9102     displayedBuffer =
      1	   9103         (IGET(sst->status) & SST_DISPLAYED_BUFFER) >>
      1	   9104           SST_DISPLAYED_BUFFER_SHIFT;
      1	   9105 
      1	   9106     // Wait until vsync is inactive to guarantee that swaps queue in the
      1	   9107     // PCI fifo properly
      1	   9108     while(!(IGET(sst->status) & SST_VRETRACE) ||
      1	   9109       ((IGET(sst->vRetrace) & 0xfff) > 100) || ((IGET(sst->vRetrace) & 0xfff)
      1	   9110         < 10))
      1	   9111         ;
      1	   9112 
      1	   9113     // First swap syncs to Vsync...Subsequent ones do not...
      1	   9114     ISET(sst->swapbufferCMD, 0x1);
      1	   9115     ISET(sst->nopCMD, 0x0);
      2	   9116     for(i=0; i<17; i++) {
      2	   9117         ISET(sst->swapbufferCMD, 0x0);
      2	   9118         ISET(sst->nopCMD, 0x0);
      1	   9119     }
      2	   9120     if(displayedBuffer) {
      2	   9121         ISET(sst->swapbufferCMD, 0x0);
      2	   9122         ISET(sst->nopCMD, 0x0);
      1	   9123     }
      1	   9124     sst1InitIdle(sstbase);
      1	   9125 
      1	   9126     return(FXTRUE);
      1	   9127 }
	   9128 
	   9129 /*
	   9130 ** sst1InitVgaPassCtrl():
	   9131 **  Control VGA passthrough setting
	   9132 **
	   9133 **
	   9134 */
	   9135 FX_EXPORT FxBool FX_CSTYLE sst1InitVgaPassCtrl(FxU32 *sstbase, FxU32 enable)
      1	   9136 {
      1	   9137     SstRegs *sst = (SstRegs *) sstbase;
      1	   9138 
      1	   9139     if(sst1InitCheckBoard(sstbase) == FXFALSE)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9140         return(FXFALSE);
      1	   9141 
      1	   9142     //if (sst1CurrentBoard->singleBrdSLISlave) {
      1	   9143     //  enable = 1;
      1	   9144     //}
      1	   9145 
      2	   9146     if(enable) {
      2	   9147         // VGA controls monitor
      2	   9148         ISET(sst->fbiInit0, (IGET(sst->fbiInit0) & ~SST_EN_VGA_PASSTHRU) | 
      2	   9149             sst1CurrentBoard->vgaPassthruEnable);
      2	   9150         ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_BLANK_EN);
      2	   9151     } else {
      2	   9152         // SST-1 controls monitor
      2	   9153         ISET(sst->fbiInit0, (IGET(sst->fbiInit0) & ~SST_EN_VGA_PASSTHRU) | 
      2	   9154             sst1CurrentBoard->vgaPassthruDisable);
      2	   9155         ISET(sst->fbiInit1, IGET(sst->fbiInit1) & ~SST_VIDEO_BLANK_EN);
      1	   9156     }
      1	   9157 
      1	   9158     return(FXTRUE);
      1	   9159 }
	   9160 
	   9161 /*
	   9162 ** sst1InitResetTmus():
	   9163 **  Reset TMUs
	   9164 **
	   9165 */
	   9166 FX_EXPORT FxBool FX_CSTYLE sst1InitResetTmus(FxU32 *sstbase)
      1	   9167 {
      1	   9168   volatile int delay;
      1	   9169   SstRegs *sst = (SstRegs *) sstbase;
      1	   9170   FxU32 allowTexturing = (GETENV(("SSTV2_TEXMAP_DISABLE"))) ? 0 : 1;
      1	   9171 
      1	   9172   if(!sst)
      1	   9173       return(FXFALSE);
      1	   9174 
      1	   9175   if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9176       return(FXFALSE);
      1	   9177 
      1	   9178   // Ignore stalls on FT Bus
      1	   9179   ISET(sst->fbiInit3, IGET(sst->fbiInit3) | SST_TEXMAP_DISABLE);
      1	   9180   // Delay
      1	   9181   for(delay=0;delay<10000;)
      1	   9182     delay++;
      1	   9183 
      1	   9184 //   while(++cntr < 6) {
      1	   9185 
      1	   9186     INIT_PRINTF(("sst1InitResetTmus(): Reset Graphics "));
      1	   9187 
      1	   9188     do
      2	   9189     {
      2	   9190       INIT_PRINTF(("."));
      2	   9191 
      2	   9192       // Set Default initialization values for all TMUs...
      2	   9193       ISET(SST_TREX(sst,0)->trexInit0, sst1CurrentBoard->tmuInit0[0]);
      2	   9194       ISET(SST_TREX(sst,1)->trexInit0, sst1CurrentBoard->tmuInit0[1]);
      2	   9195       // Delay
      2	   9196       for(delay=0;delay<10000;)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      2	   9197         delay++;
      2	   9198 
      2	   9199       ISET(SST_TREX(sst,0)->trexInit1, sst1CurrentBoard->tmuInit1[0]);
      2	   9200       ISET(SST_TREX(sst,1)->trexInit1, sst1CurrentBoard->tmuInit1[1]);
      2	   9201       // Delay
      2	   9202       for(delay=0;delay<10000;)
      2	   9203         delay++;
      2	   9204 
      2	   9205       // Reset TMU FIFOs and graphics core for all TMUs...
      2	   9206       ISET(SST_TREX(sst,0)->trexInit1, sst1CurrentBoard->tmuInit1[0] | SST_TEX_RESET_FIFO | SST_TEX_RESET_GRX);
      2	   9207       ISET(SST_TREX(sst,1)->trexInit1, sst1CurrentBoard->tmuInit1[1] | SST_TEX_RESET_FIFO | SST_TEX_RESET_GRX);
      2	   9208       // Delay
      2	   9209       for(delay=0;delay<10000;)
      2	   9210         delay++;
      2	   9211 
      2	   9212       ISET(SST_TREX(sst,1)->trexInit1, sst1CurrentBoard->tmuInit1[1]);
      2	   9213 
      2	   9214       // Allow unreset to propagate backwards...
      2	   9215       // Delay
      2	   9216       for(delay=0;delay<10000;)
      2	   9217         delay++;
      2	   9218 
      2	   9219       ISET(SST_TREX(sst,0)->trexInit1, sst1CurrentBoard->tmuInit1[0]);
      2	   9220       // Delay
      2	   9221       for(delay=0;delay<10000;)
      2	   9222         delay++;
      2	   9223 
      2	   9224       // Reset in the downstream TMU may cause glitches in FBI's TF FIFO
      2	   9225       // Waiting for Idle in FBI will not stall on something in the TF FIFO,
      2	   9226       // as the TF FIFO empty signal is not part of FBI's "busy" bit
      2	   9227 //      sst1InitIdleFBIWithTimeout(sstbase, FXTRUE, 100000);
      2	   9228       sst1InitResetFbi(sstbase);
      2	   9229 /*
      2	   9230       fbiInit0 = IGET(sst->fbiInit0) | SST_GRX_RESET | SST_PCI_FIFO_RESET;
      2	   9231 
      2	   9232       ISET(sst->fbiInit0, fbiInit0);
      2	   9233       // Delay
      2	   9234       for(delay=0;delay<10000;)
      2	   9235         delay++;
      2	   9236 
      2	   9237       fbiInit0 &= ~SST_PCI_FIFO_RESET;
      2	   9238       ISET(sst->fbiInit0, fbiInit0);
      2	   9239       // Delay
      2	   9240       for(delay=0;delay<10000;)
      2	   9241         delay++;                 
      2	   9242 
      2	   9243       fbiInit0 &= ~SST_GRX_RESET;
      2	   9244       ISET(sst->fbiInit0, fbiInit0);
      2	   9245       // Delay
      2	   9246       for(delay=0;delay<10000;)
      2	   9247         delay++;
      2	   9248 */
      2	   9249 
      2	   9250       if(allowTexturing)
      3	   9251       {
      3	   9252         ISET(sst->fbiInit3, IGET(sst->fbiInit3) & ~SST_TEXMAP_DISABLE);
      3	   9253         for(delay=0;delay<10000;)

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      3	   9254           delay++;
      2	   9255       }
      2	   9256 
      2	   9257       delay = 0;
      2	   9258 
      2	   9259       while( sst1InitReturnStatus(sstbase) & (SST_TMU_BUSY | SST_FBI_BUSY) && (delay < 50000) )
      2	   9260         delay++;
      2	   9261 
      1	   9262     }while( delay == 50000 );
      1	   9263 
      1	   9264     INIT_PRINTF(("\n"));
      1	   9265         
      1	   9266 //         INIT_PRINTF(("sst1InitResetTmus(): Could not reset graphics (0x%08lx)\n", ret));
      1	   9267 //      else
      1	   9268 //         break;
      1	   9269 //   }
      1	   9270 //   if(cntr == 6) {
      1	   9271 //       INIT_PRINTF(("sst1InitResetTmus(): Could not reset TMUs...\n"));
      1	   9272 //       return(FXFALSE);
      1	   9273 //   }
      1	   9274 
      1	   9275    // Fix problem where first Texture downloads to TMU weren't being
      1	   9276    //  received properly
      1	   9277    ISET(*(long *) (0xf00000 + (long) sstbase), 0xdeadbeef);
      1	   9278    sst1InitIdle(sstbase);
      1	   9279 
      1	   9280    return(FXTRUE);
      1	   9281 }
	   9282 
	   9283 /*
	   9284 ** sst1InitResetFbi():
	   9285 **  Reset FBI graphics engine and frontend PCI Fifo...
	   9286 **
	   9287 */
	   9288 FX_EXPORT FxBool FX_CSTYLE sst1InitResetFbi(FxU32 *sstbase)
      1	   9289 {
      1	   9290   volatile int delay;
      1	   9291 //  int i;
      1	   9292   FxU32 fbiInit0;
      1	   9293   SstRegs *sst = (SstRegs *) sstbase;
      1	   9294 /*
      1	   9295   for(i=0;i<20000;i++) sst1InitReturnStatus(sstbase);
      1	   9296   ISET(sst->fbiInit0, IGET(sst->fbiInit0) | SST_GRX_RESET | SST_PCI_FIFO_RESET);
      1	   9297   for(i=0;i<20000;i++) sst1InitReturnStatus(sstbase);
      1	   9298   ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      1	   9299   for(i=0;i<20000;i++) sst1InitReturnStatus(sstbase);
      1	   9300   ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      1	   9301   for(i=0;i<20000;i++) sst1InitReturnStatus(sstbase);
      1	   9302 */
      1	   9303   fbiInit0 = IGET(sst->fbiInit0) | SST_GRX_RESET | SST_PCI_FIFO_RESET;
      1	   9304 
      1	   9305   ISET(sst->fbiInit0, fbiInit0);
      1	   9306   // Delay
      1	   9307   for(delay=0;delay<10000;)
      1	   9308     delay++;
      1	   9309 
      1	   9310   fbiInit0 &= ~SST_PCI_FIFO_RESET;

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9311   ISET(sst->fbiInit0, fbiInit0);
      1	   9312   // Delay
      1	   9313   for(delay=0;delay<10000;)
      1	   9314     delay++;                 
      1	   9315 
      1	   9316   fbiInit0 &= ~SST_GRX_RESET;
      1	   9317   ISET(sst->fbiInit0, fbiInit0);
      1	   9318   // Delay
      1	   9319   for(delay=0;delay<10000;)
      1	   9320     delay++;
      1	   9321 
      1	   9322   return(FXTRUE);
      1	   9323 }
	   9324 
       X   9325 #if SET_BSWAP
       X   9326 #if __POWERPC__ && defined(__MWERKS__)
       X   9327 #define GET(s)       __lwbrx(s, 0 )
       X   9328 #define SET(d, s)    __stwbrx((s), (d), 0);
       X   9329 #else /* !__MWERKS__ */
       X   9330 #error "Define byte swapped macros for GET/SET"
       X   9331 #endif /* !__MWERKS__ */
       X   9332 #else /* !SET_BSWAP */
       X   9333 #ifdef GET
       X   9334 #undef GET
       X   9335 #endif
       X   9336 #ifdef SET
       X   9337 #undef SET
       X   9338 #endif
	   9339 #define GET(s)       (*s)
	   9340 #define SET(d, s)    ((*d) = s)
	   9341 #endif /* !SET_BSWAP */
	   9342 
	   9343 /*
	   9344 ** sst1InitWrite32():
	   9345 **  Write 32-bit Word to specified address
	   9346 **
	   9347 */
	   9348 FX_EXPORT void FX_CSTYLE sst1InitWrite32(FxU32 *addr, FxU32 data)
      1	   9349 {
      1	   9350   /* If the client software is using the command fifo then they are
      1	   9351    * responsible for passing a callback that can be used to put
      1	   9352    * register writes from the init code into the command fifo that
      1	   9353    * they are managing. However, some registers cannot be accessed via
      1	   9354    * the command fifo, and, inconveniently, these are not contiguously
      1	   9355    * allocated.  
      1	   9356    */
      1	   9357   const FxU32 addrOffset = ((const FxU32)addr - (const FxU32)sst1CurrentBoard->virtAddr[0]);
      1	   9358   FxBool directWriteP = ((sst1CurrentBoard == NULL) ||
      1	   9359                          (sst1CurrentBoard->set32 == NULL) ||
      1	   9360                          sst1CurrentBoard->fbiLfbLocked ||
      1	   9361                          (addrOffset == 0x004) ||                            /* intrCtrl */
      1	   9362                          ((addrOffset >= 0x1E0) && (addrOffset <= 0x200)) || /* cmdFifoBase ... fbiInit4 */
      1	   9363                          ((addrOffset >= 0x208) && (addrOffset <= 0x224)) || /* backPorch ... vSync */
      1	   9364                          ((addrOffset >= 0x22C) && (addrOffset <= 0x23C)) || /* dacData ... borderColor */
      1	   9365                          ((addrOffset >= 0x244) && (addrOffset <= 0x24C)));  /* fbiInit5 ... fbiInit7 */
      1	   9366 
      2	   9367   if (directWriteP) {

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      2	   9368     P6FENCE;
      2	   9369     SET(addr, data);
      2	   9370     P6FENCE;
      2	   9371   } else {
      2	   9372     (*sst1CurrentBoard->set32)(addr, data);
      1	   9373   }
      1	   9374 }
	   9375 
	   9376 /*
	   9377 ** sst1InitRead32():
	   9378 **  Read 32-bit Word from specified address
	   9379 **
	   9380 */
	   9381 FX_EXPORT FxU32 FX_CSTYLE sst1InitRead32(FxU32 *addr)
      1	   9382 {
      1	   9383     P6FENCE;
      1	   9384     return GET(addr);
      1	   9385 }
	   9386 
	   9387 /*
	   9388 **
	   9389 ** sst1InitCmdFifo():
	   9390 
	   9391 **   Setup Command Fifo.
	   9392 **
	   9393 **   The 'enable' parameter either enables or disables the Command Fifo.
	   9394 **
	   9395 **   Upon return, the 'virtAddrStart' parameter is filled with the starting
	   9396 **   virtual address where command fifo packets should be stored.  The
	   9397 **   'memAddrStart' parameter is filled with the address of where the command
	   9398 **   fifo is stored in frame buffer memory.  The 'memAddrStart' value is often
	   9399 **   used by the JMP command to jump to the beginning of the command fifo.
	   9400 **   The 'size' parameter is filled with the size of the command fifo.
	   9401 **   The values of 'virtAddrstart', 'memAddrStart' and 'size'
	   9402 **   are dependent on the amount of frame buffer memory detected as well as the
	   9403 **   video resolution setup by sst1InitVideo().  'virtAddrstart',
	   9404 **   'memAddrStart' and 'size' are all specified in bytes.
	   9405 **
	   9406 */
	   9407 FX_ENTRY FxBool FX_CALL sst1InitCmdFifo(FxU32 *sstbase, FxBool enable, 
	   9408   FxU32 *virtAddrStart, FxU32 *memAddrStart, FxU32 *size, FxSet32Proc set32Proc)
      1	   9409 {
      1	   9410     SstRegs *sst = (SstRegs *) sstbase;
      1	   9411     FxU32 fbiInit, fifoStart, fifoSize;
      1	   9412     FxBool directExec = (GETENV(("SSTV2_CMDFIFO_DIRECT"))) ? FXTRUE : FXFALSE;
      1	   9413     FxBool disableHoles = (GETENV(("SSTV2_CMDFIFO_NOHOLES"))) ? FXTRUE : FXFALSE;
      1	   9414 
      1	   9415     if(!sst)
      1	   9416         return(FXFALSE);
      1	   9417 
      1	   9418     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9419         return(FXFALSE);
      1	   9420 
      1	   9421     if(sst1CurrentBoard->fbiCmdFifoEn || (IGET(sst->fbiInit7) & SST_EN_CMDFIFO))
      1	   9422         sst1InitIdleNoNOP(sstbase);
      1	   9423     else
      1	   9424         sst1InitIdle(sstbase);

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9425 
      2	   9426     if(enable == FXFALSE) {
      2	   9427        // Remove any client set callbacks before continuing since
      2	   9428        // these must go straight to the hw.  
      2	   9429        sst1CurrentBoard->set32 = NULL;
      2	   9430        sst1CurrentBoard->fbiCmdFifoEn = 0;
      2	   9431 
      2	   9432        // Disable Command Fifo
      2	   9433        INIT_PRINTF(("sst1InitCmdFifo(): Disabling Command Fifo...\n"));
      2	   9434        ISET(sst->fbiInit7, IGET(sst->fbiInit7) & ~SST_EN_CMDFIFO);
      2	   9435 
      2	   9436        // Reset graphics core to force disable to take effect...
      2	   9437        ISET(sst->fbiInit0, IGET(sst->fbiInit0) | SST_GRX_RESET |
      2	   9438          SST_EN_LFB_MEMFIFO | SST_EN_TEX_MEMFIFO);
      2	   9439        sst1InitReturnStatus(sstbase);
      2	   9440        sst1InitReturnStatus(sstbase);
      2	   9441        sst1InitReturnStatus(sstbase);
      2	   9442        ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      2	   9443 
      3	   9444        if(sst1CurrentBoard->sliSlaveVirtAddr) {
      3	   9445           SstRegs *slaveSst = (SstRegs *) sst1CurrentBoard->sliSlaveVirtAddr;
      3	   9446 
      3	   9447           ISET(slaveSst->fbiInit7, IGET(slaveSst->fbiInit7) & ~SST_EN_CMDFIFO);
      3	   9448           // Reset graphics core to force disable to take effect...
      3	   9449           ISET(slaveSst->fbiInit0, IGET(slaveSst->fbiInit0) | SST_GRX_RESET |
      3	   9450             SST_EN_LFB_MEMFIFO | SST_EN_TEX_MEMFIFO);
      3	   9451           sst1InitReturnStatus(sst1CurrentBoard->sliSlaveVirtAddr);
      3	   9452           sst1InitReturnStatus(sst1CurrentBoard->sliSlaveVirtAddr);
      3	   9453           sst1InitReturnStatus(sst1CurrentBoard->sliSlaveVirtAddr);
      3	   9454           ISET(slaveSst->fbiInit0, IGET(slaveSst->fbiInit0) & ~SST_GRX_RESET);
      3	   9455 
      3	   9456           if(sst1InitCheckBoard(sst1CurrentBoard->sliSlaveVirtAddr) == FXFALSE)
      3	   9457               return(FXFALSE);
      3	   9458           sst1CurrentBoard->set32 = NULL;
      3	   9459           sst1CurrentBoard->fbiCmdFifoEn = 0;
      2	   9460        }
      2	   9461        return(FXTRUE);
      1	   9462     }
      1	   9463 
      1	   9464     sst1InitIdle(sstbase);
      1	   9465     fbiInit = IGET(sst->fbiInit4);
      1	   9466     fifoStart =
      1	   9467       (fbiInit & SST_MEM_FIFO_ROW_BASE) >> SST_MEM_FIFO_ROW_BASE_SHIFT;
      1	   9468     fifoStart <<= 12;  // Convert page-address into byte-address
      1	   9469 
      1	   9470     if(sst1CurrentBoard->fbiMemSize == 4)
      1	   9471       fifoSize = (1024 - (fifoStart >> 12)) << 12;
      1	   9472     else if(sst1CurrentBoard->fbiMemSize == 2)
      1	   9473       fifoSize = (512 - (fifoStart >> 12)) << 12;
      1	   9474     else
      1	   9475       fifoSize = (256 - (fifoStart >> 12)) << 12;
      1	   9476     if(fifoSize > (256<<10))
      1	   9477       fifoSize = (256<<10);
      1	   9478 
      1	   9479     *virtAddrStart =  (FxU32) (((FxU32) sstbase) + SST_CMDFIFO_ADDR);
      1	   9480     *memAddrStart = fifoStart;
      1	   9481     *size = fifoSize;

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9482 
      1	   9483     if(!sst1InitCmdFifoDirect(sstbase, 0, 
      1	   9484                               fifoStart, fifoSize, 
      1	   9485                               directExec, disableHoles,
      2	   9486                               set32Proc)) {
      2	   9487       INIT_PRINTF(("sst1InitCmdFifo(): sst1InitCmdFifoDirect() failed...\n"));
      2	   9488       return(FXFALSE);
      1	   9489     }
      1	   9490     
      2	   9491     if(sst1CurrentBoard->sliSlaveVirtAddr) {
      2	   9492       if(!sst1InitCmdFifoDirect(sst1CurrentBoard->sliSlaveVirtAddr, 0,
      2	   9493                                fifoStart, fifoSize, 
      2	   9494                                directExec, disableHoles,
      3	   9495                                set32Proc)) {
      3	   9496           INIT_PRINTF(("sst1InitCmdFifo(): sst1InitCmdFifoDirect() failed for SLI Slave...\n"));
      3	   9497           return(FXFALSE);
      2	   9498       }
      1	   9499     }
      1	   9500 
      1	   9501     INIT_PRINTF(("sst1InitCmdFifo() exiting with status %d...\n", FXTRUE));
      1	   9502     return(FXTRUE);
      1	   9503 }
	   9504 
	   9505 /*
	   9506 **
	   9507 ** sst1InitCmdFifoDirect():
	   9508 **   Explicitly initialize Command FIFO.  This routine is typically not 
	   9509 **   called directly from apps, but is included so that csim diags can
	   9510 **   call it directly.
	   9511 **
	   9512 **   The 'start' and 'size' parameters are specified in bytes.
	   9513 **   The 'which' parameter is not used, but is included for H3 compatibility.
	   9514 **
	   9515 */
	   9516 FX_ENTRY FxBool FX_CALL sst1InitCmdFifoDirect(FxU32 *sstbase, FxU32 which, 
	   9517   FxU32 start, FxU32 size, FxBool directExec, FxBool disableHoles, 
	   9518   FxSet32Proc set32Proc)
      1	   9519 {
      1	   9520     SstRegs *sst = (SstRegs *) sstbase;
      1	   9521     FxU32 fbiInit7, initEnable, n;
      1	   9522     FxU32 pageStart = start >> 12;
      1	   9523     FxU32 pageEnd = (start+size-1) >> 12;
      1	   9524 
      1	   9525     if(!sst)
      1	   9526         return(FXFALSE);
      1	   9527 
      1	   9528     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9529         return(FXFALSE);
      1	   9530 
      1	   9531     // sst1Initidle() routines must be properly executed...
      1	   9532     initIdleEnabled = 1;
      1	   9533 
      1	   9534     INIT_PRINTF(("sst1InitCmdFifoDirect(): Start:0x%x bytes, Size:%d(0x%x) bytes\n",
      1	   9535       start, size, size));
      1	   9536     INIT_PRINTF(("sst1InitCmdFifoDirect(): DirectExec:%d, DisableHoles:%d\n",
      1	   9537       directExec, disableHoles));
      1	   9538     INIT_PRINTF(("sst1InitCmdFifoDirect(): pageStart:%d, pageEnd:%d\n",

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9539       pageStart, pageEnd));
      1	   9540     INIT_PRINTF(("sst1InitCmdFifoDirect(): set32Proc: 0x%X\n",
      1	   9541                  (FxU32)set32Proc));
      1	   9542 
      1	   9543     if(sst1CurrentBoard->fbiCmdFifoEn || (IGET(sst->fbiInit7) & SST_EN_CMDFIFO))
      1	   9544         sst1InitIdleNoNOP(sstbase);
      1	   9545     else
      1	   9546         sst1InitIdle(sstbase);
      1	   9547     // Disable memory-backed fifo, and disallow lfb and texture writes
      1	   9548     // through command fifo...
      1	   9549     ISET(sst->fbiInit0, (IGET(sst->fbiInit0) & 
      1	   9550       ~(SST_MEM_FIFO_EN | SST_EN_LFB_MEMFIFO | SST_EN_TEX_MEMFIFO)));
      1	   9551     sst1InitReturnStatus(sstbase);
      1	   9552 
      1	   9553     fbiInit7 = IGET(sst->fbiInit7);
      1	   9554     fbiInit7 &= ~(SST_EN_CMDFIFO |
      1	   9555        SST_EN_CMDFIFO_OFFSCREEN | SST_CMDFIFO_DISABLE_HOLES |
      1	   9556        SST_CMDFIFO_REGS_SYNC_WRITES | SST_CMDFIFO_REGS_SYNC_READS |
      1	   9557        SST_CMDFIFO_RDFETCH_THRESH | SST_CMDFIFO_PCI_TIMEOUT);
      1	   9558     fbiInit7 |= SST_CMDFIFO_REGS_SYNC_WRITES | SST_CMDFIFO_REGS_SYNC_READS |
      1	   9559        (0x10<<SST_CMDFIFO_RDFETCH_THRESH_SHIFT) |
      1	   9560        (127<<SST_CMDFIFO_PCI_TIMEOUT_SHIFT);
      1	   9561     ISET(sst->fbiInit7, fbiInit7);    // turn off the command fifo
      1	   9562     sst1InitReturnStatus(sstbase);
      1	   9563 
      1	   9564     // Disable all writes to the PCI fifo while we're setting up CMDFIFO
      1	   9565     PCICFG_RD(SST1_PCI_INIT_ENABLE, initEnable);
      1	   9566     PCICFG_WR(SST1_PCI_INIT_ENABLE,
      1	   9567        ((initEnable & ~(SST_INITWR_EN | SST_PCI_FIFOWR_EN)) | SST_INITWR_EN));
      1	   9568 
      1	   9569     // Setup command fifo...
      1	   9570     ISET(sst->cmdFifoBase, (pageEnd << SST_CMDFIFO_END_SHIFT) | pageStart);
      1	   9571     sst1InitReturnStatus(sstbase);  // prevent PCI bursts...
      1	   9572     ISET(sst->cmdFifoReadPtr, start);
      1	   9573     sst1InitReturnStatus(sstbase);
      1	   9574     ISET(sst->cmdFifoAmin, start-4);
      1	   9575     sst1InitReturnStatus(sstbase);
      1	   9576     ISET(sst->cmdFifoAmax, start-4);
      1	   9577     sst1InitReturnStatus(sstbase);
      1	   9578     ISET(sst->cmdFifoDepth, 0);
      1	   9579     sst1InitReturnStatus(sstbase);
      1	   9580     ISET(sst->cmdFifoHoles, 0);
      1	   9581     sst1InitReturnStatus(sstbase);
      1	   9582     sst1InitIdle(sstbase);
      1	   9583 
      1	   9584     // Turn on command fifo...
      1	   9585     ISET(sst->fbiInit7, fbiInit7 | SST_EN_CMDFIFO |
      1	   9586       (directExec ? 0 : SST_EN_CMDFIFO_OFFSCREEN) |
      1	   9587       (disableHoles ? SST_CMDFIFO_DISABLE_HOLES : 0));
      1	   9588     // Can't perform sst1InitIdle() here because it will generate
      1	   9589     // writes to the CMDFIFO since the CMDFIFO is now enabled...
      1	   9590     sst1InitReturnStatus(sstbase);
      1	   9591 
      1	   9592     // Enable writes to be pushed onto the CMDFIFO...
      1	   9593     PCICFG_WR(SST1_PCI_INIT_ENABLE,
      1	   9594        (initEnable | SST_INITWR_EN | SST_PCI_FIFOWR_EN));
      1	   9595 

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9596     sst1CurrentBoard->fbiCmdFifoEn = 1;
      1	   9597     if(GETENV(("SSTV2_IGNORE_IDLE")))
      1	   9598        initIdleEnabled = 0;
      1	   9599 
      1	   9600     /* Set the client callbacks, if necessary. */
      1	   9601     sst1CurrentBoard->set32 = set32Proc;
      1	   9602 
      1	   9603     return(FXTRUE);
      1	   9604 }
	   9605 
	   9606 /*
	   9607 **
	   9608 ** sst1InitLfbLock():
	   9609 **   Used to workaround a hw bug when performing lfb and texture writes when
	   9610 **   the command fifo is enabled.  The routines sst1InitLfbLock() and
	   9611 **   sst1InitLfbUnlock() dynamically disable the command fifo so that lfb
	   9612 **   and texture accesses do not pass through the command fifo.
	   9613 **   WARNING: No register writes of any kind may be performed between a
	   9614 **   sst1InitLfbLock() and sst1InitLfbUnlock() pair -- only lfb reads and 
	   9615 **   writes are allowed.
	   9616 */
	   9617 FX_ENTRY FxBool FX_CALL sst1InitLfbLock(FxU32* sstbase)
      1	   9618 {
      1	   9619    if(!sstbase)
      1	   9620        return(FXFALSE);
      1	   9621 
      1	   9622    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9623        return(FXFALSE);
      1	   9624 
      1	   9625    // Idle the hardware...
      1	   9626    sst1InitIdle(sstbase);
      1	   9627 
      1	   9628    if(sst1InitLfbLockDirect(sstbase) == FXFALSE)
      1	   9629        return(FXFALSE);
      1	   9630 
      2	   9631    if(sst1CurrentBoard->sliSlaveVirtAddr) {
      2	   9632        // SLI Enabled
      2	   9633        if(sst1InitLfbLockDirect(sst1CurrentBoard->sliSlaveVirtAddr) == FXFALSE)
      2	   9634            return(FXFALSE);
      1	   9635    }
      1	   9636 
      1	   9637    return(FXTRUE);
      1	   9638 }
	   9639 
	   9640 FX_ENTRY FxBool FX_CALL sst1InitLfbLockDirect(FxU32* sstbase)
      1	   9641 {
      1	   9642    SstRegs *sst = (SstRegs *) sstbase;
      1	   9643 
      1	   9644    if(!sst)
      1	   9645        return(FXFALSE);
      1	   9646 
      1	   9647    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9648        return(FXFALSE);
      1	   9649 
      1	   9650    if((!(IGET(sst->fbiInit7) & SST_EN_CMDFIFO) &&
      1	   9651      !sst1CurrentBoard->fbiCmdFifoEn) || sst1CurrentBoard->fbiLfbLocked)
      1	   9652        return(FXTRUE);

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9653 
      1	   9654    // Force direct writes...
      1	   9655    sst1CurrentBoard->fbiLfbLocked = 1;
      1	   9656 
      1	   9657    ISET(sst->fbiInit7, IGET(sst->fbiInit7) & ~SST_EN_CMDFIFO_OFFSCREEN);
      1	   9658    sst1InitReturnStatus(sstbase);
      1	   9659    sst1InitReturnStatus(sstbase);
      1	   9660    sst1InitReturnStatus(sstbase);
      1	   9661 
      1	   9662    return(FXTRUE);
      1	   9663 }
	   9664 
	   9665 /*
	   9666 **
	   9667 ** sst1InitLfbUnlock():
	   9668 **   Used to workaround a hw bug when performing lfb and texture writes when
	   9669 **   the command fifo is enabled.  The routines sst1InitLfbLock() and
	   9670 **   sst1InitLfbUnlock() dynamically disable the command fifo so that lfb
	   9671 **   and texture accesses do not pass through the command fifo.
	   9672 **   WARNING: No register writes of any kind may be performed between a
	   9673 **   sst1InitLfbLock() and sst1InitLfbUnlock() pair -- only lfb reads and 
	   9674 **   writes are allowed.
	   9675 */
	   9676 
	   9677 FX_ENTRY FxBool FX_CALL sst1InitLfbUnlock(FxU32* sstbase)
      1	   9678 {
      1	   9679    if(!sstbase)
      1	   9680        return(FXFALSE);
      1	   9681 
      1	   9682    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9683        return(FXFALSE);
      1	   9684 
      1	   9685    // Idle the hardware.  Since lfb lock is set, a NOP will not be issued, and
      1	   9686    // sst1InitPciFifoIdleLoop() will be used instead of sst1InitIdleLoop()...
      1	   9687    sst1InitIdle(sstbase);
      1	   9688 
      2	   9689    if(sst1CurrentBoard->sliSlaveVirtAddr) {
      2	   9690        // SLI Enabled
      2	   9691        if(sst1InitLfbUnlockDirect(sst1CurrentBoard->sliSlaveVirtAddr) ==
      2	   9692          FXFALSE)
      2	   9693            return(FXFALSE);
      1	   9694    }
      1	   9695    if(sst1InitLfbUnlockDirect(sstbase) == FXFALSE)
      1	   9696        return(FXFALSE);
      1	   9697 
      1	   9698    // After the command fifo is re-enabled, make sure the chip is really idle...
      1	   9699    sst1InitIdle(sstbase);
      1	   9700 
      1	   9701    return(FXTRUE);
      1	   9702 }
	   9703 
	   9704 FX_ENTRY FxBool FX_CALL sst1InitLfbUnlockDirect(FxU32* sstbase)
      1	   9705 {
      1	   9706    SstRegs *sst = (SstRegs *) sstbase;
      1	   9707 
      1	   9708    if(!sst)
      1	   9709        return(FXFALSE);

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9710 
      1	   9711    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9712        return(FXFALSE);
      1	   9713 
      1	   9714    if(!sst1CurrentBoard->fbiCmdFifoEn || !sst1CurrentBoard->fbiLfbLocked)
      1	   9715        return(FXTRUE);
      1	   9716 
      1	   9717    ISET(sst->fbiInit7, IGET(sst->fbiInit7) | SST_EN_CMDFIFO_OFFSCREEN);
      1	   9718 
      1	   9719    sst1CurrentBoard->fbiLfbLocked = 0;
      1	   9720 
      1	   9721    sst1InitReturnStatus(sstbase);
      1	   9722    sst1InitReturnStatus(sstbase);
      1	   9723    sst1InitReturnStatus(sstbase);
      1	   9724 
      1	   9725    return(FXTRUE);
      1	   9726 }
	   9727 
	   9728 /*
	   9729 **
	   9730 ** sst1InitPrintInitRegs():
	   9731 **   Print Initialization Registers
	   9732 **
	   9733 */
	   9734 FX_EXPORT void FX_CSTYLE sst1InitPrintInitRegs(FxU32 *sstbase)
      1	   9735 {
      1	   9736     SstRegs *sst = (SstRegs *) sstbase;
      1	   9737 
      1	   9738     INIT_PRINTF(("FBI Initialization Registers:\n"));
      1	   9739     INIT_PRINTF(("-----------------------------\n"));
      1	   9740     INIT_PRINTF(("fbiInit0:0x%08x  fbiInit1:0x%08x\n",
      1	   9741       IGET(sst->fbiInit0), IGET(sst->fbiInit1)));
      1	   9742     INIT_PRINTF(("fbiInit2:0x%08x  fbiInit3:0x%08x\n",
      1	   9743       IGET(sst->fbiInit2), IGET(sst->fbiInit3)));
      1	   9744     INIT_PRINTF(("fbiInit4:0x%08x  fbiInit5:0x%08x\n",
      1	   9745       IGET(sst->fbiInit4), IGET(sst->fbiInit5)));
      1	   9746     INIT_PRINTF(("fbiInit6:0x%08x  fbiInit7:0x%08x\n",
      1	   9747       IGET(sst->fbiInit6), IGET(sst->fbiInit7)));
      1	   9748     INIT_PRINTF(("videoDimensions:0x%08x\n\n",
      1	   9749       IGET(sst->videoDimensions)));
      1	   9750     INIT_PRINTF(("FBI Command Fifo Registers:\n"));
      1	   9751     INIT_PRINTF(("---------------------------\n"));
      1	   9752     INIT_PRINTF(("cmdFifoBase:    0x%08x\tcmdFifoBump:0x%x\n",
      1	   9753       IGET(sst->cmdFifoBase), IGET(sst->cmdFifoBump)));
      1	   9754     INIT_PRINTF(("cmdFifoReadPtr: 0x%08x\tcmdFifoAmin:0x%x\n",
      1	   9755       IGET(sst->cmdFifoReadPtr), IGET(sst->cmdFifoAmin)));
      1	   9756     INIT_PRINTF(("cmdFifoAmax:    0x%08x\tcmdFifoDepth:0x%x\n",
      1	   9757       IGET(sst->cmdFifoAmax), IGET(sst->cmdFifoDepth)));
      1	   9758     INIT_PRINTF(("cmdFifoHoles:   0x%08x\n", IGET(sst->cmdFifoHoles)));
      1	   9759 }
	   9760 
	   9761 /*
	   9762 **
	   9763 ** sst1InitMeasureSiProcess():
	   9764 **   Use silicon process register to measure silicon performance
	   9765 **
	   9766 */

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

	   9767 FX_EXPORT FxU32 FX_CSTYLE sst1InitMeasureSiProcess(FxU32 *sstbase, FxU32 which)
      1	   9768 {
      1	   9769     FxU32 n, siProcess, nandOsc, norOsc;
      1	   9770     FxU32 pciCntrLoad = 0xfff;
      1	   9771     FxU32 cntr;
      1	   9772     int i;
      1	   9773 
      1	   9774     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9775         return(FXFALSE);
      1	   9776 
      1	   9777     if(GETENV(("SSTV2_SIPROCESS_CNTR")) &&
      2	   9778        (SSCANF(GETENV(("SSTV2_SIPROCESS_CNTR")), "%i", &i) == 1) ) {
      2	   9779         pciCntrLoad = i;
      2	   9780         INIT_PRINTF(("sst1InitMeasureSiProcess(): Using PCI Counter preload value of 0x%x...\n", pciCntrLoad));
      1	   9781     }
      1	   9782 
      2	   9783     if(!which) {
      2	   9784        ////////////////////////////////
      2	   9785        // Test NAND oscillator tree...
      2	   9786        ////////////////////////////////
      2	   9787        PCICFG_WR(SST1_PCI_SIPROCESS,
      2	   9788         (pciCntrLoad<<SST_SIPROCESS_PCI_CNTR_SHIFT) |
      2	   9789          SST_SIPROCESS_OSC_CNTR_RESET_N | SST_SIPROCESS_OSC_NAND_SEL);
      2	   9790    
      2	   9791        // Allow oscillator to run...
      2	   9792        PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9793        PCICFG_WR(SST1_PCI_SIPROCESS,
      2	   9794         (pciCntrLoad<<SST_SIPROCESS_PCI_CNTR_SHIFT) |
      2	   9795          SST_SIPROCESS_OSC_CNTR_RUN | SST_SIPROCESS_OSC_NAND_SEL);
      2	   9796    
      2	   9797        // Loop until PCI counter decrements to 0
      2	   9798        cntr = 0 ;
      3	   9799        do {
      3	   9800           ++cntr;
      3	   9801           PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9802        } while(siProcess & SST_SIPROCESS_PCI_CNTR);
      2	   9803    
      2	   9804        PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9805        siProcess &= SST_SIPROCESS_OSC_CNTR;
      2	   9806        nandOsc = siProcess;
      2	   9807        if(nandOsc < 3000)
      2	   9808           nandOsc <<= 1; // Running on 66 MHz PCI...
      2	   9809        sst1CurrentBoard->fbiNandTree = nandOsc;
      2	   9810 
      2	   9811        INIT_PRINTF(("sst1InitInfo(): NAND-tree: %d\n", nandOsc));
      2	   9812     } else {
      2	   9813        ////////////////////////////////
      2	   9814        // Test NOR oscillator tree...
      2	   9815        ////////////////////////////////
      2	   9816        PCICFG_WR(SST1_PCI_SIPROCESS,
      2	   9817         (pciCntrLoad<<SST_SIPROCESS_PCI_CNTR_SHIFT) |
      2	   9818          SST_SIPROCESS_OSC_CNTR_RESET_N | SST_SIPROCESS_OSC_NOR_SEL);
      2	   9819    
      2	   9820        // Allow oscillator to run...
      2	   9821        PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9822        PCICFG_WR(SST1_PCI_SIPROCESS,
      2	   9823        (pciCntrLoad<<SST_SIPROCESS_PCI_CNTR_SHIFT) |

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      2	   9824          SST_SIPROCESS_OSC_CNTR_RUN | SST_SIPROCESS_OSC_NOR_SEL);
      2	   9825    
      2	   9826        // Loop until PCI counter decrements to 0
      2	   9827        cntr = 0 ;
      3	   9828        do {
      3	   9829           ++cntr;
      3	   9830           PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9831        } while(siProcess & SST_SIPROCESS_PCI_CNTR);
      2	   9832    
      2	   9833        PCICFG_RD(SST1_PCI_SIPROCESS, siProcess);
      2	   9834        siProcess &= SST_SIPROCESS_OSC_CNTR;
      2	   9835        norOsc = siProcess;
      2	   9836        if(norOsc < 3000)
      2	   9837           norOsc <<= 1; // Running on 66 MHz PCI...
      2	   9838        sst1CurrentBoard->fbiNorTree = norOsc;
      2	   9839 
      2	   9840        INIT_PRINTF(("sst1InitInfo(): NOR-tree : %d\n", norOsc));
      1	   9841     }
      1	   9842     return(siProcess);
      1	   9843 }
	   9844 
	   9845 /*
	   9846 **
	   9847 ** sst1InitCalcTClkDelay()
	   9848 ** Calculate optimal TF/TT Clock delay values
	   9849 **
	   9850 */
	   9851 FX_EXPORT FxBool FX_CSTYLE sst1InitCalcTClkDelay(FxU32 *sstbase,
	   9852    FxU32 tmuNumber, FxU32 tClkDelay)
      1	   9853 {
      1	   9854    SstRegs *sst = (SstRegs *) sstbase;
      1	   9855    volatile FxU32 *texAddr;
      1	   9856 
      1	   9857    if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9858       return(FXFALSE);
      1	   9859 
      1	   9860    ISET(sst->tLOD, 0x0);
      1	   9861    ISET(sst->tDetail, 0x0);
      1	   9862    ISET(sst->texBaseAddr, 0x0);
      1	   9863    ISET(sst->fogMode, 0x0);
      1	   9864    ISET(sst->alphaMode, 0x0);
      1	   9865    ISET(sst->fbzMode, SST_ENCHROMAKEY);
      1	   9866    ISET(sst->fbzColorPath, SST_RGBSEL_TREXOUT | SST_CC_PASS | SST_ENTEXTUREMAP);
      1	   9867    //texAddr = (numTmu<<(21-2)) + (FxU32 *) SST_TEX_ADDRESS(sst);
      1	   9868    texAddr = (0<<(21-2)) + (FxU32 *) SST_TEX_ADDRESS(sst);
      1	   9869    ISET(texAddr[0], 0x0);
      1	   9870    texAddr = (1<<(21-2)) + (FxU32 *) SST_TEX_ADDRESS(sst);
      1	   9871    ISET(texAddr[0], 0x0);
      1	   9872    texAddr = (2<<(21-2)) + (FxU32 *) SST_TEX_ADDRESS(sst);
      1	   9873    ISET(texAddr[0], 0x0);
      1	   9874 
      1	   9875    ISET(SST_TREX(sst,tmuNumber)->trexInit1,
      1	   9876       (sst1CurrentBoard->tmuInit1[tmuNumber] & ~SST_TEX_TF_CLK_DEL_ADJ) |
      1	   9877       (tClkDelay<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT));
      1	   9878 
      1	   9879    if(!sst1InitIdleFBIWithTimeout(sstbase, FXTRUE, 10000))
      1	   9880       return(FXFALSE);

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      1	   9881 
      1	   9882    // Reset pixel stat registers
      1	   9883    ISET(sst->nopCMD, 0x3);
      1	   9884    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0xff0000);
      1	   9885    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0x00ffff);
      1	   9886    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0xf0f0f0);
      1	   9887    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0x0f0f0f);
      1	   9888    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0x55aa55);
      1	   9889    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0xaa55aa);
      1	   9890    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0x5a5a5a);
      1	   9891    sst1InitCheckTmuMemConst(sstbase, tmuNumber, 0xa5a5a5);
      1	   9892 
      1	   9893    if(!sst1InitIdleFBIWithTimeout(sstbase, FXTRUE, 10000))
      1	   9894       return(FXFALSE);
      1	   9895 
      1	   9896    if(IGET(sst->stats.fbiChromaFail))
      1	   9897       return(FXFALSE);
      1	   9898    else
      1	   9899       return(FXTRUE);
      1	   9900 }
	   9901 
	   9902 #define COLOR32TOCOLOR24_6666(X)       \
	   9903       ((((X >> 2) & 0x3F) << 0) |      \
	   9904        (((X >> 10) & 0x3F) << 6) |     \
	   9905        (((X >> 18) & 0x3F) << 12) |    \
	   9906        (((X >> 26) & 0x3F) << 18))
	   9907 #define COLOR24_6666TOCOLOR32(X)                                  \
	   9908       (((((X >> 0) & 0x3F) << 2) | (((X >> 4) & 0x3) << 0)) |     \
	   9909        ((((X >> 6) & 0x3F) << 10) | (((X >> 10) & 0x3) << 8)) |   \
	   9910        ((((X >> 12) & 0x3F) << 18) | (((X >> 16) & 0x3) << 16)) | \
	   9911        ((((X >> 18) & 0x3F) << 26) | (((X >> 22) & 0x3) << 24)))
	   9912 
	   9913 void sst1InitCheckTmuMemConst(FxU32 *sstbase, FxU32 tmuNumber,
	   9914    FxU32 dataExpect32)
      1	   9915 {
      1	   9916    SstRegs *sst = (SstRegs *) sstbase;
      1	   9917    FxU32 dataExpect6666 = COLOR32TOCOLOR24_6666(dataExpect32);
      1	   9918    FxU32 dataExpect6666To32 = COLOR24_6666TOCOLOR32(dataExpect6666) & 0xffffff;
      1	   9919 
      1	   9920    ISET(sst->chromaKey, dataExpect6666To32);
      1	   9921    ISET(sst->chromaRange, dataExpect6666To32 | SST_ENCHROMARANGE |
      1	   9922       SST_CHROMARANGE_BLUE_EX | SST_CHROMARANGE_GREEN_EX |
      1	   9923       SST_CHROMARANGE_RED_EX | SST_CHROMARANGE_BLOCK_OR);
      1	   9924 
      2	   9925    if(!tmuNumber) {
      2	   9926       ISET(sst->textureMode, SST_P8_ARGB6666 | SST_TC_REPLACE | SST_TCA_ZERO);
      2	   9927    } else if(tmuNumber == 1) {
      2	   9928       // Force downstream TMU to passthrough upstream data
      2	   9929       ISET(SST_TREX(sst,0)->textureMode, SST_P8_ARGB6666 | SST_TC_PASS |
      2	   9930         SST_TCA_PASS);
      2	   9931       ISET(SST_TREX(sst,1)->textureMode, SST_P8_ARGB6666 | SST_TC_REPLACE |
      2	   9932         SST_TCA_ZERO);
      2	   9933       ISET(SST_TREX(sst,2)->textureMode, SST_P8_ARGB6666 | SST_TC_REPLACE |
      2	   9934         SST_TCA_ZERO);
      2	   9935    } else {
      2	   9936       // Force downstream TMUs to passthrough upstream data
      2	   9937       ISET(SST_TREX(sst,0)->textureMode, SST_P8_ARGB6666 | SST_TC_PASS |

UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

      2	   9938         SST_TCA_PASS);
      2	   9939       ISET(SST_TREX(sst,1)->textureMode, SST_P8_ARGB6666 | SST_TC_PASS |
      2	   9940         SST_TCA_PASS);
      2	   9941       ISET(SST_TREX(sst,2)->textureMode, SST_P8_ARGB6666 | SST_TC_REPLACE |
      2	   9942         SST_TCA_ZERO);
      1	   9943    }
      1	   9944    // Specify color in palette entry 0...
      1	   9945    //sst->nccTable0[4]=BIT(31) | ((index>>1)<<24) | (palette[index] & 0xffffff);
      1	   9946    ISET(sst->nccTable0[4], BIT(31) | COLOR32TOCOLOR24_6666(dataExpect32));
      1	   9947    sst1InitDrawRectUsingTris(sstbase, 0, 0, 128);
      1	   9948 
      1	   9949    return;
      1	   9950 }
	   9951 
	   9952 void sst1InitDrawRectUsingTris(FxU32 *sstbase, FxU32 x, FxU32 y, FxU32 tSize)
      1	   9953 {
      1	   9954    SstRegs *sst = (SstRegs *) sstbase;
      1	   9955 
      1	   9956    ISET(sst->vA.x, (x<<SST_XY_FRACBITS));
      1	   9957    ISET(sst->vA.y, (y<<SST_XY_FRACBITS));
      1	   9958    ISET(sst->vB.x, ((x+tSize)<<SST_XY_FRACBITS));
      1	   9959    ISET(sst->vB.y, (y<<SST_XY_FRACBITS));
      1	   9960    ISET(sst->vC.x, ((x+tSize)<<SST_XY_FRACBITS));
      1	   9961    ISET(sst->vC.y, ((y+tSize)<<SST_XY_FRACBITS));
      1	   9962    ISET(sst->s, 0);
      1	   9963    ISET(sst->t, 0);
      1	   9964    ISET(sst->w, 0);
      1	   9965    ISET(sst->r, (0xff<<SST_XY_INTBITS));
      1	   9966    ISET(sst->g, 0);
      1	   9967    ISET(sst->b, 0);
      1	   9968    ISET(sst->dsdx, 0);
      1	   9969    ISET(sst->dtdx, 0);
      1	   9970    ISET(sst->dwdx, 0);
      1	   9971    ISET(sst->dsdy, 0);
      1	   9972    ISET(sst->dtdy, 0);
      1	   9973    ISET(sst->dwdy, 0);
      1	   9974    ISET(sst->triangleCMD, 0);
      1	   9975    ISET(sst->vB.x, (x<<SST_XY_FRACBITS));
      1	   9976    ISET(sst->vB.y, ((y+tSize)<<SST_XY_FRACBITS));
      1	   9977    ISET(sst->triangleCMD, 0xFFFFFFFF);
      1	   9978 }
	   9979 
       X   9980 #ifdef _MSC_VER
       X   9981 #pragma optimize ("",on)
       X   9982 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]UTIL/OBJECT=[.OUT.DEB
UG.OBJ.GLIDE.GLIDE2X.CVG.INIT]UTIL.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC
],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CV
G.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_H
W_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE
.GLIDE2X.CVG.INIT]UTIL.C


UTIL                            Source Listing                   9-MAY-2021 23:43:22  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  util.c;1

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC
These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:23"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

	      1 /*
	      2  ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3  ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4  ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5  ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6  ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7  ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8  ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9  ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10  ** 
	     11  ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12  ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13  ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14  ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15  ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16  ** THE UNITED STATES.  
	     17  ** 
	     18  ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19  **
	     20 ** 
	     21 ** 26    2/20/98 11:00a Peter
	     22 ** removed glide3 from glid2 tree
	     23 ** 
	     24 ** 25    2/17/98 3:21p Peter
	     25 ** no splash w/o deepth buffer
	     26 ** 
	     27 ** 24    1/28/98 1:12p Peter
	     28 ** Stupid swap state form gratuitous splash screen
	     29  * 
	     30  * 23    1/09/98 6:48p Atai
	     31  * grTexInfo, GR_LOD_* and GR_ASPECT_*
	     32  * 
	     33  * 21    1/06/98 6:47p Atai
	     34  * undo grSplash and remove gu routines
	     35  * 
	     36  * 20    12/18/97 2:13p Peter
	     37  * fogTable cataclysm
	     38  * 
	     39  * 19    12/15/97 5:52p Atai
	     40  * disable obsolete glide2 api for glide3
	     41  * 
	     42  * 18    12/09/97 10:20a Peter
	     43  * removed extraneous cruft
	     44  * 
	     45  * 17    11/14/97 5:03p Peter
	     46  * picking up the torch... removed #!@#$% c++ comments
	     47  * 
	     48  * 16    10/23/97 5:30p Peter
	     49  * packed rgb happiness
	     50  * 
	     51  * 15    7/31/97 11:14a Peter
	     52  * merge w/ sst1 glide tree, hopefully
	     53  * 
	     54  * 13    7/07/97 3:05p Dow
	     55  * Moved fouled clears
	     56  * 
	     57  * 12    3/18/97 9:07p Dow

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

	     58  * Got rid of #$#%#$ // comments
	     59  * 
	     60  * 11    3/16/97 12:42a Jdt
	     61  * Removed watcom warning
	     62  * 
	     63  * 10    3/13/97 10:53p Jdt
	     64  * Rewrote with simple optimizations.  Changed prototype for
	     65  * multi-resolution, and running as a better shameless plug.
	     66  * 
	     67  * 9     3/13/97 2:52a Jdt
	     68  * Added arguments to splash.
	     69  * 
	     70  * 8     3/09/97 10:31a Dow
	     71  * Added GR_DIENTRY for di glide functions
	     72  * 
	     73  * 7     3/01/97 6:24p Jdt
	     74  * Made splash force yorigin.
	     75  * 
	     76  * 6     1/02/97 1:06p Dow
	     77  * Fixed state bug
	     78  * 
	     79  * 3     11/17/96 11:16p Garymct
	     80  * Updated grSplash code to set all of the necessary state itself rather
	     81  * than expecting the caller to do so.
	     82  */
	     83 #include <math.h>
	   1523 
	   1524 #include <3dfx.h>
	   1655 #define FX_DLL_DEFINITION
	   1656 #include <fxdll.h>
	   1777 #include <glide.h>
	   3719 
	   3720 #include "fxglide.h"
	  14173 //#include "fxinline.h"
	  14174 
	  14175 #define kInternalFogTableEntryCount 64
	  14176 
	  14177 #ifndef GLIDE_SPLASH
      1	  14178 GR_DIENTRY(grSplash,void,(float x,float y,float w,float h,FxU32 _frame)) {
      1	  14179 /* nothing */
      1	  14180 }
	  14181 
       X  14182 #else /* GLIDE_SPLASH */
       X  14183 
       X  14184 /*-----------------------------
       X  14185   Constants
       X  14186   -----------------------------*/
       X  14187 #define MAX_NUM_VERTS 2556
       X  14188 
       X  14189 #define FADEIN_END_PERCENT (0.3f)
       X  14190 #define FADEOUT_BEGIN_PERCENT (0.8f)
       X  14191 
       X  14192 #define SPIN_FRAMES 25
       X  14193 #define SPIN_START  26
       X  14194 
       X  14195 #define NO_TABLE ((GrTexTable_t)(~0))
       X  14196 

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14197 /*-----------------------------
       X  14198   Macros
       X  14199   -----------------------------*/
       X  14200 #define SNAP_BIAS     ((float)(3<<18))
       X  14201 #define SNAP_COORD(X) ((X)+SNAP_BIAS)
       X  14202 
       X  14203 /*-----------------------------
       X  14204   Types
       X  14205   -----------------------------*/
       X  14206 typedef struct {
       X  14207   float x, y, z;                /* object space coordinates */
       X  14208   float nx, ny, nz;             /* object space vertex normal for lighting */
       X  14209   float s, t;                   /* pre-glide-ified texture coordinates */
       X  14210 } Vert;
       X  14211 
       X  14212 typedef struct {
       X  14213   int v[3];                     /* vertex indices into array of vertes for face */
       X  14214   int mat_index;                /* material index */
       X  14215   int aa_edge_flags;
       X  14216 } Face;
       X  14217 
       X  14218 typedef float Vector[3];
       X  14219 typedef float Matrix[16];
       X  14220 
       X  14221 typedef FxU32 Palette[256];
       X  14222 typedef struct {
       X  14223   FxU8  yRGB[16];
       X  14224   FxI16 iRGB[4][3];
       X  14225   FxI16 qRGB[4][3];
       X  14226   FxU32 packed_data[12];
       X  14227 } NCCTable;
       X  14228 typedef union {
       X  14229   Palette  palette;
       X  14230   NCCTable nccTable;
       X  14231 } TextureTable;
       X  14232 
       X  14233 /*-----------------------------
       X  14234   Globals
       X  14235   -----------------------------*/
       X  14236 /* xScale, xOffset, yScale, yOffset */
       X  14237 static float viewPort[4] = { 
       X  14238   480.0f, 320.0f, 
       X  14239   480.0f, 240.0f 
       X  14240 };
       X  14241 
       X  14242 typedef struct {
       X  14243   GrTexInfo    info;
       X  14244   FxU32        addr;
       X  14245   GrTexTable_t tableType;
       X  14246   TextureTable tableData;
       X  14247 } Texture;
       X  14248 
       X  14249 static int do_phong = 0;
       X  14250 static int pass;
       X  14251 static int fog;
       X  14252 static int useTextures;
       X  14253 static Vector light = { -0.57735f, -0.57735f, -0.57735f };

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14254 static Vector transformed_verts[MAX_NUM_VERTS];
       X  14255 static Vector transformed_norms[MAX_NUM_VERTS];
       X  14256 
       X  14257 #include "splshdat.c"
       X  14258 
       X  14259 static Texture textImage;
       X  14260 static Texture hiliteImage;
       X  14261 static Texture shadowImage;
       X  14262 
       X  14263 static FxU32 nextFreeBase;
       X  14264 
       X  14265 /*-----------------------------
       X  14266   Privates
       X  14267   -----------------------------*/
       X  14268 static void 
       X  14269 sourceTexture(Texture *texture) 
       X  14270 {
       X  14271   static Texture *lastTexture;
       X  14272 
       X  14273   if (texture != lastTexture && useTextures) {
       X  14274     grTexSource(GR_TMU0,
       X  14275                 texture->addr,
       X  14276                 GR_MIPMAPLEVELMASK_BOTH,
       X  14277                 &texture->info);
       X  14278     if (texture->tableType != NO_TABLE) {
       X  14279       grTexDownloadTable(GR_TMU0,
       X  14280                          texture->tableType,
       X  14281                          &texture->tableData);
       X  14282     }
       X  14283     lastTexture = texture;
       X  14284   }
       X  14285 }
       X  14286 
       X  14287 static GrTexTable_t 
       X  14288 texTableType(GrTextureFormat_t format) 
       X  14289 {
       X  14290   GrTexTable_t rv = (GrTexTable_t)NO_TABLE;
       X  14291 
       X  14292   switch(format) {
       X  14293   case GR_TEXFMT_YIQ_422:
       X  14294   case GR_TEXFMT_AYIQ_8422:
       X  14295     rv = GR_TEXTABLE_NCC0;
       X  14296     break;
       X  14297 
       X  14298   case GR_TEXFMT_P_8:
       X  14299   case GR_TEXFMT_AP_88:
       X  14300     rv = GR_TEXTABLE_PALETTE;
       X  14301     break;
       X  14302   }
       X  14303 
       X  14304   return rv;
       X  14305 }
       X  14306 
       X  14307 static void 
       X  14308 downloadTexture(Texture *texture, Gu3dfInfo *info) 
       X  14309 {
       X  14310   texture->info.data        = info->data;

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14311   texture->info.smallLod    = info->header.small_lod;
       X  14312   texture->info.largeLod    = info->header.large_lod;
       X  14313   texture->info.aspectRatio = info->header.aspect_ratio;
       X  14314   texture->info.format      = info->header.format;
       X  14315 
       X  14316   texture->addr = nextFreeBase;
       X  14317   nextFreeBase += grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
       X  14318                                           &texture->info);
       X  14319   grTexDownloadMipMap(GR_TMU0,
       X  14320                       texture->addr,
       X  14321                       GR_MIPMAPLEVELMASK_BOTH,
       X  14322                       &texture->info);
       X  14323 
       X  14324   texture->tableType = texTableType(info->header.format);
       X  14325   switch(texture->tableType) {
       X  14326   case GR_TEXTABLE_NCC0:
       X  14327   case GR_TEXTABLE_NCC1:
       X  14328   case GR_TEXTABLE_PALETTE:
       X  14329     texture->tableData = *(TextureTable*)(&info->table);
       X  14330     break;
       X  14331   default:
       X  14332     break;
       X  14333   }
       X  14334 }
       X  14335 
       X  14336 static void 
       X  14337 createTextures(void) 
       X  14338 {
       X  14339   Gu3dfInfo *info;
       X  14340 
       X  14341   /* Download the texture for the "3D" part of the model. */
       X  14342   info       = (Gu3dfInfo*)&text_3dfinfo;
       X  14343   info->data = (void *)text_3dfinfo_image;
       X  14344 
       X  14345   downloadTexture(&textImage, info);
       X  14346 
       X  14347   /* Download the texture for the specular highlight. */
       X  14348   info       = (Gu3dfInfo *)&hilite_3dfinfo;
       X  14349   info->data = (void *)hilite_3dfinfo_image;
       X  14350   downloadTexture(&hiliteImage, info);
       X  14351 
       X  14352   /* Download the texture for the shadow. */
       X  14353   info       = (Gu3dfInfo *)&shadow_3dfinfo;
       X  14354   info->data = (void *)shadow_3dfinfo_image;
       X  14355   downloadTexture(&shadowImage, info);
       X  14356 }
       X  14357 
       X  14358 static void 
       X  14359 vecMatMult(float *dstVec, float *srcVec, float *matrix) 
       X  14360 {
       X  14361   dstVec[0] = (srcVec[0] * matrix[0] +
       X  14362                srcVec[1] * matrix[4] +
       X  14363                srcVec[2] * matrix[8] +
       X  14364                matrix[12]);
       X  14365     
       X  14366   dstVec[1] = (srcVec[0] * matrix[1] +
       X  14367                srcVec[1] * matrix[5] +

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14368                srcVec[2] * matrix[9] +
       X  14369                matrix[13]);
       X  14370     
       X  14371   dstVec[2] = (srcVec[0] * matrix[2] +
       X  14372                srcVec[1] * matrix[6] +
       X  14373                srcVec[2] * matrix[10] +
       X  14374                matrix[14]);
       X  14375 }
       X  14376 
       X  14377 static void 
       X  14378 normMatMult(float *dstVec, float *srcVec, float *matrix) 
       X  14379 {
       X  14380   dstVec[0] = (srcVec[0] * matrix[0] +
       X  14381                srcVec[1] * matrix[4] +
       X  14382                srcVec[2] * matrix[8]);
       X  14383     
       X  14384   dstVec[1] = (srcVec[0] * matrix[1] +
       X  14385                srcVec[1] * matrix[5] +
       X  14386                srcVec[2] * matrix[9]);
       X  14387     
       X  14388   dstVec[2] = (srcVec[0] * matrix[2] +
       X  14389                srcVec[1] * matrix[6] +
       X  14390                srcVec[2] * matrix[10]);
       X  14391 }
       X  14392 
       X  14393 static void 
       X  14394 xfAndProj(int frame, int obj) 
       X  14395 {
       X  14396   int    vertex;
       X  14397   float *matrix;
       X  14398 
       X  14399   matrix = &mat[frame][obj][0];
       X  14400 
       X  14401   for(vertex = 0; vertex < num_verts[obj]; vertex++) {
       X  14402     float *srcVec;
       X  14403     float *dstVec;
       X  14404     float oow;
       X  14405 
       X  14406     /* transform point */
       X  14407     srcVec = (float*)&(vert[obj][vertex].x);
       X  14408     dstVec = (float*)transformed_verts[vertex];
       X  14409     vecMatMult(dstVec, srcVec, matrix);
       X  14410 
       X  14411     /* project point */
       X  14412     oow = 1.0f / dstVec[2];
       X  14413     dstVec[0] = dstVec[0] * oow * viewPort[0] + viewPort[1] + SNAP_BIAS;
       X  14414     dstVec[1] = dstVec[1] * oow * viewPort[2] + viewPort[3] + SNAP_BIAS;
       X  14415 
       X  14416     /* transform normal */
       X  14417     srcVec = (float*)&(vert[obj][vertex].nx);
       X  14418     dstVec = (float*)transformed_norms[vertex];
       X  14419     normMatMult(dstVec, srcVec, matrix);
       X  14420   }
       X  14421 }
       X  14422 
       X  14423 static void 
       X  14424 setupMaterial(int material_index) 

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14425 {
       X  14426   switch(material_index) {
       X  14427   case 0:                       /* 3d */
       X  14428     if(pass == 1) {
       X  14429       sourceTexture(&textImage);
       X  14430       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14431                      GR_COMBINE_FACTOR_LOCAL,
       X  14432                      GR_COMBINE_LOCAL_ITERATED,
       X  14433                      GR_COMBINE_OTHER_TEXTURE,
       X  14434                      FXFALSE);
       X  14435       do_phong = 1;
       X  14436     } else if (pass == 0xbeef) {
       X  14437       /* Pantone 320C - 3D Green */
       X  14438       grConstantColorValue(0x00989100);
       X  14439       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14440                      GR_COMBINE_FACTOR_LOCAL,
       X  14441                      GR_COMBINE_LOCAL_CONSTANT,
       X  14442                      GR_COMBINE_OTHER_ITERATED,
       X  14443                      FXFALSE);
       X  14444     } else {
       X  14445       sourceTexture(&hiliteImage);
       X  14446       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14447                      GR_COMBINE_FACTOR_ONE,
       X  14448                      GR_COMBINE_LOCAL_NONE,
       X  14449                      GR_COMBINE_OTHER_TEXTURE,
       X  14450                      FXFALSE);
       X  14451     } 
       X  14452     break;
       X  14453   case 1:                       /* fx */
       X  14454     if (pass == 0xbeef) {
       X  14455       /* Black - fx */
       X  14456       grConstantColorValue(0x00);
       X  14457       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14458                      GR_COMBINE_FACTOR_LOCAL,
       X  14459                      GR_COMBINE_LOCAL_CONSTANT,
       X  14460                      GR_COMBINE_OTHER_ITERATED,
       X  14461                      FXFALSE);
       X  14462       do_phong = 1;
       X  14463     } else {
       X  14464       sourceTexture(&hiliteImage);
       X  14465       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14466                      GR_COMBINE_FACTOR_ONE,
       X  14467                      GR_COMBINE_LOCAL_NONE,
       X  14468                      GR_COMBINE_OTHER_TEXTURE,
       X  14469                      FXFALSE);
       X  14470       do_phong = 1;
       X  14471     }
       X  14472     break;
       X  14473   case 2:
       X  14474   case 3:
       X  14475   case 4:
       X  14476     grColorCombine(GR_COMBINE_FUNCTION_LOCAL,
       X  14477                    GR_COMBINE_FACTOR_NONE,
       X  14478                    GR_COMBINE_LOCAL_ITERATED,
       X  14479                    GR_COMBINE_OTHER_NONE,
       X  14480                    FXFALSE);
       X  14481     do_phong = 0;

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14482     break;
       X  14483   }
       X  14484 }
       X  14485 
       X  14486 static void 
       X  14487 calculateIntensity(int material_index, 
       X  14488                    Vector intensity_factor, 
       X  14489                    int frame) 
       X  14490 {
       X  14491   switch(material_index) {
       X  14492   case 0:
       X  14493     /* 3d */
       X  14494     intensity_factor[0] = 1.0f;
       X  14495     intensity_factor[1] = 1.0f;
       X  14496     intensity_factor[2] = 1.0f;
       X  14497     break;
       X  14498   case 1:
       X  14499     /* fx */
       X  14500     intensity_factor[0] = 0.125f;
       X  14501     intensity_factor[1] = 0.125f;
       X  14502     intensity_factor[2] = 0.125f;
       X  14503     break;
       X  14504   case 2:
       X  14505     /* cyan */
       X  14506     intensity_factor[0] = (10.0f / 255.0f);
       X  14507     intensity_factor[1] = (75.0f / 255.0f);
       X  14508     intensity_factor[2] = (120.0f / 255.0f);
       X  14509     break;
       X  14510   case 3:
       X  14511     /* white */
       X  14512     intensity_factor[0] = 1.0f;
       X  14513     intensity_factor[1] = 1.0f;
       X  14514     intensity_factor[2] = 1.0f;
       X  14515     break;
       X  14516   case 4:
       X  14517     /* yellow */
       X  14518     intensity_factor[0] = (248.0f / 255.0f);
       X  14519     intensity_factor[1] = (204.0f / 255.0f);
       X  14520     intensity_factor[2] = 0.0f;
       X  14521     break;
       X  14522   }
       X  14523 }
       X  14524 
       X  14525 static void 
       X  14526 drawFaces(int frame, int objnum) 
       X  14527 {
       X  14528   int facenum;
       X  14529   int material_index;
       X  14530   float intensity_factor[3];
       X  14531   GrVertex gvert[3];
       X  14532   static int prev_mat_index = 0xffff;
       X  14533   int i;
       X  14534   FxBool aa_a, aa_b, aa_c;
       X  14535     
       X  14536   for(facenum = 0; facenum < num_faces[objnum]; facenum++)  {
       X  14537     material_index = face[objnum][facenum].mat_index;
       X  14538     if(material_index != prev_mat_index)  {

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14539       setupMaterial(material_index);
       X  14540       calculateIntensity(material_index,
       X  14541                          intensity_factor, frame);
       X  14542       prev_mat_index = material_index;
       X  14543     }
       X  14544         
       X  14545     if((material_index != 0) && (pass == 2))
       X  14546       continue;
       X  14547           
       X  14548     aa_a = aa_b = aa_c = FXFALSE;
       X  14549     if(face[objnum][facenum].aa_edge_flags & 4)
       X  14550       aa_a = FXTRUE;
       X  14551     if(face[objnum][facenum].aa_edge_flags & 2)
       X  14552       aa_b = FXTRUE;
       X  14553     if(face[objnum][facenum].aa_edge_flags & 1)
       X  14554       aa_c = FXTRUE;
       X  14555         
       X  14556     for(i = 0; i < 3; i++) {
       X  14557       float *transformed_vert, *transformed_norm;
       X  14558       Vert *v;
       X  14559       int vertnum;
       X  14560       float factor;
       X  14561             
       X  14562       vertnum = face[objnum][facenum].v[i];
       X  14563       transformed_vert = transformed_verts[vertnum];
       X  14564       transformed_norm = transformed_norms[vertnum];
       X  14565       v = &vert[objnum][vertnum];
       X  14566             
       X  14567       gvert[i].x = transformed_vert[0];
       X  14568       gvert[i].y = transformed_vert[1];
       X  14569       gvert[i].oow = 1.0f / transformed_vert[2];
       X  14570       gvert[i].tmuvtx[0].oow = gvert[i].oow;
       X  14571       gvert[i].tmuvtx[0].sow = v->s * gvert[i].oow;
       X  14572       gvert[i].tmuvtx[0].tow = v->t * gvert[i].oow;
       X  14573             
       X  14574       factor = ((light[0] * transformed_norm[0] + 
       X  14575                  light[1] * transformed_norm[1] + 
       X  14576                  light[2] * transformed_norm[2])+ 1.0f) * 127.5f;
       X  14577 
       X  14578       gvert[i].r = factor * intensity_factor[0];
       X  14579       gvert[i].g = factor * intensity_factor[1];
       X  14580       gvert[i].b = factor * intensity_factor[2];
       X  14581       gvert[i].a = 255.0f;
       X  14582     }
       X  14583         
       X  14584     if(pass == 2) {
       X  14585       for(i = 0; i < 3; i++) {
       X  14586         float *transformed_norm;
       X  14587                 
       X  14588         transformed_norm = 
       X  14589           transformed_norms[face[objnum][facenum].v[i]];
       X  14590                 
       X  14591         gvert[i].tmuvtx[0].sow = gvert[i].oow * 
       X  14592           (128.0f + transformed_norm[0] * 128.0f);
       X  14593         gvert[i].tmuvtx[0].tow = gvert[i].oow * 
       X  14594           (128.0f + transformed_norm[1] * 128.0f);
       X  14595                 

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14596         gvert[i].r = intensity_factor[0] * 255.0f;
       X  14597         gvert[i].g = intensity_factor[1] * 255.0f;
       X  14598         gvert[i].b = intensity_factor[2] * 255.0f;
       X  14599       }                 
       X  14600             
       X  14601       grDrawTriangle(&gvert[0], &gvert[1], &gvert[2]);
       X  14602             
       X  14603       continue;
       X  14604     }
       X  14605         
       X  14606     grAlphaBlendFunction(GR_BLEND_SRC_ALPHA, GR_BLEND_ONE_MINUS_SRC_ALPHA, 
       X  14607                          GR_BLEND_ONE, GR_BLEND_ZERO);
       X  14608     /* Do this if 3D. */
       X  14609     if(material_index == 0) {
       X  14610       /*
       X  14611        * Draw the textured 3D without specular. 
       X  14612        */
       X  14613       sourceTexture(&textImage);
       X  14614 #if 0
       X  14615       grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14616                      GR_COMBINE_FACTOR_LOCAL,
       X  14617                      GR_COMBINE_LOCAL_ITERATED,
       X  14618                      GR_COMBINE_OTHER_TEXTURE,
       X  14619                      FXFALSE);
       X  14620 #endif
       X  14621       grAADrawTriangle(&gvert[0], &gvert[1], &gvert[2], 
       X  14622                        aa_a, aa_b, aa_c);
       X  14623     } else if(material_index != 1) {
       X  14624       /*
       X  14625        * Just go ahead and draw for things that don't
       X  14626        * have specular highlights.
       X  14627        */
       X  14628       grAADrawTriangle(&gvert[0], &gvert[1], &gvert[2],
       X  14629                        aa_a, aa_b, aa_c);
       X  14630     }
       X  14631         
       X  14632     if(do_phong && (material_index != 0)) {
       X  14633       /* 
       X  14634        * figure out texture coords in [0..255.0f] based on the normal
       X  14635        * the specular highlight.
       X  14636        */
       X  14637       for(i = 0; i < 3; i++) {
       X  14638         float *transformed_norm;
       X  14639                 
       X  14640         transformed_norm = 
       X  14641           transformed_norms[face[objnum][facenum].v[i]];
       X  14642                 
       X  14643         gvert[i].tmuvtx[0].sow = gvert[i].oow * 
       X  14644           (128.0f + transformed_norm[0] * 128.0f);
       X  14645         gvert[i].tmuvtx[0].tow = gvert[i].oow * 
       X  14646           (128.0f + transformed_norm[1] * 128.0f);
       X  14647                 
       X  14648         gvert[i].r = intensity_factor[0] * 255.0f;
       X  14649         gvert[i].g = intensity_factor[1] * 255.0f;
       X  14650         gvert[i].b = intensity_factor[2] * 255.0f;
       X  14651       }                 
       X  14652             

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14653       grAADrawTriangle(&gvert[0], &gvert[1], &gvert[2], 
       X  14654                        aa_a, aa_b, aa_c);
       X  14655     }
       X  14656   }
       X  14657 }
       X  14658 
       X  14659 static void 
       X  14660 intersectLineWithZPlane(Vector result, Vector p1, 
       X  14661                         Vector p2, float z) 
       X  14662 {
       X  14663   float t;
       X  14664   
       X  14665   t = (z - p1[2]) / (p2[2] - p1[2]);
       X  14666   result[0] = p1[0] + (p2[0] - p1[0]) * t;
       X  14667   result[1] = p1[1] + (p2[1] - p1[1]) * t;
       X  14668   result[2] = z;
       X  14669 }
       X  14670 
       X  14671 static float 
       X  14672 vectorMag(float *v) 
       X  14673 {
       X  14674   return (float)sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
       X  14675 }
       X  14676 
       X  14677 static void 
       X  14678 drawShadow(int frame, int shadow_object_index, 
       X  14679            int receiver_object_index, Vector light_position) 
       X  14680 {
       X  14681   float *shadow_object_matrix;
       X  14682   float *receiver_object_matrix;
       X  14683   Vector view_verts[4];
       X  14684   Vector projected_view_verts[4];
       X  14685   int i;
       X  14686   
       X  14687   Vector local_verts[4] = {
       X  14688     { -280.0f, 0.0f, -160.0f },
       X  14689     { -280.0f, 0.0f,  150.0f },
       X  14690     {  280.0f, 0.0f,  150.0f },
       X  14691     {  280.0f, 0.0f, -160.0f } 
       X  14692   };
       X  14693   
       X  14694   float texcoords[4][2] = {
       X  14695     {  10.5f, 127.5f },
       X  14696     {  10.5f,   0.5f },
       X  14697     { 255.0f,   0.5f },
       X  14698     { 255.0f, 127.5f }
       X  14699   };
       X  14700   
       X  14701   GrVertex gvert[4];
       X  14702   GrVertex projected_gvert[4];
       X  14703   GrVertex light_gvert;
       X  14704   
       X  14705   /*
       X  14706    * The point relative to the back part of the shield that 
       X  14707    * the shadow is going to be projected onto.
       X  14708    */
       X  14709   Vector shadow_light;

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14710   
       X  14711   shadow_light[0] = light_position[0];
       X  14712   shadow_light[1] = light_position[1];
       X  14713   shadow_light[2] = light_position[2];
       X  14714   
       X  14715   shadow_object_matrix   = &mat[frame][shadow_object_index][0];
       X  14716   receiver_object_matrix = &mat[frame][receiver_object_index][0];
       X  14717   
       X  14718   /*
       X  14719    * Offset the light by the Z position of 
       X  14720    * the backplane that we are projected
       X  14721    * onto.
       X  14722    */
       X  14723   shadow_light[2] += receiver_object_matrix[14];
       X  14724   
       X  14725   for(i = 0; i < 4; i++) {
       X  14726     vecMatMult(view_verts[i], local_verts[i], shadow_object_matrix);
       X  14727         
       X  14728     /*
       X  14729      * project . . . 
       X  14730      */
       X  14731     gvert[i].oow = 1.0f / view_verts[i][2];
       X  14732     gvert[i].x = 
       X  14733       view_verts[i][0] * gvert[i].oow * viewPort[0] + 
       X  14734         viewPort[1] + SNAP_BIAS;
       X  14735     gvert[i].y = 
       X  14736       view_verts[i][1] * gvert[i].oow * viewPort[2] + 
       X  14737         viewPort[3] + SNAP_BIAS;
       X  14738         
       X  14739     /*
       X  14740      * Set up texture coordinates.
       X  14741      */
       X  14742     gvert[i].tmuvtx[0].sow = texcoords[i][0] * gvert[i].oow;
       X  14743     gvert[i].tmuvtx[0].tow = texcoords[i][1] * gvert[i].oow;
       X  14744   }
       X  14745   
       X  14746   
       X  14747   /*
       X  14748    * Intersect each line formed by the light source and a
       X  14749    * particular corner of the shadow object with the 
       X  14750    * plane which the texture is to be projected onto.
       X  14751    */
       X  14752   for(i = 0; i < 4; i++) {
       X  14753     Vector tmpvect;
       X  14754     float q;
       X  14755 
       X  14756 #if GLIDE_PACKED_RGB
       X  14757     /* dpc - 22 oct 1997 - FixMe!
       X  14758      * These are left uninitialized, yet they are being sent to the
       X  14759      * hw, probably because some other state is not being correctly
       X  14760      * setup. This doesn't seem to affect the 'correctness' of the
       X  14761      * splash screen so I'm not investigating it any more.  
       X  14762      */
       X  14763     projected_gvert[i].r = 
       X  14764     projected_gvert[i].g = 
       X  14765     projected_gvert[i].b = 
       X  14766     projected_gvert[i].a = 0.0f;

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14767 #endif /* GLIDE_PACKED_RGB */
       X  14768         
       X  14769     intersectLineWithZPlane(projected_view_verts[i], 
       X  14770                             shadow_light, 
       X  14771                             view_verts[i], 
       X  14772                             receiver_object_matrix[14] - 26.0f);
       X  14773     projected_gvert[i].oow = 1.0f / projected_view_verts[i][2];
       X  14774     projected_gvert[i].x = (projected_view_verts[i][0] * projected_gvert[i].oow * viewPort[0] +
       X  14775                             viewPort[1] + SNAP_BIAS);
       X  14776     projected_gvert[i].y = (projected_view_verts[i][1] * projected_gvert[i].oow * viewPort[2] +
       X  14777                             viewPort[3] + SNAP_BIAS);
       X  14778         
       X  14779     tmpvect[0] = projected_view_verts[i][0] - shadow_light[0];
       X  14780     tmpvect[1] = projected_view_verts[i][1] - shadow_light[1];
       X  14781     tmpvect[2] = projected_view_verts[i][2] - shadow_light[2];
       X  14782     q = vectorMag(tmpvect);
       X  14783         
       X  14784     /*
       X  14785      * Set up texture coordinates.
       X  14786      */
       X  14787     projected_gvert[i].tmuvtx[0].oow = projected_gvert[i].oow * q;
       X  14788     projected_gvert[i].tmuvtx[0].sow = texcoords[i][0] * projected_gvert[i].oow;
       X  14789     projected_gvert[i].tmuvtx[0].tow = texcoords[i][1] * projected_gvert[i].oow;
       X  14790   }
       X  14791   
       X  14792   light_gvert.oow = 1.0f / shadow_light[2];
       X  14793   light_gvert.x = shadow_light[0] * light_gvert.oow * viewPort[0] + viewPort[1] + SNAP_BIAS;
       X  14794   light_gvert.y = shadow_light[1] * light_gvert.oow * viewPort[2] + viewPort[3] + SNAP_BIAS;
       X  14795   
       X  14796   /*
       X  14797    * Draw a segment between the light and the point which hits
       X  14798    * the surface that the light is being projected onto.
       X  14799    */
       X  14800   grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
       X  14801                  GR_COMBINE_FACTOR_ONE,
       X  14802                  GR_COMBINE_LOCAL_NONE,
       X  14803                  GR_COMBINE_OTHER_TEXTURE,
       X  14804                  FXFALSE);
       X  14805   sourceTexture(&shadowImage);
       X  14806   
       X  14807   grAlphaBlendFunction(GR_BLEND_DST_COLOR, GR_BLEND_ZERO,
       X  14808                         GR_BLEND_ONE, GR_BLEND_ZERO);
       X  14809 
       X  14810   grDrawTriangle(&projected_gvert[0], 
       X  14811                  &projected_gvert[1], 
       X  14812                  &projected_gvert[2]);
       X  14813   grDrawTriangle(&projected_gvert[0], 
       X  14814                  &projected_gvert[2], 
       X  14815                  &projected_gvert[3]);
       X  14816   grDrawTriangle(&projected_gvert[0], 
       X  14817                  &projected_gvert[2], 
       X  14818                  &projected_gvert[1]);
       X  14819   grDrawTriangle(&projected_gvert[0], 
       X  14820                  &projected_gvert[3], 
       X  14821                  &projected_gvert[2]);
       X  14822   
       X  14823   grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ZERO,

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14824                        GR_BLEND_ONE, GR_BLEND_ZERO);
       X  14825   
       X  14826 }
       X  14827 
       X  14828 
       X  14829 /*-------------------------------------------------------------------
       X  14830   Function: grSplash
       X  14831   Date: 3/13
       X  14832   Implementor(s): GaryMcT
       X  14833   Library: Glide
       X  14834   Description:
       X  14835   Render the opening splash screen animation, or render
       X  14836   a single frame of the splash screen.
       X  14837   Arguments:
       X  14838   x, y - upper left hand coord of window
       X  14839   w, h - width and height of window to render
       X  14840   _frame - frame number to render (~0 to render all frames)
       X  14841   Return:
       X  14842   none
       X  14843   -------------------------------------------------------------------*/
       X  14844 GR_DIENTRY(grSplash,void,(float x,float y,float w,float h,FxU32 _frame))
       X  14845 {
       X  14846   GrState oldState;
       X  14847   int frame;
       X  14848   Vector lights[] = {
       X  14849     { 5.0f, 300.0f, -1500.0f },
       X  14850     { 5.0f, 150.0f, -1000.0f },
       X  14851     { -30.0f, 150.0f, -1000.0f },
       X  14852     { -30.0f, 100.0f, -1000.0f },
       X  14853     { 30.0f, 70.0f, -1000.0f },
       X  14854   };
       X  14855   GrFog_t fogTable[kInternalFogTableEntryCount];
       X  14856   int fadeInFrames, fadeOutFrames;
       X  14857 
       X  14858   GR_BEGIN_NOFIFOCHECK("grSplash", 85);
       X  14859   GDBG_INFO_MORE(gc->myLevel,"(%f,%f,%f,%f,%d)\n", x, y, w, h, _frame);
       X  14860 
       X  14861   /* Check Screen Dimensions and Check Avail of Depth Buffer */
       X  14862   if ((x > gc->state.screen_width) || 
       X  14863       ((x+w) > gc->state.screen_width) ||
       X  14864       (y > gc->state.screen_height) ||
       X  14865       ((y+h) > gc->state.screen_height)) 
       X  14866     return;
       X  14867 
       X  14868   if (gc->state.screen_height == 640) {
       X  14869     if (gc->fbuf_size == 1) {
       X  14870       return;
       X  14871     }
       X  14872   } else if (gc->state.screen_width == 800) {
       X  14873     if ((gc->fbuf_size == 1) ||
       X  14874         (gc->fbuf_size == 2)) {
       X  14875       return;
       X  14876     }
       X  14877   }
       X  14878 
       X  14879   if (gc->grAuxBuf == 0) return;
       X  14880 

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14881   if (!(gc->state.fbi_config.fbzMode & SST_YORIGIN)) {
       X  14882     y = ((gc->state.screen_height - 1.0f) - (h-1.0f)) - y;
       X  14883   }
       X  14884         
       X  14885   viewPort[0] = w *  (480.0f / 640.0f);
       X  14886   viewPort[1] = x + (w / 2.0f);
       X  14887   viewPort[2] = h;
       X  14888   viewPort[3] = y + (h / 2.0f);
       X  14889 
       X  14890   grGlideGetState(&oldState);
       X  14891 
       X  14892   grSstOrigin(GR_ORIGIN_LOWER_LEFT);
       X  14893 
       X  14894   if (_frame == 0) {
       X  14895     createTextures();
       X  14896     useTextures = 1;
       X  14897   } else {
       X  14898     useTextures = 0;
       X  14899   }
       X  14900 
       X  14901   grAlphaTestFunction(GR_CMP_ALWAYS);
       X  14902   grChromakeyMode(GR_CHROMAKEY_DISABLE);
       X  14903   grConstantColorValue(0xffffffff);
       X  14904   grDepthBufferMode(GR_DEPTHBUFFER_WBUFFER);
       X  14905   grDepthMask(FXTRUE);
       X  14906   grAlphaCombine(GR_COMBINE_FUNCTION_LOCAL,
       X  14907                  GR_COMBINE_FACTOR_NONE,
       X  14908                  GR_COMBINE_LOCAL_ITERATED,
       X  14909                  GR_COMBINE_OTHER_NONE,
       X  14910                  FXFALSE);
       X  14911   grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ZERO,
       X  14912                        GR_BLEND_ONE, GR_BLEND_ZERO);
       X  14913   if (useTextures)
       X  14914     grTexCombine(GR_TMU0, 
       X  14915                  GR_COMBINE_FUNCTION_LOCAL, GR_COMBINE_FACTOR_NONE,
       X  14916                  GR_COMBINE_FUNCTION_NONE, GR_COMBINE_FACTOR_NONE,
       X  14917                  FXFALSE, FXFALSE);
       X  14918   else
       X  14919     grTexCombine(GR_TMU0,
       X  14920                  GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
       X  14921                  GR_COMBINE_FUNCTION_NONE, GR_COMBINE_FACTOR_NONE,
       X  14922                  FXTRUE, FXFALSE);
       X  14923   grTexMipMapMode(GR_TMU0,
       X  14924                   GR_MIPMAP_NEAREST,
       X  14925                   FXFALSE);
       X  14926   grTexFilterMode(GR_TMU0,
       X  14927                   GR_TEXTUREFILTER_BILINEAR,
       X  14928                   GR_TEXTUREFILTER_BILINEAR);
       X  14929   grDepthBufferFunction(GR_CMP_LEQUAL);
       X  14930   grCullMode(GR_CULL_NEGATIVE);
       X  14931   /* grClipWindow((int)x, (int)y, (int)(x+w), (int)(y+h)); */
       X  14932   grFogColorValue(0x0);
       X  14933   
       X  14934   fadeInFrames  = (int)(((float)total_num_frames) * FADEIN_END_PERCENT);
       X  14935   fadeOutFrames = (int)(((float)total_num_frames) * 
       X  14936                         (1.0f - FADEOUT_BEGIN_PERCENT));
       X  14937 

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14938   if (_frame == 0) {          /* Render Whole Animation */
       X  14939     for(frame = 1; frame < total_num_frames; frame++) {
       X  14940       int i;
       X  14941             
       X  14942       /* Set Fog Value For This Frame */
       X  14943       if(frame < fadeInFrames)  {
       X  14944         unsigned char fval = (((unsigned char)0xFF) - 
       X  14945                               ((unsigned char)(255.0f * (float)(frame + 1) / (float)fadeInFrames)));
       X  14946         for(i = 0; i < kInternalFogTableEntryCount; i++) fogTable[i] = fval;
       X  14947         grFogMode(GR_FOG_WITH_TABLE);
       X  14948         grFogTable(fogTable);
       X  14949         fog = 1;
       X  14950       } else if(frame > total_num_frames-fadeOutFrames) {
       X  14951         unsigned char fval = (((unsigned char)0xFF) - 
       X  14952                               (unsigned char)(255.0f* ((float)(total_num_frames - frame))/ 
       X  14953                                               ((float)fadeOutFrames)));
       X  14954         for(i = 0; i < kInternalFogTableEntryCount; i++) 
       X  14955           fogTable[i] = fval;
       X  14956         grFogMode(GR_FOG_WITH_TABLE);
       X  14957         grFogTable(fogTable);
       X  14958         fog = 1;
       X  14959       } else  {
       X  14960         grFogMode(GR_FOG_DISABLE);
       X  14961         fog = 0;
       X  14962       }
       X  14963         
       X  14964       grBufferClear(0x00000000, 0, GR_WDEPTHVALUE_FARTHEST);
       X  14965         
       X  14966       pass = 1;
       X  14967 
       X  14968       /*
       X  14969        * Avoid Z-aliasing between the shield and the 3dfx by
       X  14970        * not writing Z for the shield.
       X  14971        */
       X  14972 
       X  14973       grDepthMask(FXFALSE);
       X  14974       /* cyan part of shield */
       X  14975       xfAndProj(frame, 2);
       X  14976       drawFaces(frame, 2);
       X  14977       
       X  14978       /* yellow and white part of shield. */
       X  14979       xfAndProj(frame, 0);
       X  14980       drawFaces(frame, 0);
       X  14981 
       X  14982       /*
       X  14983        * Reanable writes to the depth-buffer.
       X  14984        */
       X  14985       grDepthMask(FXTRUE);
       X  14986 
       X  14987       /*
       X  14988        * Draw the shadow projected from the 3Dfx logo onto
       X  14989        * the rest of the powershield.
       X  14990        */
       X  14991       grDepthBufferFunction(GR_CMP_ALWAYS);
       X  14992       grFogMode(GR_FOG_DISABLE);
       X  14993       drawShadow(frame, 1, 0, lights[0]);
       X  14994       if (fog) grFogMode(GR_FOG_WITH_TABLE); /* hack around mp fog */

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

       X  14995       grDepthBufferFunction(GR_CMP_LEQUAL);
       X  14996 
       X  14997       /* 3Dfx logo */
       X  14998       xfAndProj(frame, 1);
       X  14999       drawFaces(frame, 1);
       X  15000       grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ONE,
       X  15001                            GR_BLEND_ONE, GR_BLEND_ZERO);
       X  15002 
       X  15003       pass = 2;
       X  15004       drawFaces(frame, 1);
       X  15005       pass = 1;
       X  15006       grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ZERO,
       X  15007                            GR_BLEND_ONE, GR_BLEND_ZERO);
       X  15008 
       X  15009       grBufferSwap(2);
       X  15010     }
       X  15011   } else {                      /* Render One Frame */
       X  15012     frame = ((_frame>>1) % SPIN_FRAMES)+SPIN_START;
       X  15013         
       X  15014     grColorMask(FXFALSE, FXFALSE);
       X  15015     grBufferClear(0x00000000, 0, GR_WDEPTHVALUE_FARTHEST);
       X  15016     grColorMask(FXTRUE, FXFALSE);
       X  15017         
       X  15018     pass = 0xbeef;
       X  15019         
       X  15020     /* 3Dfx logo */
       X  15021     xfAndProj(frame, 1);
       X  15022     drawFaces(frame, 1);
       X  15023   }
       X  15024 
       X  15025   /* Get rid of the remnants on teh screen just in case
       X  15026    * the app (like PowerRender) doesn't do it itself yet
       X  15027    * assumes that the screen is clear.
       X  15028    */
       X  15029   if (frame == 0) {
       X  15030     int i;
       X  15031     
       X  15032     for(i = 0; i < gc->grColBuf; i++) {
       X  15033       grBufferClear(0x00000000, 0, GR_WDEPTHVALUE_FARTHEST);
       X  15034       grBufferSwap(0);
       X  15035     }
       X  15036   }
       X  15037     
       X  15038   /*
       X  15039    * Clean up after yourself!
       X  15040    */
       X  15041   grGlideSetState(&oldState);
       X  15042 
       X  15043 }
       X  15044 
       X  15045 #endif /* GLIDE_SPLASH */

GSPLASH                         Source Listing                   9-MAY-2021 23:43:01  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             8-MAY-2021 19:33:14  gsplash.c;3

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSPLASH/OBJECT=[
.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSPLASH.OBJ/INCLUDE_DIRECTORY=([.GLI
DE.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.
GLIDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_
TRISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLID
E_LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSPLASH.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:01"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


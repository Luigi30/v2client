SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 1
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 */
	     21 
	     22 /*
	     23 ** Initialization code for SST-1 board.
	     24 **
	     25 ** NOTE: This code must compiled with optimizations DISABLED!!
	     26 **
	     27 ** The following environment variables can optionally be used to alter 
	     28 ** functionality (A value of X is a "don't care"):
	     29 **
	     30 ** Variable                    Value   Description
	     31 ** --------                    -----   -----------
	     32 ** SSTV2_ARCADE                  X       Allow special configs for arcade use
	     33 ** SSTV2_ALLOC_AUX               {0,1}   Number of aux. buffers to allocate
	     34 ** SSTV2_ALLOC_COLOR             {2,3}   Number of color buffers to allocate
	     35 ** SSTV2_BACKPORCH               hex     Specify value of backPorch video register
	     36 ** SSTV2_BOARDS                  val     Specify number of SST-1 boards in system
	     37 ** SSTV2_CMDFIFO_DIRECT          X       Enable Direct Execution of CMDFIFO
	     38 ** SSTV2_CMDFIFO_NOHOLES         X       Disable hole counting feature in CMDFIFO
	     39 ** SSTV2_DEBUGDAC                X       Print out debug information for DAC
	     40 **                                       reads and writes
	     41 ** SSTV2_DEVICEID                X       Specify the device ID value passed to
	     42 **                                       the PCI library
	     43 ** SSTV2_DIMENSIONS              hex     Specify value of videoDimensions register
	     44 ** SSTV2_FASTMEM_RAS_READS       X       Allow fast ras reads
	     45 ** SSTV2_FASTPCIRD               X       Enable fast PCI reads
	     46 ** SSTV2_FBICFG                  hex     Specify FBI configuration strapping bits
	     47 ** SSTV2_FBI_MEMSIZE             val     Specify amount of frame buffer memory
	     48 ** SSTV2_FT_CLKDEL               hex     Fbi-to-Trex clock delay value
	     49 ** SSTV2_GAMMA                   float   Floating point value for gamma correction
	     50 ** SSTV2_GRXCLK                  val     16 <= Frequency < 80 (50 is default)
	     51 ** SSTV2_HSYNC                   hex     Specify value of hSync video register
	     52 ** SSTV2_IGNORE_CLKDELAYS        X       Ignore calls to sst1InitSetClkDelays()
	     53 ** SSTV2_IGNORE_IDLE             X       Ignore calls to sst1InitIdle*()
	     54 ** SSTV2_IGNORE_INIT_GAMMA       X       Bypass sst1InitGamma call and return
	     55 ** SSTV2_IGNORE_INIT_REGISTERS   X       Bypass sst1InitRegisters call and return
	     56 ** SSTV2_IGNORE_INIT_VIDEO       X       Bypass sst1InitVideo call and return
	     57 ** SSTV2_INITDEBUG               X       Enable debug output

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 2
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

	     58 ** SSTV2_INITDEBUG_FILE          file    File to direct all debug output
	     59 ** SSTV2_MEMFIFO                 0       Disable FBI Memory FIFO
	     60 ** SSTV2_MEMFIFO                 1       Enable FBI Memory FIFO
	     61 ** SSTV2_MEMFIFO_ENTRIES         hex     Set number of entries in memory fifo
	     62 ** SSTV2_MEMFIFO_HWM             hex     Set memory fifo high water mark
	     63 ** SSTV2_MEMFIFO_LFB             {0,1}   Specify LFB writes through Memory FIFO
	     64 ** SSTV2_MEMFIFO_LWM             hex     Set memory fifo low water mark
	     65 ** SSTV2_MEMFIFO_TEX             {0,1}   Specify Texture writes through Mem FIFO
	     66 ** SSTV2_MEMOFFSET               hex     Specify value of memoffset video register
	     67 ** SSTV2_NOCHECKHANG             X       Do not Check for FBI Hangs for texturing
	     68 ** SSTV2_NODEVICEINFO            X       Ignore calls to sst1InitFillDeviceInfo()
	     69 ** SSTV2_NOSHUTDOWN              X       Do not turn off monitor refresh on call
	     70 **                                       to sst1InitShutdown()
	     71 ** SSTV2_NUM_TMUS                {1,2,3} Specify number of TMUs detected
	     72 ** SSTV2_PCIFIFO_LWM             hex     Set pci fifo low water mark
	     73 ** SSTV2_PFT_CLKDEL              hex     Preliminary Fbi-to-Trex clock delay value
	     74 ** SSTV2_PTF0_CLKDEL             hex     Prelim TMU2Fbi clock delay value (TMU #0)
	     75 ** SSTV2_PTF1_CLKDEL             hex     Prelim TMU2Fbi clock delay value (TMU #1)
	     76 ** SSTV2_PTF2_CLKDEL             hex     Prelim TMU2Fbi clock delay value (TMU #2)
	     77 ** SSTV2_SIPROCESS_CNTR          hex     Silicon process monitor PCI counter load
	     78 ** SSTV2_SLIDETECT               {0,1}   Specify Scanline Interleaving detection
	     79 ** SSTV2_SLIM_VIN_CLKDEL         hex     Specify FBI internal video clock delay
	     80 **                                       (SLI Master)
	     81 ** SSTV2_SLIM_VOUT_CLKDEL        hex     Specify FBI external video clock delay
	     82 **                                       (SLI Master)
	     83 ** SSTV2_SLIS_VIN_CLKDEL         hex     Specify FBI internal video clock delay
	     84 **                                       (SLI Slave)
	     85 ** SSTV2_SLIS_VOUT_CLKDEL        hex     Specify FBI external video clock delay
	     86 **                                       (SLI Slave)
	     87 ** SSTV2_SCREENREFRESH           {60,75, Select monitor refresh rate
	     88 **                               85,120}
	     89 ** SSTV2_SCREENREZ               {512,   Select monitor resolution (512x384)
	     90 **                               512256, (512x256)
	     91 **                               640400, (640x400)
	     92 **                               640,    (640x480)
	     93 **                               800,    (800x600)
	     94 **                               856,    (856x600)
	     95 **                               960,    (960x720)
	     96 **                               1024}   (1024x768)
	     97 ** SSTV2_SLOWMEM_RTW             X       Insert wait state for read-to-write 
	     98 **                                       transitions
	     99 ** SSTV2_SLOWMEM_WTR             X       Insert wait state for write-to-read 
	    100 **                                       transitions
	    101 ** SSTV2_SLOWPCIWR               X       Enable 1 wait-state PCI writes
	    102 ** SSTV2_SLISWAP                 1       Use dac_data[0] for SLI swapping
	    103 ** SSTV2_SWAPBOARDS              X       Swap order of mapping boards
	    104 ** SSTV2_TEXMAP_DISABLE          X       Disable texture mapping
	    105 ** SSTV2_TF0_CLKDEL              hex     Trex-to-Fbi clock delay value (TMU #0)
	    106 ** SSTV2_TF1_CLKDEL              hex     Trex-to-Fbi clock delay value (TMU #1)
	    107 ** SSTV2_TF2_CLKDEL              hex     Trex-to-Fbi clock delay value (TMU #2)
	    108 ** SSTV2_TF_FIFO_THRESH          hex     Set TREX-to-FBI FIFO threshold
	    109 ** SSTV2_TILESINX                hex     Specify value of tilesInX video register
	    110 ** SSTV2_TMUCFG                  hex     Specify TMU configuration strapping bits
	    111 ** SSTV2_TMUMEM                  X       Enable accurate determination of TMU mem
	    112 ** SSTV2_TMU_MEMSIZE             val     Specify amount of texture memory
	    113 ** SSTV2_TREX0INIT0              hex     Set trexInit0 register value - TMU #0
	    114 ** SSTV2_TREX0INIT1              hex     Set trexInit1 register value - TMU #0

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 3
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

	    115 ** SSTV2_TREX1INIT0              hex     Set trexInit0 register value - TMU #1
	    116 ** SSTV2_TREX1INIT1              hex     Set trexInit1 register value - TMU #1
	    117 ** SSTV2_TREX2INIT0              hex     Set trexInit0 register value - TMU #2
	    118 ** SSTV2_TREX2INIT1              hex     Set trexInit1 register value - TMU #2
	    119 ** SSTV2_VIN_CLKDEL              hex     Specify FBI internal video clock delay
	    120 ** SSTV2_VOUT_CLKDEL             hex     Specify FBI external video clock delay
	    121 ** SSTV2_VGA_PASS                {0,1}   Force VGA_PASS output to {0,1}
	    122 ** SSTV2_VIDCLK2X                val     Video clock frequency (2x dot clock)
	    123 ** SSTV2_VIDEO_24BPP             0       Select 16-bit video output
	    124 ** SSTV2_VIDEO_24BPP             1       Select 24-bit video output
	    125 ** SSTV2_VIDEO_DISABLE           X       Turn off Video/Monitor refresh in FBI
	    126 ** SSTV2_VIDEO_FILTER_DISABLE    X       Disable video filtering
	    127 ** SSTV2_VIDEO_FILTER_THRESHOLD  hex     Set video filtering threshold
	    128 ** SSTV2_VIDEO_NOCLEAR           X       Do not clear buffers in sst1InitVideo()
	    129 ** SSTV2_VIDEO_CLEARCOLOR        hex     Clear screen color
	    130 ** SSTV2_VFIFO_THRESH            {0-31}  Select video fifo threshold
	    131 ** SSTV2_VSYNC                   hex     Specify value of vSync video register
	    132 ** SSTV2_NOREMAP                 0       Don't try to remap single board sli.
	    133 ** SSTV2_MISMATCHED_SLI          X       Allow mismatched SLI
	    134 **
	    135 ** VOODOO2_FILE                  name    Filename used in place of "voodoo2.ini"
	    136 ** VOODOO2_PATH                  path    Path used to locate "voodoo2.ini" file
	    137 **
	    138 */
	    139 
	    140 extern unsigned short int channel;
	    141 #include <starlet.h>
	  14239 #include <iodef.h>
	  16115 #include <ints.h>
	  16193 
	  16194 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
	  16195 
       X  16196 #ifdef _MSC_VER
       X  16197 #pragma optimize ("",off)
       X  16198 #endif
	  16199 #include <stdio.h>
	  17810 #include <stdlib.h>
	  19905 #include <math.h>
       X  20797 #ifdef BUILD_FOR_SST1
       X  20798 #include <sst.h>
       X  20799 #else
	  20800 #include <3dfx.h>
	  20931 #include <cvgregs.h>
	  21159 #include <cvgdefs.h>
	  22100 #endif
	  22101 #include <fxpci.h>
	  22364 #define SST1INIT_ALLOCATE // Allocate variables in sst1init.h
	  22365 #define FX_DLL_DEFINITION
	  22366 #include <fxdll.h>
	  22487 
	  22488 #if !macintosh && !__linux__
	  22489 #include <fxremap.h>
	  22502 #endif
	  22503 #include <sst1vid.h>
	  22613 #include <sst1init.h>
	  24989 #include "rcver.h"
	  24995 

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 4
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

       X  24996 #ifdef __WIN32__
       X  24997 #include <windows.h>
       X  24998 #endif
	  24999 
	  25000 /*
	  25001 ** sst1InitMapBoard():
	  25002 **  Find and map SST-1 board into virtual memory
	  25003 **
	  25004 **    Returns:
	  25005 **      FxU32 pointer to base of SST-1 board if successful mapping occurs
	  25006 **      FXFALSE if cannot map or find SST-1 board
	  25007 **
	  25008 */
	  25009 FX_EXPORT FxU32 * FX_CSTYLE sst1InitMapBoard(FxU32 BoardNumber)
      1	  25010 {
      1	  25011   FxU32 buf;
      1	  25012   // Make an I/O call to the driver and fetch the linear base.
      1	  25013   sys$qiow(0,
      1	  25014       channel,
      1	  25015       IO$_ACCESS,
      1	  25016       NULL,
      1	  25017       0,
      1	  25018       0,
      1	  25019       (void *)&buf,
      1	  25020       0,
      1	  25021       4,
      1	  25022       0,
      1	  25023       0,
      1	  25024       0);
      1	  25025 
      1	  25026   printf("sst1InitMapBoard: returning base %08X\n", buf);
      1	  25027   return (FxU32 *)buf;
      1	  25028 
      1	  25029     //return(sst1InitMapBoardDirect(BoardNumber, FXTRUE));
      1	  25030 }
	  25031 
	  25032 // Use this flag to force a info clear when doing a
	  25033 // sst1InitMapBoard() for the first time.  sst1InitShutdown()
	  25034 // will also set this flag to TRUE to force a clear
	  25035 // next time around.
	  25036 static FxU32 clearBoardInfo = FXTRUE;
	  25037 
	  25038 FX_EXPORT FxU32 * FX_CSTYLE sst1InitMapBoardDirect(FxU32 BoardNumber, 
	  25039                                                    FxBool resetSLI)
      1	  25040 {
      1	  25041     static FxU32 firstTime = 1;
      1	  25042     FxU32 vendorID = _3DFX_PCI_ID;     // 3Dfx Vendor ID
      1	  25043     FxU32 deviceID;                    // 0x0002 - Look for a Voodoo2 board (0xFFFF - Find any 3Dfx board)
      1	  25044     FxU32 sizeOfCard = 0x1000000;      // 16 MBytes of addr space for SST-1
      1	  25045     FxU32 *sstbase;
      1	  25046     FxU32 j, n;
      1	  25047     FxU32 sstv2_noremap = 0;
      1	  25048     int i;
      1	  25049 
      1	  25050     if( GETENV( ("SSTV2_DEVICEID") ) &&
      1	  25051         (SSCANF(GETENV(("SSTV2_DEVICEID")), "%i", &i) == 1) )
      1	  25052       deviceID = i;

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 5
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25053     else
      1	  25054       deviceID = 0x0002;
      1	  25055 
      1	  25056 #if !DIRECTX
      1	  25057     // Open PCI library (necessary for multiple calls to init routines, after
      1	  25058     // PCI library is closed by pciClose() call in sst1InitShutdown().
      1	  25059     // 
      1	  25060     // NB: It is safe to do this even if we never called pciClose.
      1	  25061     pciOpen();
      1	  25062 #endif
      1	  25063 
      1	  25064     /* NB: firstTime does not get cleared until we actually find a
      1	  25065      * board and get one mapped (A little weird to begin w/, but
      1	  25066      * probably not worth changing at this late date). However,
      1	  25067      * sst1InitMapBoard usually gets called up to MAX_PCI_DEVICES
      1	  25068      * which means that we'll be re-counting and re-mapping boards
      1	  25069      * over and over which is just whacked. Now, if we fail to find
      1	  25070      * any suitable boards via sst1InitNumBoardsInSystem we clear the
      1	  25071      * firstTime flag, and carry on checking for the non-existant
      1	  25072      * board which will (of course) fail to map.  
      1	  25073      */
      2	  25074     if(firstTime) {
      2	  25075       // Find "voodoo2.ini" file if it exists...
      2	  25076       sst1InitUseVoodooFile = sst1InitVoodooFile();
      2	  25077       
      2	  25078       if( GETENV( ("SSTV2_NOREMAP") ) &&
      2	  25079           (SSCANF(GETENV(("SSTV2_NOREMAP")), "%i", &i) == 1) )
      2	  25080         sstv2_noremap = i;
      2	  25081       else
      2	  25082         sstv2_noremap = 0;
      2	  25083 #if !macintosh && !__linux__
      3	  25084       if (!sstv2_noremap) {
      3	  25085         fxremap(); /* remap single board SLI */
      2	  25086       }
      2	  25087 #endif
      3	  25088       if(!(boardsInSystem = sst1InitNumBoardsInSystem())) {
      3	  25089         firstTime = FXTRUE;
      3	  25090         return(NULL);
      2	  25091       }
      1	  25092     }
      1	  25093 
      2	  25094     if( clearBoardInfo ) {
      2	  25095         INIT_PRINTF(("sst1InitMapBoard(): BoardsInSystem = %d\n",
      2	  25096           boardsInSystem));
      2	  25097 
      2	  25098         // Clear board info structure
      2	  25099         sst1InitClearBoardInfo();
      2	  25100         
      2	  25101         clearBoardInfo = FXFALSE;
      2	  25102 
      2	  25103 #if !DIRECTX
      2	  25104         /* dpc - 26 feb 1998
      2	  25105          * If glide is running on windows the a pciClose will close
      2	  25106          * the vxd etc. This is not functionally longer fatal, but w/o
      2	  25107          * it we will not be able to do things like set the caching on
      2	  25108          * the board's memory etc. This is bad. 
      2	  25109          *

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 6
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      2	  25110          * The actual cost of doing the re-mapping again is pretty low
      2	  25111          * because both the pci library and the init code are caching the
      2	  25112          * addresses of the board. However, the call to the pciLibrary
      2	  25113          * to map the board has the side affect of causing the vxd to be
      2	  25114          * loaded. It is this that is responsible for setting up caching.
      2	  25115          */
      2	  25116         firstTime = FXTRUE;
      2	  25117 #endif /* !DIRECTX */
      1	  25118     }
      1	  25119 
      2	  25120     if(firstTime) {
      2	  25121         int boardLoopStart = 0;
      2	  25122         int boardLoopStop = SST1INIT_MAX_BOARDS;
      2	  25123         int boardLoopInc = 1;
      2	  25124         int index = 0;
      2	  25125 
      2	  25126         sst1InitClearBoardInfo();
      3	  25127         if(GETENV(("SSTV2_SWAPBOARDS"))) {
      3	  25128            boardLoopStart = SST1INIT_MAX_BOARDS-1;
      3	  25129            boardLoopStop = -1;
      3	  25130            boardLoopInc = -1;
      2	  25131         }
      2	  25132 
      3	  25133         for(j=0; j<SST1INIT_MAX_BOARDS; j++) {
      3	  25134            sst1BoardInfo[j].virtAddr[0] = (SstRegs *) NULL;
      3	  25135            sst1BoardInfo[j].physAddr[0] = (FxU32) NULL;
      3	  25136            sst1BoardInfo[j].deviceNumber = 0xdead;
      3	  25137            sst1BoardInfo[j].fbiRevision = 0xdead;
      3	  25138            sst1BoardInfo[j].deviceID = 0xdead;
      3	  25139            sst1BoardInfo[j].vendorID = 0xdead;
      2	  25140         }
      2	  25141 
      2	  25142 
      2	  25143         // Map all boards in the system
      2	  25144         // Check that scanline interleaving is not enabled...
      3	  25145         for(j = boardLoopStart; j != (FxU32)boardLoopStop; j += boardLoopInc) {
      3	  25146             sstbase = pciMapCardMulti(vendorID, deviceID, sizeOfCard,
      3	  25147                                       &sst1InitDeviceNumber, j, 0);
      4	  25148             if(sstbase) {
      4	  25149                 sst1BoardInfo[index].virtAddr[0] = (SstRegs *) sstbase;
      4	  25150                 PCICFG_RD(PCI_BASE_ADDRESS_0, sst1BoardInfo[index].physAddr[0]);
      4	  25151                 sst1BoardInfo[index].deviceNumber = sst1InitDeviceNumber;
      4	  25152 
      4	  25153                 //sst1BoardInfo[index].singleBrdSLISlave = 
      4	  25154                 //        ((sst1InitDeviceNumber >> 13) & 0x7);
      5	  25155                 {
      5	  25156                   FxU32 oldFbiRevision, newFbiRevision;
      5	  25157 
      5	  25158                   PCICFG_RD(PCI_REVISION_ID, oldFbiRevision);
      5	  25159                   PCICFG_RD(SST1_PCI_INIT_ENABLE, newFbiRevision);
      5	  25160                   sst1BoardInfo[index].fbiFab =
      5	  25161                     (newFbiRevision & SST_CHUCK_MFTG_ID) >>
      5	  25162                     SST_CHUCK_MFTG_ID_SHIFT;
      5	  25163                   newFbiRevision = (newFbiRevision & SST_CHUCK_REVISION_ID) >>
      5	  25164                     SST_CHUCK_REVISION_ID_SHIFT;
      5	  25165                   if(oldFbiRevision != 0x2 && newFbiRevision < 4)
      5	  25166                      return(NULL);

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 7
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      5	  25167                   sst1BoardInfo[index].fbiRevision = newFbiRevision;
      4	  25168                 }
      4	  25169                 PCICFG_RD(PCI_DEVICE_ID, sst1BoardInfo[index].deviceID);
      4	  25170                 PCICFG_RD(PCI_VENDOR_ID, sst1BoardInfo[index].vendorID);
      4	  25171 
      4	  25172                 // Enable Memory accesses to SST-1
      4	  25173                 // Must be set for PnP BIOS which do not enable memory mapped
      4	  25174                 // accesses (sst1InitSliDetect reads memory mapped regs)
      4	  25175                 PCICFG_WR(PCI_COMMAND, SST_PCIMEM_ACCESS_EN);
      4	  25176                 index++;
      4	  25177             } else {
      4	  25178                 FxU32 code = pciGetErrorCode();
      5	  25179                 if (code != PCI_ERR_NOERR) {
      5X  25180 #ifdef __WIN32__
      5X  25181                   MessageBox(NULL, pciGetErrorString(), NULL, MB_OK);
      5X  25182                   INIT_PRINTF(("sst1InitMapBoard(): 0x%X\n", GetLastError()));
      5X  25183 #endif
      5	  25184 
      5	  25185                   INIT_PRINTF(("pciError(): %s", pciGetErrorString()));
      5	  25186 
      5	  25187                   exit(-1);
      4	  25188                 }
      3	  25189             }
      2	  25190         }
      1	  25191     }
      1	  25192 
      2	  25193     if(resetSLI) {
      2	  25194        // Search through all known boards for SLI enabled...
      2	  25195        FxU32 k;
      2	  25196        SstRegs *sst;
      2	  25197 
      3	  25198        for(k=0; k<boardsInSystemReally; k++) {
      3	  25199           // Disable SLI if detected...
      3	  25200           if(!(sstbase = (FxU32 *) sst1BoardInfo[k].virtAddr[0]))
      3	  25201              return(NULL);
      3	  25202           sst1InitDeviceNumber = sst1BoardInfo[k].deviceNumber;
      3	  25203           sst1CurrentBoard = &sst1BoardInfo[k];
      3	  25204           sst = (SstRegs *) sstbase;
      3	  25205 
      4	  25206           if(IGET(sst->fbiInit1) & SST_EN_SCANLINE_INTERLEAVE) {
      4	  25207              INIT_PRINTF(("sst1InitMapBoard(): Disabling Scanline Interleaving (board #%d)...\n", (k+1)));
      4	  25208              // Disable SLI Snooping...
      4	  25209              PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      4	  25210              PCICFG_WR(SST1_PCI_INIT_ENABLE, j &
      4	  25211                ~(SST_SCANLINE_SLV_OWNPCI | SST_SCANLINE_SLI_SLV |
      4	  25212                  SST_SLI_SNOOP_EN | SST_SLI_SNOOP_MEMBASE));
      4	  25213              ISET(sst->fbiInit1, IGET(sst->fbiInit1) &
      4	  25214                ~SST_EN_SCANLINE_INTERLEAVE);
      4	  25215              sst1InitReturnStatus(sstbase);
      3	  25216           }
      3	  25217 
      3	  25218           // Tristate video output signals, so two boards connected as SLI
      3	  25219           // do not have contention problems when SSTV2_SLIDETECT=0
      3	  25220           if(firstTime)
      3	  25221              sst1InitVideoShutdown(sstbase, FXFALSE);
      2	  25222        }
      1	  25223     }

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 8
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25224     firstTime = 0;
      1	  25225 
      1	  25226     // Max number of supported boards in system
      1	  25227     if(BoardNumber > SST1INIT_MAX_BOARDS) return(NULL);
      1	  25228 
      1	  25229     if(!(sstbase = (FxU32 *) sst1BoardInfo[BoardNumber].virtAddr[0]))
      1	  25230         return (NULL);
      1	  25231 
      1	  25232     INIT_PRINTF(("sst1InitMapBoard(): vAddr:0x%x pAddr:0x%x Dev:0x%x Board:%d\n",
      1	  25233         (FxU32) sst1BoardInfo[BoardNumber].virtAddr[0],
      1	  25234         (FxU32) sst1BoardInfo[BoardNumber].physAddr[0],
      1	  25235         (FxU32) sst1BoardInfo[BoardNumber].deviceNumber, BoardNumber));
      1	  25236 
      1	  25237     // Default settings
      1	  25238     sst1BoardInfo[BoardNumber].vgaPassthruDisable = SST_EN_VGA_PASSTHRU;
      1	  25239     sst1BoardInfo[BoardNumber].vgaPassthruEnable = 0x0;
      1	  25240     sst1BoardInfo[BoardNumber].fbiVideo16BPP = 0;
      1	  25241 
      2	  25242     if(GETENV(("SSTV2_VGA_PASS"))) {
      2	  25243         INIT_PRINTF(("sst1InitMapBoard(): Using SST_VGA_PASS=%d\n",
      2	  25244             ATOI(GETENV(("SSTV2_VGA_PASS")))));
      3	  25245         if(ATOI(GETENV(("SSTV2_VGA_PASS")))) {
      3	  25246             sst1BoardInfo[BoardNumber].vgaPassthruEnable = SST_EN_VGA_PASSTHRU;
      3	  25247             sst1BoardInfo[BoardNumber].vgaPassthruDisable = 0x0;
      3	  25248         } else {
      3	  25249             sst1BoardInfo[BoardNumber].vgaPassthruDisable = SST_EN_VGA_PASSTHRU;
      3	  25250             sst1BoardInfo[BoardNumber].vgaPassthruEnable = 0x0;
      2	  25251         }
      1	  25252     }
      1	  25253 
      1	  25254     return(sstbase);
      1	  25255 }
	  25256 
	  25257 /*
	  25258 ** sst1InitRegisters():
	  25259 **  Initialize registers and memory and return to power-on state
	  25260 **
	  25261 **    Returns:
	  25262 **      FXTRUE if successfully initializes SST-1
	  25263 **      FXFALSE if cannot initialize SST-1
	  25264 **
	  25265 */
	  25266 FX_EXPORT FxBool FX_CSTYLE sst1InitRegisters(FxU32 *sstbase)
      1	  25267 {
      1	  25268     FxU32 n, tf_fifo_thresh;
      1	  25269     FxU32 ft_clkdel, tf0_clkdel, tf1_clkdel, tf2_clkdel;
      1	  25270     sst1ClkTimingStruct sstGrxClk;
      1	  25271     SstRegs *sst = (SstRegs *) sstbase;
      1	  25272     int i;
      1	  25273 
      1	  25274     if(!sst)
      1	  25275         return(FXFALSE);
      1	  25276 
      1	  25277     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	  25278         return(FXFALSE);
      1	  25279 
      2	  25280     if(GETENV(("SSTV2_IGNORE_INIT_REGISTERS"))) {

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 9
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      2	  25281         INIT_PRINTF(("WARNING: Ignoring sst1InitRegisters()...\n"));
      2	  25282         sst1InitIdleFBINoNOP(sstbase);
      2	  25283         return(FXTRUE);
      1	  25284     }
      1	  25285 
      1	  25286     if(GETENV(("SSTV2_TEXMAP_DISABLE")))
      1	  25287        INIT_PRINTF(("sst1InitRegisters() WARNING: Disabling texture mapping\n"));
      1	  25288 
      1	  25289 #if !DIRECTX
      1	  25290     // Open PCI library (necessary for multiple calls to init routines, after
      1	  25291     // PCI library is closed by pciClose() call in sst1InitShutdown()
      1	  25292     pciOpen();
      1	  25293 #endif
      1	  25294 
      1	  25295     // Enable writes to the FBIINIT registers
      1	  25296     // Do not allow writes into the pci fifo until everything is reset
      1	  25297     PCICFG_WR(SST1_PCI_INIT_ENABLE, SST_INITWR_EN);
      1	  25298 
      1	  25299     // Reset Snoop registers to default values
      1	  25300     PCICFG_WR(SST1_PCI_BUS_SNOOP0, SST_PCI_BUS_SNOOP_DEFAULT);
      1	  25301     PCICFG_WR(SST1_PCI_BUS_SNOOP1, SST_PCI_BUS_SNOOP_DEFAULT);
      1	  25302     sst1InitReturnStatus(sstbase); // Stall - can't call IdleFbi because 
      1	  25303     sst1InitReturnStatus(sstbase); // FBI could be hung at this stage
      1	  25304     sst1InitReturnStatus(sstbase);
      1	  25305     
      1	  25306     // Adjust Trex-to-Fbi FIFO
      1	  25307     if(GETENV(("SSTV2_TF_FIFO_THRESH")) &&
      1	  25308        (SSCANF(GETENV(("SSTV2_TF_FIFO_THRESH")), "%i", &i) == 1) )
      1	  25309         tf_fifo_thresh = i;
      1	  25310     else
      1	  25311         tf_fifo_thresh = 0x8;
      1	  25312     INIT_PRINTF(("sst1InitRegisters(): Setting TREX-to-FBI FIFO THRESHOLD to 0x%x...\n",
      1	  25313         tf_fifo_thresh));
      1	  25314 
      1	  25315     if(GETENV(("SSTV2_PFT_CLKDEL")) &&
      1	  25316        (SSCANF(GETENV(("SSTV2_PFT_CLKDEL")), "%i", &i) == 1) )
      1	  25317         ft_clkdel = i;
      1	  25318     else
      1	  25319         ft_clkdel = 0x8; // Okay for 16 MHz startup...
      1	  25320     INIT_PRINTF(("sst1InitRegisters(): Setting PRELIM FT-CLK delay to 0x%x...\n", ft_clkdel));
      1	  25321 
      1	  25322     // SST_FBIINIT3_DEFAULT is set to disable texture mapping, so if
      1	  25323     // TMUs are hung, it will not affect FBI
      1	  25324     ISET(sst->fbiInit3,
      1	  25325        (SST_FBIINIT3_DEFAULT & ~(SST_FT_CLK_DEL_ADJ | SST_TF_FIFO_THRESH)) |
      1	  25326        (ft_clkdel << SST_FT_CLK_DEL_ADJ_SHIFT) |
      1	  25327        (tf_fifo_thresh << SST_TF_FIFO_THRESH_SHIFT));
      1	  25328 
      1	  25329     // Wait for Fbi-to-Trex clock delay value to propogate
      1	  25330     sst1InitReturnStatus(sstbase); // Stall - can't call IdleFbi because
      1	  25331     sst1InitReturnStatus(sstbase); // FBI could be hung at this stage
      1	  25332     sst1InitReturnStatus(sstbase);
      1	  25333 
      1	  25334     // Reset graphics and video units
      1	  25335     // Must reset video unit before graphics unit, otherwise video unit could
      1	  25336     // potentially hang waiting for the graphics unit to respond
      1	  25337     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 10
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25338 
      1	  25339     // Don't wait for idle because graphics could be hung...
      1	  25340     sst1InitReturnStatus(sstbase);
      1	  25341     sst1InitReturnStatus(sstbase);
      1	  25342     sst1InitReturnStatus(sstbase);
      1	  25343     ISET(sst->fbiInit0,
      1	  25344       IGET(sst->fbiInit0) | (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      1	  25345 
      1	  25346     sst1InitIdleFBINoNOP(sstbase);
      1	  25347 
      1	  25348     // Unreset PCI FIFO...
      1	  25349     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      1	  25350     sst1InitIdleFBINoNOP(sstbase);
      1	  25351 
      1	  25352     // Unreset graphics subsystem
      1	  25353     // THIS MUST BE PRESENT OTHERWISE THE PCI FIFO WILL NEVER DRAIN!
      1	  25354     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      1	  25355     sst1InitIdleFBINoNOP(sstbase);
      1	  25356 
      1	  25357     // Reset all FBI and TREX Init registers
      1	  25358     ISET(sst->fbiInit0, SST_FBIINIT0_DEFAULT);
      1	  25359     ISET(sst->fbiInit1, SST_FBIINIT1_DEFAULT);
      1	  25360     ISET(sst->fbiInit2, SST_FBIINIT2_DEFAULT);
      1	  25361     ISET(sst->fbiInit3,
      1	  25362        (SST_FBIINIT3_DEFAULT & ~(SST_FT_CLK_DEL_ADJ | SST_TF_FIFO_THRESH)) |
      1	  25363        (ft_clkdel << SST_FT_CLK_DEL_ADJ_SHIFT) |
      1	  25364        (tf_fifo_thresh << SST_TF_FIFO_THRESH_SHIFT));
      1	  25365     ISET(sst->fbiInit4, SST_FBIINIT4_DEFAULT);
      1	  25366     ISET(sst->fbiInit5, SST_FBIINIT5_DEFAULT);
      1	  25367     ISET(sst->fbiInit6, SST_FBIINIT6_DEFAULT);
      1	  25368     sst1CurrentBoard->fbiInit6 = SST_FBIINIT6_DEFAULT;
      1	  25369     ISET(sst->fbiInit7, SST_FBIINIT7_DEFAULT);
      1	  25370     sst1InitIdleFBINoNOP(sstbase);  // Wait until init regs are reset
      1	  25371 
      1	  25372     // Enable writes to the FBIINIT registers and allow pushes onto PCI FIFO
      1	  25373     PCICFG_WR(SST1_PCI_INIT_ENABLE, (SST_INITWR_EN | SST_PCI_FIFOWR_EN));
      1	  25374 
      1	  25375     // Determine DAC Type
      2	  25376     if(sst1InitDacDetect(sstbase) == FXFALSE) {
      2	  25377         INIT_PRINTF(("sst1InitRegisters(): Could not detect DAC...\n"));
      2	  25378         return(FXFALSE);
      1	  25379     }
      1	  25380 
      1	  25381     // set TREX0 init values
      1	  25382     if(GETENV(("SSTV2_TREX0INIT0")) &&
      2	  25383        (SSCANF(GETENV(("SSTV2_TREX0INIT0")), "%i", &i) == 1) ) {
      2	  25384         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX0INIT0 environment variable\n"));
      2	  25385         sst1CurrentBoard->tmuInit0[0] = i;
      1	  25386     } else
      1	  25387         sst1CurrentBoard->tmuInit0[0] = SST_TREX0INIT0_DEFAULT;
      1	  25388 
      1	  25389     INIT_PRINTF(("sst1InitRegisters(): Storing TREX0INIT0=0x%x\n",
      1	  25390         sst1CurrentBoard->tmuInit0[0]));
      1	  25391     if(GETENV(("SSTV2_TREX0INIT1")) &&
      2	  25392        (SSCANF(GETENV(("SSTV2_TREX0INIT1")), "%i", &i) == 1) ) {
      2	  25393         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX0INIT1 environment variable\n"));
      2	  25394         sst1CurrentBoard->tmuInit1[0] = i;

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 11
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25395     } else
      1	  25396         sst1CurrentBoard->tmuInit1[0] = SST_TREX0INIT1_DEFAULT;
      1	  25397 
      1	  25398     if(GETENV(("SSTV2_PTF0_CLKDEL")) &&
      2	  25399        (SSCANF(GETENV(("SSTV2_PTF0_CLKDEL")), "%i", &tf0_clkdel) == 1)) {
      2	  25400         sst1CurrentBoard->tmuInit1[0] = (sst1CurrentBoard->tmuInit1[0] &
      2	  25401             ~SST_TEX_TF_CLK_DEL_ADJ) |
      2	  25402             (tf0_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	  25403     }
      1	  25404     INIT_PRINTF(("sst1InitRegisters(): Storing TREX0INIT1=0x%x\n",
      1	  25405         sst1CurrentBoard->tmuInit1[0]));
      1	  25406 
      1	  25407     // set TREX1 init values
      1	  25408     if(GETENV(("SSTV2_TREX1INIT0")) && 
      2	  25409        (SSCANF(GETENV(("SSTV2_TREX1INIT0")), "%i", &i) == 1) ) {
      2	  25410         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX1INIT0 environment variable\n"));
      2	  25411         sst1CurrentBoard->tmuInit0[1] = i;
      1	  25412     } else
      1	  25413         sst1CurrentBoard->tmuInit0[1] = SST_TREX1INIT0_DEFAULT;
      1	  25414     INIT_PRINTF(("sst1InitRegisters(): Storing TREX1INIT0=0x%x\n",
      1	  25415         sst1CurrentBoard->tmuInit0[1]));
      1	  25416     if(GETENV(("SSTV2_TREX1INIT1")) &&
      2	  25417        (SSCANF(GETENV(("SSTV2_TREX1INIT1")), "%i", &i) == 1) ) {
      2	  25418         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX1INIT1 environment variable\n"));
      2	  25419         sst1CurrentBoard->tmuInit1[1] = i;
      1	  25420     } else
      1	  25421         sst1CurrentBoard->tmuInit1[1] = SST_TREX1INIT1_DEFAULT;
      1	  25422     if(GETENV(("SSTV2_PTF1_CLKDEL")) &&
      2	  25423        (SSCANF(GETENV(("SSTV2_PTF1_CLKDEL")), "%i", &tf1_clkdel) == 1) ) {
      2	  25424         sst1CurrentBoard->tmuInit1[1] = (sst1CurrentBoard->tmuInit1[1] &
      2	  25425             ~SST_TEX_TF_CLK_DEL_ADJ) |
      2	  25426             (tf1_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);
      1	  25427     }
      1	  25428     INIT_PRINTF(("sst1InitRegisters(): Storing TREX1INIT1=0x%x\n",
      1	  25429         sst1CurrentBoard->tmuInit1[1]));
      1	  25430 
      1	  25431 
      1	  25432     // set TREX2 init values
      1	  25433     if(GETENV(("SSTV2_TREX2INIT0")) &&
      2	  25434        (SSCANF(GETENV(("SSTV2_TREX2INIT0")), "%i", &i) == 1) ) {
      2	  25435         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX2INIT0 environment variable\n"));
      2	  25436         sst1CurrentBoard->tmuInit0[2] = i;
      1	  25437     } else
      1	  25438         sst1CurrentBoard->tmuInit0[2] = SST_TREX2INIT0_DEFAULT;
      1	  25439     INIT_PRINTF(("sst1InitRegisters(): Storing TREX2INIT0=0x%x\n",
      1	  25440         sst1CurrentBoard->tmuInit0[2]));
      1	  25441     if(GETENV(("SSTV2_TREX2INIT1")) &&
      2	  25442        (SSCANF(GETENV(("SSTV2_TREX2INIT1")), "%i", &i) == 1) ) {
      2	  25443         INIT_PRINTF(("sst1InitRegisters(): Using SST_TREX2INIT1 environment variable\n"));
      2	  25444         sst1CurrentBoard->tmuInit1[2] = i;
      1	  25445     } else
      1	  25446         sst1CurrentBoard->tmuInit1[2] = SST_TREX2INIT1_DEFAULT;
      1	  25447     if(GETENV(("SSTV2_PTF2_CLKDEL")) &&
      2	  25448        (SSCANF(GETENV(("SSTV2_PTF2_CLKDEL")), "%i", &tf2_clkdel) == 1) ) {
      2	  25449         sst1CurrentBoard->tmuInit1[2] = (sst1CurrentBoard->tmuInit1[2] &
      2	  25450             ~SST_TEX_TF_CLK_DEL_ADJ) |
      2	  25451             (tf2_clkdel<<SST_TEX_TF_CLK_DEL_ADJ_SHIFT);

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 12
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25452     }
      1	  25453     INIT_PRINTF(("sst1InitRegisters(): Storing TREX2INIT1=0x%x\n", 
      1	  25454         sst1CurrentBoard->tmuInit1[2]));
      1	  25455 
      1	  25456     // Set clock at 16 MHz to properly transmit TREX configuration registers
      1	  25457     // Note that setting the clock will automatically reset the TMUs...
      1	  25458     // sst1InitResetTmus() also will de-assert TEXMAP_DISABLE in fbiInit3
      1	  25459     // unless SSTV2_TEXMAP_DISABLE is set
      1	  25460     if(!sst1InitComputeClkParams(16.0f, &sstGrxClk)) 
      1	  25461       return(FXFALSE);
      1	  25462     if(!sst1InitSetGrxClk(sstbase, &sstGrxClk))
      1	  25463       return(FXFALSE);
      1	  25464     sst1CurrentBoard->initGrxClkDone = 0;
      1	  25465 
      1	  25466     // Set PCI wait-states
      2	  25467     if(GETENV(("SSTV2_SLOWPCIWR"))) {
      2	  25468         INIT_PRINTF(("sst1InitRegisters(): Setting up SLOW PCI Writes...\n"));
      2	  25469         ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_PCI_WRWS_1);
      1	  25470     } else
      1	  25471         ISET(sst->fbiInit1, IGET(sst->fbiInit1) & ~SST_PCI_WRWS_1);
      1	  25472 
      2	  25473     if(GETENV(("SSTV2_FASTPCIRD"))) {
      2	  25474         INIT_PRINTF(("sst1InitRegisters(): Setting up FAST PCI Reads...\n"));
      2	  25475         ISET(sst->fbiInit4, IGET(sst->fbiInit4) & ~SST_PCI_RDWS_2);
      1	  25476     }
      1	  25477     sst1InitIdleFBINoNOP(sstbase);
      1	  25478 
      1	  25479     // Enable Linear frame buffer reads
      1	  25480     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_LFB_READ_EN);
      1	  25481 
      1	  25482     // Swapbuffer algorithm is based on VSync initially
      1	  25483     ISET(sst->fbiInit2, (IGET(sst->fbiInit2) & ~SST_SWAP_ALGORITHM) |
      1	  25484       SST_SWAP_VSYNC);
      1	  25485 
      1	  25486     // Enable LFB read-aheads
      1	  25487     ISET(sst->fbiInit4, IGET(sst->fbiInit4) | SST_EN_LFB_RDAHEAD);
      1	  25488 
      1	  25489     // Enable triangle alternate register mapping
      1	  25490     ISET(sst->fbiInit3, IGET(sst->fbiInit3) | SST_ALT_REGMAPPING);
      1	  25491 
      1	  25492     // Enable Endian Byte Swapping
      1	  25493     ISET(sst->fbiInit0, IGET(sst->fbiInit0) | SST_EN_ENDIAN_SWAPPING);
      1	  25494 
      1	  25495     // Setup DRAM Refresh
      1	  25496     ISET(sst->fbiInit2, (IGET(sst->fbiInit2) & ~SST_DRAM_REFRESH_CNTR) |
      1	  25497         SST_DRAM_REFRESH_16MS);
      1	  25498     sst1InitIdleFBINoNOP(sstbase);
      1	  25499     ISET(sst->fbiInit2, IGET(sst->fbiInit2) | SST_EN_DRAM_REFRESH);
      1	  25500     sst1InitIdleFBINoNOP(sstbase);
      1	  25501 
      2	  25502     {
      2	  25503        // Setup memory timings...
      2	  25504        FxU32 fbiInit1 = IGET(sst->fbiInit1);
      2	  25505        FxU32 fbiInit2 = IGET(sst->fbiInit2) |
      2	  25506           SST_EN_DRAM_RD_AHEAD_FIFO | SST_EN_FAST_RD_AHEAD_WR;
      2	  25507 
      3	  25508        if(GETENV(("SSTV2_SLOWMEM_WTR"))) {

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 13
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      3	  25509           INIT_PRINTF(("sst1InitRegisters(): Running slow write-to-read memory timing...\n"));
      3	  25510           fbiInit1 |= SST_DISEN_RD_AHEAD_WR_RD;
      2	  25511        }
      3	  25512        if(GETENV(("SSTV2_SLOWMEM_RTW"))) {
      3	  25513           INIT_PRINTF(("sst1InitRegisters(): Running slow read-to-write memory timing...\n"));
      3	  25514           fbiInit2 &= ~SST_EN_FAST_RD_AHEAD_WR;
      2	  25515        }
      3	  25516        if(GETENV(("SSTV2_FASTMEM_RAS_READS"))) {
      3	  25517           INIT_PRINTF(("sst1InitRegisters(): Enabling fast RAS read memory timing...\n"));
      3	  25518           fbiInit2 |= SST_EN_FAST_RAS_READ;
      2	  25519        }
      2	  25520        ISET(sst->fbiInit1, fbiInit1);
      2	  25521        sst1InitReturnStatus(sstbase);
      2	  25522        ISET(sst->fbiInit2, fbiInit2);
      2	  25523        sst1InitReturnStatus(sstbase);
      1	  25524     }
      1	  25525 
      1	  25526     // Return all other registers to their power-on state
      1	  25527     sst1InitIdleFBINoNOP(sstbase);
      1	  25528     sst1InitSetResolution(sstbase, &SST_VREZ_640X480_60, 0);
      1	  25529     sst1InitIdleFBINoNOP(sstbase);
      1	  25530 
      1	  25531     // Get DRAMs up and running (refresh is already enabled)...
      1	  25532     ISET(sst->c1, 0x0);
      1	  25533     ISET(sst->c0, 0x0);
      1	  25534     ISET(sst->zaColor, 0x0);
      1	  25535     ISET(sst->clipLeftRight, 100); // draw into 50x50 area
      1	  25536     ISET(sst->clipBottomTop, 100);
      1	  25537     ISET(sst->fbzMode, SST_RGBWRMASK | SST_ZAWRMASK);
      1	  25538     ISET(sst->fastfillCMD, 0x0);   // Frontbuffer & Z/A
      1	  25539     ISET(sst->nopCMD, 0x1); // Clear fbistat registers after clearing screen
      1	  25540     sst1InitIdleFBINoNOP(sstbase);
      1	  25541 
      1	  25542     sst1InitRenderingRegisters(sstbase);    
      1	  25543     sst1CurrentBoard->tmuRevision = 0xdead; // Force sst1InitFillDeviceInfo()
      2	  25544     if(sst1InitFillDeviceInfo(sstbase, sst1CurrentBoard) == FXFALSE) {
      2	  25545         INIT_PRINTF(("sst1InitRegisters(): ERROR filling DeviceInfo...\n"));
      2	  25546 
      2	  25547         return(FXFALSE);
      1	  25548     }
      1	  25549 
      1	  25550     sst1InitIdleFBINoNOP(sstbase);
      1	  25551     sst1InitRenderingRegisters(sstbase);
      1	  25552     sst1InitIdleFBINoNOP(sstbase);
      1	  25553 
      1	  25554     // LFB writes stored in memory FIFO?
      1	  25555     if(GETENV(("SSTV2_MEMFIFO_LFB")))
      1	  25556         n = ATOI(GETENV(("SSTV2_MEMFIFO_LFB")));
      1	  25557     else
      1	  25558         n = 1;
      2	  25559     if(n) {
      2	  25560         INIT_PRINTF(("sst1InitRegisters(): LFB Writes go through memory FIFO...\n"));
      2	  25561         ISET(sst->fbiInit0, IGET(sst->fbiInit0) | SST_EN_LFB_MEMFIFO);
      2	  25562         sst1InitIdleFBINoNOP(sstbase);
      1	  25563     }
      1	  25564 
      1	  25565     // Texture memory writes stored in memory FIFO?

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 14
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25566     if(GETENV(("SSTV2_MEMFIFO_TEX")))
      1	  25567         n = ATOI(GETENV(("SSTV2_MEMFIFO_TEX")));
      1	  25568     else
      1	  25569         n = 1;
      2	  25570     if(n) {
      2	  25571         INIT_PRINTF(("sst1InitRegisters(): TEXTURE Writes go through memory FIFO...\n"));
      2	  25572         ISET(sst->fbiInit0, IGET(sst->fbiInit0) | SST_EN_TEX_MEMFIFO);
      2	  25573         sst1InitIdleFBINoNOP(sstbase);
      1	  25574     }
      1	  25575 
      1	  25576     ISET(sst->vRetrace, 0x0);
      1	  25577     ISET(sst->backPorch, 0x0);
      1	  25578     ISET(sst->videoDimensions, 0x0);
      1	  25579     ISET(sst->hSync, 0x0);
      1	  25580     ISET(sst->vSync, 0x0);
      1	  25581     ISET(sst->videoFilterRgbThreshold, 0x0);
      1	  25582 
      1	  25583     sst1InitIdleFBINoNOP(sstbase);  // Wait until init regs are reset
      1	  25584 
      1	  25585     // Update info structure for initEnable
      1	  25586     PCICFG_RD(SST1_PCI_INIT_ENABLE, sst1CurrentBoard->fbiInitEnable);
      1	  25587 
      1	  25588     INIT_PRINTF(("sst1InitRegisters(): exiting with status %d...\n", FXTRUE));
      1	  25589     return(FXTRUE);
      1	  25590 }
	  25591 
	  25592 FX_EXPORT void FX_CSTYLE sst1InitRenderingRegisters(FxU32 *sstbase)
      1	  25593 {
      1	  25594     FxU32 i;
      1	  25595     SstRegs *sst = (SstRegs *) sstbase;
      1	  25596 
      1	  25597     ISET(sst->vA.x, 0x0); ISET(sst->vA.y, 0x0);
      1	  25598     ISET(sst->vB.x, 0x0); ISET(sst->vB.y, 0x0);
      1	  25599     ISET(sst->vC.x, 0x0); ISET(sst->vC.y, 0x0);
      1	  25600 
      1	  25601     ISET(sst->r, 0x0); ISET(sst->g, 0x0);
      1	  25602     ISET(sst->b, 0x0); ISET(sst->z, 0x0);
      1	  25603     ISET(sst->a, 0x0); ISET(sst->s, 0x0);
      1	  25604     ISET(sst->t, 0x0); ISET(sst->w, 0x0);
      1	  25605 
      1	  25606     ISET(sst->drdx, 0x0); ISET(sst->dgdx, 0x0);
      1	  25607     ISET(sst->dbdx, 0x0); ISET(sst->dzdx, 0x0);
      1	  25608     ISET(sst->dadx, 0x0); ISET(sst->dsdx, 0x0);
      1	  25609     ISET(sst->dtdx, 0x0); ISET(sst->dwdx, 0x0);
      1	  25610 
      1	  25611     ISET(sst->drdy, 0x0); ISET(sst->dgdy, 0x0);
      1	  25612     ISET(sst->dbdy, 0x0); ISET(sst->dzdy, 0x0);
      1	  25613     ISET(sst->dady, 0x0); ISET(sst->dsdy, 0x0);
      1	  25614     ISET(sst->dtdy, 0x0); ISET(sst->dwdy, 0x0);
      1	  25615 
      1	  25616     ISET(sst->fbzColorPath, 0x0);
      1	  25617     ISET(sst->fogMode, 0x0);
      1	  25618     ISET(sst->alphaMode, 0x0);
      1	  25619     ISET(sst->fbzMode, 0x0);
      1	  25620     ISET(sst->lfbMode, 0x0);
      1	  25621     ISET(sst->clipLeftRight, 0x0);
      1	  25622     ISET(sst->clipBottomTop, 0x0);

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 15
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25623 
      1	  25624     ISET(sst->fogColor, 0x0);
      1	  25625     ISET(sst->zaColor, 0x0);
      1	  25626     ISET(sst->chromaKey, 0x0);
      1	  25627     ISET(sst->chromaRange, 0x0);
      1	  25628     ISET(sst->stipple, 0x0);
      1	  25629     ISET(sst->c0, 0x0);
      1	  25630     ISET(sst->c1, 0x0);
      1	  25631 
      1	  25632     ISET(sst->sSetupMode, 0x0);
      1	  25633     ISET(sst->sVx, 0x0);
      1	  25634     ISET(sst->sVy, 0x0);
      1	  25635     ISET(sst->sARGB, 0x0);
      1	  25636     ISET(sst->sRed, 0x0);
      1	  25637     ISET(sst->sGreen, 0x0);
      1	  25638     ISET(sst->sBlue, 0x0);
      1	  25639     ISET(sst->sAlpha, 0x0);
      1	  25640     ISET(sst->sVz, 0x0);
      1	  25641     ISET(sst->sOowfbi, 0x0);
      1	  25642     ISET(sst->sOow0, 0x0);
      1	  25643     ISET(sst->sSow0, 0x0);
      1	  25644     ISET(sst->sTow0, 0x0);
      1	  25645     ISET(sst->sOow1, 0x0);
      1	  25646     ISET(sst->sSow1, 0x0);
      1	  25647     ISET(sst->sTow1, 0x0);
      1	  25648 
      1	  25649     ISET(sst->nopCMD, 0x3);   // Clear fbistat and trianglesOut registers
      1	  25650 
      1	  25651     for(i=0; i<32; i++)
      1	  25652         ISET(sst->fogTable[i], 0x0);
      1	  25653 
      1	  25654     ISET(sst->bltSrcBaseAddr, 0x0);
      1	  25655     ISET(sst->bltDstBaseAddr, 0x0);
      1	  25656     ISET(sst->bltXYstrides, 0x0);
      1	  25657     ISET(sst->bltSrcChromaRange, 0x0);
      1	  25658     ISET(sst->bltDstChromaRange, 0x0);
      1	  25659     ISET(sst->bltClipX, 0x0);
      1	  25660     ISET(sst->bltClipY, 0x0);
      1	  25661     ISET(sst->bltSrcXY, 0x0);
      1	  25662     ISET(sst->bltDstXY, 0x0);
      1	  25663     ISET(sst->bltSize, 0x0);
      1	  25664     ISET(sst->bltRop, 0x0);
      1	  25665     ISET(sst->bltColor, 0x0);
      1	  25666     ISET(sst->bltCommand, 0x0);
      1	  25667 
      1	  25668     // clear TMU registers
      1	  25669     ISET(sst->textureMode, 0x0);
      1	  25670     ISET(sst->tLOD, 0x0);
      1	  25671     ISET(sst->tDetail, 0x0);
      1	  25672     ISET(sst->texBaseAddr, 0x0);
      1	  25673     ISET(sst->texBaseAddr1, 0x0);
      1	  25674     ISET(sst->texBaseAddr2, 0x0);
      1	  25675     ISET(sst->texBaseAddr38, 0x0);
      1	  25676 
      1	  25677     for(i=0; i<12; i++)
      1	  25678         ISET(sst->nccTable0[i], 0x0);
      1	  25679     for(i=0; i<12; i++)

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 16
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25680         ISET(sst->nccTable1[i], 0x0);
      1	  25681     sst1InitIdle(sstbase);
      1	  25682 
      1	  25683     ISET(sst->tchromaKey, 0x0);
      1	  25684     ISET(sst->tchromaRange, 0x0);
      1	  25685 
      1	  25686 }
	  25687 
	  25688 /*
	  25689 ** sst1InitShutdown():
	  25690 **  Shutdown SST-1
	  25691 **    Resets state of VGA_PASS to return monitor control back to the VGA
	  25692 **    Powers-down the DAC
	  25693 **    Resets the graphics clock in FBI to conserve power
	  25694 **
	  25695 **    Returns:
	  25696 **      FXTRUE if successfully shuts down SST-1
	  25697 **      FXFALSE if cannot shut down the SST-1
	  25698 **
	  25699 */
	  25700 FX_EXPORT FxBool FX_CSTYLE sst1InitShutdown(FxU32 *sstbase)
      1	  25701 {
      1	  25702     SstRegs *sstMaster = (SstRegs *) sstbase;
      1	  25703     SstRegs *sstSlave;
      1	  25704     SstRegs *sstPtr;
      1	  25705     FxU32 n;
      1	  25706     FxU32 sliEnabled;
      1	  25707     sst1ClkTimingStruct sstGrxClk;
      1	  25708 
      1	  25709     if(!sstbase)
      1	  25710         return(FXFALSE);
      1	  25711 
      1	  25712     if(sst1InitCheckBoard((FxU32 *) sstbase) == FXFALSE)
      1	  25713         return(FXFALSE);
      1	  25714 
      1	  25715     // sst1Initidle() routines must be properly executed...
      1	  25716     initIdleEnabled = 1;
      1	  25717 
      1	  25718     sliEnabled = (sst1CurrentBoard->sliSlaveVirtAddr != (FxU32 *) NULL) ? 1 : 0;
      1	  25719     sstSlave = (SstRegs *) sst1CurrentBoard->sliSlaveVirtAddr;
      1	  25720 
      1X  25721 #if 0
      1X  25722     // If the command fifo is enabled, we can't issue a NOP first, so wait
      1X  25723     // until the PCI fifo is empty...
      1X  25724     sst1InitPciFifoIdleLoop(sstbase);
      1X  25725     if(sst1CurrentBoard->sliSlaveVirtAddr)
      1X  25726        sst1InitPciFifoIdleLoop(sst1CurrentBoard->sliSlaveVirtAddr);
      1X  25727 #else
      1	  25728     sst1InitIdle(sstbase);
      1	  25729 #endif
      1	  25730 
      1	  25731     // Disable the command fifo if enabled...
      1	  25732     if(sst1CurrentBoard->fbiCmdFifoEn ||
      1	  25733        (IGET(sstMaster->fbiInit7) & SST_EN_CMDFIFO))
      1	  25734        sst1InitCmdFifo(sstbase, FXFALSE, (void *) NULL, (void *) NULL,
      1	  25735         (void *) NULL, NULL);
      1	  25736 

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 17
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25737     sst1InitIdle(sstbase);
      1	  25738 
      2	  25739     if(sliEnabled && !GETENV(("SSTV2_NOSHUTDOWN"))) {
      2	  25740         if(sst1InitShutdownSli(sstbase) == FXFALSE)
      2	  25741             return(FXFALSE);
      1	  25742     }
      1	  25743 
      1	  25744     if(GETENV(("SSTV2_NOSHUTDOWN")))
      1	  25745         INIT_PRINTF(("sst1InitShutdown(): Bypassing shutdown with SSTV2_NOSHUTDOWN\n"));
      1	  25746 
      1	  25747     n = 0;
      2	  25748     while(!GETENV(("SSTV2_NOSHUTDOWN"))) {
      2	  25749         if(!n)
      2	  25750             sstPtr = sstMaster;
      2	  25751         else
      2	  25752             sstPtr = sstSlave;
      2	  25753 
      2	  25754         if(sst1InitCheckBoard((FxU32 *) sstPtr) == FXFALSE)
      2	  25755             return(FXFALSE);
      2	  25756 
      2	  25757         INIT_PRINTF(("sst1InitShutdown(): Shutting down SST-1 #%d...\n", n));
      2	  25758 
      2	  25759         // Reset video unit to guarantee no contentions on the memory bus
      2	  25760         // Blank DAC so VGA Passthru works properly
      2	  25761         ISET(sstPtr->fbiInit1,
      2	  25762           IGET(sstPtr->fbiInit1) | (SST_VIDEO_RESET | SST_VIDEO_BLANK_EN));
      2	  25763         // Turn off dram refresh to guarantee no contentions on the
      2	  25764         // memory bus
      2	  25765         ISET(sstPtr->fbiInit2, IGET(sstPtr->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      2	  25766 
      2	  25767         // Reset graphics subsystem
      2	  25768         ISET(sstPtr->fbiInit0,
      2	  25769           IGET(sstPtr->fbiInit0) | (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      2	  25770         sst1InitIdleFBINoNOP((FxU32 *) sstPtr);
      2	  25771         ISET(sstPtr->fbiInit0, IGET(sstPtr->fbiInit0) & ~SST_PCI_FIFO_RESET);
      2	  25772 
      2	  25773         sst1InitIdleFBINoNOP((FxU32 *) sstPtr);
      2	  25774         ISET(sstPtr->fbiInit0, IGET(sstPtr->fbiInit0) & ~SST_GRX_RESET);
      2	  25775         sst1InitIdleFBINoNOP((FxU32 *) sstPtr);
      2	  25776 
      2	  25777         // Turnaround VGA_PASS to allow VGA monitor
      2	  25778         sst1InitVgaPassCtrl((FxU32 *) sstPtr, 1);
      2	  25779         sst1InitIdleFBINoNOP((FxU32 *) sstPtr);
      2	  25780 
      2	  25781         // Set clock at 30 MHz to reduce power consumption...
      2	  25782         sst1InitComputeClkParams((float) 30.0, &sstGrxClk);
      2	  25783         if(sst1InitSetGrxClk((FxU32 *) sstPtr, &sstGrxClk) == FXFALSE)
      2	  25784           INIT_PRINTF(("sst1InitShutdown() WARNING: sst1InitSetGrxClk failed...Continuing...\n"));
      2	  25785         sst1CurrentBoard->initGrxClkDone = 0;
      2	  25786 
      2	  25787 #ifndef __linux__
      2	  25788         pciUnmapPhysical((FxU32)sst1CurrentBoard->virtAddr[0], 0x1000000UL); 
      2	  25789 #endif
      2	  25790         if((++n > 1) || !sliEnabled)
      2	  25791             break;
      1	  25792     }
      1	  25793 

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 18
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25794     /* sst1InitIdle(sstbase);  */
      1	  25795 
      1	  25796 #if !DIRECTX
      1	  25797     // 
      1	  25798     // HACK alert.
      1	  25799     //
      1	  25800     // There's a pciClose(), but nobody calls it. This is needed by the
      1	  25801     // DOS DPMI services to close fxmemmap.vxd.
      1	  25802     //
      1	  25803     // Note that the call to pciClose must be after the shutdown sequence,
      1	  25804     // as the shutdown sequence uses PCI configuration reads/writes...
      1	  25805     //
      1	  25806     pciClose();
      1	  25807 #endif /* !DIRECTX */
      1	  25808 
      1	  25809     INIT_PRINTF(("sst1InitShutdown(): Returning with status %d...\n", FXTRUE));
      1	  25810 #ifdef INIT_OUTPUT
      1	  25811     if ( sst1InitMsgFile != stdout )
      1	  25812         fclose(sst1InitMsgFile);
      1	  25813 #endif
      1	  25814 
      1	  25815     // Make sure that the board info structures are
      1	  25816     // cleared next time sst1InitMapBoard() is called.
      1	  25817     clearBoardInfo = FXTRUE;
      1	  25818 
      1	  25819     return(FXTRUE);
      1	  25820 }
	  25821 
	  25822 /*
	  25823 ** sst1InitCheckBoard():
	  25824 **  Set internal global variables for multiple SST-1 support
	  25825 **
	  25826 */
	  25827 FX_EXPORT FxBool FX_CSTYLE sst1InitCheckBoard(FxU32 *sstbase)
      1	  25828 {
      1	  25829     FxU32 n;
      1	  25830     FxBool returnVal = FXFALSE;
      1	  25831 
      2	  25832     for(n=0; n<boardsInSystem; n++) {
      3	  25833         if((FxU32 *) sst1BoardInfo[n].virtAddr[0] == sstbase) {
      3	  25834             sst1InitDeviceNumber = sst1BoardInfo[n].deviceNumber;
      3	  25835             sst1CurrentBoard = &sst1BoardInfo[n];
      3	  25836             returnVal = FXTRUE;
      3	  25837             n = boardsInSystem;
      2	  25838         }
      1	  25839     }
      1	  25840     return(returnVal);
      1	  25841 }
	  25842 
	  25843 /*
	  25844 ** sst1InitGetBaseAddr():
	  25845 **  Return virtual base address to hardware
	  25846 **  Returns NULL if board requested has not been mapped
	  25847 **
	  25848 */
	  25849 FX_EXPORT FxU32 * FX_CSTYLE sst1InitGetBaseAddr(FxU32 boardNum)
      1	  25850 {

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 19
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25851   SstRegs* sstBaseAddr = sst1BoardInfo[boardNum].virtAddr[0];
      1	  25852   sst1DeviceInfoStruct devInfo;
      1	  25853 
      1	  25854   if ((sstBaseAddr != NULL) &&
      1	  25855       sst1InitGetDeviceInfo((FxU32*)sstBaseAddr, &devInfo) &&
      1	  25856       devInfo.sliDetected &&
      2	  25857       !devInfo.monitorDetected) {
      2	  25858     
      2	  25859     SstRegs* tempAddr = NULL;
      2	  25860 
      3	  25861     if (boardNum > 0) {
      4	  25862       if (sst1BoardInfo[boardNum - 1].sliSlaveVirtAddr == (FxU32*)sstBaseAddr) {
      4	  25863         tempAddr = sst1BoardInfo[boardNum - 1].virtAddr[0];
      3	  25864       }
      2	  25865     }
      2	  25866 
      3	  25867     if ((tempAddr == NULL) && (boardNum < boardsInSystem)) {
      4	  25868       if (sst1BoardInfo[boardNum + 1].sliSlaveVirtAddr == (FxU32*)sstBaseAddr) {
      4	  25869         tempAddr = sst1BoardInfo[boardNum + 1].virtAddr[0];
      3	  25870       }
      2	  25871     }
      2	  25872 
      2	  25873     if (tempAddr != NULL) sstBaseAddr = tempAddr;
      1	  25874   }
      1	  25875   
      1	  25876   return (FxU32*)sstBaseAddr;
      1	  25877 }
	  25878 
	  25879 /*
	  25880 ** sst1InitClearBoardInfo():
	  25881 **  Clear board configuration information
	  25882 **
	  25883 */
	  25884 void sst1InitClearBoardInfo(void)
      1	  25885 {
      1	  25886     FxU32 n, j;
      1	  25887 
      2	  25888     for(n=0; n<SST1INIT_MAX_BOARDS; n++) {
      2	  25889         sst1BoardInfo[n].size = sizeof(sst1DeviceInfoStruct);
      2	  25890         //sst1BoardInfo[n].virtAddr[0] = (SstRegs *) NULL;
      2	  25891         //sst1BoardInfo[n].physAddr[0] = (FxU32) NULL;
      2	  25892         //sst1BoardInfo[n].deviceNumber = 0xdead;
      2	  25893         //sst1BoardInfo[n].vendorID = 0xdead;
      2	  25894         //sst1BoardInfo[n].deviceID = 0xdead;
      2	  25895 
      2	  25896         //sst1BoardInfo[n].fbiRevision = 0xdead;
      2	  25897         //sst1BoardInfo[n].fbiFab = 0xdead;
      2	  25898         sst1BoardInfo[n].fbiBoardID = 0xdead;
      2	  25899         sst1BoardInfo[n].fbiVideo16BPP = 0xdead;
      2	  25900         sst1BoardInfo[n].fbiVideoWidth = 0xdead;
      2	  25901         sst1BoardInfo[n].fbiVideoHeight = 0xdead;
      2	  25902         sst1BoardInfo[n].fbiVideoRefresh = 0xdead;
      2	  25903         sst1BoardInfo[n].fbiVideoColBuffs = 0xdead;
      2	  25904         sst1BoardInfo[n].fbiVideoAuxBuffs = 0xdead;
      2	  25905         sst1BoardInfo[n].fbiVideoMemOffset = 0xdead;
      2	  25906         sst1BoardInfo[n].fbiVideoTilesInX = 0xdead;
      2	  25907         sst1BoardInfo[n].fbiVideoStruct = (sst1VideoTimingStruct *) NULL;

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 20
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      2	  25908         sst1BoardInfo[n].fbiVideoDacType = 0xdead;
      2	  25909         sst1BoardInfo[n].fbiMemoryFifoEn = 0x0;
      2	  25910         sst1BoardInfo[n].fbiCmdFifoEn = 0x0;
      2	  25911         sst1BoardInfo[n].fbiLfbLocked = 0x0;
      2	  25912         sst1BoardInfo[n].fbiConfig = 0xdead;
      2	  25913         sst1BoardInfo[n].fbiGrxClkFreq = 0xdead;
      2	  25914         sst1BoardInfo[n].fbiMemSize = 0x0;
      2	  25915         sst1BoardInfo[n].fbiInitGammaDone = 0x0;
      2	  25916         sst1BoardInfo[n].fbiGammaRed = (double) 0.0;
      2	  25917         sst1BoardInfo[n].fbiGammaGreen = (double) 0.0;
      2	  25918         sst1BoardInfo[n].fbiGammaBlue = (double) 0.0;
      2	  25919 
      2	  25920         sst1BoardInfo[n].tmuRevision = 0xdead;
      2	  25921         sst1BoardInfo[n].numberTmus = 0xdead;
      2	  25922         sst1BoardInfo[n].tmuConfig = 0xdead;
      2	  25923         sst1BoardInfo[n].tmuGrxClkFreq = 0xdead;
      2	  25924 
      3	  25925         for(j=0; j<MAX_NUM_TMUS; j++) {
      3	  25926             sst1BoardInfo[n].tmuFab[j] = 0xdead;
      3	  25927             sst1BoardInfo[n].tmuMemSize[j] = 0x0;
      3	  25928             sst1BoardInfo[n].tmuInit0[j] = 0xdead;
      3	  25929             sst1BoardInfo[n].tmuInit1[j] = 0xdead;
      2	  25930         }
      2	  25931         sst1BoardInfo[n].fbiInit6 = 0;
      2	  25932         sst1BoardInfo[n].fbiInitEnable = 0;
      2	  25933 
      2	  25934         sst1BoardInfo[n].sliDetected = 0;
      2	  25935         sst1BoardInfo[n].monitorDetected = 0;
      2	  25936         sst1BoardInfo[n].sliSlaveVirtAddr = (FxU32 *) NULL;
      2	  25937         sst1BoardInfo[n].initGrxClkDone = 0;
      2	  25938         sst1BoardInfo[n].vgaPassthruDisable = 0;
      2	  25939         sst1BoardInfo[n].vgaPassthruEnable = 0;
      2	  25940         sst1BoardInfo[n].memFifoStatusLwm = 0xdead;
      1	  25941     }
      1	  25942 }
	  25943 
	  25944 /*
	  25945 ** sst1InitNumBoardsInSystem():
	  25946 **  Returns the number of SST-1 boards in the system
	  25947 **
	  25948 */
	  25949 FX_ENTRY FxU32 FX_CSTYLE sst1InitNumBoardsInSystem(void)
      1	  25950 {
      1	  25951     FxU32 vendorID = _3DFX_PCI_ID;     // 3Dfx Vendor ID
      1	  25952     FxU32 deviceID;                    // 0x0002 - Find Voodoo2 boards ( 0xFFFF - Find any 3Dfx board)
      1	  25953     FxU32 j, n;
      1	  25954 
      1	  25955     if( GETENV( ("SSTV2_DEVICEID") ) )
      1	  25956       deviceID = ATOI( GETENV( "SSTV2_DEVICEID" ) );
      1	  25957     else
      1	  25958       deviceID = 0x0002;
      1	  25959 
      1	  25960     boardsInSystemReally = 0;
      2	  25961     for(j=0; j<SST1INIT_MAX_BOARDS; j++) {
      2	  25962        if(pciFindCardMulti(vendorID, deviceID, &n, j))
      2	  25963            boardsInSystemReally++;
      1	  25964     }

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 21
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

      1	  25965     if(GETENV(("SSTV2_BOARDS")))
      1	  25966        return(ATOI(GETENV(("SSTV2_BOARDS"))));
      1	  25967     else
      1	  25968        return(boardsInSystemReally);
      1	  25969 }
	  25970 
	  25971 /*
	  25972 ** sst1InitCaching
	  25973 **
	  25974 ** Sets up memory caching on P6 class systems and K7 systems for the
	  25975 ** lower 8 MB of the 16 MB virtual address space of the card. These
	  25976 ** hold the command fifo area.
	  25977 **
	  25978 */
	  25979 #ifdef __ALPHA
	  25980 FX_ENTRY FxBool FX_CSTYLE 
	  25981 sst1InitCaching(FxU32* sstBase, FxBool enableP)
      1	  25982 {
      1	  25983   // not on VMS
      1	  25984   return FXTRUE;
      1	  25985 }
	  25986 #endif
	  25987 
       X  25988 #ifdef __i386__
       X  25989 FX_ENTRY FxBool FX_CSTYLE 
       X  25990 sst1InitCaching(FxU32* sstBase, FxBool enableP)
       X  25991 {
       X  25992   FxBool retVal = sst1InitCheckBoard(sstBase);
       X  25993 
       X  25994   if (!retVal) return FXFALSE;
       X  25995 
       X  25996   if (enableP && (GETENV("SSTV2_IGNORE_CACHING") == NULL)) {
       X  25997     FxU32 physAddr;
       X  25998     
       X  25999     /* Get the board's base. Isn't this the same as what we
       X  26000      * cary around in sst1CurrentBoard->physAddr[0]?
       X  26001      */
       X  26002     pciGetConfigData(PCI_BASE_ADDRESS_0, sst1CurrentBoard->deviceNumber, &physAddr);
       X  26003     
       X  26004     // For some reason, there sometimes is a 008 at the end of the
       X  26005     // physical address, so mask that puppy RTF out
       X  26006     physAddr &= 0xfffff000;
       X  26007 
       X  26008     /* dpc - 23 jan 1998 - Warning!!!!!
       X  26009      * We are no longer mapping the entire board range as uswc because
       X  26010      * this causes weird problems on some systems. We are now mapping
       X  26011      * the 3d register area as uncacheable (since no one should be
       X  26012      * writing here anyway, except to bump the swapbufferCMD register)
       X  26013      * and the command fifo range and lfb range as uswc.
       X  26014      *
       X  26015      * NB: It is still unclear why this is happening because the
       X  26016      * memory page containing the registers is never really explicitly
       X  26017      * written to until we are shutting down so changing its caching
       X  26018      * characteristics should have no bearing on anything.  */
       X  26019     {
       X  26020 #define kCacheSizeWriteCombine (0x08UL << 20UL)
       X  26021 #define kCacheSizeUncacheable  (0x1000UL)

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 22
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

       X  26022       FxBool hasWC = pciFindMTRRMatch(physAddr, kCacheSizeWriteCombine,
       X  26023                                       PciMemTypeWriteCombining, 
       X  26024                                       &sst1CurrentBoard->mtrrWriteCombine);
       X  26025       FxBool hasUC = pciFindMTRRMatch(physAddr, kCacheSizeUncacheable,
       X  26026                                       PciMemTypeUncacheable,
       X  26027                                       &sst1CurrentBoard->mtrrUncacheable);
       X  26028 
       X  26029       if (!hasWC) {
       X  26030         if (pciFindFreeMTRR(&sst1CurrentBoard->mtrrWriteCombine)) {
       X  26031           hasWC = pciSetMTRR(sst1CurrentBoard->mtrrWriteCombine,
       X  26032                              physAddr, kCacheSizeWriteCombine,
       X  26033                              PciMemTypeWriteCombining);
       X  26034           if (!hasWC) INIT_PRINTF(("sst1InitCaching(): Could not set wc mtrr\n"));
       X  26035         } else {
       X  26036           INIT_PRINTF(("sst1InitCaching(): Could not find wc mtrr\n"));
       X  26037         }
       X  26038       } else {
       X  26039         INIT_PRINTF(("sst1InitCaching(): Already have wc\n"));
       X  26040       }
       X  26041 
       X  26042       if (!hasUC) {
       X  26043         if (pciFindFreeMTRR(&sst1CurrentBoard->mtrrUncacheable)) {
       X  26044           hasUC = pciSetMTRR(sst1CurrentBoard->mtrrUncacheable,
       X  26045                              physAddr, kCacheSizeUncacheable,
       X  26046                              PciMemTypeUncacheable);
       X  26047           if (!hasUC) INIT_PRINTF(("sst1InitCaching(): Could not set uc mtrr\n"));
       X  26048         } else {
       X  26049           INIT_PRINTF(("sst1InitCaching(): Could not find uc mtrr\n"));
       X  26050         }
       X  26051       } else {
       X  26052         INIT_PRINTF(("sst1InitCaching(): Already have uc\n"));
       X  26053       }
       X  26054 
       X  26055       /* We only succeed if we have them both since having only uswc
       X  26056        * seems to cause problems.  
       X  26057        */
       X  26058       retVal = (hasWC && hasUC);
       X  26059       if (!retVal) goto __errExit;
       X  26060 
       X  26061       INIT_PRINTF(("sst1InitCaching(): wc(0x%X) : uc(0x%X)\n",
       X  26062                    sst1CurrentBoard->mtrrWriteCombine,
       X  26063                    sst1CurrentBoard->mtrrUncacheable));
       X  26064     }
       X  26065   } else {
       X  26066     /* This always succeeds */
       X  26067     retVal = FXTRUE;
       X  26068 
       X  26069 __errExit:
       X  26070     if (sst1CurrentBoard->mtrrUncacheable != 0) {
       X  26071       pciSetMTRR(sst1CurrentBoard->mtrrUncacheable, 0, 0, 0);
       X  26072       sst1CurrentBoard->mtrrUncacheable = 0;
       X  26073     }
       X  26074 
       X  26075     if (sst1CurrentBoard->mtrrWriteCombine != 0) {
       X  26076       pciSetMTRR(sst1CurrentBoard->mtrrWriteCombine, 0, 0, 0);
       X  26077       sst1CurrentBoard->mtrrWriteCombine = 0;
       X  26078     }

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 23
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

       X  26079   }
       X  26080 
       X  26081   return retVal;
       X  26082 } // sst1InitSetCaching
       X  26083 
       X  26084 
       X  26085 
       X  26086 /*
       X  26087 ** sst1InitCachingAMD
       X  26088 **
       X  26089 ** Sets up memory caching for AMD K6 and AMD K7 systems for the entire
       X  26090 ** 16mb virtual address space of the card. For K7, goes through
       X  26091 ** sst1InitCaching
       X  26092 **
       X  26093 */
       X  26094 
       X  26095 #define kCacheSizeWriteCombineAMD (0x08UL << 20UL)      /* 8 MB   */
       X  26096 #define kCacheSizeUncacheableAMD  (0x20000UL)           /* 128 KB */
       X  26097 
       X  26098 FX_ENTRY FxBool FX_CSTYLE
       X  26099 sst1InitCachingAMD(FxU32* sstBase, FxBool enableP, FxBool hasP2MTRR)
       X  26100 {
       X  26101   FxBool retVal = sst1InitCheckBoard(sstBase);
       X  26102 
       X  26103   if (!retVal) return FXFALSE;
       X  26104 
       X  26105   /* The K7 has MTRRs that are exactly compatible to the P6/PII, so
       X  26106      we just do the work through the existing sst1InitCaching function
       X  26107   */
       X  26108 
       X  26109   if (hasP2MTRR) { 
       X  26110      return sst1InitCaching(sstBase, enableP);
       X  26111   }
       X  26112 
       X  26113   /* If it's not a K7, we must have a K6 with WC support, i.e. a K6-2 with
       X  26114      CXT core or a Sharptooth, otherwise we wouldn't have gotten here.
       X  26115   */
       X  26116 
       X  26117   if (enableP && (GETENV("SSTV2_IGNORE_CACHING") == NULL)) {
       X  26118     FxU32 physAddr;
       X  26119     
       X  26120     /* Get the board's base. Isn't this the same as what we
       X  26121      * carry around in sst1CurrentBoard->physAddr[0]?
       X  26122      */
       X  26123 
       X  26124     pciGetConfigData(PCI_BASE_ADDRESS_0, sst1CurrentBoard->deviceNumber, &physAddr);
       X  26125     
       X  26126     /* For some reason, there sometimes is a 008 at the end of the
       X  26127      * physical address, so mask that puppy RTF out
       X  26128      */
       X  26129 
       X  26130     physAddr &= 0xfffff000;
       X  26131 
       X  26132     /* dpc - 23 jan 1998 - Warning!!!!!
       X  26133      * We are no longer mapping the entire board range as uswc because
       X  26134      * this causes weird problems on some systems. We are now mapping
       X  26135      * the 3d register area as uncacheable (since no one should be

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 24
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

       X  26136      * writing here anyway, except to bump the swapbufferCMD register)
       X  26137      * and the command fifo range and lfb range as uswc.
       X  26138      *
       X  26139      * NB: It is still unclear why this is happening because the
       X  26140      * memory page containing the registers is never really explicitly
       X  26141      * written to until we are shutting down so changing its caching
       X  26142      * characteristics should have no bearing on anything.
       X  26143      *
       X  26144      * This might no be necessary for K6, as K6 maintains strong write
       X  26145      * ordering in WC regions. We do this here compatible to PII just in
       X  26146      * case. Note: Overlapping WC and UC regions results in UC type on K6,
       X  26147      * just like on PII. Note: the smallest MTRR region size on K6 is 128 KB,
       X  26148      * while on PII it is 4 KB. We make the UC region as small as we can.
       X  26149      */
       X  26150    
       X  26151     /* For K6, we don't do any elaborate allocation, as it only has two
       X  26152      * variable size memory regions, and we need both for Voodoo2. So, we
       X  26153      * just jam the data into the two available MTRRs.
       X  26154      */
       X  26155 
       X  26156     pciSetMTRRAmdK6 (0, physAddr, kCacheSizeWriteCombineAMD, PciMemTypeWriteCombining);
       X  26157     pciSetMTRRAmdK6 (1, physAddr, kCacheSizeUncacheableAMD, PciMemTypeUncacheable);
       X  26158     
       X  26159   } else {  /* disable MTRRs */
       X  26160 
       X  26161     /* This always succeeds */
       X  26162 
       X  26163     retVal = FXTRUE;
       X  26164 
       X  26165     /* Since AMD recommends a "free for all" policy for allocating MTRRs
       X  26166        on K6, we do nothing for "disable". Any software that wants to grab
       X  26167        the MTRRs can just do so. Leaving the MTRR enabled might actually
       X  26168        beneficial in a situation like the following: We run a D3D app, then
       X  26169        a Glide app, then a D3D app, but the second time around D3D doesn't
       X  26170        re-initialize, since it's still active, so it doesn't reprogram the
       X  26171        MTRRs.
       X  26172      */
       X  26173 
       X  26174     // pciSetMTRRAmdK6 (0, 0, 0, 0);    /* size == 0 implies disable */
       X  26175     // pciSetMTRRAmdK6 (1, 0, 0, 0);    /* size == 0 implies disable */
       X  26176 
       X  26177   }
       X  26178 
       X  26179   return retVal;
       X  26180 } // sst1InitSetCachingAMD
       X  26181 #endif
	  26182 
       X  26183 #ifdef _MSC_VER
       X  26184 #pragma optimize ("",on)
       X  26185 #endif

SST1INIT                        Source Listing                  10-MAY-2021 00:42:52  VSI C V7.4-002-50R2O              Page 25
V1.0                                                            10-MAY-2021 00:42:37  sst1init.c;6

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]SST1INIT/OBJECT=[.OUT
.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]SST1INIT.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIB
S.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GL
IDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP
,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1)
 [.GLIDE.GLIDE2X.CVG.INIT]SST1INIT.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May 10 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="00:42:52"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

	      1 #include <stdio.h>
	   1612 #include <stdlib.h>
	   3707 #include <string.h>
	   4158 #include <3dfx.h>
	   4289 #include <fxpci.h>
       X   4552 #if defined(__DOS32__)
       X   4553 /* for INIT_PRINTF: */
       X   4554 #include <sst1init.h>
       X   4555 #else
	   4556 #define INIT_PRINTF(a)     (void)0
	   4557 #endif
	   4558 #define FX_DLL_DEFINITION
	   4559 #include <fxdll.h>
	   4680 
	   4681 #define SIZE_SST1_NEEDED   0x100000
	   4682 #define END_ADDRESS        0x10000000
	   4683 #define S3_SHIFT           0x400000
	   4684 
	   4685 struct RangeSTRUCT
	   4686 {
	   4687    FxU32                address;
	   4688    FxU32                range;
	   4689    FxU32                id;
	   4690    FxU32                is_voodoo; /* 1 = is voodoo, 2 = hidden SLI */
	   4691    FxU32                is_S3;
	   4692    struct RangeSTRUCT   *next;
	   4693    struct RangeSTRUCT   *prev;
	   4694 };
	   4695 
	   4696 typedef struct RangeSTRUCT RangeStruct;
	   4697 
	   4698 static void InitRemap(void);
	   4699 static void CloseRemap(void);
	   4700 static void GetMemoryMap(void);
	   4701 static void RemapVoodoo(RangeStruct *conflict);
	   4702 static void AdjustMapForS3(void);
	   4703 static RangeStruct *TestForConflicts(void);
	   4704 static void RemoveEntry(RangeStruct *del);
	   4705 static void InsertEntry(RangeStruct *ins);
	   4706 static FxBool FindHole(RangeStruct *conflict);
	   4707 static FxU32 SnapToDecentAddress(FxU32 address,RangeStruct *conflict);
	   4708 static FxBool fits_in_hole(RangeStruct *begin,FxU32 end,RangeStruct *hole,RangeStruct *conflict);
	   4709 static FxBool fits_under(RangeStruct *first,FxU32 minimum,RangeStruct *hole,RangeStruct *conflict);
	   4710 static FxU32 pciGetType(int i);
	   4711 static void pciGetRange(PciRegister reg,FxU32 device_number,FxU32 *data);
	   4712 static FxBool pciGetAddress(PciRegister reg,FxU32 device_number,FxU32 *data);
	   4713 
	   4714 static void ForceCleanUp(void);
	   4715 static FxBool FindNecessaryCards(void);
	   4716 static FxBool IsCardVoodoo(int i);
	   4717 static FxBool IsCardS3(int i);
	   4718 static void AddMapEntry(FxU32 address,FxU32 range,FxU32 id,FxBool VoodooCard,FxBool S3Card);
       X   4719 #if 0 /* not used */
       X   4720 static void HandleMemoryOverlap(void);
       X   4721 static FxBool overlap_map(RangeStruct *begin,FxU32 end);
       X   4722 #endif
	   4723 

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

	   4724 static FxU32 num_voodoos=0;
	   4725 
	   4726 static RangeStruct map[80];
       X   4727 #if 0 /* not used */
       X   4728 static RangeStruct hole[80];
       X   4729 #endif
	   4730 static RangeStruct *first_entry;
	   4731 static RangeStruct *last_entry;
	   4732 static int entries=0;
	   4733 static RangeStruct master_hole;
	   4734 static FxU32 conflicts_found=0;
	   4735 
	   4736 static void fxremap_dowork(int argc,char **argv,int doit_silently)
      1	   4737 {
      1	   4738    RangeStruct *conflict;
      1	   4739 
      1	   4740    InitRemap();
      1	   4741 
      1	   4742    if (!FindNecessaryCards())
      2	   4743    {
      2	   4744       INIT_PRINTF(("No Voodoo chipset was detected\n"));
      2	   4745       ForceCleanUp();
      1	   4746    }
      1	   4747 
      1	   4748    GetMemoryMap();
      1	   4749 
      1	   4750    /* expand region of mapping for S3 card */
      1	   4751    AdjustMapForS3();
      1	   4752    /* see if we find any conflicts with any voodoo card */
      1	   4753    while ((conflict=TestForConflicts()))
      2	   4754    {
      2	   4755       conflicts_found++;
      2	   4756       /* since it is going to move */
      2	   4757       /* remove entry, so we can possibly use it as a hole */
      2	   4758       RemoveEntry(conflict);
      2	   4759       if (FindHole(conflict))
      3	   4760       {
      3	   4761          conflict->address=master_hole.address;
      3	   4762          RemapVoodoo(conflict);
      2	   4763       }
      2	   4764       else
      3	   4765       {
      3	   4766          INIT_PRINTF(("Unable to find region to map conflicting board\n"));
      3	   4767          ForceCleanUp();
      3	   4768          return;
      2	   4769       }
      1	   4770    }
      1	   4771 
      2	   4772    if (!conflicts_found) {
      2	   4773       INIT_PRINTF(("No conflict with the Voodoo cards was found\n"));
      1	   4774    }
      1	   4775    CloseRemap();
      1	   4776 }
	   4777 
      1	   4778 void fxremap(void) {
      1	   4779   fxremap_dowork(0,NULL,1);
      1	   4780 }

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

	   4781 
	   4782 static void InitRemap(void)
      1	   4783 {
      1	   4784 #if !DIRECTX
      1	   4785    pciOpen();
      1	   4786 #endif
      1	   4787 }
	   4788 
	   4789 static void CloseRemap(void)
      1	   4790 {
      1	   4791    // pciClose();
      1	   4792 }
	   4793 
      1	   4794 static FxU32 pciGetConfigData_R(PciRegister reg, FxU32 devNum) {
      1	   4795    FxU32 data;
      1	   4796 
      2	   4797    if (pciGetConfigData(reg,devNum,&data) == FXTRUE) {
      2	   4798       return (data);
      2	   4799    } else {
      2	   4800       return (0xFFFFFFFF);
      1	   4801    }
      1	   4802 }
	   4803 
	   4804 #define PCI_NORMAL_TYPE 0
	   4805 #define PCI_BRIDGE_TYPE 1
	   4806 
	   4807 static void GetMemoryMap(void)
      1	   4808 {
      1	   4809    FxU32    temp,temp2;
      1	   4810    FxU32    type;
      1	   4811    int      devNum;
      1	   4812    int fn;     /* function number iterator */
      1	   4813    int maxFnNumber;
      1	   4814    int multi_fn = 0;
      1	   4815 
      1	   4816    for (devNum=0;devNum<MAX_PCI_DEVICES;devNum++)
      2	   4817    {
      2	   4818       if (pciDeviceExists(devNum))
      3	   4819       {
      3	   4820 
      4	   4821          if (pciGetConfigData_R(PCI_HEADER_TYPE,devNum) & (1<<7)) {
      4	   4822              maxFnNumber = 8; /* multifunction! */
      4	   4823              multi_fn = 1;
      4	   4824          } else {
      4	   4825              multi_fn = 0;
      4	   4826              if ((pciGetConfigData_R(PCI_VENDOR_ID,devNum) == 0x121a) &&
      5	   4827                  (pciGetConfigData_R(PCI_DEVICE_ID,devNum) == 0x02)) {
      5	   4828                  maxFnNumber = 8; /* single board SLI! */
      5	   4829              } else {
      5	   4830                  maxFnNumber = 1;
      4	   4831              }
      3	   4832          }
      3	   4833 
      4	   4834          for(fn=0;fn<maxFnNumber;fn++) {
      4	   4835 
      4	   4836            int i = devNum | (fn << 13); /* add function number */
      5	   4837            if (pciGetConfigData_R(PCI_VENDOR_ID,i) != 0xFFFF) {

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      5	   4838 
      5	   4839              /* two header types */
      5	   4840              /* one for bridges and one for everything else */
      5	   4841              type=pciGetType(i);
      6	   4842              if (type==PCI_NORMAL_TYPE) {
      7	   4843                if (pciGetAddress(PCI_BASE_ADDRESS_0,i,&temp)) {
      7	   4844                  pciGetRange(PCI_BASE_ADDRESS_0,i,&temp2);
      7	   4845                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6	   4846                }
      7	   4847                if (pciGetAddress(PCI_BASE_ADDRESS_1,i,&temp)) {
      7	   4848                  pciGetRange(PCI_BASE_ADDRESS_1,i,&temp2);
      7	   4849                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6	   4850                }
      6	   4851 
      6X   4852 #if 0
      6	   4853                /* Legacy address which is not needed for sst1 type
      6	   4854                 * things w/o 2d.
      6X   4855                 */
      6X   4856                if (pciGetAddress(PCI_IO_BASE_ADDRESS,i,&temp)) {
      6X   4857                  pciGetRange(PCI_IO_BASE_ADDRESS,i,&temp2);
      6X   4858                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6X   4859                }
      6X   4860 #endif
      7	   4861                if (pciGetAddress(PCI_ROM_BASE_ADDRESS,i,&temp)) {
      7	   4862                  pciGetRange(PCI_ROM_BASE_ADDRESS,i,&temp2);
      7	   4863                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6	   4864                }
      6	   4865              } else if (type==PCI_BRIDGE_TYPE) {
      7	   4866                if (pciGetAddress(PCI_BASE_ADDRESS_0,i,&temp)) {
      7	   4867                  pciGetRange(PCI_BASE_ADDRESS_0,i,&temp2);
      7	   4868                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6	   4869                }
      7	   4870                if (pciGetAddress(PCI_BASE_ADDRESS_1,i,&temp)) {
      7	   4871                  pciGetRange(PCI_BASE_ADDRESS_1,i,&temp2);
      7	   4872                  AddMapEntry(temp,temp2,i,IsCardVoodoo(i),IsCardS3(i));
      6	   4873                }
      5	   4874              }
      4	   4875            } /* if function number exists */
      3	   4876          } /* for all function numbers */
      2	   4877       }
      1	   4878    }
      1	   4879 }
	   4880 
	   4881 static void AdjustMapForS3(void)
      1	   4882 {
      1	   4883    RangeStruct *cur;
      1	   4884 
      1	   4885    cur=first_entry;
      1	   4886 
      1	   4887    while(cur)
      2	   4888    {
      2	   4889       if (cur->is_S3)
      3	   4890       {
      3	   4891          cur->address-=S3_SHIFT;
      3	   4892          cur->range=S3_SHIFT<<1;
      2	   4893       }
      2	   4894       cur=cur->next;

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      1	   4895    }
      1	   4896 }
	   4897 
	   4898 static RangeStruct *TestForConflicts(void)
      1	   4899 {
      1	   4900    RangeStruct *cur,*next;
      1	   4901 
      1	   4902    cur=first_entry;
      1	   4903 
      1	   4904    while(cur)
      2	   4905    {
      2	   4906       /* if this is a poorly mapped voodoo2 single board SLI, then remap */
      3	   4907       if ((cur->is_voodoo == 2) && (cur->address == 0xFF00000)) {
      3	   4908         return (cur);
      2	   4909       }
      2	   4910 
      2	   4911       if (cur->next)
      3	   4912       {
      3	   4913          if ((cur->address + cur->range) > cur->next->address)
      4	   4914          {
      4	   4915             next=cur->next;
      4	   4916             if ((cur->is_voodoo)||(next->is_voodoo))
      5	   4917             {
      5	   4918                if (cur->is_voodoo)
      6	   4919                {
      6	   4920                   return cur;
      5	   4921                }
      5	   4922                return next;
      4	   4923             }
      5	   4924             else {
      5	   4925                INIT_PRINTF(("FxRemap: Possible PCI conflict not with Voodoo device\n"
      5	   4926                                "%X (%X) <-> %X (%X)\n",cur->id, cur->address,
      5	   4927                                cur->next->id, cur->next->address));
      4	   4928             }
      3	   4929          }
      2	   4930       }
      2	   4931       else
      3	   4932       {
      3	   4933          if ((cur->address + cur->range) > END_ADDRESS)
      3	   4934             return cur;
      2	   4935       }
      2	   4936       cur=cur->next;
      1	   4937    }
      1	   4938    return NULL;
      1	   4939 }
	   4940 
	   4941 static void AddMapEntry(FxU32 address,FxU32 range,FxU32 id,FxBool VoodooCard,FxBool S3Card)
      1	   4942 {
      1	   4943    RangeStruct *temp,*cur,*next;
      1	   4944 
      1	   4945 //jcochrane@3dfx.com
      1	   4946    int        entry=0;
      1	   4947    FxU32	   tmp_address=0;
      1	   4948 //END
      1	   4949 
      1X   4950 #if 0
      1X   4951    static int    test_entry=0;

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      1X   4952 
      1X   4953    address=test_data[test_entry].address;
      1X   4954    range=~(test_data[test_entry++].range - 0x1);
      1X   4955 #endif
      1	   4956    /* only if address != 0 */
      1	   4957 
      1	   4958 //jcochrane@3dfx.com
      1	   4959 //check for duplicate entries in the map table,ignore if there is
      1	   4960 
      1	   4961 	tmp_address=address>>4;
      1	   4962 	for(entry=0;entry<entries;entry++)
      2	   4963 	{
      2	   4964 		if( tmp_address == map[entry].address)
      2	   4965 			address=0;
      1	   4966 	}
      1	   4967 //END
      1	   4968 
      1	   4969    if(address)
      2	   4970    {
      2	   4971       map[entries].address=address>>4;
      2	   4972       map[entries].range=((~range)>>4)+0x1;
      2	   4973 
      2	   4974       map[entries].id=id;
      2	   4975       map[entries].is_voodoo=VoodooCard;
      2	   4976       map[entries].is_S3=S3Card;
      2	   4977 
      2	   4978       temp=&map[entries++];
      2	   4979       if (entries<=1)
      3	   4980       {
      3	   4981          first_entry=temp;
      3	   4982          last_entry=temp;
      3	   4983          temp->next=NULL;
      3	   4984          temp->prev=NULL;
      3	   4985          return;
      2	   4986       }
      2	   4987 
      2	   4988       cur=first_entry;
      2	   4989       next=NULL;
      2	   4990       while(cur)
      3	   4991       {
      3	   4992          if (temp->address < cur->address)
      4	   4993          {
      4	   4994             next=cur;
      4	   4995             break;
      3	   4996          }
      3	   4997          cur=cur->next;
      2	   4998       }
      2	   4999       if (next)
      3	   5000       {
      3	   5001          temp->next=next;
      3	   5002          temp->prev=next->prev;
      3	   5003          next->prev=temp;
      3	   5004          if (next==first_entry)
      3	   5005             first_entry=temp;
      3	   5006          else
      3	   5007             (temp->prev)->next=temp;
      2	   5008       }

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      2	   5009       else
      3	   5010       {
      3	   5011          last_entry->next=temp;
      3	   5012          temp->prev=last_entry;
      3	   5013          last_entry=temp;
      3	   5014          temp->next=NULL;
      2	   5015       }
      1	   5016    }
      1	   5017 }
	   5018 
	   5019 static void RemoveEntry(RangeStruct *del)
      1	   5020 {
      1	   5021    RangeStruct *prev;
      1	   5022 
      1	   5023    if (!(del->next))
      2	   5024    {
      2	   5025       if (!(del->prev))
      3	   5026       {
      3	   5027          INIT_PRINTF(("FxRemap: No entries mapped\n"));
      3	   5028          ForceCleanUp();
      3	   5029          return;
      2	   5030       }
      2	   5031       prev=del->prev;
      2	   5032       last_entry=prev;
      2	   5033 
      2	   5034       prev->next=NULL;
      2	   5035       del->prev=NULL;
      2	   5036       del->next=NULL;
      1	   5037    }
      1	   5038    else
      2	   5039    {
      2	   5040       if (!(del->prev))
      3	   5041       {
      3	   5042          del->next->prev=NULL;
      3	   5043          first_entry=del->next;
      2	   5044       }
      2	   5045       else
      3	   5046       {
      3	   5047          del->next->prev=del->prev;
      3	   5048          del->prev->next=del->next;
      2	   5049       }
      2	   5050       del->next=NULL;
      2	   5051       del->prev=NULL;
      1	   5052    }
      1	   5053 }
	   5054 
	   5055 static void InsertEntry(RangeStruct *ins)
      1	   5056 {
      1	   5057    RangeStruct *cur;
      1	   5058 
      1	   5059    cur=first_entry;
      1	   5060    
      1	   5061    ins->next=NULL;
      1	   5062    ins->prev=NULL;
      1	   5063 
      1	   5064    if (!first_entry)
      2	   5065    {

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      2	   5066       first_entry=ins;
      2	   5067       last_entry=ins;
      2	   5068       return;
      1	   5069    }
      1	   5070    while(cur)
      2	   5071    {
      2	   5072       if (ins->address < cur->address)
      3	   5073       {
      3	   5074          ins->next=cur;
      3	   5075          ins->prev=cur->prev;
      3	   5076          cur->prev=ins;
      3	   5077          
      3	   5078          if (!ins->prev)
      4	   5079          {
      4	   5080             first_entry=ins;
      3	   5081          }
      3	   5082          else
      4	   5083          {
      4	   5084             (ins->prev)->next=ins;
      3	   5085          }
      3	   5086          return;
      2	   5087       }
      2	   5088       cur=cur->next;
      1	   5089    }
      1	   5090 
      1	   5091    /* if it got this far it needs to go at the end */
      1	   5092    ins->prev=last_entry;
      1	   5093    last_entry->next=ins;
      1	   5094    last_entry=ins;
      1	   5095 }
	   5096 
	   5097 static FxU32 SnapToDecentAddress(FxU32 address,RangeStruct *conflict)
      1	   5098 {
      1	   5099    FxU32 range;
      1	   5100    FxU32 mask;
      1	   5101    FxU32 not_mask;
      1	   5102 
      1	   5103    range=conflict->range;
      1	   5104    if (range<0x10000)
      1	   5105       range=0x10000;
      1	   5106    mask=range;
      1	   5107    mask-=1;
      1	   5108    not_mask=~mask;
      1	   5109 
      1	   5110    if (address & mask)
      2	   5111    {
      2	   5112       address=(address & not_mask) + range;
      1	   5113    }
      1	   5114    return address;
      1	   5115 }
	   5116 
	   5117 static FxBool fits_in_hole(RangeStruct *begin,FxU32 end,RangeStruct *hole,RangeStruct *conflict)
      1	   5118 {
      1	   5119    FxU32 address;
      1	   5120 
      1	   5121    address=begin->address+begin->range;
      1	   5122 

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      1	   5123    address=SnapToDecentAddress(address,conflict);
      1	   5124 
      1	   5125    /* note could be <= */
      1	   5126    /* this is safer but more inefficient memory wise */
      1	   5127    if ((address+conflict->range)<end)
      2	   5128    {
      2	   5129       hole->address=address;
      2	   5130       hole->range=end-address;
      2	   5131       return FXTRUE;
      1	   5132    }
      1	   5133    return FXFALSE;
      1	   5134 }
	   5135 
	   5136 static FxBool fits_under(RangeStruct *first,FxU32 minimum,RangeStruct *hole,RangeStruct *conflict)
      1	   5137 {
      1	   5138    FxU32 address;
      1	   5139 
      1	   5140    address=minimum;
      1	   5141    address=SnapToDecentAddress(address,conflict);
      1	   5142 
      1	   5143    if ((address+conflict->range) < first->address)
      2	   5144    {
      2	   5145       hole->address=address;
      2	   5146       hole->range=first->address - address;
      2	   5147       return FXTRUE;
      1	   5148    }
      1	   5149    return FXFALSE;
      1	   5150 }
	   5151 
	   5152 
	   5153 static FxBool FindHole(RangeStruct *conflict)
      1	   5154 {
      1	   5155    RangeStruct *cur;
      1	   5156 
      1	   5157    cur=first_entry;
      1	   5158 
      1	   5159    while(cur)
      2	   5160    {
      2	   5161       if (!(cur->next))
      3	   5162       {
      3	   5163          if (fits_in_hole(cur,END_ADDRESS,&master_hole,conflict))
      4	   5164          {
      4	   5165             return FXTRUE;
      3	   5166          }
      2	   5167       }
      2	   5168       else
      3	   5169       {
      3	   5170          if (fits_in_hole(cur,cur->next->address,&master_hole,conflict))
      4	   5171          {
      4	   5172             return FXTRUE;
      3	   5173          }
      2	   5174       }
      2	   5175       cur=cur->next;
      1	   5176    }
      1	   5177 
      1	   5178    /* see if we can find a whole located below addressed boards */
      1	   5179    /* don't want to go below 0xA000000 for addressing our boards */

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      1	   5180    if (first_entry->address > 0xA000000)
      2	   5181    {
      2	   5182       if (fits_under(first_entry,0xA000000,&master_hole,conflict))
      2	   5183          return FXTRUE;
      1	   5184    }
      1	   5185    return FXFALSE;
      1	   5186 }
	   5187 
	   5188 static void RemapVoodoo(RangeStruct *conflict)
      1	   5189 {
      1	   5190    FxU32    address;
      1	   5191 
      1	   5192    /* put conflict back into memory map */
      1	   5193    InsertEntry(conflict);
      1	   5194 
      1	   5195    address=(conflict->address)<<4;
      1	   5196    pciSetConfigData(PCI_BASE_ADDRESS_0,conflict->id,&address);
      1	   5197    INIT_PRINTF(("Remapped Voodoo Board to avoid a conflict\n"));
      1	   5198 }
	   5199 
	   5200 static void pciGetRange(PciRegister reg,FxU32 device_number,FxU32 *data)
      1	   5201 {
      1	   5202    FxU32    temp=0xFFFFFFFF;
      1	   5203    FxU32    size,save;
      1	   5204    
      1	   5205    pciGetConfigData(reg,device_number,&save);
      1	   5206    pciSetConfigData(reg,device_number,&temp);
      1	   5207    pciGetConfigData(reg,device_number,&size);
      1	   5208    pciSetConfigData(reg,device_number,&save);
      1	   5209 
      1	   5210    *data=size;
      1	   5211 }
	   5212 
	   5213 static FxBool pciGetAddress(PciRegister reg,FxU32 device_number,FxU32 *data)
      1	   5214 {
      1	   5215    pciGetConfigData(reg,device_number,data);
      1	   5216    if ((*data)==0)
      1	   5217       return FXFALSE;
      1	   5218    if (*data & 0x01)
      1	   5219       return FXFALSE;
      1	   5220    return FXTRUE;
      1	   5221 }
	   5222 
	   5223 static void ForceCleanUp(void)
      1	   5224 {
      1	   5225    // pciClose();
      1	   5226    // exit(1);
      1	   5227 }
	   5228 
	   5229 static FxBool FindNecessaryCards(void)
      1	   5230 {
      1	   5231    FxBool voodoo_found=FXFALSE;
      1	   5232    int   i;
      1	   5233 
      1	   5234    for (i=0;i<MAX_PCI_DEVICES;i++)
      2	   5235    {
      2	   5236       if (pciDeviceExists(i))

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      3	   5237       {
      3	   5238          if(IsCardVoodoo(i))
      4	   5239          {
      4	   5240             voodoo_found=FXTRUE;
      4	   5241             num_voodoos++;
      3	   5242          }
      2	   5243       }
      1	   5244    }
      1	   5245    if (!voodoo_found)
      1	   5246       return FXFALSE;
      1	   5247    return FXTRUE;
      1	   5248 }
	   5249 
	   5250 static FxU32 pciGetType(int i)
      1	   5251 {
      1	   5252    FxU32 header_type;
      1	   5253 
      1	   5254    pciGetConfigData(PCI_HEADER_TYPE,i,&header_type);
      1	   5255 
      1	   5256    return header_type;
      1	   5257 }
	   5258 
	   5259 static FxBool IsCardVoodoo(int i)
      1	   5260 {
      1	   5261    FxU32    vendor,dev_id;
      1	   5262    FxU32    fn_num = (i >> 13) & 0x7; 
      1	   5263    int      true_val;
      1	   5264 
      2	   5265    if (fn_num) {
      2	   5266      true_val = 2;
      2	   5267    } else {
      2	   5268      true_val = 1;
      1	   5269    }
      1	   5270    
      1	   5271    pciGetConfigData(PCI_VENDOR_ID,i,&vendor);
      1	   5272    pciGetConfigData(PCI_DEVICE_ID,i,&dev_id);
      1	   5273    /* if sst1 */
      1	   5274    if ((vendor==0x121a)&&(dev_id==0x0001))
      1	   5275       return FXTRUE;
      1	   5276    /* if voodoo2 */
      2	   5277    if ((vendor==0x121a)&&(dev_id==0x0002)) {
      2	   5278       if (true_val == 2) { INIT_PRINTF(("found voodoo2 hidden sli\n")); }
      2	   5279       return true_val;
      1	   5280    }
      1	   5281    /* if banshee */
      1	   5282    if ((vendor==0x121a)&&(dev_id==0x0003))
      1	   5283       return FXTRUE;
      1	   5284    /* if h4? or whatever is next */
      1	   5285    if ((vendor==0x121a)&&(dev_id==0x0004))
      1	   5286       return FXTRUE;
      1	   5287    return FXFALSE;
      1	   5288 }
	   5289 
	   5290 static FxBool IsCardS3(int i)
      1	   5291 {
      1	   5292    FxU32    vendor,dev_id;
      1	   5293 

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

      1	   5294    pciGetConfigData(PCI_VENDOR_ID,i,&vendor);
      1	   5295    pciGetConfigData(PCI_DEVICE_ID,i,&dev_id);
      1	   5296    if ((vendor==0x5333)&&((dev_id==0x88f0)||(dev_id==0x8880)))
      1	   5297       return FXTRUE;
      1	   5298 
      1	   5299    return FXFALSE;
      1	   5300 }
	   5301 
       X   5302 #if 0 /* not used */
       X   5303 static void HandleMemoryOverlap(void)
       X   5304 {
       X   5305    RangeStruct *cur;
       X   5306 
       X   5307    cur=first_entry;
       X   5308    while(cur)
       X   5309    {
       X   5310       if (cur!=last_entry)
       X   5311       {
       X   5312          if (overlap_map(cur,cur->next->address))
       X   5313          {
       X   5314             if (cur->range<(cur->next->address+cur->next->range-cur->address))
       X   5315                cur->range=cur->next->address+cur->next->range-cur->address;
       X   5316             if (cur->next==last_entry)
       X   5317             {
       X   5318                last_entry=cur;
       X   5319                cur->next=NULL;
       X   5320             }
       X   5321             else
       X   5322             {
       X   5323                cur->next=cur->next->next;
       X   5324                cur->next->prev=cur;
       X   5325             }
       X   5326          }
       X   5327          else
       X   5328             cur=cur->next;
       X   5329       }
       X   5330       else
       X   5331          cur=cur->next;
       X   5332    }
       X   5333 }
       X   5334 
       X   5335 static FxBool overlap_map(RangeStruct *begin,FxU32 end)
       X   5336 {
       X   5337    if ((begin->address+begin->range)>end)
       X   5338       return FXTRUE;
       X   5339    return FXFALSE;
       X   5340 }
       X   5341 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]FXREMAP/OBJECT=[.OUT.
DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]FXREMAP.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.
FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLID
E2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,G

FXREMAP                         Source Listing                   9-MAY-2021 23:43:15  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  fxremap.c;1

LIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [
.GLIDE.GLIDE2X.CVG.INIT]FXREMAP.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:15"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


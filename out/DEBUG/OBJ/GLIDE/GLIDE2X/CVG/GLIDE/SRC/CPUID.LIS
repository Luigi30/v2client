CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

	      1 /*
	      2  * CPU detection code
	      3  *
	      4  *
	      5  * Revision 1.1.2.2  2006/09/02 03:12:29  guillemj
	      6  * Backport glide3 fix for PIC compilation with gcc 4.1 from Hans de Goede.
	      7  *
	      8  * Revision 1.1.2.1  2004/12/12 15:16:02  koolsmoky
	      9  * new cpuid
	     10  *
	     11  * Revision 1.1.2.10  2004/10/05 14:54:29  dborca
	     12  * DOS/OpenWatcom woes
	     13  *
	     14  * Revision 1.1.2.9  2003/08/04 12:45:47  dborca
	     15  * Preparing for MinGW 2.0
	     16  *
	     17  * Revision 1.1.2.8  2003/07/29 10:04:32  dborca
	     18  * Shamelessness.
	     19  * Safeguard in CPUID.
	     20  * Changed contact address!
	     21  * Koolsmoky's texture download fixes.
	     22  *
	     23  * Revision 1.1.2.7  2003/07/25 07:14:58  dborca
	     24  * ... in the name of the Linux, DRI and the sacred Glide...
	     25  *
	     26  * Revision 1.1.2.6  2003/07/24 13:13:03  koolsmoky
	     27  * use __try/__except mechanism for win32 to catch SSE sigillegal in win95
	     28  *
	     29  * Revision 1.1.2.5  2003/07/01 11:16:42  dborca
	     30  * fixed  a bug in GNUC code when running Intel; also removed detritus
	     31  *
	     32  * Revision 1.1.2.3  2003/06/13 07:22:58  dborca
	     33  * more fixes to NASM sources
	     34  *
	     35  */
	     36 
	     37 #include <signal.h>
	   1432 #include <setjmp.h>
	   1618 #include <string.h>
	   2069 
	   2070 #include "cpuid.h"
	   2094 
       X   2095 #if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 3)))
       X   2096 typedef unsigned int __attribute__((__may_alias__)) word32;
       X   2097 #else
	   2098 typedef unsigned int word32;
	   2099 #endif
	   2100 
	   2101 /* These are the bit flags that get set on calling cpuid
	   2102  * with register eax set to 1
	   2103  */
	   2104 #define _MMX_FEATURE_BIT	0x00800000
	   2105 #define _SSE_FEATURE_BIT	0x02000000
	   2106 #define _SSE2_FEATURE_BIT	0x04000000
	   2107 
	   2108 /* This bit is set when cpuid is called with
	   2109  * register set to 80000001h (only applicable to AMD)

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

	   2110  */
	   2111 #define _3DNOW_FEATURE_BIT	0x80000000
	   2112 #define _3DNOWPLUS_FEATURE_BIT	0x40000000
	   2113 #define _MMXPLUS_FEATURE_BIT	0x00400000
	   2114 
	   2115 /* Testing code:
	   2116  * TEST_SSE       = xorps xmm0, xmm0
	   2117  * TEST_SSE2      = xorpd xmm0, xmm0
	   2118  * TEST_3DNOW     = femms
	   2119  * TEST_MMX       = emms
	   2120  * TEST_3DNOWPLUS = femms | pswapd mm0, mm0 | femms
	   2121  * TEST_MMXPLUS   = emms | pminsw mm0, mm0 | emms
	   2122  */
       X   2123 #ifdef __GNUC__
       X   2124 #define TEST_CPUID(f)    __asm __volatile ("pushl %%ebx; cpuid; popl %%ebx"::"a"(f):"%ecx", "%edx")
       X   2125 #define TEST_SSE()       __asm __volatile (".byte 0x0f, 0x57, 0xc0")
       X   2126 #define TEST_SSE2()      __asm __volatile (".byte 0x66, 0x0f, 0x57, 0xc0")
       X   2127 #define TEST_3DNOW()     __asm __volatile (".byte 0x0f, 0x0e")
       X   2128 #define TEST_MMX()       __asm __volatile (".byte 0x0f, 0x77")
       X   2129 #define TEST_3DNOWPLUS() __asm __volatile (".byte 0x0f, 0x0e, 0x0f, 0x0f, 0xc0, 0xbb, 0x0f, 0x0e")
       X   2130 #define TEST_MMXPLUS()   __asm __volatile (".byte 0x0f, 0x77, 0x0f, 0xea, 0xc0, 0x0f, 0x77")
       X   2131 #elif defined(__i386__)
       X   2132 #define TEST_CPUID(f)    __asm { _asm mov eax, f _asm cpuid }
       X   2133 #define TEST_SSE()       __asm { _asm _emit 0x0f _asm _emit 0x57 _asm _emit 0xc0 }
       X   2134 #define TEST_SSE2()      __asm { _asm _emit 0x66 _asm _emit 0x0f _asm _emit 0x57 _asm _emit 0xc0 }
       X   2135 #define TEST_3DNOW()     __asm { _asm _emit 0x0f _asm _emit 0x0e }
       X   2136 #define TEST_MMX()       __asm { _asm _emit 0x0f _asm _emit 0x77 }
       X   2137 #define TEST_3DNOWPLUS() __asm { _asm _emit 0x0f _asm _emit 0x0e _asm _emit 0x0f _asm _emit 0x0f _asm _emit 0xc0 _as
       X   2137 m _emit 0xbb _asm _emit 0x0f _asm _emit 0x0e }
       X   2138 #define TEST_MMXPLUS()   __asm { _asm _emit 0x0f _asm _emit 0x77 _asm _emit 0x0f _asm _emit 0xea _asm _emit 0xc0 _as
       X   2138 m _emit 0x0f _asm _emit 0x77 }
       X   2139 #endif
	   2140 
	   2141 
	   2142 #ifndef __MSC__
	   2143 static jmp_buf j;
	   2144 
	   2145 
	   2146 /* Desc: signal handler
	   2147  *
	   2148  * In  : signal number
	   2149  * Out : -
	   2150  *
	   2151  * Note: returns by `longjmp'ing
	   2152  */
	   2153 static void handler (int signal)
      1	   2154 {
      1	   2155  longjmp(j, signal + 1); /* so we can tell... also ensure we don't pass 0 */
      1	   2156 }
	   2157 
	   2158 
	   2159 /* Desc: check if CPU has specific feature
	   2160  *
	   2161  * In  : feature request
	   2162  * Out : 0 == fail, input == pass
	   2163  *
	   2164  * Note: this should be in the `has_feature' body. The reason it isn't:

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

	   2165  *       under some systems (notably Linux), the `setjmp' may thrash EBX,
	   2166  *       which is used for PositionIndependentCode/GlobalOffsetTable system.
	   2167  *       Since EBX is non-volatile register, it should be restored upon return.
	   2168  */
	   2169 static int check_feature (int feature)
      1	   2170 {
      2	   2171  if (setjmp(j)) {
      2	   2172     /* we got here only when `longjmp'ed by signal handlers */
      2	   2173     return 0;
      2	   2174  } else {
      2	   2175     /* we have signals and jump buffer set */
      3	   2176     switch (feature) {
      3X   2177       #ifdef __i386__
      3X   2178            case _CPU_HAS_CPUID:         TEST_CPUID(0);    break;
      3X   2179            case _CPU_FEATURE_SSE:       TEST_SSE();       break;
      3X   2180            case _CPU_FEATURE_SSE2:      TEST_SSE2();      break;
      3X   2181            case _CPU_FEATURE_3DNOW:     TEST_3DNOW();     break;
      3X   2182            case _CPU_FEATURE_MMX:       TEST_MMX();       break;
      3X   2183            case _CPU_FEATURE_3DNOWPLUS: TEST_3DNOWPLUS(); break;
      3X   2184            case _CPU_FEATURE_MMXPLUS:   TEST_MMXPLUS();   break;
      3X   2185       #endif
      3	   2186            default: return 0;
      2	   2187     }
      2	   2188     return feature;
      1	   2189  }
      1	   2190 }
	   2191 #endif
	   2192 
	   2193 
	   2194 /* Desc: perform (possibly faulting) instructions in a safe manner
	   2195  *
	   2196  * In  : feature request
	   2197  * Out : 0 == fail, input == pass
	   2198  *
	   2199  * Note: pure ANSI code; stupid Watcom cannot handle this.
	   2200  */
	   2201 static int has_feature (int feature)
      1	   2202 {
      1	   2203 #ifndef __MSC__
      1	   2204  int rv;
      1	   2205 
      1	   2206  /* register signal handlers */
      1	   2207  void (*old_sigill)(int) = signal(SIGILL, handler);
      2	   2208  if (old_sigill == SIG_ERR) {
      2	   2209     return 0;
      1	   2210  }
      1	   2211 
      1	   2212  rv = check_feature(feature);
      1	   2213 
      1	   2214  /* restore the signal handlers */
      1	   2215  signal(SIGILL, old_sigill);
      1	   2216  return rv;
      1X   2217 #else
      1	   2218  /* Use the non-standard __try/__except mechanism because win95 fails to catch
      1	   2219   * sigillegal for SSE using standard signal mechanism.
      1	   2220   * HACK ALERT! HACK ALERT! HACK ALERT!
      1	   2221   * This means the MinGW version cannot be safely run under Win95!

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

      1X   2222   */
      1X   2223 #define _TRY() __try {
      1X   2224 #define _EXCEPTION() } __except(1) { return 0; } /* EXCEPTION_EXECUTE_HANDLER=1 */
      1X   2225  switch (feature) {
      1X   2226     case _CPU_HAS_CPUID:         _TRY() TEST_CPUID(0)    _EXCEPTION() break;
      1X   2227     case _CPU_FEATURE_SSE:       _TRY() TEST_SSE()       _EXCEPTION() break;
      1X   2228     case _CPU_FEATURE_SSE2:      _TRY() TEST_SSE2()      _EXCEPTION() break;
      1X   2229     case _CPU_FEATURE_3DNOW:     _TRY() TEST_3DNOW()     _EXCEPTION() break;
      1X   2230     case _CPU_FEATURE_MMX:       _TRY() TEST_MMX()       _EXCEPTION() break;
      1X   2231     case _CPU_FEATURE_3DNOWPLUS: _TRY() TEST_3DNOWPLUS() _EXCEPTION() break;
      1X   2232     case _CPU_FEATURE_MMXPLUS:   _TRY() TEST_MMXPLUS()   _EXCEPTION() break;
      1X   2233     default: return 0;
      1X   2234  }
      1X   2235  return feature;
      1X   2236 #endif
      1	   2237 }
	   2238 
	   2239 
	   2240 /* Desc: get CPU info
	   2241  *
	   2242  * In  : pointer to _p_info
	   2243  * Out : features
	   2244  *
	   2245  * Note: -
	   2246  */
	   2247 int _cpuid (_p_info *pinfo)
      1	   2248 {
      1	   2249  word32 dwId = 0;
      1	   2250  word32 dwFeature = 0;
      1	   2251  word32 dwExt = 0;
      1	   2252  int feature = 0, os_support = 0;
      1	   2253  char Ident[13];
      1	   2254 
      2	   2255  if (!has_feature(_CPU_HAS_CPUID)) {
      2	   2256     return 0;
      1	   2257  }
      1	   2258 
      1X   2259 #ifdef __GNUC__
      1	   2260  __asm("\n\
      1	   2261 	/* get the vendor string */	\n\
      1	   2262 	pushl	%%ebx			\n\
      1	   2263 	xorl	%%eax, %%eax		\n\
      1	   2264 	cpuid				\n\
      1	   2265 	movl	%%ebx, %%eax		\n\
      1	   2266 	popl	%%ebx			\n\
      1	   2267 	movl	%%eax, %3		\n\
      1	   2268 	movl	%%edx, %4		\n\
      1	   2269 	movl	%%ecx, %5		\n\
      1	   2270 	/* get the Standard bits */	\n\
      1	   2271 	pushl	%%ebx			\n\
      1	   2272 	movl	$1, %%eax		\n\
      1	   2273 	cpuid				\n\
      1	   2274 	popl	%%ebx			\n\
      1	   2275 	movl	%%eax, %1		\n\
      1	   2276 	movl	%%edx, %2		\n\
      1	   2277 	/* get AMD-specials */		\n\
      1	   2278 	pushl	%%ebx			\n\

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

      1	   2279 	movl	$0x80000000, %%eax	\n\
      1	   2280 	cpuid				\n\
      1	   2281 	popl	%%ebx			\n\
      1	   2282 	cmpl	$0x80000000, %%eax	\n\
      1	   2283 	jc	0f			\n\
      1	   2284 	pushl	%%ebx			\n\
      1	   2285 	movl	$0x80000001, %%eax	\n\
      1	   2286 	cpuid				\n\
      1	   2287 	popl	%%ebx			\n\
      1	   2288 	movl	%%edx, %0		\n\
      1	   2289  0:					\n\
      1X   2290  ":"=g"(dwExt), "=g"(dwId), "=g"(dwFeature),
      1X   2291    "=g"(((word32 *)Ident)[0]), "=g"(((word32 *)Ident)[1]), "=g"(((word32 *)Ident)[2])
      1X   2292  ::"%eax", "%ecx", "%edx");
      1X   2293 #elif defined(__i386__)
      1X   2294     _asm
      1X   2295     {
      1X   2296         push ebx
      1X   2297         push ecx
      1X   2298         push edx
      1X   2299 
      1X   2300         /* get the vendor string */
      1X   2301         xor eax,eax
      1X   2302         cpuid
      1X   2303         mov dword ptr [Ident],ebx
      1X   2304         mov dword ptr [Ident+4],edx
      1X   2305         mov dword ptr [Ident+8],ecx
      1X   2306 
      1X   2307         /* get the Standard bits */
      1X   2308         mov eax,1
      1X   2309         cpuid
      1X   2310         mov dwId,eax
      1X   2311         mov dwFeature,edx
      1X   2312 
      1X   2313         /* get AMD-specials */
      1X   2314         mov eax,80000000h
      1X   2315         cpuid
      1X   2316         cmp eax,80000000h
      1X   2317         jc notamd
      1X   2318         mov eax,80000001h
      1X   2319         cpuid
      1X   2320         mov dwExt,edx
      1X   2321 
      1X   2322 notamd:
      1X   2323         pop ecx
      1X   2324         pop ebx
      1X   2325         pop edx
      1X   2326     }
      1X   2327 #endif
      1	   2328 
      1	   2329 #ifndef __WATCOMC__
      1	   2330  /* stupid watcom does not sigill... */
      2	   2331  if (dwFeature & _MMX_FEATURE_BIT) {
      2	   2332     feature |= _CPU_FEATURE_MMX;
      2	   2333     os_support |= has_feature(_CPU_FEATURE_MMX);
      1	   2334  }
      2	   2335  if (dwExt & _3DNOW_FEATURE_BIT) {

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

      2	   2336     feature |= _CPU_FEATURE_3DNOW;
      2	   2337     os_support |= has_feature(_CPU_FEATURE_3DNOW);
      1	   2338  }
      2	   2339  if (dwExt & _3DNOWPLUS_FEATURE_BIT) {
      2	   2340     feature |= _CPU_FEATURE_3DNOWPLUS;
      2	   2341     os_support |= has_feature(_CPU_FEATURE_3DNOWPLUS);
      1	   2342  }
      2	   2343  if (dwExt & _MMXPLUS_FEATURE_BIT) {
      2	   2344     feature |= _CPU_FEATURE_MMXPLUS;
      2	   2345     os_support |= has_feature(_CPU_FEATURE_MMXPLUS);
      1	   2346  }
      2	   2347  if (dwFeature & _SSE_FEATURE_BIT) {
      2	   2348     feature |= _CPU_FEATURE_SSE;
      2	   2349     os_support |= has_feature(_CPU_FEATURE_SSE);
      1	   2350  }
      2	   2351  if (dwFeature & _SSE2_FEATURE_BIT) {
      2	   2352     feature |= _CPU_FEATURE_SSE2;
      2	   2353     os_support |= has_feature(_CPU_FEATURE_SSE2);
      1	   2354  }
      1	   2355 #endif
      1	   2356 
      2	   2357  if (pinfo) {
      2	   2358     memset(pinfo, 0, sizeof(_p_info));
      2	   2359     pinfo->os_support = os_support;
      2	   2360     pinfo->feature = feature;
      2	   2361     pinfo->family = (dwId >> 8) & 0xF; /* retrieving family */
      2	   2362     pinfo->model = (dwId >> 4) & 0xF;  /* retrieving model */
      2	   2363     pinfo->stepping = dwId & 0xF;      /* retrieving stepping */
      2	   2364     Ident[12] = 0;
      2	   2365     strcpy(pinfo->v_name, Ident);
      1	   2366  }
      1	   2367 
      1	   2368  return feature;
      1	   2369 }
	   2370 
	   2371 
       X   2372 #if CPUTEST
       X   2373 #include <stdio.h>
       X   2374 /* Desc:
       X   2375  *
       X   2376  * In  :
       X   2377  * Out :
       X   2378  *
       X   2379  * Note:
       X   2380  */
       X   2381 int main (void)
       X   2382 {
       X   2383  _p_info p;
       X   2384  _cpuid(&p);
       X   2385  printf("vendor  : %s\n", p.v_name);
       X   2386  printf("family  : %d\n", p.family);
       X   2387  printf("model   : %d\n", p.model);
       X   2388  printf("stepping: %X\n", p.stepping);
       X   2389  printf("feature : %08x\n", p.feature);
       X   2390  printf("support : %08x\n", p.os_support);
       X   2391  printf("--------\n");
       X   2392  printf("cpuid   : %d\n", has_feature(_CPU_HAS_CPUID));

CPUID                           Source Listing                   9-MAY-2021 23:42:41  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             8-MAY-2021 19:02:47  cpuid.c;2

       X   2393  printf("MMX     : %d\n", has_feature(_CPU_FEATURE_MMX));
       X   2394  printf("SSE     : %d\n", has_feature(_CPU_FEATURE_SSE));
       X   2395  printf("SSE2    : %d\n", has_feature(_CPU_FEATURE_SSE2));
       X   2396  printf("3DNow!  : %d\n", has_feature(_CPU_FEATURE_3DNOW));
       X   2397  printf("3DNow!+ : %d\n", has_feature(_CPU_FEATURE_3DNOWPLUS));
       X   2398  printf("MMX+    : %d\n", has_feature(_CPU_FEATURE_MMXPLUS));
       X   2399  return 0;
       X   2400 }
       X   2401 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]CPUID/OBJECT=[.O
UT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]CPUID.OBJ/INCLUDE_DIRECTORY=([.GLIDE.S
WLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLID
E.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRIS
ETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LI
B=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]CPUID.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:41"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


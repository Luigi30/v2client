CANOPUS                         Source Listing                   9-MAY-2021 23:43:13  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  canopus.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Initialization code for initializing canpus cards w/ assymetric
	     21 ** inter-chip buses.
	     22 **
	     23 */
	     24 
       X     25 #ifdef _MSC_VER
       X     26 #pragma optimize ("",off)
       X     27 #endif
	     28 #include <stdio.h>
	   1639 #include <stdlib.h>
	   3734 #include <math.h>
       X   4626 #ifdef BUILD_FOR_SST1
       X   4627 #include <sst.h>
       X   4628 #else
	   4629 #include <3dfx.h>
	   4760 #include <cvgregs.h>
	   4988 #include <cvgdefs.h>
	   5929 #endif
	   5930 #define FX_DLL_DEFINITION
	   5931 #include <fxdll.h>
	   6052 #include <sst1vid.h>
	   6162 #include <sst1init.h>
	   8800 
	   8801 #include "canopus.h"
	   8841 
	   8842 /*
	   8843  * Syntax:                                                  LarsF (8/2/97)
	   8844  *        sst1InitComputeClkParamsATT_Int(Frequ, *clkTiming);
	   8845  *  
	   8846  *----------------------------------------------------------------------------
	   8847  * Description:
	   8848  *              Calculates the PLL Parameter for the given Frequency in Hz
	   8849  *
	   8850  * Input : Frequ        - Frequency in Hz
	   8851  *         *clkTiming   - pointer to timing structure
	   8852  * Output: *clkTiming   - pointer to timing structure which would be filled
	   8853  * Return: 1 - Sucess, 0 - Error
	   8854  */

CANOPUS                         Source Listing                   9-MAY-2021 23:43:13  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  canopus.c;1

	   8855 FxBool 
	   8856 sst1InitComputeClkParamsATT_Int(FFLOAT dwFreq, sst1ClkTimingStruct *clkTiming)
      1	   8857 {
      1	   8858 #define MMAX    (126+2)     /* physical limit of the M parameter */
      1	   8859 #define NMID    18          /* PLL: middle N test range          */
      1	   8860 #define NDELTA  15          /* PLL: +/- N test range             */
      1	   8861 #define FI      (14318180l) /* PLL: PLL frequenz in HZ           */
      1	   8862 
      1	   8863   FxU32   lPDiv, lRatio;
      1	   8864   FxU16   sN, sM, sP;
      1	   8865   FxU16   sNBest, sMBest;
      1	   8866   FxU32   lError, lActual;
      1	   8867   FxU32   lBestErr, lBestFreq;
      1	   8868 
      1	   8869   // first check range of Frequ
      1	   8870   if ((dwFreq < 15000000) || (dwFreq > 240000000)) return FXFALSE;
      1	   8871 
      1	   8872   // get the best P divider for the given Frequency 
      2	   8873   if (dwFreq < 30000000) {
      2	   8874     sP = 3; /* divide by 16 */
      2	   8875     lPDiv = 8;
      2	   8876   } else if ( dwFreq < 60000000 ) {
      2	   8877     sP = 2; /* divide by 8 */
      2	   8878     lPDiv = 4;
      2	   8879   } else if ( dwFreq < 120000000 ) {
      2	   8880     sP = 1; /* divide by 4 */
      2	   8881     lPDiv = 2;
      2	   8882   } else {
      2	   8883     sP = 0; /* divide by 1 */
      2	   8884     lPDiv = 1;
      1	   8885   }
      1	   8886 
      1	   8887   // next find the best N/M combination
      1	   8888   lBestErr = 99999999;
      1	   8889   sNBest = 0;
      1	   8890   sMBest = 0;
      1	   8891   lRatio = (FxU32)((dwFreq*10l)/(FI/100l)) * lPDiv; // lRatio in [1/1000]
      2	   8892   for ( sN= (NMID-NDELTA); sN <= (NMID+NDELTA); sN++ ) {
      2	   8893     sM = (unsigned short)((lRatio * sN + 500) / 1000l);
      2	   8894     if (sM > MMAX) sM = MMAX;
      2	   8895     
      2	   8896     lActual = (FxU32)((FI * sM) / (sN * lPDiv));
      2	   8897     lError = (lActual > dwFreq) ? (lActual - dwFreq) : (dwFreq - lActual);
      3	   8898     if ( lError < lBestErr ) {
      3	   8899       sNBest    = sN;
      3	   8900       sMBest    = sM;
      3	   8901       lBestErr  = lError;
      3	   8902       lBestFreq = lActual;
      2	   8903     } /* if best */
      2	   8904 
      2	   8905     /* increment M also */
      2	   8906     sM++;
      2	   8907     if (sM > MMAX) sM = MMAX;
      2	   8908 
      2	   8909     lActual = (FxU32)((FI * sM) / (sN * lPDiv));
      2	   8910     lError = (lActual > dwFreq) ? (lActual - dwFreq) : (dwFreq - lActual);
      3	   8911     if ( lError < lBestErr) {

CANOPUS                         Source Listing                   9-MAY-2021 23:43:13  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  canopus.c;1

      3	   8912       sNBest    = sN;
      3	   8913       sMBest    = sM;
      3	   8914       lBestErr  = lError;
      3	   8915       lBestFreq = lActual;
      2	   8916     } /* if best */
      1	   8917   } /* for sN */
      1	   8918 
      1	   8919   if(sNBest == 0) return(FXFALSE);
      1	   8920 
      1	   8921   sM    = sMBest-2; 
      1	   8922   sN    = sNBest-2;
      1	   8923   
      1	   8924   clkTiming->freq = (float)(dwFreq / 1000000.0f);
      1	   8925   clkTiming->clkTiming_M = sM;
      1	   8926   clkTiming->clkTiming_P = sP;
      1	   8927   clkTiming->clkTiming_N = sN;
      2	   8928   if(dwFreq <  37000000) {
      2	   8929     clkTiming->clkTiming_L = 0xa;
      2	   8930     clkTiming->clkTiming_IB = 0x6;
      2	   8931   } else if(dwFreq < 45000000) {
      2	   8932     clkTiming->clkTiming_L = 0xc;
      2	   8933     clkTiming->clkTiming_IB = 0x4;
      2	   8934   } else if(dwFreq < 58000000) {
      2	   8935     clkTiming->clkTiming_L = 0x8;
      2	   8936     clkTiming->clkTiming_IB = 0x4;
      2	   8937   } else if(dwFreq < 66000000) {
      2	   8938     clkTiming->clkTiming_L = 0xa;
      2	   8939     clkTiming->clkTiming_IB = 0x6;
      2	   8940   } else {
      2	   8941     clkTiming->clkTiming_L = 0xa;
      2	   8942     clkTiming->clkTiming_IB = 0x8;
      1	   8943   }
      1	   8944 
      1	   8945   return FXTRUE;
      1	   8946 } /* sst1InitComputeClkParamsATT_Int() */
	   8947 
	   8948 /*
	   8949 ** sst1UsrSetGrxClk():
	   8950 **  Initialize FBI and TREX Memory clocks to a user value
	   8951 **  NOTE: sst1InitCalcGrxClk() must be called prior to sst1InitGrxClk()
	   8952 **  NOTE: sst1InitGrxClk() resets the PCI fifo and the graphics subsystem of FBI
	   8953 **
	   8954 */
	   8955 FxBool 
	   8956 sst1SetGrxClk_Canopus(FxU32* sstbase, FFLOAT grxclk)
      1	   8957 {
      1	   8958   FxBool  RetVal;
      1	   8959   sst1ClkTimingStruct sstGrxClk;
      1	   8960   
      1	   8961   if(!sst1InitCheckBoard(sstbase))
      1	   8962     return(FXFALSE);
      1	   8963   
      1	   8964   if(!sst1InitComputeClkParamsATT_Int(grxclk * CLOCK_MULTIPLIER, &sstGrxClk))
      1	   8965     return(FXFALSE);
      1	   8966   
      1	   8967   sst1CurrentBoard->initGrxClkDone = 0;  // Allow clk to be reset to user value.
      1	   8968   

CANOPUS                         Source Listing                   9-MAY-2021 23:43:13  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  canopus.c;1

      1	   8969   RetVal = sst1InitSetGrxClk(sstbase, &sstGrxClk);
      1	   8970   
      1	   8971   sst1CurrentBoard->initGrxClkDone = 0;  // Allow clk to be set to the choosen value again
      1	   8972   
      1	   8973   return(RetVal);
      1	   8974 }
	   8975 
       X   8976 #ifdef _MSC_VER
       X   8977 #pragma optimize ("",on)
       X   8978 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]CANOPUS/OBJECT=[.OUT.
DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]CANOPUS.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.
FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLID
E2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,G
LIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [
.GLIDE.GLIDE2X.CVG.INIT]CANOPUS.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:13"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 1
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.1.1.1.2.8  2007/06/23 08:42:10  koolsmoky
	     21 ** Removed duplicate disableDitherSub envars
	     22 **
	     23 ** Revision 1.1.1.1.2.7  2005/04/25 23:58:41  koolsmoky
	     24 ** Fix _texDownloadProcs comma separator.
	     25 ** Thanks to Ozkan Sezer <sezeroz@gmail.com>.
	     26 **
	     27 ** Revision 1.1.1.1.2.6  2005/01/22 14:52:02  koolsmoky
	     28 ** enabled packed argb for cmd packet type 3
	     29 **
	     30 ** Revision 1.1.1.1.2.5  2005/01/13 16:09:05  koolsmoky
	     31 ** Restict calls to pciOpen() pciClose() when compiled with DIRECTX option. this fixes problems with the win32 minip
	     31 ort opened in exclusive mode.
	     32 **
	     33 ** Revision 1.1.1.1.2.4  2005/01/02 04:15:53  koolsmoky
	     34 ** disabled mtrr's on sli slave devices
	     35 **
	     36 ** Revision 1.1.1.1.2.3  2004/12/27 20:46:37  koolsmoky
	     37 ** added dll entry point to call grGlideShutdown when a process is detached
	     38 **
	     39 ** Revision 1.1.1.1.2.2  2004/12/23 20:45:56  koolsmoky
	     40 ** converted to nasm syntax
	     41 ** added x86 asm, 3dnow! triangle and mmx, 3dnow! texture download optimizations
	     42 **
	     43 ** Revision 1.1.1.1.2.1  2004/12/12 15:27:47  koolsmoky
	     44 ** changes to support new cpuid
	     45 ** set default to disable alpha dither subtraction
	     46 **
	     47 ** Revision 1.1.1.1  1999/12/07 21:49:10  joseph
	     48 ** Initial checkin into SourceForge.
	     49 **
	     50 ** 
	     51 ** 110   6/30/98 6:08p Jeske
	     52 ** fixed bug where we tried to setup MTRRs on old (<p6) systems which
	     53 ** didn't have them. 
	     54 ** 
	     55 ** 109   5/21/98 5:52p Peter
	     56 ** mismatched pairs

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 2
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	     57 ** 
	     58 ** 108   5/20/98 3:51p Peter
	     59 ** no fifo glide
	     60 ** 
	     61 ** 107   5/18/98 12:15p Peter
	     62 ** better point code
	     63 ** 
	     64 ** 106   4/21/98 5:53p Peter
	     65 ** slidetect vs hw pointers
	     66 ** 
	     67 ** 105   4/08/98 3:52p Peter
	     68 ** point coordinate truncation
	     69 ** 
	     70 ** 104   4/06/98 9:55a Peter
	     71 ** sli slave detection for oem dll
	     72 ** 
	     73 ** 103   3/17/98 6:50p Peter
	     74 ** sli paired vs active
	     75 ** 
	     76 ** 102   3/17/98 3:00p Peter
	     77 ** removed unused stats
	     78 ** 
	     79 ** 101   3/13/98 5:08p Peter
	     80 ** doh, got it backwards
	     81 ** 
	     82 ** 100   3/13/98 3:39p Peter
	     83 ** voodoo1.5 silliness
	     84 ** 
	     85 ** 99    2/20/98 9:05a Peter
	     86 ** removed remnants of comdex grot
	     87 ** 
	     88 ** 98    2/11/98 5:25p Peter
	     89 ** detection dialog fixes
	     90 ** 
	     91 ** 97    1/30/98 4:51p Peter
	     92 ** fixed sli-detect for multiple pairs
	     93 ** 
	     94 ** 96    1/30/98 4:27p Peter
	     95 ** no uswc for sli slave
	     96 ** 
	     97 ** 95    1/24/98 12:29p Peter
	     98 ** more caching fun
	     99 ** 
	    100 ** 94    1/20/98 11:03a Peter
	    101 ** env var to force triple buffering
	    102  * 
	    103  * 93    1/16/98 5:41p Peter
	    104  * fixed sense of lod_dither
	    105  * 
	    106  * 92    1/14/98 10:22a Peter
	    107  * no more hacks
	    108  * 
	    109  * 91    1/08/98 7:09p Peter
	    110  * real hw stuff modulo makefile change
	    111  * 
	    112  * 90    1/07/98 11:18a Atai
	    113  * remove GrMipMapInfo and GrGC.mm_table in glide3

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 3
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	    114  * 
	    115  * 89    1/07/98 10:22a Peter
	    116  * lod dithering env var
	    117  * 
	    118  * 88    12/17/97 10:08a Peter
	    119  * fast system comdex twiddling
	    120  * 
	    121  * 87    12/09/97 4:20p Peter
	    122  * 0x100 fbiRev ofset for v2
	    123  * 
	    124  * 86    12/09/97 12:20p Peter
	    125  * mac glide port
	    126  * 
	    127  * 85    12/05/97 4:26p Peter
	    128  * watcom warnings
	    129  * 
	    130  * 84    12/03/97 2:36p Peter
	    131  * upped comdex reset defaults
	    132  * 
	    133  * 83    12/02/97 9:48a Dow
	    134  * Removed some spurious code I inadvertantly added.
	    135  * 
	    136  * 82    11/21/97 6:24p Dow
	    137  * Banshee Lying about being Rush stuf
	    138  * 
	    139  * 81    11/21/97 11:19a Dow
	    140  * Made Banshee report Voodoo2
	    141  * 
	    142  * 80    11/20/97 6:39p Peter
	    143  * fixed direct_exec w/ csim
	    144  * 
	    145  * 79    11/19/97 2:49p Peter
	    146  * env vars in registry for win32
	    147  * 
	    148  * 78    11/17/97 4:55p Peter
	    149  * watcom warnings/chipfield stuff
	    150  * 
	    151  * 77    11/15/97 7:43p Peter
	    152  * more comdex silliness
	    153  * 
	    154  * 76    11/14/97 11:10p Peter
	    155  * open vs hw init confusion
	    156  * 
	    157  * 75    11/14/97 5:02p Peter
	    158  * more comdex stuff
	    159  * 
	    160  * 74    11/14/97 12:09a Peter
	    161  * comdex thing and some other stuff
	    162  * 
	    163  * 73    11/12/97 9:54p Peter
	    164  * fixed all the muckage from new config
	    165  * 
	    166  * 72    11/12/97 9:37p Dow
	    167  * Textures on Banshee half work
	    168  * 
	    169  * 71    11/12/97 9:22a Dow
	    170  * h3 mods

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 4
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	    171  * 
	    172  * 70    11/08/97 3:34p Peter
	    173  * fixed stupid gdbg_info crasher
	    174  * 
	    175  * 69    11/04/97 4:00p Dow
	    176  * Banshee Mods
	    177  * 
	    178  * 68    11/03/97 3:43p Peter
	    179  * h3/cvg cataclysm
	    180  * 
	    181  * 67    11/01/97 12:11p Pgj
	    182  * glide.dll ---> glide2x.dll
	    183  * 
	    184  * 66    10/31/97 8:53a Peter
	    185  * last lying change, really
	    186  * 
	    187  * 65    10/30/97 3:42p Peter
	    188  * protected the last bit of nonsense
	    189  * 
	    190  * 64    10/30/97 3:37p Peter
	    191  * spoof sst1
	    192  * 
	    193  * 63    10/29/97 2:45p Peter
	    194  * C version of Taco's packing code
	    195  * 
	    196  * 62    10/23/97 5:28p Peter
	    197  * sli fifo thing
	    198  * 
	    199  * 61    9/15/97 7:31p Peter
	    200  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	    201  * place, lfb's are on, Hmmmm.. probably more
	    202  * 
	    203  * 60    9/10/97 10:13p Peter
	    204  * fifo logic from GaryT, non-normalized fp first cut
	    205  * 
	    206  * 59    9/05/97 5:29p Peter
	    207  * changes for direct hw
	    208  * 
	    209  * 58    9/01/97 3:18p Peter
	    210  * correct integer rounding for pts
	    211  * 
	    212  * 57    8/30/97 5:59p Tarolli
	    213  * init and hal fixups
	    214  * 
	    215  * 56    8/30/97 1:19p Peter
	    216  * first cut at using blit to clear, more to come to do inner rects
	    217  * 
	    218  * 55    8/18/97 3:52p Peter
	    219  * pre-hw arrival fixes/cleanup
	    220  * 
	    221  * 54    7/30/97 2:42p Peter
	    222  * shared and sanitized
	    223  * 
	    224  * 53    7/28/97 2:41p Peter
	    225  * turned sli code back on for cvg, but waiting for hal
	    226  * 
	    227  * 52    7/25/97 11:40a Peter

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 5
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	    228  * removed dHalf, change field name to match real use for cvg
	    229  * 
	    230  * 51    7/08/97 2:47p Peter
	    231  * fixed merge stupidity from last checkin
	    232  * 
	    233  * 50    7/02/97 12:28p Peter
	    234  * removed spurious NOP, tex dl
	    235  * 
	    236  * 49    6/24/97 4:02p Peter
	    237  * proper cmd fifo placement
	    238  * 
	    239  * 48    6/23/97 4:46p Peter
	    240  * fixed my ,uckage
	    241  * 47    6/23/97 4:43p Peter
	    242  * cleaned up #defines etc for a nicer tree
	    243 **
	    244 */
	    245 
	    246 #include <stdio.h>
	   1857 #include <string.h>
	   2308 
	   2309 #include <3dfx.h>
	   2440 #include <glidesys.h>
	   2572 
	   2573 #define FX_DLL_DEFINITION
	   2574 #include <fxdll.h>
	   2695 #include <glide.h>
	   4506 #include "fxglide.h"
	  14788 
       X  14789 #if GLIDE_DISPATCH_SETUP 
       X  14790 /* Collection of all of the known procs for a given system */
       X  14791 #if GLIDE_PACKED_RGB
       X  14792 static GrTriSetupProc _triSetupProcs[][3][2] =
       X  14793 #else /* !GLIDE_PACKED_RGB */
       X  14794 static GrTriSetupProc _triSetupProcs[][1][2] =
       X  14795 #endif /* !GLIDE_PACKED_RGB */
       X  14796 {
       X  14797   /* Default Procs */
       X  14798   {
       X  14799     {_trisetup, _trisetup_cull}
       X  14800 #if GLIDE_PACKED_RGB
       X  14801    ,{_trisetup_rgb, _trisetup_cull_rgb},
       X  14802     {_trisetup_argb, _trisetup_cull_argb}
       X  14803 #endif /* GLIDE_PACKED_RGB */
       X  14804   },
       X  14805 #if GL_AMD3D
       X  14806   /* 3DNow!(tm) Procs */
       X  14807  {
       X  14808     {_trisetup_3DNow, _trisetup_cull_3DNow}
       X  14809 #if GLIDE_PACKED_RGB
       X  14810    ,{_trisetup_rgb_3DNow, _trisetup_cull_rgb_3DNow},
       X  14811     {_trisetup_argb_3DNow, _trisetup_cull_argb_3DNow}
       X  14812 #endif /* GLIDE_PACKED_RGB */
       X  14813   },
       X  14814 #endif /* GL_AMD3D */
       X  14815 };
       X  14816 #endif /* GLIDE_DISPATCH_SETUP */

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 6
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

	  14817 
       X  14818 #if GLIDE_DISPATCH_DOWNLOAD
       X  14819 static GrTexDownloadProc _texDownloadProcs[][2][4] = 
       X  14820 {
       X  14821   /* Default Procs */
       X  14822   { 
       X  14823     {
       X  14824       _grTexDownload_Default_8_1, 
       X  14825       _grTexDownload_Default_8_2,
       X  14826       _grTexDownload_Default_8_4,
       X  14827       _grTexDownload_Default_8_WideS
       X  14828     }, 
       X  14829     {
       X  14830       _grTexDownload_Default_16_1,
       X  14831       _grTexDownload_Default_16_2,
       X  14832       _grTexDownload_Default_16_WideS,
       X  14833       _grTexDownload_Default_16_WideS
       X  14834     }
       X  14835   },
       X  14836 #if GL_AMD3D
       X  14837   { 
       X  14838     { 
       X  14839       _grTexDownload_Default_8_1, 
       X  14840       _grTexDownload_Default_8_2, 
       X  14841       _grTexDownload_Default_8_4, 
       X  14842       _grTexDownload_3DNow_MMX, 
       X  14843     },
       X  14844     {
       X  14845       _grTexDownload_Default_16_1,
       X  14846       _grTexDownload_Default_16_2,
       X  14847       _grTexDownload_3DNow_MMX,
       X  14848       _grTexDownload_3DNow_MMX,
       X  14849     }
       X  14850   },
       X  14851 #endif /* GL_AMD3D */
       X  14852 #if GL_MMX
       X  14853   { 
       X  14854     { 
       X  14855       _grTexDownload_Default_8_1, 
       X  14856       _grTexDownload_Default_8_2, 
       X  14857       _grTexDownload_Default_8_4, 
       X  14858       _grTexDownload_MMX, 
       X  14859     },
       X  14860     {
       X  14861       _grTexDownload_Default_16_1,
       X  14862       _grTexDownload_Default_16_2,
       X  14863       _grTexDownload_MMX,
       X  14864       _grTexDownload_MMX,
       X  14865     }
       X  14866   },
       X  14867 #endif /* GL_MMX */
       X  14868 };
       X  14869 #endif /* GLIDE_DISPATCH_DOWNLOAD */
	  14870 
       X  14871 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
       X  14872 #define WIN32_LEAN_AND_MEAN
       X  14873 #include <windows.h>

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 7
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

       X  14874 BOOL WINAPI 
       X  14875 DllMain(HANDLE hInst, ULONG  ul_reason_for_call, LPVOID lpReserved) 
       X  14876 {
       X  14877   switch( ul_reason_for_call ) {
       X  14878   case DLL_PROCESS_DETACH:
       X  14879     GDBG_INFO(80, "DllMain: DLL_PROCESS_DETACH\n");
       X  14880     grGlideShutdown();
       X  14881     pciClose();
       X  14882     break;
       X  14883   case DLL_PROCESS_ATTACH:
       X  14884     if (!pciOpen()) {
       X  14885       GDBG_INFO(80, "pci bus could not be opened\n");
       X  14886       return FALSE;
       X  14887     }
       X  14888     GDBG_INFO(80, "DllMain: DLL_PROCESS_ATTACH\n");
       X  14889     break;
       X  14890   case DLL_THREAD_ATTACH:
       X  14891     GDBG_INFO(80, "DllMain: DLL_THREAD_ATTACH\n");
       X  14892     break;
       X  14893   case DLL_THREAD_DETACH:
       X  14894     GDBG_INFO(80, "DllMain: DLL_THREAD_DETACH\n");
       X  14895     break;
       X  14896   default:
       X  14897     GDBG_INFO(80, "DllMain: Unhandled message.\n");
       X  14898     break;
       X  14899   }
       X  14900   
       X  14901   return TRUE;
       X  14902 
       X  14903 } /* DllMain */
       X  14904 #endif
	  14905 
	  14906 /*-------------------------------------------------------------------
	  14907   Function: _grSstDetectResources
	  14908   Date: --
	  14909   Implementor(s): Dow, Gmt, Jdt
	  14910   Library: Glide
	  14911   Description:
	  14912   Discover devices on the PCI bus.
	  14913   Discover configuration of detected devices.
	  14914   Initialize all Glide GC's 
	  14915 
	  14916   Recognized devices depend upon compile time flags
	  14917 
	  14918   This code should NOT initialize the hardware 
	  14919   any more than is necessary for discovery of 
	  14920   configuration
	  14921 
	  14922   Arguments: none
	  14923   Return: 
	  14924   FXTRUE  - at least one device was detected
	  14925   FXFALSE - no devices were detected.
	  14926   -------------------------------------------------------------------*/
	  14927 FxBool 
	  14928 _grSstDetectResources(void)
      1	  14929 {
      1	  14930   static FxBool calledP = FXFALSE;

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 8
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      1	  14931   FxBool rv = FXFALSE;
      1	  14932   FxU32 ctx, device;
      1	  14933 
      1	  14934   GDBG_INFO(280, "_grSstDetectResources()\n");
      1	  14935 
      1	  14936 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      2	  14937   {
      2X  14938 #if GLIDE_INIT_HAL
      2X  14939     HalInfo* halInfo = fxHalInit(0);
      2X  14940     if (halInfo == NULL) goto __errExit;
      2X  14941 #else /* !GLIDE_INIT_HAL */
      2	  14942     FxDeviceInfo dummyDevInfo;
      2	  14943 #endif /* !GLIDE_INIT_HAL */
      2	  14944 
      2	  14945     /* The first time through the init code we need to map 
      2	  14946      * all of the boards. Future calls can just grab this
      2	  14947      * info out of the halInfo that we have here.
      2	  14948      */
      3	  14949     if (!calledP) {
      3	  14950       FxU32 count = HAL_MAX_BOARDS;
      3	  14951       FxBool inSliPairP = FXFALSE;
      3	  14952       GrHwConfiguration* hwConfig = &_GlideRoot.hwConfig;
      3	  14953 
      3	  14954       /* NB: The hw will initially return fbiRevision == 2, but
      3	  14955        * the init code does some more dorking w/ stuff and detects
      3	  14956        * if it is really a CVG and sets it to 4.
      3	  14957        */
      3	  14958       const FxU32 hwRevNum = ((GETENV("FX_GLIDE_HW_REV") == NULL)
      3	  14959                               ? 4
      3	  14960                               : atol(GETENV("FX_GLIDE_HW_REV")));
      3	  14961       
      4	  14962       for(ctx = device = 0; device < count; device++) {
      4	  14963         const FxDeviceInfo* curDev = NULL;
      4	  14964         FxBool regInitP = FXFALSE;
      4	  14965         SstRegs* devRegs;
      4	  14966 
      4X  14967 #if GLIDE_INIT_HAL
      4X  14968         devRegs = fxHalMapBoard(device);
      4X  14969         curDev = halInfo->boardInfo + device;
      4X  14970 #else /* !GLIDE_INIT_HAL */
      4	  14971         devRegs = (SstRegs*)sst1InitMapBoard(device);
      5	  14972         if (devRegs != NULL) {
      6	  14973           if (sst1InitGetDeviceInfo((FxU32*)devRegs, &dummyDevInfo)) {
      6	  14974             dummyDevInfo.virtAddr[0] = devRegs;
      6	  14975             curDev = &dummyDevInfo;
      5	  14976           }
      4	  14977         }
      4	  14978 #endif /* !GLIDE_INIT_HAL */
      4	  14979 
      4	  14980         if ((devRegs != NULL) && 
      4	  14981             (curDev != NULL) &&
      5	  14982             (curDev->fbiRevision >= hwRevNum)) {
      5	  14983           const FxU32 curSstNum = hwConfig->num_sst;
      5	  14984           FxU32 i;
      5	  14985 
      5	  14986 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)        
      5	  14987           /* Internally we always keep the real type. */

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 9
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      5	  14988           hwConfig->SSTs[ctx].type = GR_SSTTYPE_Voodoo2;
      5X  14989 #else
      5X  14990 #error "What do you think you're doing?"
      5X  14991 #endif
      5	  14992 
      5X  14993 #if GLIDE_INIT_HAL
      5X  14994           if (!fxHalInitRegisters(curDev->virtAddr[0])) goto __errRegFailure;
      5X  14995 
      5X  14996 #else /* !GLIDE_INIT_HAL */
      5	  14997           /* dpc - 23 jan 1998 - FixMe!
      5	  14998            * We set up the caching characteristics here so that we
      5	  14999            * mimic the actions of the nt driver, where everything is
      5	  15000            * happy, in win95.  However, if this is the slave of an sli
      5	  15001            * pair then we don't want to waste mtrr's that we're never
      5	  15002            * really going to write to.  
      5	  15003            */
      6	  15004           if (!inSliPairP/* && (_GlideRoot.CPUType.family >= 6)*/) {
      6	  15005 		sst1InitCaching((FxU32*)devRegs, FXTRUE);
      5	  15006 	  }
      5	  15007 
      5	  15008           if (!sst1InitRegisters((FxU32*)devRegs) ||
      5	  15009               !sst1InitGetDeviceInfo((FxU32*)devRegs, &dummyDevInfo)) goto __errRegFailure;
      5	  15010           curDev = &dummyDevInfo;
      5	  15011 #endif /* !GLIDE_INIT_HAL */
      5	  15012 
      5	  15013           /* Set up pointers to the various address spaces within the hw */
      5	  15014           _GlideRoot.GCs[ctx].base_ptr  = (FxU32*)HW_BASE_PTR(devRegs);
      5	  15015           _GlideRoot.GCs[ctx].reg_ptr   = (FxU32*)HW_REG_PTR(devRegs);
      5	  15016           _GlideRoot.GCs[ctx].lfb_ptr   = (FxU32*)HW_LFB_PTR(devRegs);
      5	  15017           _GlideRoot.GCs[ctx].tex_ptr   = (FxU32*)HW_TEX_PTR(devRegs);
      5	  15018 
      5	  15019           /* Video parameters */
      5	  15020           _GlideRoot.GCs[ctx].grSstRez     = GR_RESOLUTION_NONE;
      5	  15021           _GlideRoot.GCs[ctx].grSstRefresh = curDev->fbiVideoRefresh;
      5	  15022         
      5	  15023           /* Chip configuration */
      5	  15024           _GlideRoot.GCs[ctx].num_tmu   = curDev->numberTmus;
      5	  15025           _GlideRoot.GCs[ctx].fbuf_size = hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.fbRam;
      5	  15026 
      5	  15027           /* Independet board or physical sli master */
      6	  15028           if (!inSliPairP) {
      6	  15029             _GlideRoot.gcMap[curSstNum] = _GlideRoot.gcNum;
      6	  15030             
      6	  15031             /* Voodoo^2 glide2x returns that it is an sst1, but the
      6	  15032              * revision is bumped so that developers can really tell.
      6	  15033              * Additionally, we now have the fun on Voodoo^1.5 which is
      6	  15034              * just a Voodoo^2 in a 2200 configuration. 
      6	  15035              */
      6	  15036             hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.fbiRev = (curDev->fbiRevision + 
      6	  15037                                                                        ((curDev->numberTmus == 1)
      6	  15038                                                                         ? 0x080 
      6	  15039                                                                         : 0x100));
      6	  15040             
      6	  15041             hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.fbRam     = curDev->fbiMemSize;
      6	  15042             hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.nTexelfx  = curDev->numberTmus;
      6	  15043             hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.sliDetect = curDev->sliDetected;
      6	  15044 

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 10
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      7	  15045             for(i = 0; i < curDev->numberTmus; i++) {
      7	  15046               const FxU32 curTmuMemSize = curDev->tmuMemSize[i];
      7	  15047               
      7	  15048               hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.tmuConfig[i].tmuRev = curDev->tmuRevision;
      7	  15049               hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.tmuConfig[i].tmuRam = curTmuMemSize;
      6	  15050             }
      6	  15051 
      6	  15052             hwConfig->num_sst++;
      5	  15053           }
      5	  15054 
      5	  15055           /* Clear the tmu state */
      6	  15056           for(i = 0; i < curDev->numberTmus; i++) {
      6	  15057             const FxU32 curTmuMemSize = curDev->tmuMemSize[i];
      6	  15058             
      6	  15059             memset(&_GlideRoot.GCs[ctx].tmu_state[i], 0, sizeof(_GlideRoot.GCs[ctx].tmu_state[i]));
      6	  15060             _GlideRoot.GCs[ctx].tmu_state[i].total_mem = (curTmuMemSize << 20);
      6	  15061             
      6	  15062             _GlideRoot.GCs[ctx].tmu_state[i].ncc_mmids[0] = 
      6	  15063               _GlideRoot.GCs[ctx].tmu_state[i].ncc_mmids[1] = GR_NULL_MIPMAP_HANDLE;
      5	  15064           }
      5	  15065 
      5	  15066           /* sst1GetDeviceInfo will not return any pairing information
      5	  15067            * until after the boards are paired w/ sst1InitSli which we
      5	  15068            * have not yet done. Currently we assume that the next
      5	  15069            * discovered board will be the slave.  
      5	  15070            */
      5	  15071           _GlideRoot.GCs[ctx].scanline_interleaved = curDev->sliDetected;
      5	  15072           _GlideRoot.GCs[ctx].sliPairP             = curDev->sliPaired;
      5	  15073           _GlideRoot.GCs[ctx].slave_ptr            = NULL;
      5	  15074 
      5	  15075           /* Are we currenly mapping a physcial sli-slave? */
      6	  15076           if (curDev->sliDetected && inSliPairP) {
      6	  15077             _GlideRoot.GCs[ctx - 1].slave_ptr = _GlideRoot.GCs[ctx].base_ptr;
      6	  15078 
      6	  15079             /* Report the minimum of the two boards' memory if they
      6	  15080              * are different.  The hw does not care becuase it is just
      6	  15081              * not going to access the memory.
      6	  15082              */
      7	  15083             {
      7	  15084               const FxU32 curSstNum = hwConfig->num_sst - 1;
      7	  15085               GrTMUConfig_t* tmuConfig = hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.tmuConfig;
      7	  15086 
      7	  15087               /* Fbi memory */
      8	  15088               if ((FxU32)hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.fbRam != curDev->fbiMemSize) {
      8	  15089                 hwConfig->SSTs[curSstNum].sstBoard.Voodoo2Config.fbRam = curDev->fbiMemSize;
      7	  15090               }
      7	  15091 
      7	  15092               /* Tmu memory */
      8	  15093               for(i = 0; i < curDev->numberTmus; i++) {
      9	  15094                 if ((FxU32)tmuConfig[i].tmuRam != curDev->tmuMemSize[i]) {
      9	  15095                   tmuConfig[i].tmuRam = MIN((FxU32)tmuConfig[i].tmuRam, curDev->tmuMemSize[i]);
      8	  15096                 }
      7	  15097               }
      6	  15098             }
      5	  15099           }
      5	  15100 
      5	  15101           /* On an sli system the boards cannot be addressed

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 11
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      5	  15102            * separately so pairing and detection are different things,
      5	  15103            * and we need to keep track of these paired boards as an
      5	  15104            * atomic unit.
      5	  15105            */
      5	  15106           inSliPairP = (curDev->sliPaired ? !inSliPairP : FXFALSE);
      5	  15107 
      5	  15108           /* This device is ready to go. */
      5	  15109           regInitP = FXTRUE;
      5	  15110           _GlideRoot.gcNum++;
      5	  15111           _GlideRoot.GCs[ctx].hwInitP = FXTRUE;
      5	  15112         
      5	  15113           rv = FXTRUE;
      5	  15114           ctx++;
      5	  15115 
      5	  15116           __errRegFailure:
      5	  15117           /* For some reason we failed to init the board that we just mapped. */
      6	  15118           if (!regInitP && (devRegs != NULL)) {
      6X  15119 #if GLIDE_INIT_HAL
      6X  15120             fxHalShutdown(devRegs);
      6X  15121 #else /* !GLIDE_INIT_HAL */
      6	  15122             /*if (_GlideRoot.CPUType.family >= 6) {*/
      6	  15123               sst1InitCaching((FxU32*)devRegs, FXFALSE);
      6	  15124             /*}*/
      6	  15125             pciUnmapPhysical((FxU32)devRegs, 0x1000000UL);
      6	  15126 #endif /* !GLIDE_INIT_HAL */
      5	  15127           }
      4	  15128         }
      3	  15129       }
      3	  15130 
      3	  15131       /* Done setting up. Don't do the silly mapping thing again. */
      3	  15132       calledP = FXTRUE;
      3	  15133     } else {
      3	  15134       /* Did we previously find boards? */
      3	  15135       rv = (_GlideRoot.hwConfig.num_sst != 0);
      2	  15136     }
      2	  15137 
      2	  15138     goto __errExit; /* Keep warnings happy */
      2	  15139 __errExit:
      2	  15140     ;
      1	  15141   }
      1X  15142 #else
      1X  15143 #  error "Write code for this chip"
      1X  15144 #endif  
      1	  15145   
      1	  15146   return rv;
      1	  15147 } /* _grSstDetectResources */
	  15148 
	  15149 
	  15150 static void
	  15151 displayBoardInfo(int i, GrHwConfiguration *hwc)
      1	  15152 {
      1	  15153   if ((hwc->SSTs[i].type == GR_SSTTYPE_VOODOO) ||
      2	  15154       (hwc->SSTs[i].type == GR_SSTTYPE_Voodoo2)) {
      2	  15155     int tmuNum;
      2	  15156 
      2	  15157     GDBG_INFO(80,"SST board %d: 3Dfx Voodoo%s\n", 
      2	  15158               i, ((hwc->SSTs[i].type == GR_SSTTYPE_VOODOO) ? " Graphics" : "^2"));

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 12
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      3	  15159     if (hwc->SSTs[i].sstBoard.VoodooConfig.sliDetect) {
      3	  15160       GDBG_INFO(80,"\tScanline Interleaved\n");
      2	  15161     }
      2	  15162 
      2	  15163     GDBG_INFO(80,"\tPixelfx rev 0x%lX with %d MB Frame Buffer\n",
      2	  15164               hwc->SSTs[i].sstBoard.VoodooConfig.fbiRev,
      2	  15165               hwc->SSTs[i].sstBoard.VoodooConfig.fbRam);
      2	  15166     GDBG_INFO(80,"\t%d Texelfx chips:\n",
      2	  15167               hwc->SSTs[i].sstBoard.VoodooConfig.nTexelfx);
      2	  15168     for (tmuNum = 0;
      2	  15169          tmuNum < hwc->SSTs[i].sstBoard.VoodooConfig.nTexelfx;
      3	  15170          tmuNum++) {
      3	  15171       GDBG_INFO(80,"\t\tTexelfx %d: Rev 0x%lX, %d MB Texture\n", tmuNum,
      3	  15172                 hwc->SSTs[i].sstBoard.VoodooConfig.tmuConfig[tmuNum].tmuRev,
      3	  15173                 hwc->SSTs[i].sstBoard.VoodooConfig.tmuConfig[tmuNum].tmuRam);
      2	  15174     }
      2	  15175   } else if (hwc->SSTs[i].type == GR_SSTTYPE_SST96) {
      2	  15176     GDBG_INFO(80,"SST board %d: 3Dfx Voodoo Rush\n", i);
      2	  15177     GDBG_INFO(80,"\tFBI Jr. with %d MB Frame Buffer\n",
      2	  15178               hwc->SSTs[i].sstBoard.SST96Config.fbRam);
      2	  15179     GDBG_INFO(80,"\tTexelfx chips:  1\n");
      2	  15180   } else {
      2	  15181     GDBG_INFO(80,"error: SSTs %d: unknown type\n",i);
      1	  15182   }
      1	  15183 } /* displayBoardInfo */
	  15184 
       X  15185 #if defined(FX_DLL_ENABLE) && (GLIDE_PLATFORM & GLIDE_OS_WIN32)
       X  15186 #include <windows.h>
       X  15187 #endif
	  15188 
	  15189 void
	  15190 _GlideInitEnvironment(void)
      1	  15191 {
      1	  15192 #define FN_NAME "_GlideInitEnvironment"
      1	  15193   int i;
      1	  15194 
      1	  15195   if (_GlideRoot.initialized)          /* only execute once */
      1	  15196     return;
      1	  15197   GDBG_INIT();                          /* init the GDEBUG libraray */
      1	  15198   GDBG_INFO(80,"%s()\n", FN_NAME);
      1	  15199 
      1X  15200 #ifdef __WIN32__
      1X  15201   grErrorSetCallback(_grErrorWindowsCallback);
      1X  15202 #else
      1	  15203   grErrorSetCallback(_grErrorDefaultCallback);
      1	  15204 #endif /* __WIN32__ */
      1	  15205 
      1X  15206 #ifdef GLIDE_DEBUG
      1X  15207   GDBG_INFO(0,"GLIDE DEBUG LIBRARY\n"); /* unconditional display */
      1X  15208 #endif
      1	  15209 
      1X  15210 #if defined(FX_DLL_ENABLE) && (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1X  15211   { /* GMT: display the DLL pathname for sanity checking */
      1X  15212     char buf[132];
      1X  15213     if (GetModuleFileName(GetModuleHandle("glide2x.dll"), buf, sizeof(buf))) {
      1X  15214 #ifdef GLIDE_DEBUG
      1X  15215       GDBG_INFO(0,"DLL path: %s\n",buf); /* unconditional display */

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 13
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      1X  15216 #else
      1X  15217       GDBG_INFO(80,"DLL path: %s\n",buf);
      1X  15218 #endif
      1X  15219     } /* silent failure */
      1X  15220   }
      1X  15221 #endif
      1	  15222 
      1	  15223   /* Get CPU Info */
      1	  15224   _cpuid(&_GlideRoot.CPUType);
      1	  15225 
      1	  15226   /* Check for vendor specific optimization cases */
      1	  15227   GDBG_INFO( 0,"   CPU Vendor: %s\n", _GlideRoot.CPUType.v_name);
      1	  15228   GDBG_INFO(80,"   MMX Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_MMX ? 'Y' : 'N');
      1	  15229   GDBG_INFO(80,"   SSE Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_SSE ? 'Y' : 'N');
      1	  15230   GDBG_INFO(80,"  SSE2 Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_SSE2 ? 'Y' : 'N');
      1	  15231   GDBG_INFO(80," 3DNow Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_3DNOW ? 'Y' : 'N');
      1	  15232   GDBG_INFO(80,"  MMX+ Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_MMXPLUS ? 'Y' : 'N');
      1	  15233   GDBG_INFO(80,"3DNow+ Support: %c\n", _GlideRoot.CPUType.os_support&_CPU_FEATURE_3DNOWPLUS ? 'Y' : 'N');
      1	  15234   
      1	  15235   /* No CPU Extensions Allowed */
      1	  15236   if (GETENV("FX_GLIDE_NO_CPU_EXTENSIONS"))
      2	  15237   {
      2	  15238     _GlideRoot.CPUType.feature = _GlideRoot.CPUType.os_support = 0;
      2	  15239     GDBG_INFO(0,"CPU Extensions disabled\n");
      1	  15240   }
      1	  15241 
      1X  15242 #if GLIDE_DISPATCH_SETUP || GLIDE_DISPATCH_DOWNLOAD
      1X  15243   /* Default case */
      1X  15244 #if GLIDE_DISPATCH_SETUP
      1X  15245   _GlideRoot.deviceArchProcs.curTriProcs = _triSetupProcs + 0;
      1X  15246 #endif /* GLIDE_DISPATCH_SETUP */
      1X  15247 #if GLIDE_DISPATCH_DOWNLOAD
      1X  15248   _GlideRoot.deviceArchProcs.curTexProcs = _texDownloadProcs + 0;
      1X  15249 #endif /* GLIDE_DISPATCH_DOWNLOAD */
      1X  15250 
      1X  15251   /* Check for vendor specific optimization cases */
      1X  15252 #ifdef GL_MMX
      1X  15253   if (_GlideRoot.CPUType.os_support & _CPU_FEATURE_MMX) {
      1X  15254 #if GLIDE_DISPATCH_DOWNLOAD
      1X  15255     _GlideRoot.deviceArchProcs.curTexProcs = _texDownloadProcs + 2;
      1X  15256 #endif /* GLIDE_DISPATCH_DOWNLOAD */
      1X  15257   }
      1X  15258 #endif /* GL_MMX */
      1X  15259 
      1X  15260 #ifdef GL_AMD3D
      1X  15261   if (_GlideRoot.CPUType.os_support & _CPU_FEATURE_3DNOW) {
      1X  15262 #if GLIDE_DISPATCH_SETUP
      1X  15263     _GlideRoot.deviceArchProcs.curTriProcs = _triSetupProcs + 1;
      1X  15264 #endif /* GLIDE_DISPATCH_SETUP */
      1X  15265 #if GLIDE_DISPATCH_DOWNLOAD
      1X  15266     _GlideRoot.deviceArchProcs.curTexProcs = _texDownloadProcs + 1;
      1X  15267 #endif /* GLIDE_DISPATCH_DOWNLOAD */
      1X  15268   }
      1X  15269 #endif /* GL_AMD3D */
      1X  15270   
      1X  15271 #endif /* GLIDE_DISPATCH_SETUP || GLIDE_DISPATCH_DOWNLOAD */
      1	  15272 

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 14
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      1	  15273   /* Check for user environment tweaks */
      2	  15274   {
      2	  15275     const char* envStr;
      2	  15276 
      2	  15277 #define GLIDE_GETENV(__envVar, __defVal) \
      2	  15278     (((envStr = GETENV(__envVar)) == NULL) ? (__defVal) : atol(envStr))
      2	  15279 
      2	  15280     _GlideRoot.environment.triBoundsCheck    = (GETENV("FX_GLIDE_BOUNDS_CHECK") != NULL);
      2X  15281 #ifdef GLIDE_SPLASH
      2X  15282     _GlideRoot.environment.noSplash          = (GETENV("FX_GLIDE_NO_SPLASH") != NULL);
      2X  15283 #else
      2	  15284     _GlideRoot.environment.noSplash          = 1;
      2	  15285 #endif
      2X  15286 #ifdef GLIDE_PLUG
      2X  15287     _GlideRoot.environment.shamelessPlug     = (GETENV("FX_GLIDE_SHAMELESS_PLUG") != NULL);
      2X  15288 #else
      2	  15289     _GlideRoot.environment.shamelessPlug     = 0;
      2	  15290 #endif
      2	  15291     _GlideRoot.environment.ignoreReopen      = (GETENV("FX_GLIDE_IGNORE_REOPEN") != NULL);
      2	  15292     _GlideRoot.environment.texLodDither      = ((GETENV("FX_GLIDE_LOD_DITHER") == NULL)
      2	  15293                                                 ? 0x00UL
      2	  15294                                                 : SST_TLODDITHER);
      2	  15295     
      2	  15296     _GlideRoot.environment.nColorBuffer      = GLIDE_GETENV("FX_GLIDE_ALLOC_COLOR", -1L);
      2	  15297     _GlideRoot.environment.nAuxBuffer        = GLIDE_GETENV("FX_GLIDE_ALLOC_AUX", -1L);    
      2	  15298     _GlideRoot.environment.swFifoLWM         = GLIDE_GETENV("FX_GLIDE_LWM", -1L);
      2	  15299 
      2	  15300     _GlideRoot.environment.swapInterval      = GLIDE_GETENV("FX_GLIDE_SWAPINTERVAL", -1L);
      3	  15301     if ((envStr != NULL) && (_GlideRoot.environment.swapInterval < 0)) {
      3	  15302       _GlideRoot.environment.swapInterval = 0;
      2	  15303     }
      2	  15304     
      2	  15305     _GlideRoot.environment.snapshot          = GLIDE_GETENV("FX_SNAPSHOT", 0);
      2	  15306 
      2	  15307     /* set default to disable alpha dither subtraction */
      3	  15308     switch(GLIDE_GETENV("SSTH3_ALPHADITHERMODE", 1L)) {
      3	  15309     default:
      3	  15310     case 1: /* Or Automatic? */
      3	  15311     case 2:
      3	  15312       _GlideRoot.environment.disableDitherSub = FXTRUE;
      3	  15313       break;
      3	  15314     case 3:
      3	  15315       _GlideRoot.environment.disableDitherSub = FXFALSE;
      3	  15316       break;
      2	  15317     }  
      2	  15318     GDBG_INFO(80,"  disableDitherSub: %d\n",_GlideRoot.environment.disableDitherSub);  
      2	  15319     
      2	  15320     GDBG_INFO(80,"    triBoundsCheck: %d\n",_GlideRoot.environment.triBoundsCheck);
      2	  15321     GDBG_INFO(80,"      swapInterval: %d\n",_GlideRoot.environment.swapInterval);
      2	  15322     GDBG_INFO(80,"          noSplash: %d\n",_GlideRoot.environment.noSplash);
      2	  15323     GDBG_INFO(80,"     shamelessPlug: %d\n",_GlideRoot.environment.shamelessPlug);
      2	  15324     /*GDBG_INFO(80,"               cpu: %d\n",_GlideRoot.CPUType);*/
      2	  15325     GDBG_INFO(80,"          snapshot: %d\n",_GlideRoot.environment.snapshot);
      2	  15326     GDBG_INFO(80,"  disableDitherSub: %d\n",_GlideRoot.environment.disableDitherSub);
      1	  15327   }
      1	  15328 
      1	  15329   /* constant pool */

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 15
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3

      1	  15330   _GlideRoot.pool.f0   =   0.0F;
      1	  15331   _GlideRoot.pool.fHalf=   0.5F;
      1	  15332   _GlideRoot.pool.f1   =   1.0F;
      1	  15333   _GlideRoot.pool.f255 = 255.0F;
      1	  15334 
      1X  15335 #if GLIDE_PACKED_RGB
      1X  15336   _GlideRoot.pool.fBiasHi = (float)(0x01 << 15);
      1X  15337   _GlideRoot.pool.fBiasLo = (float)(0x01 << 23);
      1X  15338 #endif /* GLIDE_PACKED_RGB */
      1	  15339 
      1	  15340   _GlideRoot.current_sst = 0;                    /* make sure there's a valid GC */
      1	  15341   _GlideRoot.curGC = &_GlideRoot.GCs[0];         /* just for 'booting' the library */
      2	  15342   {
      2	  15343     const FxBool hwDetectP = _grSstDetectResources();
      2	  15344 
      3	  15345     if (!hwDetectP) {
      3	  15346       char s[128];
      3	  15347       const char* errStr = s;
      3	  15348       
      4	  15349       if (pciGetErrorCode() == PCI_ERR_NOERR) {
      4	  15350 #ifndef __linux__
      4	  15351         sprintf(s, "%s: glide2x.dll expected %s, none detected\n",
      4	  15352                 FN_NAME, GLIDE_DRIVER_NAME);
      4X  15353 #else
      4X  15354         sprintf(s, "%s: libglide2x.so expected %s, none detected\n",
      4X  15355                 FN_NAME, GLIDE_DRIVER_NAME);
      4X  15356 #endif
      4	  15357       } else {
      4	  15358         errStr = pciGetErrorString();
      3	  15359       }
      3	  15360       
      3	  15361       GrErrorCallback(errStr, FXTRUE);
      2	  15362     }
      2	  15363     
      2	  15364     /* GMT: this isn't really necessary since GlideRoot is static */
      3	  15365     for (i = 0; i < _GlideRoot.hwConfig.num_sst; i++) {
      3	  15366       _GlideRoot.GCs[i].mm_table.free_mmid = 0;
      3	  15367       displayBoardInfo(i, &_GlideRoot.hwConfig);
      2	  15368     }
      2	  15369     
      2	  15370     _grMipMapInit();
      2	  15371     _GlideRoot.initialized = hwDetectP;               /* save this for the end */
      1	  15372   }
      1	  15373 } /* _GlideInitEnvironment */


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GPCI/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GPCI.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GPCI.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

GPCI                            Source Listing                  10-MAY-2021 00:42:15  VSI C V7.4-002-50R2O              Page 16
V1.0                                                            10-MAY-2021 00:42:00  gpci.c;3


These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May 10 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="00:42:16"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


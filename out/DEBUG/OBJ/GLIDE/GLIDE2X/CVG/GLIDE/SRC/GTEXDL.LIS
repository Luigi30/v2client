GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.2.2.3  2005/04/23 18:33:33  koolsmoky
	     21 ** added workaround for 8bit wide texture downloads for old revision TMUs
	     22 **
	     23 ** Revision 1.2.2.2  2005/01/22 14:52:02  koolsmoky
	     24 ** enabled packed argb for cmd packet type 3
	     25 **
	     26 ** Revision 1.2.2.1  2004/12/23 20:45:56  koolsmoky
	     27 ** converted to nasm syntax
	     28 ** added x86 asm, 3dnow! triangle and mmx, 3dnow! texture download optimizations
	     29 **
	     30 ** Revision 1.2  2000/10/03 18:28:33  mercury
	     31 ** 003-clean_up_cvg-000, cvg tree cleanup.
	     32 **
	     33 ** Revision 1.1.1.1  1999/12/07 21:49:11  joseph
	     34 ** Initial checkin into SourceForge.
	     35 **
	     36 ** 
	     37 ** 61    5/18/98 12:11p Peter
	     38 ** removed unnecesasry fencing
	     39 ** 
	     40 ** 60    4/29/98 2:32p Peter
	     41 ** fixed texture palette broadcast
	     42 ** 
	     43 ** 59    3/30/98 2:46p Peter
	     44 ** fixed texture download muckage
	     45 ** 
	     46 ** 58    3/29/98 10:54p Jdt
	     47 ** Unset GLIDE_POINTCAST_PALETTE
	     48 ** 
	     49 ** 57    2/20/98 5:31p Peter
	     50 ** crybaby glide
	     51 ** 
	     52 ** 56    2/20/98 11:00a Peter
	     53 ** removed glide3 from glid2 tree
	     54 ** 
	     55 ** 55    2/02/98 2:14p Atai
	     56 ** fixed palette broadcasts in  _grTexDownloadNccTable and
	     57 ** _grTexDownloadPalette 

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

	     58  * 
	     59  * 54    1/09/98 6:48p Atai
	     60  * grTexInfo, GR_LOD_* and GR_ASPECT_*
	     61  * 
	     62  * 53    1/08/98 7:09p Peter
	     63  * real hw stuff modulo makefile change
	     64  * 
	     65  * 52    1/08/98 4:58p Atai
	     66  * tex table broadcast, grVertexLayout enable/disable, stq, and some
	     67  * defines
	     68  * 
	     69  * 51    1/08/98 11:06a Dow
	     70  * Set palette downloads to broadcast.
	     71  * 
	     72  * 50    12/11/97 4:15p Peter
	     73  * fixed assertions
	     74  * 
	     75  * 49    12/09/97 12:20p Peter
	     76  * mac glide port
	     77  * 
	     78  * 48    12/05/97 4:26p Peter
	     79  * watcom warnings
	     80  * 
	     81  * 47    12/02/97 9:48a Dow
	     82  * Got rid of Texelfx rev 0 warning
	     83  * 
	     84  * 46    11/21/97 1:03p Peter
	     85  * small texture download problem
	     86  * 
	     87  * 45    11/20/97 6:57p Dow
	     88  * Texture Downloads for Banshee
	     89  * 
	     90  * 44    11/18/97 4:36p Peter
	     91  * chipfield stuff cleanup and w/ direct writes
	     92  * 
	     93  * 43    11/17/97 4:55p Peter
	     94  * watcom warnings/chipfield stuff
	     95  * 
	     96  * 42    11/14/97 12:09a Peter
	     97  * comdex thing and some other stuff
	     98  * 
	     99  * 41    11/12/97 11:16a Peter
	    100  * cleaned up assertions
	    101  * 
	    102  * 40    11/05/97 1:50p Peter
	    103  * fixed partial palette downloads
	    104  * 
	    105  * 39    11/03/97 3:43p Peter
	    106  * h3/cvg cataclysm
	    107  * 
	    108  * 38    10/08/97 11:33a Peter
	    109  * reg group for palette download
	    110  * 
	    111  * 37    9/15/97 7:31p Peter
	    112  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	    113  * place, lfb's are on, Hmmmm.. probably more
	    114  * 

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

	    115  * 36    9/04/97 3:32p Peter
	    116  * starting grouping serial reg writes
	    117  * 
	    118  * 35    8/18/97 3:52p Peter
	    119  * pre-hw arrival fixes/cleanup
	    120  * 
	    121  * 34    7/26/97 5:18p Peter
	    122  * fixed macro muckage
	    123  * 
	    124  * 33    7/08/97 2:49p Peter
	    125  * 
	    126  * 32    7/02/97 12:28p Peter
	    127  * removed spurious NOP, tex dl
	    128  * 
	    129  * 31    6/30/97 3:22p Peter
	    130  * cmd fifo sanity
	    131  * 
	    132 **
	    133 */
	    134 
	    135 #include <3dfx.h>
	    266 #define FX_DLL_DEFINITION
	    267 #include <fxdll.h>
	    388 #include <glide.h>
	   2330 #include "fxglide.h"
	  14222 
	  14223 /* externals from gtex.c */
	  14224 extern FxU32 _gr_aspect_xlate_table[];
	  14225 extern FxU32 _gr_evenOdd_xlate_table[];
	  14226 extern const int _grMipMapHostWH[GR_ASPECT_1x8 + 1][GR_LOD_1 + 1][2];
	  14227 
	  14228 /*---------------------------------------------------------------------------
	  14229 ** _grTexDownloadNccTable
	  14230 **
	  14231 ** Downloads an ncctable to the specified _physical_ TMU(s).  This
	  14232 ** function is called internally by Glide and should not be executed
	  14233 ** by an application.
	  14234 */
	  14235 GR_DDFUNC(_grTexDownloadNccTable,
	  14236           void,
	  14237           (GrChipID_t tmu, FxU32 which, const GuNccTable *table, int start, int end))
      1	  14238 {
      1	  14239 #define FN_NAME "_grTexDownloadNccTable"
      1	  14240   GR_BEGIN_NOFIFOCHECK(FN_NAME,89);
      1	  14241   GDBG_INFO_MORE(gc->myLevel,"(%d,%d, 0x%x, %d,%d)\n",tmu,which,table,start,end);
      1	  14242   GR_ASSERT(start==0);
      1	  14243   GR_ASSERT(end==11);
      1	  14244 
      1	  14245   /* check for null pointer */
      1	  14246   if (table == NULL) return;
      1	  14247 
      1	  14248   _GlideRoot.stats.palDownloads++;
      1	  14249   _GlideRoot.stats.palBytes += (end-start+1)<<2;
      1	  14250 
      2	  14251   if (gc->tmu_state[tmu].ncc_table[which] != table) {
      2	  14252     SstRegs* texHW;
      2	  14253     int i;

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      2X  14254 #ifdef GLIDE_POINTCAST_PALETTE
      2X  14255     texHW = SST_TMU(hw,tmu);
      2X  14256 #else
      2	  14257     texHW = SST_CHIP(hw,0xe);
      2	  14258 #endif
      2	  14259 
      3	  14260     if (which == 0) {
      3X  14261 #ifdef GLIDE_POINTCAST_PALETTE
      3X  14262       REG_GROUP_BEGIN((0x02UL << tmu), nccTable0, 12, 0x0FFF);
      3X  14263 #else
      4	  14264       REG_GROUP_BEGIN(0x0EUL, nccTable0, 12, 0x0FFF);
      4	  14265 #endif
      4	  14266       for (i = 0; i < 12; i++) REG_GROUP_SET(texHW, nccTable0[i], table->packed_data[i]);
      3	  14267       REG_GROUP_END();
      3	  14268     } else {
      3X  14269 #ifdef GLIDE_POINTCAST_PALETTE
      3X  14270       REG_GROUP_BEGIN((0x02UL << tmu), nccTable1, 12, 0x0FFF);
      3X  14271 #else
      4	  14272       REG_GROUP_BEGIN(0x0EUL, nccTable1, 12, 0x0FFF);
      4	  14273 #endif
      4	  14274       for (i = 0; i < 12; i++) REG_GROUP_SET(texHW, nccTable1[i], table->packed_data[i]);
      3	  14275       REG_GROUP_END();
      2	  14276     }
      2	  14277 
      2	  14278     gc->tmu_state[tmu].ncc_table[which] = table;
      1	  14279   }
      1	  14280 
      1	  14281   GR_END();
      1	  14282 #undef FN_NAME
      1	  14283 } /* _grTexDownloadNccTable */
	  14284 
	  14285 /*-------------------------------------------------------------------
	  14286   Function: _grTexDownloadPalette
	  14287   Date: 6/9
	  14288   Implementor(s): jdt
	  14289   Library: Glide
	  14290   Description:
	  14291     Private function to download a palette to the specified tmu
	  14292   Arguments:
	  14293     tmu - which tmu to download the palette to
	  14294     pal - the pallete data
	  14295     start - beginning index to download
	  14296     end   - ending index to download
	  14297   Return:
	  14298     none
	  14299   -------------------------------------------------------------------*/
	  14300 GR_DDFUNC(_grTexDownloadPalette,
	  14301           void,
	  14302           (GrChipID_t tmu, GuTexPalette *pal, int start, int end))
      1	  14303 {
      1	  14304 #define FN_NAME "_grTexDownloadPalette"
      1	  14305   GR_BEGIN_NOFIFOCHECK(FN_NAME, 89);
      1	  14306   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x, %d,%d)\n",tmu,pal,start,end);
      1	  14307 
      1	  14308   GR_CHECK_F(FN_NAME, pal == NULL, "pal invalid");
      1	  14309   GR_CHECK_F(FN_NAME, start < 0, "invalid start index");
      1	  14310   GR_CHECK_F(FN_NAME, end > 255, "invalid end index");

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      1	  14311     
      1	  14312   /* NOTE:
      1	  14313   **
      1	  14314   **  This code broadcasts the palette because in the future, we will
      1	  14315   **  only support one global texture palette no matter how many TMUs
      1	  14316   **  there are.  This is fallout from the fact that future hardware
      1	  14317   **  has a unified memory architecture.
      1	  14318   **  
      1	  14319   **  Source licensees (meaning arcade or LBE vendors that) require the
      1	  14320   **  one palette/tmu mode should define GLIDE_POINTCAST_PALETTE on
      1	  14321   **  the command line for this file.  Understand, however, that this
      1	  14322   **  will not work on future hardware.
      1	  14323   */
      1	  14324 
      1X  14325 #ifdef GLIDE_POINTCAST_PALETTE
      1	  14326   /*
      1	  14327   **  FURTHER NOTE:  
      1	  14328   **  There is a sublety (nice way of saying BUG) here.
      1	  14329   **  If TMU0 is specified, then the palette will be broadcast to all
      1	  14330   **  TMUS.  So, if the user downloads TMU1's palette, then TMU0's
      1	  14331   **  palette, TMU0's palette will be on *both* TMUs.  This is a
      1	  14332   **  pretty strong indicator that no one is using separate palettes
      1	  14333   **  on different TMUs.
      1X  14334   */
      1X  14335   hw = SST_TMU(hw,tmu);
      1X  14336 #else
      1	  14337   hw = SST_CHIP(hw,0xE);
      1	  14338 #endif
      1	  14339 
      1	  14340   _GlideRoot.stats.palDownloads++;
      1	  14341   _GlideRoot.stats.palBytes += ((end - start + 1) << 2);
      1	  14342 
      1	  14343   /* We divide the writes into 3 chunks trying to group things into
      1	  14344    * complete 8 word grouped packets to fit the nccTable palette
      1	  14345    * format: stuff before the 8 word alignment, aligned writes, and
      1	  14346    * stuff after the 8 word alignment to the end. The slop regions
      1	  14347    * are one packet apiece.  
      1	  14348    */
      2	  14349   {
      2X  14350 #ifdef GLIDE_POINTCAST_PALETTE
      2X  14351     const FifoChipField chipId = (FifoChipField)(0x02UL << tmu);
      2X  14352 #else
      2	  14353     const FifoChipField chipId = (FifoChipField)0x0EUL;
      2	  14354 #endif
      2	  14355     const int endSlop = (end & ~0x07);
      2	  14356     const int startSlop = MIN(((start + 8) & ~0x07) - 1, end);
      2	  14357     int i = start;
      2	  14358 
      2	  14359     /* Is the start of the palette range unaligned or is the end of
      2	  14360      * the range less than a completely aligned range?  
      2	  14361      */
      3	  14362     if (((start & 0x07) != 0) || (end < ((start + 8) & ~0x07))) {
      3	  14363       const FxI32 slopCount = startSlop - start + 1;
      3	  14364       GR_ASSERT((slopCount > 0) && (slopCount <= 8));
      3	  14365     
      4	  14366       REG_GROUP_BEGIN(chipId, nccTable0[4 + (start & 0x07)], 
      4	  14367                       slopCount, (0xFF >> (8 - slopCount)));

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      5	  14368       while(i < start + slopCount) {
      5	  14369         REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)],
      5	  14370                       (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF)));
      5	  14371         i++;
      4	  14372       }
      3	  14373       REG_GROUP_END();
      2	  14374     }
      2	  14375 
      2	  14376     /* Do all of the aligned palette ranges. */
      3	  14377     while(i < endSlop) {
      3	  14378       const int endIndex = i + 8;
      3	  14379       
      4	  14380       REG_GROUP_BEGIN(chipId, nccTable0[4], 8, 0xFF);
      5	  14381       while(i < endIndex) {
      5	  14382         REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)],
      5	  14383                       (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF)));
      5	  14384         i++;
      4	  14385       }
      3	  14386       REG_GROUP_END();
      2	  14387     }
      2	  14388   
      2	  14389     /* Do we have any more slop at the end of the ragne? */
      3	  14390     if (i <= end) {
      3	  14391       const FxU32 slopCount = end - endSlop + 1;
      3	  14392       
      4	  14393       REG_GROUP_BEGIN(chipId, nccTable0[4], 
      4	  14394                       slopCount, (0xFF >> (8 - slopCount)));
      5	  14395       while(i <= end) {
      5	  14396         REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)],
      5	  14397                       (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF)));
      5	  14398         i++;
      4	  14399       }
      3	  14400       REG_GROUP_END();
      2	  14401     }
      1	  14402   }
      1	  14403     
      1	  14404   GR_END();
      1	  14405 #undef FN_NAME
      1	  14406 } /* _grTexDownloadPalette */
	  14407 
	  14408 /*-------------------------------------------------------------------
	  14409   Function: grTexDownloadTable
	  14410   Date: 6/3
	  14411   Implementor(s): jdt, GaryMcT
	  14412   Library: glide
	  14413   Description:
	  14414     download look up table data to a tmu
	  14415   Arguments:
	  14416     tmu - which tmu
	  14417     type - what type of table to download
	  14418         One of:
	  14419             GR_TEXTABLE_NCC0
	  14420             GR_TEXTABLE_NCC1
	  14421             GR_TEXTABLE_PALETTE
	  14422     void *data - pointer to table data
	  14423   Return:
	  14424     none

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

	  14425   -------------------------------------------------------------------*/
	  14426 GR_ENTRY(grTexDownloadTable,
	  14427          void,
	  14428          (GrChipID_t tmu, GrTexTable_t type,  void *data))
      1	  14429 {
      1	  14430 #define FN_NAME "grTexDownloadTable"
      1	  14431   GR_BEGIN_NOFIFOCHECK("grTexDownloadTable",89);
      1	  14432   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,0x%x)\n",tmu,type,data);
      1	  14433   GR_CHECK_TMU(FN_NAME,tmu);
      1	  14434   GR_CHECK_F(FN_NAME, type > GR_TEXTABLE_PALETTE, "invalid table specified");
      1	  14435   GR_CHECK_F(FN_NAME, !data, "invalid data pointer");
      1	  14436 
      1	  14437   if (type == GR_TEXTABLE_PALETTE)     /* Need Palette Download Code */
      1	  14438     _grTexDownloadPalette(tmu, (GuTexPalette *)data, 0, 255);
      2	  14439   else {                                 /* Type is an ncc table */
      2	  14440     _grTexDownloadNccTable(tmu, type, (GuNccTable*)data, 0, 11);
      2	  14441     /*    _grTexDownloadNccTable(tmu, type, (GuNccTable*)data, 0, 11); */
      1	  14442   }
      1	  14443   GR_END();
      1	  14444 #undef FN_NAME
      1	  14445 } /* grTexDownloadTable */
	  14446 
	  14447 
	  14448 /*-------------------------------------------------------------------
	  14449   Function: grTexDownloadMipMapLevelPartial
	  14450   Date: 6/2
	  14451   Implementor(s): GaryMcT, Jdt
	  14452   Library: glide
	  14453   Description:
	  14454     Downloads a mipmap level to the specified tmu at the given
	  14455     texture start address
	  14456   Arguments:
	  14457     tmu           - which tmu
	  14458     startAddress - starting address for texture download,
	  14459                      this should be some value between grTexMinAddress()
	  14460                      and grTexMaxAddress()
	  14461     thisLod      - lod constant that describes the mipmap level
	  14462                     to be downloaded
	  14463     largeLod     - largest level of detail in complete mipmap to 
	  14464                    be downloaded at startAddress of which level to
	  14465                    be downloaded is a part
	  14466     aspectRatio  - aspect ratio of this mipmap
	  14467     format        - format of mipmap image data
	  14468     evenOdd      - which set of mipmap levels have been downloaded for
	  14469                     the selected texture
	  14470                     One of:
	  14471                       GR_MIPMAPLEVELMASK_EVEN 
	  14472                       GR_MIPMAPLEVELMASK_ODD
	  14473                       GR_MIPMAPLEVELMASK_BOTH
	  14474     data          - pointer to mipmap data
	  14475   Return:
	  14476     none
	  14477   -------------------------------------------------------------------*/
	  14478 
	  14479 GR_ENTRY(grTexDownloadMipMapLevelPartial,
	  14480          void,
	  14481          (GrChipID_t tmu, FxU32 startAddress,

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

	  14482           GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t   aspectRatio,
	  14483           GrTextureFormat_t format, FxU32 evenOdd, void *data, int t, int max_t))
      1	  14484 {
      1	  14485   const FifoChipField chipId = (FifoChipField)(0x02UL << tmu);
      1	  14486   FxI32 sh;
      1	  14487 #if !GLIDE_DISPATCH_DOWNLOAD
      1	  14488   FxU32 max_s, width, tmu_baseaddress;
      1	  14489 #endif
      1	  14490 #define FN_NAME "grTexDownloadMipMapLevelPartial"
      1	  14491 
      1	  14492   GR_BEGIN_NOFIFOCHECK(FN_NAME, 89);
      1	  14493   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x, %d,%d,%d, %d,%d 0x%x, %d,%d)\n",
      1	  14494                  tmu,startAddress,thisLod,largeLod,aspectRatio,
      1	  14495                  format,evenOdd,data,t,max_t);
      1	  14496   
      1	  14497   /* Check fo silly things */
      2	  14498   {
      2	  14499     const FxU32 size = _grTexTextureMemRequired(thisLod, thisLod, 
      2	  14500                                                 aspectRatio, format, evenOdd);
      2	  14501 
      2	  14502   GR_CHECK_TMU(FN_NAME, tmu);
      2	  14503   GR_CHECK_COMPATABILITY(FN_NAME, 
      2	  14504                          startAddress + size > gc->tmu_state[tmu].total_mem,
      2	  14505                          "insufficient texture ram at startAddress");
      2	  14506   GR_CHECK_COMPATABILITY(FN_NAME, 
      2	  14507                          startAddress & 0x7,
      2	  14508                          "unaligned startAddress");
      2	  14509   GR_CHECK_F(FN_NAME, thisLod > GR_LOD_1,
      2	  14510              "thisLod invalid");
      2	  14511   GR_CHECK_F(FN_NAME, largeLod > GR_LOD_1,
      2	  14512              "largeLod invalid");
      2	  14513   GR_CHECK_F(FN_NAME, thisLod < largeLod,
      2	  14514              "thisLod may not be larger than largeLod");
      2	  14515   GR_CHECK_F(FN_NAME, aspectRatio > GR_ASPECT_1x8 || 
      2	  14516              aspectRatio < GR_ASPECT_8x1,
      2	  14517              "aspectRatio invalid");
      2	  14518   GR_CHECK_F(FN_NAME, evenOdd > 0x3 || evenOdd == 0,
      2	  14519              "evenOdd mask invalid");
      2	  14520   GR_CHECK_F(FN_NAME, !data,
      2	  14521              "invalid data pointer");
      2	  14522   GR_CHECK_F(FN_NAME, max_t >= _grMipMapHostWH[aspectRatio][thisLod][1],
      2	  14523              "invalid end row");
      2	  14524 
      2	  14525   if ((startAddress < 0x200000) && (startAddress + size > 0x200000))
      2	  14526     GrErrorCallback("grTexDownloadMipMapLevelPartial: mipmap level cannot span 2 Mbyte boundary",
      2	  14527                     FXTRUE);
      1	  14528   }
      1	  14529 
      1	  14530   /*------------------------------------------------------------
      1	  14531     Skip this level entirely if not in odd/even mask
      1	  14532     ------------------------------------------------------------*/
      1	  14533   if (!(evenOdd & (thisLod & 0x1 ? GR_MIPMAPLEVELMASK_ODD:GR_MIPMAPLEVELMASK_EVEN)))
      1	  14534     goto all_done;
      1	  14535 
      2	  14536   {
      2	  14537   /*------------------------------------------------------------
      2	  14538     Compute Base Address Given Start Address Offset

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      2	  14539     ------------------------------------------------------------*/
      2	  14540     const FxU32 baseAddress = _grTexCalcBaseAddress(startAddress,
      2	  14541                                       largeLod, 
      2	  14542                                       aspectRatio,
      2	  14543                                       format,
      2	  14544                                                     evenOdd) >> 3;
      2	  14545   
      2	  14546   /*------------------------------------------------------------
      2	  14547     Compute pertinant contents of tLOD and texMode registers 
      2	  14548     ------------------------------------------------------------*/
      2	  14549     FxU32 tLod = SST_TLOD_MINMAX_INT(largeLod, GR_LOD_1);
      2	  14550     FxU32 texMode = format << SST_TFORMAT_SHIFT;
      2	  14551     
      2	  14552   tLod |= _gr_evenOdd_xlate_table[evenOdd];
      2	  14553   tLod |= _gr_aspect_xlate_table[aspectRatio];
      2	  14554     
      3	  14555   if (gc->state.tmu_config[tmu].textureMode & SST_SEQ_8_DOWNLD) {
      3	  14556     sh = 2;
      3	  14557     texMode |= SST_SEQ_8_DOWNLD;
      3	  14558   } else {
      3	  14559     sh = 3;
      2	  14560   }
      2	  14561 
      2	  14562   /*------------------------------------------------------------
      2	  14563     Update TLOD, texMode, baseAddress
      2	  14564     ------------------------------------------------------------*/
      2	  14565   hw = SST_TMU(hw,tmu);
      3	  14566   REG_GROUP_BEGIN(chipId, textureMode, 3, 0x0B);
      4	  14567   {
      4	  14568     REG_GROUP_SET(hw, textureMode, texMode);
      4	  14569     REG_GROUP_SET(hw, tLOD,        tLod);
      4	  14570     REG_GROUP_SET(hw, texBaseAddr, baseAddress);
      3	  14571   }
      2	  14572   REG_GROUP_END();
      1	  14573   }
      1	  14574 
      1X  14575 #if GLIDE_DISPATCH_DOWNLOAD
      1X  14576   /* Do the download */
      1X  14577   {
      1X  14578     const FxU32 
      1X  14579       width = _grMipMapHostWH[aspectRatio][thisLod][0],
      1X  14580       formatSel = (format >= GR_TEXFMT_16BIT),
      1X  14581       tmuBaseAddr = ((FxU32)gc->tex_ptr + 
      1X  14582                      (((FxU32)tmu) << 21UL) + 
      1X  14583                      (((FxU32)thisLod) << 17UL));
      1X  14584     FxU32 
      1X  14585       widthSel = (width >> 0x01UL),
      1X  14586       max_s = width >> (formatSel
      1X  14587                         ? 1   /* 16-bit texture */
      1X  14588                         : 2); /* 8-bit texture */
      1X  14589 
      1X  14590     if (max_s < 1) max_s = 1;
      1X  14591     if (widthSel > 2) widthSel = 3;
      1X  14592     
      1X  14593     _GlideRoot.stats.texBytes += max_s * (max_t - t + 1) * 4;
      1X  14594 
      1X  14595     if ((sh == 3) && !formatSel && (width > 4)) {

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      1X  14596       /* 8-bit >4xN texture with Old revision TMUs (GR_SSTTYPE_VOODOO) */
      1X  14597       const FxU8* src8  = (const FxU8*)data;
      1X  14598       /* Compute Physical Write Pointer */
      1X  14599       const FxU32
      1X  14600         tmu_baseaddress = (FxU32)gc->tex_ptr +
      1X  14601                           (((FxU32)tmu) << 21) + (((FxU32)thisLod) << 17);
      1X  14602 
      1X  14603       for (; t <= max_t; t++) {
      1X  14604         FxU32
      1X  14605           s,
      1X  14606           tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      1X  14607 
      1X  14608         LINEAR_WRITE_BEGIN(max_s, kLinearWriteTex,
      1X  14609                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      1X  14610                            0x00UL, 0x00UL);
      1X  14611         for (s = 0; s < max_s; s+=2) {
      1X  14612           const FxU32 t0 = *(const FxU32*)(src8   );
      1X  14613           const FxU32 t1 = *(const FxU32*)(src8 + sizeof(FxU32));
      1X  14614 
      1X  14615           LINEAR_WRITE_SET_8(tex_address                , t0);
      1X  14616           LINEAR_WRITE_SET_8(tex_address + sizeof(FxU32), t1);
      1X  14617 
      1X  14618           tex_address += 16;
      1X  14619           src8 += (sizeof(FxU32) << 1);
      1X  14620         }
      1X  14621         LINEAR_WRITE_END();
      1X  14622       }
      1X  14623     } else {
      1X  14624       /* GR_SSTTYPE_Voodoo2 all go through here */
      1X  14625       (*((*_GlideRoot.deviceArchProcs.curTexProcs)[formatSel][widthSel]))(gc, 
      1X  14626                                                                           tmuBaseAddr,
      1X  14627                                                                           max_s, t, max_t,
      1X  14628                                                                           data);
      1X  14629     }
      1X  14630   }
      1X  14631 #else
      1	  14632   /*------------------------------------------------------------
      1	  14633     Determine max_s
      1	  14634     ------------------------------------------------------------*/
      1	  14635   width = _grMipMapHostWH[aspectRatio][thisLod][0];
      1	  14636   max_s = width >> ((format < GR_TEXFMT_16BIT)
      1	  14637                     ? 2   /* 8-bit texture */
      1	  14638                     : 1); /* 16-bit texture */
      1	  14639   if (max_s < 1) max_s = 1;
      1	  14640 
      1	  14641   _GlideRoot.stats.texBytes += max_s * (max_t - t + 1) * 4;
      1	  14642 
      1	  14643   /*------------------------------------------------------------
      1	  14644     Compute Physical Write Pointer
      1	  14645     ------------------------------------------------------------*/
      1	  14646   tmu_baseaddress = (FxU32)gc->tex_ptr;
      1	  14647   tmu_baseaddress += (((FxU32)tmu) << 21) + (((FxU32)thisLod) << 17);
      1	  14648 
      1	  14649   /*------------------------------------------------------------
      1	  14650     Handle 8-bit Textures
      1	  14651     ------------------------------------------------------------*/
      2	  14652   if (format < GR_TEXFMT_16BIT) { /* 8 bit textures */

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      2	  14653     /* Hoisted initialization */
      2	  14654     FxU32 tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      2	  14655     const FxU8* src8  = (const FxU8*)data;
      2	  14656 
      3	  14657     switch(width) {
      3	  14658     case 1:
      4	  14659       for (; t <= max_t; t++) {
      5	  14660         LINEAR_WRITE_BEGIN(1, kLinearWriteTex, 
      5	  14661                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      5	  14662                            0x00UL, 0x00UL);
      5	  14663         LINEAR_WRITE_SET_8(tex_address, (const FxU32)*(const FxU8*)src8);
      4	  14664         LINEAR_WRITE_END();
      4	  14665       
      4	  14666         src8 += width;
      4	  14667         tex_address += TEX_ROW_ADDR_INCR(1);
      3	  14668       }
      3	  14669       break;
      3	  14670 
      3	  14671     case 2:
      4	  14672       for (; t <= max_t; t++) {
      5	  14673         LINEAR_WRITE_BEGIN(1, kLinearWriteTex, 
      5	  14674                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      5	  14675                            0x00UL, 0x00UL);
      5	  14676         LINEAR_WRITE_SET_8(tex_address, (const FxU32)*(const FxU16*)src8);
      4	  14677         LINEAR_WRITE_END();
      4	  14678             
      4	  14679         src8 += width;
      4	  14680         tex_address += TEX_ROW_ADDR_INCR(1);
      3	  14681       }
      3	  14682       break;
      3	  14683 
      3	  14684     case 4:
      4	  14685       for (; t <= max_t; t++) {
      5	  14686         LINEAR_WRITE_BEGIN(1, kLinearWriteTex, 
      5	  14687                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      5	  14688                            0x00UL, 0x00UL);
      5	  14689         LINEAR_WRITE_SET_8(tex_address, *(const FxU32*)src8);
      4	  14690         LINEAR_WRITE_END();
      4	  14691         
      4	  14692         src8 += width;
      4	  14693         tex_address += TEX_ROW_ADDR_INCR(1);
      3	  14694       }
      3	  14695       break;
      3	  14696 
      4	  14697     default: { /* >4xN texture */
      4	  14698       const FxU32 texAddrInc = ((sh == 3)
      4	  14699                                 ? 16 /* Old TMUs */
      4	  14700                                 : 8);/* New TMUs */
      4	  14701 
      5	  14702       for (; t <= max_t; t++) {
      5	  14703         FxU32 s;
      5	  14704 
      5	  14705         tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      5	  14706 
      6	  14707         LINEAR_WRITE_BEGIN(max_s, kLinearWriteTex,
      6	  14708                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      6	  14709                            0x00UL, 0x00UL);

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      7	  14710         for (s = 0; s < max_s; s+=2) {
      7	  14711           const FxU32 t0 = *(const FxU32*)(src8   );
      7	  14712           const FxU32 t1 = *(const FxU32*)(src8 + sizeof(FxU32));
      7	  14713                     
      7	  14714           LINEAR_WRITE_SET_8(tex_address                , t0);
      7	  14715           LINEAR_WRITE_SET_8(tex_address + sizeof(FxU32), t1);
      7	  14716 
      7	  14717           tex_address += texAddrInc;
      7	  14718           src8 += (sizeof(FxU32) << 1);
      6	  14719         }
      5	  14720         LINEAR_WRITE_END();
      4	  14721       }
      4	  14722       break;
      3	  14723     }
      2	  14724     }
      2	  14725   } else { /* 16-bit Textures */
      2	  14726     /* Hoisted initialization */
      2	  14727     FxU32 tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      2	  14728     const FxU16* src16 = (const FxU16*)data;
      2	  14729 
      2	  14730         /* Cases 1, 2 don't need inner loops for s */
      3	  14731     switch(width) {
      3	  14732     case 1:
      4	  14733         for (; t <= max_t; t++) {
      5	  14734           LINEAR_WRITE_BEGIN(1, kLinearWriteTex,
      5	  14735                              (FxU32)tex_address - (FxU32)gc->tex_ptr,
      5	  14736                              0x00UL, 0x00UL);
      5	  14737         LINEAR_WRITE_SET_16(tex_address, (const FxU32)*(const FxU16*)src16);
      4	  14738           LINEAR_WRITE_END();
      4	  14739           
      4	  14740           src16 += width;
      4	  14741           tex_address += TEX_ROW_ADDR_INCR(1);
      3	  14742         }
      3	  14743       break;
      3	  14744       
      3	  14745     case 2:
      4	  14746       for (; t <= max_t; t++) {
      5	  14747         LINEAR_WRITE_BEGIN(1, kLinearWriteTex,
      5	  14748                            (FxU32)tex_address - (FxU32)gc->tex_ptr,
      5	  14749                            0x00UL, 0x00UL);
      5	  14750         LINEAR_WRITE_SET_16(tex_address, *(const FxU32*)src16);
      4	  14751         LINEAR_WRITE_END();
      4	  14752         
      4	  14753         src16 += width;
      4	  14754         tex_address += TEX_ROW_ADDR_INCR(1);
      3	  14755       }
      3	  14756       break;
      3	  14757 
      3	  14758     default:
      4	  14759       for (; t <= max_t; t++) {
      4	  14760         FxU32 s;
      4	  14761 
      4	  14762         tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      4	  14763 
      4	  14764         /* Loop unrolled to process 2 dwords per iteration */            
      5	  14765         LINEAR_WRITE_BEGIN(max_s, kLinearWriteTex,
      5	  14766                            (FxU32)tex_address - (FxU32)gc->tex_ptr,

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      5	  14767                            0x00UL, 0x00UL);
      6	  14768         for (s = 0; s < max_s; s += 2) {
      6	  14769           const FxU32 t0 = *(const FxU32*)(src16   );
      6	  14770           const FxU32 t1 = *(const FxU32*)(src16 + 2);
      6	  14771 
      6	  14772           GDBG_INFO(195, "s = %d, t= %d, address = 0x%x\n",
      6	  14773                     s, t, (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
      6	  14774           LINEAR_WRITE_SET_16(tex_address    , t0);
      6	  14775           LINEAR_WRITE_SET_16(tex_address + 4, t1);
      6	  14776                
      6	  14777           tex_address += 8;
      6	  14778           src16 += 4;
      5	  14779         }
      5	  14780               
      4	  14781         LINEAR_WRITE_END();
      3	  14782       }
      3	  14783 
      3	  14784       break;
      2	  14785     }
      1	  14786   }
      1	  14787 #endif
      1	  14788   
      1	  14789   /*------------------------------------------------------------
      1	  14790     Restore TLOD, texMode, baseAddress
      1	  14791     ------------------------------------------------------------*/
      2	  14792   REG_GROUP_BEGIN(chipId, textureMode, 3, 0x0B);
      3	  14793   {
      3	  14794     REG_GROUP_SET(hw, textureMode, gc->state.tmu_config[tmu].textureMode);
      3	  14795     REG_GROUP_SET(hw, tLOD,        gc->state.tmu_config[tmu].tLOD);
      3	  14796     REG_GROUP_SET(hw, texBaseAddr, gc->state.tmu_config[tmu].texBaseAddr);
      2	  14797   }
      1	  14798   REG_GROUP_END();
      1	  14799 
      1	  14800 all_done:
      1	  14801   _GlideRoot.stats.texDownloads++;
      1	  14802 #undef FN_NAME
      1	  14803 } /* grTexDownloadMipmapLevelPartial */
	  14804 
	  14805 /* 
	  14806    Let me take this opportunity to register my formal opposition to
	  14807    this function.  Either we do this or we don't.  Let's not hack like
	  14808    this.
	  14809 
	  14810    CHD
	  14811 */
	  14812 
	  14813 GR_ENTRY(ConvertAndDownloadRle,
	  14814          void,
	  14815          (GrChipID_t tmu, FxU32 startAddress,
	  14816           GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio,
	  14817           GrTextureFormat_t format, FxU32 evenOdd,
	  14818           FxU8 *bm_data, long bm_h,
	  14819           FxU32 u0, FxU32 v0,
	  14820           FxU32 width, FxU32 height, FxU32 dest_width, FxU32 dest_height, FxU16 *tlut))
      1	  14821 {
      1	  14822   const FifoChipField chipId = (FifoChipField)(0x02UL << tmu);
      1	  14823   FxI32 sh;

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      1	  14824   FxU32 max_s,s,t,max_t,tex_address, tmu_baseaddress;
      1	  14825   FxU32 tLod, texMode, baseAddress,size;
      1	  14826   FxU32 offset,expected_size;
      1	  14827   unsigned long  i;
      1	  14828   FxU16 *src;
      1	  14829   extern FxU16 rle_line[256]; /* diTex.c */
      1	  14830   extern FxU16 *rle_line_end; /* ditex.c */
      1	  14831 #define FN_NAME "ConvertAndDownloadRLE"
      1	  14832   GR_BEGIN_NOFIFOCHECK(FN_NAME, 89);
      1	  14833    
      1	  14834   /* make sure even number */
      1	  14835   width&=0xFFFFFFFE;
      1	  14836    
      1	  14837   max_s=width>>1;
      1	  14838   max_t=height;
      1	  14839    
      1	  14840   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x, %d,%d,%d, %d,%d 0x%x, %d)\n",
      1	  14841                  tmu,startAddress,thisLod,largeLod,aspectRatio,
      1	  14842                  format,evenOdd,bm_data,max_t);
      1	  14843    
      1	  14844   size = _grTexTextureMemRequired(thisLod, thisLod, aspectRatio, format, evenOdd);
      1	  14845   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14846   GR_CHECK_F(FN_NAME, startAddress + size > gc->tmu_state[tmu].total_mem,
      1	  14847              "insufficient texture ram at startAddress");
      1	  14848   GR_CHECK_F(FN_NAME, startAddress & 0x7, "unaligned startAddress");
      1	  14849   GR_CHECK_F(FN_NAME, thisLod > GR_LOD_1, "thisLod invalid");
      1	  14850   GR_CHECK_F(FN_NAME, largeLod > GR_LOD_1, "largeLod invalid");
      1	  14851   GR_CHECK_F(FN_NAME, thisLod < largeLod, "thisLod may not be larger than largeLod");
      1	  14852   GR_CHECK_F(FN_NAME, aspectRatio > GR_ASPECT_1x8 || 
      1	  14853              aspectRatio < GR_ASPECT_8x1,
      1	  14854              "aspectRatio invalid");
      1	  14855   GR_CHECK_F(FN_NAME, evenOdd > 0x3 || evenOdd == 0, "evenOdd mask invalid");
      1	  14856   GR_CHECK_F(FN_NAME, !bm_data, "invalid data pointer");
      1	  14857   GR_CHECK_F(FN_NAME, (dest_height-1) >= (FxU32)_grMipMapHostWH[aspectRatio][thisLod][1],
      1	  14858              "invalid end row");
      1	  14859 
      1	  14860   if ((startAddress < 0x200000) && (startAddress + size > 0x200000))
      1	  14861     GrErrorCallback("grTexDownloadMipMapLevelPartial: mipmap level cannot span 2 Mbyte boundary",
      1	  14862                     FXTRUE);
      1	  14863 
      1	  14864   /*------------------------------------------------------------
      1	  14865     Skip this level entirely if not in odd/even mask
      1	  14866     ------------------------------------------------------------*/
      1	  14867   if (!(evenOdd & (thisLod & 0x1 ? GR_MIPMAPLEVELMASK_ODD:GR_MIPMAPLEVELMASK_EVEN)))
      1	  14868     goto all_done;
      1	  14869   
      1	  14870   /*------------------------------------------------------------
      1	  14871     Compute Base Address Given Start Address Offset
      1	  14872     ------------------------------------------------------------*/
      1	  14873   baseAddress = _grTexCalcBaseAddress(startAddress,
      1	  14874                                       largeLod, 
      1	  14875                                       aspectRatio,
      1	  14876                                       format,
      1	  14877                                       evenOdd);
      1	  14878   baseAddress >>= 3;
      1X  14879 #if H3
      1X  14880   baseAddress = ((baseAddress << 3) & ~0x0F);

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      1X  14881 #endif
      1	  14882 
      1	  14883   /*------------------------------------------------------------
      1	  14884     Compute Physical Write Pointer
      1	  14885     ------------------------------------------------------------*/
      1	  14886   tmu_baseaddress = (FxU32)gc->tex_ptr;
      1	  14887   tmu_baseaddress += (((FxU32)tmu)<<21) + (((FxU32)thisLod)<<17);
      1	  14888   
      1	  14889   /*------------------------------------------------------------
      1	  14890     Compute pertinant contents of tLOD and texMode registers 
      1	  14891     ------------------------------------------------------------*/
      1	  14892   tLod = SST_TLOD_MINMAX_INT(largeLod, GR_LOD_1);
      1	  14893   tLod |= _gr_evenOdd_xlate_table[evenOdd];
      1	  14894   tLod |= _gr_aspect_xlate_table[aspectRatio];
      1	  14895   texMode = format << SST_TFORMAT_SHIFT;
      2	  14896   if (gc->state.tmu_config[tmu].textureMode & SST_SEQ_8_DOWNLD) {
      2	  14897     sh = 2;
      2	  14898     texMode |= SST_SEQ_8_DOWNLD;
      2	  14899   } else {
      2	  14900     sh = 3;
      1	  14901   }
      1	  14902 
      1	  14903   /*------------------------------------------------------------
      1	  14904     Update TLOD, texMode, baseAddress
      1	  14905     ------------------------------------------------------------*/
      1	  14906   hw = SST_TMU(hw,tmu);
      2	  14907   REG_GROUP_BEGIN(chipId, textureMode, 3, 0x0B);
      3	  14908   {
      3	  14909     REG_GROUP_SET(hw, textureMode, texMode);
      3	  14910     REG_GROUP_SET(hw, tLOD,        tLod);
      3	  14911     REG_GROUP_SET(hw, texBaseAddr, baseAddress);
      2	  14912   }
      1	  14913   REG_GROUP_END();
      1	  14914   
      1	  14915   _GlideRoot.stats.texBytes += dest_width * (dest_height) * 2;
      1	  14916   
      1	  14917   /* here I can do my writes and conversion and I will be so happy */
      1	  14918   offset=4+bm_h;
      1	  14919   for (i=0; i<v0; i++)
      1	  14920     offset += bm_data[4+i];
      1	  14921   
      1	  14922   max_s=dest_width>>1;
      1	  14923   expected_size=max_s*5;
      1	  14924   
      1	  14925   rle_line_end=rle_line+width+u0;
      2	  14926   for(t=0;t<max_t;t++) {
      2	  14927     tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      2	  14928     src = rle_line + u0;
      2	  14929       
      2	  14930     rle_decode_line_asm(tlut,&bm_data[offset],rle_line);
      2	  14931       
      3	  14932     LINEAR_WRITE_BEGIN(max_s, kLinearWriteTex, 
      3	  14933                        (FxU32)tex_address - (FxU32)gc->tex_ptr,
      3	  14934                        0x00UL, 0x00UL);         
      4	  14935     for(s = 0; s < max_s; s++) {
      4	  14936       LINEAR_WRITE_SET(tex_address + (s << 2), *(FxU32 *) src);
      4	  14937       src += 2;

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1

      3	  14938     }
      2	  14939     LINEAR_WRITE_END();
      2	  14940       
      2	  14941     offset+=bm_data[4+i++];
      1	  14942   }
      1	  14943 
      2	  14944   if (dest_height>height) {
      2	  14945     tex_address = tmu_baseaddress + TEX_ROW_ADDR_INCR(t);
      2	  14946     src=rle_line+u0;
      2	  14947 
      3	  14948     LINEAR_WRITE_BEGIN(max_s, kLinearWriteTex, 
      3	  14949                        (FxU32)tex_address - (FxU32)gc->tex_ptr,
      3	  14950                        0x00UL, 0x00UL);            
      4	  14951     for(s = 0; s < max_s; s++) {
      4	  14952       LINEAR_WRITE_SET(tex_address + (s << 2), *(FxU32 *) src);
      4	  14953       src += 2;
      3	  14954     }
      2	  14955     LINEAR_WRITE_END();         
      1	  14956   }
      1	  14957 
      1	  14958   /*------------------------------------------------------------
      1	  14959     Restore TLOD, texMode, baseAddress
      1	  14960     ------------------------------------------------------------*/
      2	  14961   REG_GROUP_BEGIN(chipId, textureMode, 3, 0x0B);
      3	  14962   {
      3	  14963     REG_GROUP_SET(hw, textureMode, gc->state.tmu_config[tmu].textureMode);
      3	  14964     REG_GROUP_SET(hw, tLOD,        gc->state.tmu_config[tmu].tLOD);
      3	  14965     REG_GROUP_SET(hw, texBaseAddr, gc->state.tmu_config[tmu].texBaseAddr);
      2	  14966   }
      1	  14967   REG_GROUP_END();
      1	  14968 
      1	  14969 all_done:
      1	  14970   _GlideRoot.stats.texDownloads++;
      1	  14971 #undef FN_NAME
      1	  14972 }
	  14973 
	  14974 
	  14975 
	  14976 
	  14977 
	  14978 


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEXDL/OBJECT=[.
OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEXDL.OBJ/INCLUDE_DIRECTORY=([.GLIDE
.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GL
IDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TR
ISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_
LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEXDL.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

GTEXDL                          Source Listing                   9-MAY-2021 23:43:05  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  gtexdl.c;1


 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:05"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 */
	     20 
	     21 #include <stdlib.h>
	   2664 #include <stdio.h>
	   3727 #include <string.h>
	   4178 #include <time.h>
	   4976 #include "3dfx.h"
	   5107 #include "fximg.h"
	   5284 #include "fxos.h"
	   5333 
	   5334 /*
	   5335 ** PRIVATE GLOBAL DATA
	   5336 */
	   5337 
	   5338 char *imgErrorString = "No error.";
	   5339 
	   5340 /*
	   5341 ** PRIVATE UTILITY FUNCTIONS
	   5342 */
	   5343 
	   5344 /* _fixStream
	   5345 **
	   5346 ** Summary: UNPUBLISHED - change mode for input / output streams so that
	   5347 **          they are are in binary mode for dos apps.
	   5348 */
       X   5349 #if defined( __DOS__ ) || defined( WIN32 )
	   5350 /* 
	   5351 ** On dos-compatible platforms, iostreams must be set to binary( untranslated )
	   5352 ** mode
       X   5353 */
       X   5354 #include <fcntl.h>
       X   5355 #include <io.h>
       X   5356 void _fixStream( FILE *stream )
       X   5357 {
       X   5358 	setmode( fileno( stream ), O_BINARY );
       X   5359 }
       X   5360 #else
	   5361 /*
	   5362 ** Otherwise do nothing

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	   5363 */
	   5364 #define _fixStream( X ) X = X
	   5365 #endif
	   5366 
	   5367 
	   5368 /* _imgStrUpr
	   5369 **
	   5370 ** Summary: UNPUBLISHED - upper case the provided string in place.
	   5371 **          Provided because strupr isn't provided in all clib implementations.
	   5372 */
	   5373 void _imgStrUpr( char *str )
      1	   5374 {
      1	   5375     FxU32 index;
      1	   5376     for ( index = 0; index < strlen( str ); index++ )
      2	   5377     {
      2	   5378 		if ( str[index] >= 'a' && str[index] <= 'z' )
      3	   5379 		{
      3	   5380 	    	str[index] -= 'a' - 'A';
      2	   5381 		}
      1	   5382     }
      1	   5383 }
	   5384 
	   5385 /* _imgIsLittleEndian
	   5386 **
	   5387 ** UNPUBLISHED - returns FXTRUE if the host architecture
	   5388 **               stores memory in little endian format
	   5389 */
	   5390 FxBool _imgIsLittleEndian( void )
      1	   5391 {
      1	   5392     unsigned long x = 0x0000FFFF;
      1	   5393     return( *((char *)&x)?FXTRUE:FXFALSE );
      1	   5394 }
	   5395 
	   5396 /* _imgTxDecodeColorFormat
	   5397 **
	   5398 ** UNPUBLISHED - returns the integer color format give in a tdf color format
	   5399 **
	   5400 */
	   5401 imgTxColorFormat _imgTxDecodeColorFormat( char * String )
      1	   5402 {
      1	   5403   if(!strcmp(String,"true") ||
      1	   5404      !strcmp(String,"TRUE"))
      1	   5405     return txColorTrue;
      1	   5406   else if(!strcmp(String,"i8") ||
      1	   5407 	  !strcmp(String,"I8"))
      1	   5408     return txColorI_8;
      1	   5409   else if(!strcmp(String,"a8") ||
      1	   5410 	  !strcmp(String,"A8"))
      1	   5411     return txColorA_8;
      1	   5412   else if(!strcmp(String,"ai44") ||
      1	   5413 	  !strcmp(String,"AI44"))
      1	   5414     return txColorAI_44;
      1	   5415   else if(!strcmp(String,"yiq") ||
      1	   5416 	  !strcmp(String,"YIQ"))
      1	   5417     return txColorYIQ;
      1	   5418   else if(!strcmp(String,"rgb332") ||
      1	   5419 	  !strcmp(String,"RGB332"))

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5420     return txColorRGB_332;
      1	   5421   else if(!strcmp(String,"rgb565") ||
      1	   5422 	  !strcmp(String,"RGB565"))
      1	   5423     return txColorRGB_565;
      1	   5424   else if(!strcmp(String,"argb8332") ||
      1	   5425 	  !strcmp(String,"ARGB8332"))
      1	   5426     return txColorARGB_8332;
      1	   5427   else if(!strcmp(String,"argb1555") ||
      1	   5428 	  !strcmp(String,"ARGB1555"))
      1	   5429     return txColorARGB_1555;
      1	   5430   else if(!strcmp(String,"ayiq8422") ||
      1	   5431 	  !strcmp(String,"AYIQ8422"))
      1	   5432     return txColorAYIQ_8422;
      1	   5433   else if(!strcmp(String,"argb4444") ||
      1	   5434 	  !strcmp(String,"ARGB4444"))
      1	   5435     return txColorARGB_4444;
      1	   5436   else if(!strcmp(String,"ai88") ||
      1	   5437 	  !strcmp(String,"AI88"))
      1	   5438     return txColorAI_88;
      1	   5439   else if(!strcmp(String,"argb8888") ||
      1	   5440 	  !strcmp(String,"ARGB8888"))
      1	   5441     return txColorARGB_8888;
      1	   5442   else
      1	   5443     return txColorUnknown;
      1	   5444 }
	   5445 
	   5446 /* _imgMSBReplicate
	   5447 **
	   5448 ** Summary: UNPUBLISHED - Replicates the msb's of the input value to fill
	   5449 **                        in an 8-bit color channel;
	   5450 */
	   5451 #define _imgMSBReplicate( COLOR, LEFT_SHIFT, RIGHT_SHIFT ) (COLOR << LEFT_SHIFT) | (COLOR >> RIGHT_SHIFT)
	   5452 
	   5453 /* _imgGuessType
	   5454 **
	   5455 ** Summary: UNPUBLISHED - read the first word of an image file stream
	   5456 **          determine the file type.
	   5457 */
	   5458 FxBool _imgGuessType( FILE *stream, ImgType *type )
      1	   5459 {
      1	   5460     FxU32 cookie = 0;
      1	   5461     int   c;
      1	   5462     
      1	   5463     if ( stream == NULL )
      2	   5464     {
      2	   5465 		imgErrorString = "Bad File Handle";
      2	   5466 		return FXFALSE;
      1	   5467     }
      1	   5468     
      1	   5469     if ( ( c = fgetc( stream ) ) == EOF )
      2	   5470     {
      2	   5471 		imgErrorString = "Unexpected end of file";
      2	   5472 		return FXFALSE;
      1	   5473     }
      1	   5474     
      1	   5475     cookie = (c << 8);
      1	   5476     

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5477     if ( ( c = fgetc( stream ) ) == EOF )
      2	   5478     {
      2	   5479 		imgErrorString = "Unexpected end of file";
      2	   5480 		return FXFALSE;
      1	   5481     }
      1	   5482     
      1	   5483     cookie |= c;
      1	   5484     
      1	   5485     switch( cookie )
      2	   5486     {
      2	   5487       	case ('P' << 8) | '9': // SBI
      2	   5488 			*type = IMG_SBI;
      2	   5489 			break;
      2	   5490       	case ('P' << 8) | '6': // PPM
      2	   5491 			*type = IMG_P6;
      2	   5492 			break;
      2	   5493       	case ('3' << 8) | 'd': // 3df
      2	   5494       	case ('3' << 8) | 'D': // 3df
      2	   5495 			*type = IMG_3DF;
      2	   5496 			break;
      2	   5497       	case 0xDA01:
      2	   5498 			*type = IMG_RGT;
      2	   5499 			break;
      2	   5500       	case (('E' << 8) | 'L'):
      2	   5501 	  cookie = 0;
      2	   5502 	  if ( ( c = fgetc( stream ) ) == EOF )
      3	   5503 	    {
      3	   5504 	      imgErrorString = "Unexpected end of file";
      3	   5505 	      return FXFALSE;
      2	   5506 	    }
      2	   5507 	  cookie = (cookie << 8) | c;
      2	   5508 	  if ( ( c = fgetc( stream ) ) == EOF )
      3	   5509 	    {
      3	   5510 	      imgErrorString = "Unexpected end of file";
      3	   5511 	      return FXFALSE;
      2	   5512 	    }
      2	   5513 	  cookie = (cookie << 8) | c;
      2	   5514 	  if (cookie == (('R' << 8) | 'S'))
      2	   5515 	    *type = IMG_SRLE;
      2	   5516 	  break;
      2	   5517       	default: // Might Be TGA
      2	   5518 			if ( ( c = fgetc( stream ) ) == EOF )
      3	   5519 			{
      3	   5520 	    		imgErrorString = "Unexpected end of file";
      3	   5521 	    		return FXFALSE;
      2	   5522 			}
      2	   5523 			cookie <<= 8;
      2	   5524 			cookie |= c;
      2	   5525 	
      2	   5526 			if ( (cookie & 0x00FFFF) == 0x0002 ) *type = IMG_TGA32;
      2	   5527 			else *type = IMG_UNKNOWN;
      2	   5528 			break;
      1	   5529     }
      1	   5530     return FXTRUE;
      1	   5531 }
	   5532 
	   5533 

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	   5534 /* _imgReadSbiHeader
	   5535 **
	   5536 ** Summary: UNPUBLISHED - read header and fill in header info
	   5537 */
	   5538 FxBool _imgReadSbiHeader( FILE *stream, SbiInfo *info )
      1	   5539 {
      1	   5540     char buffer[256];
      1	   5541     FxU32 state = 1;
      1	   5542     FxBool done = FXFALSE;
      1	   5543     
      1	   5544     if ( stream == NULL )
      2	   5545     {
      2	   5546 		imgErrorString = "Bad file handle.";
      2	   5547 		return FXFALSE;
      1	   5548     }
      1	   5549     
      1	   5550     while( !done && fgets( buffer, 256, stream ) )
      2	   5551     {
      2	   5552 		char *token;
      2	   5553 	
      2	   5554 		if ( buffer[0] == '#' ) continue;
      2	   5555 		for (token = strtok( buffer, " \t\n\r" );
      2	   5556 			token != NULL;
      2	   5557 			token = strtok( NULL, " \t\n\r" ))
      2	   5558 		switch( state )
      3	   5559 	    	{
      3	   5560 	      		case 1: // YOrigin
      3	   5561 					if ( token[1] == '+' ) info->yOrigin = 1;
      3	   5562 					else if ( token[1] == '-' )	info->yOrigin = 0;
      3	   5563 					else
      4	   5564 					{
      4	   5565 		    			imgErrorString = "Error parsing y-origin.";
      4	   5566 		    			return FXFALSE;
      3	   5567 					}
      3	   5568 					state++;
      3	   5569 					break;
      3	   5570 	      		case 2:   // Width
      3	   5571 					info->width = atoi( token );
      3	   5572 					state++;
      3	   5573 					break;
      3	   5574 	      		case 3: // height
      3	   5575 					info->height = atoi( token );
      3	   5576 					state++;
      3	   5577 					break;
      3	   5578 	     	 	case 4: // 'R'
      3	   5579 					if ( token[0] != 'R' )
      4	   5580 					{
      4	   5581 		    			imgErrorString = "Error parsing R color channel.";
      4	   5582 		    			return FXFALSE;
      3	   5583 					}
      3	   5584 					state++;
      3	   5585 					break;
      3	   5586 	      		case 5: // Red Channel
      3	   5587 					info->redBits = atoi( token );
      3	   5588 					state++;
      3	   5589 					break;
      3	   5590 	      		case 6: // 'G'

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   5591 					if ( token[0] != 'G' )
      4	   5592 					{
      4	   5593 		    			imgErrorString = "Error parsing G color channel.";
      4	   5594 		    			return FXFALSE;
      3	   5595 					}
      3	   5596 					state++;
      3	   5597 					break;
      3	   5598 	      		case 7: // Green Channel
      3	   5599 					info->greenBits = atoi( token );
      3	   5600 					state++;
      3	   5601 					break;
      3	   5602 	      		case 8: // 'B'
      3	   5603 					if ( token[0] != 'B' )
      4	   5604 					{
      4	   5605 		    			imgErrorString = "Error parsing B color channel.";
      4	   5606 		    			return FXFALSE;
      3	   5607 					}
      3	   5608 					state++;
      3	   5609 					break;
      3	   5610 	      		case 9: // Blue Channel                             
      3	   5611 					info->blueBits = atoi( token );
      3	   5612 					done = FXTRUE;
      3	   5613 					state++;
      3	   5614 					break;
      3	   5615 	      		default:
      3	   5616 					break;
      2	   5617 	    	}
      1	   5618     }
      1	   5619     
      1	   5620     if ( state < 10 )
      2	   5621     {
      2	   5622 		imgErrorString = "Read error before end of header.";
      2	   5623 		return FXFALSE;
      1	   5624     }
      1	   5625     
      1	   5626     info->sizeInBytes = info->width * info->height * 4;
      1	   5627     
      1	   5628     return FXTRUE;
      1	   5629 }
	   5630 
	   5631 /* _imgReadP6Header
	   5632 **
	   5633 ** Summary: UNPUBLISHED - read header and fill in header info
	   5634 */
	   5635 FxBool _imgReadP6Header( FILE *stream,  P6Info *info )
      1	   5636 {
      1	   5637     char buffer[256];
      1	   5638     FxU32 state = 1;
      1	   5639     FxBool done = FXFALSE;
      1	   5640     
      1	   5641     if ( stream == NULL )
      2	   5642     {
      2	   5643 		imgErrorString = "Bad file handle.";
      2	   5644 		return FXFALSE;
      1	   5645     }
      1	   5646     
      1	   5647     while( !done && fgets( buffer, 256, stream ) )

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   5648     {
      2	   5649 		char *token;
      2	   5650 	
      2	   5651 		if ( buffer[0] == '#' ) continue;
      2	   5652 		for (token = strtok( buffer, " \t\n\r" );
      2	   5653 			token != NULL;
      2	   5654 			token = strtok( NULL, " \t\n\r" ))
      2	   5655 	    	switch( state )
      3	   5656 	    	{
      3	   5657 	     		case 1:   // Width
      3	   5658 					info->width = atoi( token );
      3	   5659 					state++;
      3	   5660 					break;
      3	   5661 	      		case 2: // height
      3	   5662 					info->height = atoi( token );
      3	   5663 					state++;
      3	   5664 					break;
      3	   5665 	      		case 3: // Color Depth
      3	   5666 					info->colorChannelMax = atoi( token );
      3	   5667 					if ( info->colorChannelMax != 255 )
      4	   5668 					{
      4	   5669 		    			imgErrorString = "Unsupported max color value.  Must be 255.";
      4	   5670 		    			return FXFALSE;
      3	   5671 					}
      3	   5672 					state++;
      3	   5673 					done = FXTRUE;
      3	   5674 					break;
      3	   5675 	      		default:
      3	   5676 					imgErrorString = "General parse error reading header.";
      3	   5677 					return FXFALSE;
      3	   5678 					break;
      2	   5679 	    	}
      1	   5680     }
      1	   5681     
      1	   5682     if ( state < 4 )
      2	   5683     {
      2	   5684 		imgErrorString = "Read error before end of header.";
      2	   5685 		return FXFALSE;
      1	   5686     }
      1	   5687     
      1	   5688     info->sizeInBytes = info->width * info->height * 4;
      1	   5689     
      1	   5690     return FXTRUE;
      1	   5691 }
	   5692 
	   5693 /* _imgReadTGAHeader
	   5694 **
	   5695 ** Summary: UNPUBLISHED - read header and fill in header info
	   5696 */
	   5697 FxBool _imgReadTGAHeader( FILE *stream, TgaInfo *info )
      1	   5698 {
      1	   5699     struct {
      1	   5700 		FxU8 CMapStartLo;
      1	   5701 		FxU8 CMapStartHi;
      1	   5702 		FxU8 CMapLengthLo;
      1	   5703 		FxU8 CMapLengthHi;
      1	   5704 		FxU8 CMapDepth;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5705 		FxU8 XOffSetLo;
      1	   5706 		FxU8 XOffSetHi;
      1	   5707 		FxU8 YOffSetLo;
      1	   5708 		FxU8 YOffSetHi;
      1	   5709 		FxU8 WidthLo;
      1	   5710 		FxU8 WidthHi;
      1	   5711 		FxU8 HeightLo;
      1	   5712 		FxU8 HeightHi;
      1	   5713 		FxU8 PixelDepth;
      1	   5714 		FxU8 ImageDescriptor;
      1	   5715     } partialTGAHeader;
      1	   5716     
      1	   5717     if ( stream == NULL )
      2	   5718     {
      2	   5719 		imgErrorString = "Bad file handle.";
      2	   5720 		return FXFALSE;
      1	   5721     }
      1	   5722     
      1	   5723     if ( fread( &partialTGAHeader, 1, 15, stream ) != 15 )
      2	   5724     {
      2	   5725 	  	imgErrorString = "Unexpected end of file.";
      2	   5726 		return FXFALSE;
      1	   5727     }
      1	   5728     
      1	   5729     info->width  = partialTGAHeader.WidthHi << 8 | partialTGAHeader.WidthLo;
      1	   5730     info->height = partialTGAHeader.HeightHi << 8 | partialTGAHeader.HeightLo;
      1	   5731     info->yOrigin = 0x01 & partialTGAHeader.ImageDescriptor;
      1	   5732     info->sizeInBytes = info->width * info->height * 4;
      1	   5733     
      1	   5734     return FXTRUE;
      1	   5735 }
	   5736 
	   5737 /* _imgWriteTGAHeader
	   5738 **
	   5739 ** Summary: UNPUBLISHED - write header
	   5740 */
      1	   5741 FxBool _imgWriteTGAHeader( FILE *stream, const TgaInfo *info ) {
      1	   5742 
      1	   5743     struct {
      1	   5744 		FxU8 IDLength;
      1	   5745 		FxU8 ColorMapType;
      1	   5746 		FxU8 ImgType;
      1	   5747 		FxU8 CMapStartLo;
      1	   5748 		FxU8 CMapStartHi;
      1	   5749 		FxU8 CMapLengthLo;
      1	   5750 		FxU8 CMapLengthHi;
      1	   5751 		FxU8 CMapDepth;
      1	   5752 		FxU8 XOffSetLo;
      1	   5753 		FxU8 XOffSetHi;
      1	   5754 		FxU8 YOffSetLo;
      1	   5755 		FxU8 YOffSetHi;
      1	   5756 		FxU8 WidthLo;
      1	   5757 		FxU8 WidthHi;
      1	   5758 		FxU8 HeightLo;
      1	   5759 		FxU8 HeightHi;
      1	   5760 		FxU8 PixelDepth;
      1	   5761 		FxU8 ImageDescriptor;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5762     } tgaHeader;
      1	   5763     
      1	   5764     if ( stream == NULL )
      2	   5765     {
      2	   5766 		imgErrorString = "Bad file handle.";
      2	   5767 		return FXFALSE;
      1	   5768     }
      1	   5769 	
      1	   5770 	tgaHeader.IDLength         = 0;
      1	   5771 	tgaHeader.ColorMapType     = 0;
      1	   5772 	tgaHeader.ImgType          = 0x2;
      1	   5773 	tgaHeader.CMapStartLo      = 0;
      1	   5774 	tgaHeader.CMapStartHi      = 0;
      1	   5775 	tgaHeader.CMapLengthLo     = 0;
      1	   5776 	tgaHeader.CMapLengthHi     = 0;
      1	   5777 	tgaHeader.CMapDepth        = 0;
      1	   5778 	tgaHeader.XOffSetLo        = 0;
      1	   5779 	tgaHeader.XOffSetHi        = 0;
      1	   5780 	tgaHeader.YOffSetLo        = 0;
      1	   5781 	tgaHeader.YOffSetHi        = 0;
      1	   5782 	tgaHeader.WidthHi          = (FxU8)(info->width >> 8) & 0xFF;
      1	   5783 	tgaHeader.WidthLo          = (FxU8)info->width & 0xFF;
      1	   5784 	tgaHeader.HeightHi         = (FxU8)(info->height >> 8) & 0xFF;
      1	   5785 	tgaHeader.HeightLo         = (FxU8)info->height & 0xFF;
      1	   5786 	tgaHeader.PixelDepth       = 32;
      1	   5787 	tgaHeader.ImageDescriptor  = info->yOrigin ? ( 0x1 ) : ( 0x0 );	
      1	   5788 	    
      1	   5789 
      2	   5790 	if ( fwrite( &tgaHeader, 1, 18, stream ) != 18 ) {
      2	   5791 		imgErrorString = "TGA Header stream write error.";
      2	   5792 		return FXFALSE;
      1	   5793 	}
      1	   5794 
      1	   5795 	return FXTRUE;
      1	   5796 }
	   5797     
	   5798 /* _imgReadRGTHeader
	   5799 **
	   5800 ** Summary: UNPUBLISHED - read header and fill in header info
	   5801 */
	   5802 FxBool _imgReadRGTHeader( FILE *stream, RgtInfo *info )
      1	   5803 {
      1	   5804     const FxU16 ITYPE_RLE      = 0x01;
      1	   5805     const FxU16 ITYPE_NCC      = 0x02;
      1	   5806     const FxU16 ITYPE_BGR      = 0x04;
      1	   5807     const FxU16 ITYPE_RGT      = 0x08;
      1	   5808     
      1	   5809     struct {
      1	   5810 		FxU8 typeLo;
      1	   5811 		FxU8 typeHi;
      1	   5812 		FxU8 dimLo;
      1	   5813 		FxU8 dimHi;
      1	   5814 		FxU8 sizeXLo;
      1	   5815 		FxU8 sizeXHi;
      1	   5816 		FxU8 sizeYLo;
      1	   5817 		FxU8 sizeYHi;
      1	   5818 		FxU8 sizeZLo;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5819 		FxU8 sizeZHigh;
      1	   5820     } partialRGTHeader;
      1	   5821     
      1	   5822     if ( stream == NULL )
      2	   5823     {
      2	   5824 		imgErrorString = "Bad file handle.";
      2	   5825 		return FXFALSE;
      1	   5826     }
      1	   5827     
      1	   5828     if ( fread( &partialRGTHeader, 1, 10, stream ) != 10 )
      2	   5829     {
      2	   5830 		imgErrorString = "Unexpected end of file.";
      2	   5831 		return FXFALSE;
      1	   5832     }
      1	   5833     
      1	   5834     info->width = partialRGTHeader.sizeXHi << 8 | partialRGTHeader.sizeXLo;
      1	   5835     info->height = partialRGTHeader.sizeYHi << 8 | partialRGTHeader.sizeYLo;
      1	   5836     info->sizeInBytes = info->width * info->height * 4;
      1	   5837     info->rle = partialRGTHeader.typeHi & ITYPE_RLE;
      1	   5838     info->bgr = partialRGTHeader.typeHi & ITYPE_BGR;
      1	   5839     info->rgb = partialRGTHeader.typeHi & ITYPE_RGT;
      1	   5840     info->ncc = partialRGTHeader.typeHi & ITYPE_NCC;
      1	   5841     
      1	   5842     return FXTRUE;
      1	   5843 }
	   5844 
	   5845 /* _imgRead3DFHeader
	   5846 **
	   5847 ** Summary: UNPUBLISHED - read header and fill in header info
	   5848 */
      1	   5849 FxBool _imgRead3DFHeader( FILE *stream, TdfInfo *info ) {
      1	   5850 	FxBool done = FXFALSE;
      1	   5851     char buffer[256];
      1	   5852 	FxU32 state = 0;
      1	   5853 	float tempFloat;
      1	   5854 
      2	   5855     if ( stream == NULL ) {
      2	   5856 		imgErrorString = "Bad file handle.";
      2	   5857 		return FXFALSE;
      1	   5858     }
      1	   5859 
      2	   5860     while( !done && fgets( buffer, 256, stream ) ) {
      2	   5861 		char *token;
      2	   5862 	
      2	   5863 		if ( buffer[0] == '#' ) continue;
      2	   5864 		for (token = strtok( buffer, " \t\n\r" );
      2	   5865 			token != NULL;
      2	   5866 			token = strtok( NULL, " \t\n\r" ))
      3	   5867 	    	switch( state )	{
      3	   5868 				case  0:   // 'f'
      4	   5869 					if ( token[0] != 'f' ) {
      4	   5870 						imgErrorString = "Bad cookie( \"3df\" ).";
      4	   5871 						return FXFALSE;
      3	   5872 					}
      3	   5873 					state++;
      3	   5874 					break;
      3	   5875 				case  1:   // Version

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   5876 					if ( sscanf( token, 
      3	   5877 							     "v%f", 
      4	   5878 							     &tempFloat ) == 0 ) {	
      4	   5879 						imgErrorString = "Couldn't determine version of 3DF file.";
      4	   5880 						return FXFALSE;
      3	   5881 					}
      3	   5882 					info->version = tempFloat;
      3	   5883 					state++;
      3	   5884 					break;
      3	   5885 				case  2:  // Color Format
      4	   5886 					if ( (info->colorFormat = _imgTxDecodeColorFormat( token ))==txColorUnknown 
      4	   5886 ) {
      4	   5887 						imgErrorString = "3DF Unknown color format.";
      4	   5888 						return FXFALSE;
      3	   5889 					} 
      3	   5890 					state++;
      3	   5891 					break;
      3	   5892 				case  3:  // "lod"
      4	   5893 					if ( strcmp( token, "lod" ) ) {
      4	   5894 						imgErrorString = "Bad lod range identifier.";
      4	   5895 						return FXFALSE;
      3	   5896 					}
      3	   5897 					state++;
      3	   5898 					break;
      3	   5899 				case  4:  // "range:"
      4	   5900 					if ( strcmp( token, "range:" ) ) {
      4	   5901 						imgErrorString = "Bad lod range identifier.";
      4	   5902 						return FXFALSE;
      3	   5903 					}
      3	   5904 					state++;
      3	   5905 					break;
      3	   5906 				case  5:  // lodMin
      3	   5907 					info->lodMin = atoi( token );
      3	   5908 					state++;
      3	   5909 					break;
      3	   5910 				case  6:  // lodMax
      3	   5911 					info->lodMax = atoi( token );
      3	   5912 					state++;
      3	   5913 					break;
      3	   5914 				case  7:  // "aspect"
      4	   5915 					if ( strcmp( token , "aspect" ) ) {	
      4	   5916 						imgErrorString = "Bad aspect ratio identifier.";
      4	   5917 						return FXFALSE;
      3	   5918 					}
      3	   5919 					state++;
      3	   5920 					break;
      3	   5921 				case  8:  // "ratio:"
      4	   5922 					if ( strcmp( token, "ratio:" ) ) {	
      4	   5923 						imgErrorString = "Bad aspect ratio identifier.";
      4	   5924 						return FXFALSE;
      3	   5925 					}
      3	   5926 					state++;
      3	   5927 					break;
      3	   5928 				case  9:  // aspectWidth
      3	   5929 					info->aspectWidth = atoi( token );
      3	   5930 					state++;
      3	   5931 					break;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   5932 				case 10:  // aspectHeight
      3	   5933 					info->aspectHeight = atoi( token );
      3	   5934 					done = FXTRUE;
      3	   5935 					break;
      3	   5936 				default:
      3	   5937 					imgErrorString = "General parse error reading header.";
      3	   5938 					return FXFALSE;
      3	   5939 					break;
      2	   5940 	    	}
      1	   5941     }
      1	   5942     
      2	   5943     if ( state != 10 ) {
      2	   5944 		imgErrorString = "Read error before end of header.";
      2	   5945 		return FXFALSE;
      1	   5946     }
      1	   5947 
      2	   5948 	if ( info->lodMin > info->lodMax ) {
      2	   5949 		imgErrorString = "3DF Format Error.  lodMin must be <= lodMax.";
      2	   5950 		return FXFALSE;
      1	   5951 	}
      1	   5952 
      1	   5953 	// Calculate Width and Height with All Mipmaps
      2	   5954 	if ( info->aspectWidth < info->aspectHeight ) {
      2	   5955 		FxU32 lod;
      2	   5956 		info->height = info->lodMax;
      2	   5957 		info->width = info->lodMax / info->aspectHeight;
      3	   5958 		for ( lod = info->lodMax / 2; lod >= info->lodMin; lod /= 2 ) {
      3	   5959 			info->width += lod > 1 ? lod / info->aspectHeight : 1;
      2	   5960 		}
      2	   5961 	} else {
      2	   5962 		FxU32 lod;
      2	   5963 		info->width = info->lodMax;
      2	   5964 		info->height = info->lodMax / info->aspectWidth;
      3	   5965 		for ( lod = info->lodMax / 2; lod >= info->lodMin; lod /= 2 ) {
      3	   5966 			info->height += lod > 1 ? lod / info->aspectWidth : 1;
      2	   5967 		}
      1	   5968 	}
      1	   5969 
      1	   5970 	info->sizeInBytes = info->width * info->height * 4;
      1	   5971 
      1	   5972     return FXTRUE;
      1	   5973 }
	   5974 
	   5975 
	   5976 /* _imgRead3DFData
	   5977 **
	   5978 ** Summary: UNPUBLISHED - read data from a 3DF file.
	   5979 **          when the texuslib has an owner, and it
	   5980 **          is reliably maintained, this will be
	   5981 **          converted over to calls to the library.
	   5982 */
	   5983 /* Read in data from a 3DF file. */
	   5984 FxBool _imgRead3DFData( FILE *stream, const TdfInfo *info, ImgData *data )
      1	   5985 {
      1	   5986 	FxBool doVerticalDisplay;
      1	   5987 	ImgData *destPtr, *destOrigin;
      1	   5988 	FxU32 xBound, yBound;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   5989 	FxU32 lod;
      1	   5990 
      1	   5991 	struct { 
      1	   5992 		FxU8  yRGB[16];
      1	   5993 		FxI16 iRGB[4][3];
      1	   5994 		FxI16 qRGB[4][3];
      1	   5995 	} imgYIQTable;
      1	   5996 
      2	   5997 	if ( stream == NULL ) {
      2	   5998 		imgErrorString = "Bad file handle.";
      2	   5999 		return FXFALSE;
      1	   6000 	}  
      1	   6001 
      1	   6002   	/* Read in the YIQ decompression table, if necessary. */
      2	   6003   	if( (info->colorFormat == txColorYIQ) || (info->colorFormat == txColorAYIQ_8422) ) {
      2	   6004 		FxU32 index;
      3	   6005 		for( index=0; index < 16; index++ ) {
      3	   6006             getc( stream );
      3	   6007 			imgYIQTable.yRGB[index] = (FxU8) getc( stream );
      2	   6008 		}
      3	   6009 		for( index=0; index < 4;index++ ) {	
      3	   6010 			FxI16 msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6011 			FxI16 lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6012 			imgYIQTable.iRGB[index][0] = msb | lsb;
      3	   6013 			msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6014 			lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6015 			imgYIQTable.iRGB[index][1] = msb | lsb;
      3	   6016 			msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6017 			lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6018 			imgYIQTable.iRGB[index][2] = msb | lsb;
      2	   6019 		}
      3	   6020 		for( index=0; index < 4;index++ ) {	
      3	   6021 			FxI16 msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6022 			FxI16 lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6023 			imgYIQTable.qRGB[index][0] = msb | lsb;
      3	   6024 			msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6025 			lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6026 			imgYIQTable.qRGB[index][1] = msb | lsb;
      3	   6027 			msb = (FxI16) ( getc( stream ) & 0xFF ) << 8;
      3	   6028 			lsb = (FxI16) ( getc( stream ) & 0xFF );
      3	   6029 			imgYIQTable.qRGB[index][2] = msb | lsb;
      2	   6030 		}
      3	   6031 		if ( feof( stream ) ) {
      3	   6032 			imgErrorString = "Unexpected end of file reading YIQ Table.";
      3	   6033 			return FXFALSE;
      2	   6034 		}
      1	   6035 	}
      1	   6036 
      1	   6037 	/* Read in the Image One mipmap level at a time */
      1	   6038 
      1	   6039 	doVerticalDisplay = (info->aspectHeight <= info->aspectWidth ) ? FXTRUE : FXFALSE;
      1	   6040 
      1	   6041 	destPtr = destOrigin = data;
      2	   6042 	if ( doVerticalDisplay ) {
      2	   6043 		yBound = info->lodMax / info->aspectWidth;
      2	   6044 		xBound = info->lodMax;	
      2	   6045 	} else { 

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   6046 		yBound = info->lodMax;
      2	   6047 		xBound = info->lodMax / info->aspectHeight;
      1	   6048 	}
      1	   6049 
      2	   6050 	for ( lod = info->lodMax; lod >= info->lodMin; lod /= 2 )	{
      2	   6051 		FxU32 x, y;
      3	   6052 		switch( info->colorFormat )	{
      3	   6053 			case txColorTrue:        /* True color, 24-bit color (RGB) + 8-bit alpha.               */
      3	   6054 			case txColorARGB_8888:   /* 8-bits of Alpha, Red, Green, and Blue.  Not yet supported.  */
      4	   6055 				for ( y = 0; y < yBound; y++ ) {
      5	   6056 					for( x = 0; x < xBound; x++ ) {
      5	   6057 						FxU8 r, g, b, a;
      5	   6058 						a = getc( stream );
      5	   6059 						r = getc( stream );
      5	   6060 						g = getc( stream );
      5	   6061 						b = getc( stream );
      5	   6062 						*destPtr++ = b;
      5	   6063 						*destPtr++ = g;
      5	   6064 						*destPtr++ = r;
      5	   6065 						*destPtr++ = a;
      4	   6066 					}
      4	   6067 					destPtr += (info->width - xBound) * 4;
      3	   6068 				}
      3	   6069 				break;
      3	   6070 			case txColorI_8:         /* 8-bit intensity.                                            */
      3	   6071 	        		                 /* For this, an intensity is calculated by averaging the       */
      3	   6072 	                		         /* RG and B channels, and placed back into all three channels  */
      3	   6073 			                         /* so that outputs of TGA's and PPM's will look okay.          */
      4	   6074 				for ( y = 0; y < yBound; y++ ) {
      5	   6075 					for ( x = 0; x < xBound; x++ ) {
      5	   6076 						FxU8 intensity;
      5	   6077 						intensity = getc( stream );
      5	   6078 						*destPtr++ = intensity;
      5	   6079 						*destPtr++ = intensity;
      5	   6080 						*destPtr++ = intensity;
      5	   6081 						*destPtr++ = intensity;
      4	   6082 					}
      4	   6083 					destPtr += (info->width - xBound) * 4;
      3	   6084 				}
      3	   6085 				break;
      3	   6086 			case txColorA_8: /* 8-bit alpha. */
      4	   6087 				for ( y = 0; y < yBound; y++ ) {
      5	   6088 					for ( x = 0; x < xBound; x++ ) {
      5	   6089 						FxU8 alpha;
      5	   6090 						alpha = getc( stream );
      5	   6091 						*destPtr++ = alpha;
      5	   6092 						*destPtr++ = alpha;
      5	   6093 						*destPtr++ = alpha;
      5	   6094 						*destPtr++ = alpha;
      4	   6095 					}
      4	   6096 					destPtr += (info->width - xBound) * 4;
      3	   6097 				}
      3	   6098 				break;
      3	   6099 			case txColorARGB_1555:
      4	   6100 				for ( y = 0; y < yBound; y++ ) {
      5	   6101 					for ( x = 0; x < xBound; x++ ) {
      5	   6102 						FxU16 color;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      5	   6103 						FxU8  a,r,g,b;
      5	   6104 						color = ( 0xFF & getc( stream ) ) << 8;
      5	   6105 						color |= ( 0xFF & getc( stream ) );
      5	   6106 						a = ( color >> 15 ) & 0x01;
      5	   6107 						r = ( color >> 10 ) & 0x1F;
      5	   6108 						g = ( color >> 5  ) & 0x1F;
      5	   6109 						b =   color         & 0x1F;
      5	   6110 
      5	   6111 						*destPtr++ = _imgMSBReplicate( b, 3, 2);
      5	   6112 						*destPtr++ = _imgMSBReplicate( g, 3, 2);
      5	   6113   						*destPtr++ = _imgMSBReplicate( r, 3, 2);
      5	   6114 						*destPtr++ = a ? 0x0 : 0xFF;
      4	   6115 					}
      4	   6116 					destPtr += (info->width - xBound) * 4;
      3	   6117 				}
      3	   6118 				break;
      3	   6119 			case txColorARGB_4444:
      4	   6120 				for ( y = 0; y < yBound; y++ ) {
      5	   6121 					for ( x = 0; x < xBound; x++ ) {
      5	   6122 						FxU16 color;
      5	   6123 						FxU8  a,r,g,b;
      5	   6124 						color = ( 0xFF & getc( stream ) ) << 8;
      5	   6125 						color |= ( 0xFF & getc( stream ) );
      5	   6126 						a = ( color >> 12 ) & 0x0F;
      5	   6127 						r = ( color >> 8  ) & 0x0F;
      5	   6128 						g = ( color >> 4  ) & 0x0F;
      5	   6129 						b = ( color >> 0  ) & 0x0F;
      5	   6130 
      5	   6131 						*destPtr++ = _imgMSBReplicate( b, 4, 0 );
      5	   6132 						*destPtr++ = _imgMSBReplicate( g, 4, 0 );
      5	   6133   						*destPtr++ = _imgMSBReplicate( r, 4, 0 );
      5	   6134 						*destPtr++ = _imgMSBReplicate( a, 4, 0 );
      4	   6135 					}
      4	   6136 					destPtr += (info->width - xBound) * 4;
      3	   6137 				}
      3	   6138 				break;
      3	   6139 			case txColorRGB_565:
      4	   6140 				for ( y = 0; y < yBound; y++ ) {
      5	   6141 					for ( x = 0; x < xBound; x++ ) {
      5	   6142 						FxU16 color;
      5	   6143 						FxU8  r,g,b;
      5	   6144 						color = ( 0xFF & getc( stream ) ) << 8;
      5	   6145 						color |= ( 0xFF & getc( stream ) );
      5	   6146 						r = ( color >> 11 ) & 0x1F;
      5	   6147 						g = ( color >> 5 ) &  0x3F;
      5	   6148 						b = ( color >> 0 ) &  0x1F;
      5	   6149 
      5	   6150 						*destPtr++ = _imgMSBReplicate( b, 3, 2 );
      5	   6151 						*destPtr++ = _imgMSBReplicate( g, 2, 4);
      5	   6152   						*destPtr++ = _imgMSBReplicate( r, 3, 2);
      5	   6153 						*destPtr++ = 0x0; // Alpha
      4	   6154 					}
      4	   6155 					destPtr += (info->width - xBound) * 4;
      3	   6156 				}
      3	   6157 				break;
      3	   6158 			case txColorAI_44:
      3	   6159 			default:

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   6160 				imgErrorString = "Unhandled 3df color format.";
      3	   6161 				return FXFALSE;	
      2	   6162 		}
      3	   6163 		if ( doVerticalDisplay ) { 
      3	   6164 			destPtr = destOrigin + ( yBound * info->width * 4 );
      3	   6165 		} else {
      3	   6166 			destPtr = destOrigin + (xBound * 4);
      2	   6167 		}
      2	   6168 		destOrigin = destPtr;
      2	   6169 		if ( yBound > 1 ) yBound /= 2;
      2	   6170 		if ( xBound > 1 ) xBound /= 2;
      1	   6171 	}
      1	   6172 	
      1X   6173 #if 0
      1X   6174 	case txColorAI_44:       /* 4-bit alpha, 4-bit intensity.                               */
      1X   6175 	                         /* For this conversion, the alpha is shredded to four bits,    */
      1X   6176                                  /* the intensities are averaged and then shredded into four    */
      1X   6177                                  /* bits, and then the intensity is placed into all three       */
      1X   6178                                  /* color channels.                                             */
      1X   6179 	  /* Loop through the entire image. */
      1X   6180 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6181 	    {
      1X   6182 	      /* Read in both alpha and intensity. */
      1X   6183 	      fread(&tmpChar,1,1,ImageFile);
      1X   6184 	      tmpColor = tmpChar;
      1X   6185 	      
      1X   6186 	      /* Extract the alpha portion. */
      1X   6187 	      Image->AlphaChannel[index] = (tmpColor & 0xf0);
      1X   6188 
      1X   6189 	      /* Extract the color portion. */
      1X   6190 	      Image->RedChannel[index] = 
      1X   6191 	      Image->GreenChannel[index] = 
      1X   6192 	      Image->BlueChannel[index] = ((tmpColor & 0x0f)<<4);
      1X   6193 	    }
      1X   6194 	  
      1X   6195 	  break;
      1X   6196 
      1X   6197 	case txColorYIQ:         /* Narrow-channel, compressed color.                           */
      1X   6198 	  /* Get a copy of the YIQ table so that it doesn't have to be dereferenced
      1X   6199 	     every single time it's used. */
      1X   6200 	  YIQTable = Image->YIQTable;
      1X   6201 	  
      1X   6202 	  /* Loop through the entire image. */
      1X   6203 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6204 	    {
      1X   6205 	      /* Get the YIQ pixel into a temporary value. */
      1X   6206 	      fread(&tmpChar,1,1,ImageFile);
      1X   6207 	      tmpColor = (tmpChar & 0xff);
      1X   6208 	      
      1X   6209 	      /* Rip out YIQ from that pixel. */
      1X   6210 	      y = tmpColor >> 4;
      1X   6211 	      i = (tmpColor >> 2) & 0x3;
      1X   6212 	      q = (tmpColor >> 0) & 0x3;
      1X   6213 
      1X   6214 	      /* Convert the colors back out. */
      1X   6215 	      r = YIQTable.yRGB[y] + YIQTable.iRGB[i][0] + YIQTable.qRGB[q][0];
      1X   6216 	      g = YIQTable.yRGB[y] + YIQTable.iRGB[i][1] + YIQTable.qRGB[q][1];

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1X   6217 	      b = YIQTable.yRGB[y] + YIQTable.iRGB[i][2] + YIQTable.qRGB[q][2];
      1X   6218 
      1X   6219 	      /* Clamp the values. */
      1X   6220 	      if( r < 0 ) r = 0; else if ( r > 0xff ) r = 0xff;
      1X   6221 	      if( g < 0 ) g = 0; else if ( g > 0xff ) g = 0xff;
      1X   6222 	      if( b < 0 ) b = 0; else if ( b > 0xff ) b = 0xff;
      1X   6223 
      1X   6224 	      /* Stick the values into the image structure. */
      1X   6225 	      Image->RedChannel[index] = (unsigned char)r;
      1X   6226 	      Image->GreenChannel[index] = (unsigned char)g;
      1X   6227 	      Image->BlueChannel[index] = (unsigned char)b;
      1X   6228 	      
      1X   6229 	      /* Make up something for alpha. */
      1X   6230 	      Image->AlphaChannel[index] = 0xff;
      1X   6231 	    }
      1X   6232 
      1X   6233 	  break;
      1X   6234 
      1X   6235 	case txColorRGB_332:     /* 3-bit red, 3-bit green, 2-bit blue.                         */
      1X   6236                                  /* Shred bits off of the color channels, and tip the alpha     */
      1X   6237                                  /* channel up to 0xff.                                         */
      1X   6238 	  /* Loop through the entire image. */
      1X   6239 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6240 	    {
      1X   6241 	      /* Combine the whole color into one byte. */
      1X   6242 	      fread(&tmpChar,1,1,ImageFile);
      1X   6243 
      1X   6244 	      /* Rip the byte apart into colors. */
      1X   6245 	      Image->RedChannel[index] = (tmpChar & 0xe0);
      1X   6246 	      Image->GreenChannel[index] = (tmpChar & 0x1c)<<3;
      1X   6247 	      Image->BlueChannel[index] = (tmpChar & 0x03)<<6;
      1X   6248 
      1X   6249 	      /* Make up something for alpha. */
      1X   6250 	      Image->AlphaChannel[index] = 0xff;
      1X   6251 	    }
      1X   6252 	  
      1X   6253 	  break;
      1X   6254 	case txColorRGB_565:     /* 5-bit red, 6-bit green, 5-bit blue.                         */
      1X   6255                                  /* Shred bits off of the color channels, and tip the alpha     */
      1X   6256                                  /* channel up to 0xff.                                         */
      1X   6257 	  /* Loop through the entire image. */
      1X   6258 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6259 	    {
      1X   6260 	      /* Read both bytes into a tmp color. */
      1X   6261 	      fread(&tmpChar,1,1,ImageFile);
      1X   6262 	      tmpColor = (tmpChar & 0xff)<<8;
      1X   6263 	      fread(&tmpChar,1,1,ImageFile);
      1X   6264 	      tmpColor |= (tmpChar & 0xff);
      1X   6265 	  
      1X   6266 	      /* Rip the short apart into colors. */
      1X   6267 	      Image->RedChannel[index] = (tmpColor & 0xf800)>>8;
      1X   6268 	      Image->GreenChannel[index] = (tmpColor & 0x07e0)>>3;
      1X   6269 	      Image->BlueChannel[index] = (tmpColor & 0x001f)<<3;
      1X   6270 	      
      1X   6271 	      /* Make up something for alpha. */
      1X   6272 	      Image->AlphaChannel[index] = 0xff;
      1X   6273 	    }

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1X   6274 	  
      1X   6275 	  break;
      1X   6276 	case txColorARGB_8332:   /* 8-bit alpha, 3-bit red, 3-bit green, 2-bit blue.            */
      1X   6277                                  /* Nothing but shredding.                                      */
      1X   6278 	  /* Loop through the entire image. */
      1X   6279 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6280 	    {
      1X   6281 	      /* Read both bytes into a tmp color. */
      1X   6282 	      fread(&tmpChar,1,1,ImageFile);
      1X   6283 	      tmpColor = (tmpChar & 0xff)<<8;
      1X   6284 	      fread(&tmpChar,1,1,ImageFile);
      1X   6285 	      tmpColor |= (tmpChar & 0xff);
      1X   6286 	      
      1X   6287 	      /* Read out the alpha. */
      1X   6288 	      Image->AlphaChannel[index] = ((tmpColor & 0xff00)>>8);
      1X   6289 
      1X   6290 	      /* Rip the byte apart into colors. */
      1X   6291 	      Image->RedChannel[index] = (tmpColor & 0xe0);
      1X   6292 	      Image->GreenChannel[index] = (tmpColor & 0x1c)<<3;
      1X   6293 	      Image->BlueChannel[index] = (tmpColor & 0x03)<<6;
      1X   6294 	    }
      1X   6295 	  
      1X   6296 	  break;
      1X   6297 	case txColorARGB_1555:   /* 1-bit alpha, 5-bit red, 5-bit green, 5-bit blue.            */
      1X   6298 	                         /* Nothing but shredding.                                      */
      1X   6299 	  /* Loop through the entire image. */
      1X   6300 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6301 	    {
      1X   6302 	      /* Read both bytes into a tmp color. */
      1X   6303 	      fread(&tmpChar,1,1,ImageFile);
      1X   6304 	      tmpColor = (tmpChar & 0xff)<<8;
      1X   6305 	      fread(&tmpChar,1,1,ImageFile);
      1X   6306 	      tmpColor |= (tmpChar & 0xff);
      1X   6307 
      1X   6308 	      /* Rip the color apart. */
      1X   6309 	      Image->AlphaChannel[index] = (tmpColor & 0x8000)>>8;
      1X   6310 	      Image->RedChannel[index] = (tmpColor & 0x7c00)>>7;
      1X   6311 	      Image->GreenChannel[index] = (tmpColor & 0x03e0)>>2;
      1X   6312 	      Image->BlueChannel[index] = (tmpColor & 0x001f)<<3;
      1X   6313 	    }
      1X   6314 	  
      1X   6315 	  break;
      1X   6316 
      1X   6317 	case txColorAYIQ_8422:   /* 8-bit alpha + narrow-channel compressed color.              */
      1X   6318 	  /* Get a copy of the YIQ table so that it doesn't have to be dereferenced
      1X   6319 	     every single time it's used. */
      1X   6320 	  YIQTable = Image->YIQTable;
      1X   6321 	  
      1X   6322 	  /* Loop through the entire image. */
      1X   6323 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6324 	    {
      1X   6325 	      /* Get alpha from the first byte. */
      1X   6326 	      fread(&tmpChar,1,1,ImageFile);
      1X   6327 	      (Image->AlphaChannel[index]) = (unsigned char)tmpChar;
      1X   6328 	      
      1X   6329 	      /* Get the YIQ pixel into a temporary value. */
      1X   6330 	      fread(&tmpChar,1,1,ImageFile);

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1X   6331 	      tmpColor = (tmpChar & 0xff);
      1X   6332 
      1X   6333 	      /* Rip out YIQ from that pixel. */
      1X   6334 	      y = tmpColor >> 4;
      1X   6335 	      i = (tmpColor >> 2) & 0x3;
      1X   6336 	      q = (tmpColor >> 0) & 0x3;
      1X   6337 
      1X   6338 	      /* Convert the colors back out. */
      1X   6339 	      r = YIQTable.yRGB[y] + YIQTable.iRGB[i][0] + YIQTable.qRGB[q][0];
      1X   6340 	      g = YIQTable.yRGB[y] + YIQTable.iRGB[i][1] + YIQTable.qRGB[q][1];
      1X   6341 	      b = YIQTable.yRGB[y] + YIQTable.iRGB[i][2] + YIQTable.qRGB[q][2];
      1X   6342 
      1X   6343 	      /* Clamp the values. */
      1X   6344 	      if( r < 0 ) r = 0; else if ( r > 0xff ) r = 0xff;
      1X   6345 	      if( g < 0 ) g = 0; else if ( g > 0xff ) g = 0xff;
      1X   6346 	      if( b < 0 ) b = 0; else if ( b > 0xff ) b = 0xff;
      1X   6347 
      1X   6348 	      /* Stick the values into the image structure. */
      1X   6349 	      Image->RedChannel[index] = (unsigned char)r;
      1X   6350 	      Image->GreenChannel[index] = (unsigned char)g;
      1X   6351 	      Image->BlueChannel[index] = (unsigned char)b;
      1X   6352 	      
      1X   6353 	      /* Make up something for alpha. */
      1X   6354 	      Image->AlphaChannel[index] = 0xff;
      1X   6355 	    }
      1X   6356 
      1X   6357 	  break;
      1X   6358 	case txColorARGB_4444:   /* 4-bit alpha, 4-bit red, 4-bit green, 4-bit blue.            */
      1X   6359 	                         /* Nothing but shredding.                                      */
      1X   6360 	  /* Loop through the entire image. */
      1X   6361 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6362 	    {
      1X   6363 	      /* Read both bytes into a tmp color. */
      1X   6364 	      fread(&tmpChar,1,1,ImageFile);
      1X   6365 	      tmpColor = (tmpChar & 0xff)<<8;
      1X   6366 	      fread(&tmpChar,1,1,ImageFile);
      1X   6367 	      tmpColor |= (tmpChar & 0xff);
      1X   6368 
      1X   6369 	      /* Rip that color apart. */
      1X   6370 	      Image->AlphaChannel[index] = (tmpColor & 0xf000)>>8;
      1X   6371 	      Image->RedChannel[index] = (tmpColor & 0x0f00)>>4;
      1X   6372 	      Image->GreenChannel[index] = (tmpColor & 0x00f0);
      1X   6373 	      Image->BlueChannel[index] = (tmpColor & 0x000f)<<4;
      1X   6374 	    }
      1X   6375 	  
      1X   6376 	  break;
      1X   6377 	case txColorAI_88:       /* 8-bit alpha, 8-bit itensity.                                */
      1X   6378 	                         /* Same as txColorAI_44, minus the shredding.                  */
      1X   6379 	  /* Loop through the entire image. */
      1X   6380 	  for(index=0;index<((Image->Width)*(Image->Height));index++)
      1X   6381 	    {
      1X   6382 	      /* Grab alpha from the first byte. */
      1X   6383 	      fread(&tmpChar,1,1,ImageFile);
      1X   6384 	      (Image->AlphaChannel[index]) = (tmpChar & 0xff);
      1X   6385 	      
      1X   6386 	      /* And grab the intensity from the second byte. */
      1X   6387 	      fread(&tmpChar,1,1,ImageFile);

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1X   6388 	      Image->RedChannel[index] =
      1X   6389 	      Image->GreenChannel[index] =
      1X   6390 	      Image->BlueChannel[index] = (tmpChar & 0xff);
      1X   6391 	    }
      1X   6392 	  
      1X   6393 	  break;
      1X   6394 	}
      1X   6395     }
      1X   6396   
      1X   6397   /* Close the file. */
      1X   6398   fclose(ImageFile);
      1X   6399 #endif
      1	   6400 
      1	   6401   return FXTRUE;
      1	   6402 }
	   6403 
	   6404 
	   6405 
	   6406 /* _imgReadTGAData
	   6407 **
	   6408 ** Summary: UNPUBLISHED - read data from a TGA file
	   6409 ** TGA is BGRA
	   6410 */
	   6411 FxBool _imgReadTGAData( FILE *stream, const TgaInfo *info, ImgData *data )
      1	   6412 {
      1	   6413 	FxI32 y, y0, y1, dy, scanlineLength;
      1	   6414 	const int bytesPerPixel = 4;
      1	   6415 
      1	   6416     if ( stream == NULL )
      2	   6417     {
      2	   6418 		imgErrorString = "Bad file handle.";
      2	   6419 		return FXFALSE;
      1	   6420     }
      1	   6421 
      1	   6422 	if ( info->height == 0 ) return FXTRUE;
      1	   6423 
      1	   6424 	if ( info->yOrigin == 0 )
      2	   6425 	{
      2	   6426 		dy = -1;
      2	   6427 		y0 = info->height - 1;
      2	   6428 		y1 = -1;
      1	   6429 	}
      1	   6430 	else
      2	   6431 	{
      2	   6432 		dy = 1;
      2	   6433 		y0 = 0;
      2	   6434 		y1 = info->height;
      1	   6435 	}
      1	   6436 
      1	   6437 	scanlineLength = info->width * bytesPerPixel;
      1	   6438 
      1	   6439 	for ( y = y0; y != y1; y += dy )
      2	   6440 	{
      2	   6441 		if ( fread( data + scanlineLength * y, 1, scanlineLength, stream ) !=
      2	   6442 			 (FxU32) scanlineLength )
      3	   6443 		{
      3	   6444 			imgErrorString = "Unexpected end of file";

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   6445 			return FXFALSE;
      2	   6446 		}
      1	   6447 	}
      1	   6448     
      1	   6449     return FXTRUE;
      1	   6450 }
	   6451 
	   6452 
	   6453 
	   6454 /* _imgWriteTGAData
	   6455 **
	   6456 ** Summary: UNPUBLISHED - write data out to a tga
	   6457 ** TGA is BGRA
	   6458 */
	   6459 FxBool _imgWriteTGAData( FILE *stream, const TgaInfo *info, const ImgData *data )
      1	   6460 {
      1	   6461 	FxI32 y, scanlineLength;
      1	   6462 	const int bytesPerPixel = 4;
      1	   6463 
      1	   6464     if ( stream == NULL )
      2	   6465     {
      2	   6466 		imgErrorString = "Bad file handle.";
      2	   6467 		return FXFALSE;
      1	   6468     }
      1	   6469 
      1	   6470 	scanlineLength = info->width * bytesPerPixel;
      1	   6471 
      1	   6472 	for ( y = info->height - 1; y >= 0; y-- )
      2	   6473 	{
      2	   6474 		if ( fwrite( data + scanlineLength * y, 1, scanlineLength, stream ) !=
      2	   6475 			 (FxU32) scanlineLength )
      3	   6476 		{
      3	   6477 			imgErrorString = "TGA stream write error.";
      3	   6478 			return FXFALSE;
      2	   6479 		}
      1	   6480 	}
      1	   6481     
      1	   6482     return FXTRUE;
      1	   6483 }
	   6484 
	   6485 /* _imgReadRGTData
	   6486 **
	   6487 ** Summary: UNPUBLISHED - read data from an RGT file ( rgt's are bottom up )
	   6488 ** RGT is RGBA in memory (low byte to high byte), or ABGR in a register
	   6489 */
	   6490 FxBool _imgReadRGTData( FILE *stream, const RgtInfo *info, ImgData *data )
      1	   6491 {
      1	   6492 	FxU32 scanlineSize = info->width * 4;
      1	   6493 	FxU32 x,y;
      1	   6494     
      2	   6495     if ( stream == NULL ) {
      2	   6496 		imgErrorString = "Bad file handle.";
      2	   6497 		return FXFALSE;
      1	   6498     }
      1	   6499 
      2	   6500 	if ( info->ncc != 0 ) {	
      2	   6501 		imgErrorString = "Compressed RGT's not yet supported.";

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   6502 		return FXFALSE;
      1	   6503 	}
      1	   6504 
      1	   6505 	// load rgt, rgt's are bottom up
      2	   6506 	for ( y = 0; y < info->height; y++ ) {
      2	   6507 		ImgData *scanlineBuffer = data + scanlineSize * ( (info->height-1) - y );
      3	   6508 		if ( fread( scanlineBuffer, 1, scanlineSize, stream ) != scanlineSize )	{
      3	   6509 			imgErrorString = "Unexpected end of file.";
      3	   6510 			return FXFALSE;
      2	   6511 		}
      1	   6512 	}
      1	   6513 
      2	   6514 	if ( info->rgb ) {
      2	   6515 		fprintf(stderr," (RGB->BGR)"); fflush(stderr);
      3	   6516 		for ( y = 0; y < info->height; y++ ) {
      4	   6517 			for ( x = 0; x < info->width; x++ ) {
      4	   6518 				ImgData swap;
      4	   6519 				swap = data[2];
      4	   6520 				data[2] = data[0];
      4	   6521 				data[0] = swap;
      4	   6522 				data += 4;
      3	   6523 			}
      2	   6524 		}
      2	   6525 
      1	   6526 	}
      1	   6527 
      1	   6528     return FXTRUE;
      1	   6529 }
	   6530 
	   6531 /* _imgReadSbiData
	   6532 **
	   6533 ** Summary: UNPUBLISHED - read data from an SBI file
	   6534 */
	   6535 FxBool _imgReadSbiData( FILE *stream, const SbiInfo *info, ImgData *data )
      1	   6536 {
      1	   6537     FxI32 y, y0, y1, dy;
      1	   6538     FxU32 x;
      1	   6539     FxU32 rShift, gShift, bShift, rMask, gMask, bMask;
      1	   6540 	FxU32 rRightShift, rLeftShift;
      1	   6541 	FxU32 gRightShift, gLeftShift;
      1	   6542 	FxU32 bRightShift, bLeftShift;
      1	   6543 	FxU32 scanlineWidth;
      1	   6544 	ImgData *baseOfData;
      1	   6545     
      1	   6546     if ( stream == NULL )
      2	   6547     {
      2	   6548 		imgErrorString = "Bad file handle.";
      2	   6549 		return FXFALSE;
      1	   6550     }
      1	   6551     
      1	   6552     bShift = 0;
      1	   6553     gShift = info->blueBits;
      1	   6554     rShift = gShift + info->greenBits;
      1	   6555 
      1	   6556     rMask = (FxU32) ~0;
      1	   6557     rMask >>= sizeof( FxU32 ) * 8 - info->redBits;
      1	   6558 	rLeftShift = 8 - info->redBits;

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   6559 	rRightShift = info->redBits - rLeftShift;
      1	   6560     
      1	   6561     gMask = (FxU32) ~0;
      1	   6562     gMask >>= sizeof( FxU32 ) * 8 - info->greenBits;
      1	   6563 	gLeftShift = 8 - info->greenBits;
      1	   6564 	gRightShift = info->greenBits - gLeftShift;
      1	   6565     
      1	   6566     bMask = (FxU32) ~0;
      1	   6567     bMask >>= sizeof( FxU32 ) * 8 - info->blueBits;
      1	   6568 	bLeftShift = 8 - info->blueBits;
      1	   6569 	bRightShift = info->blueBits - bLeftShift;
      1	   6570 
      1	   6571 	scanlineWidth = info->width * 4;
      1	   6572 	baseOfData = data;
      1	   6573 
      1	   6574     if ( info->yOrigin == 0 )
      2	   6575     {
      2	   6576 		y0 = info->height - 1;
      2	   6577 		y1 = -1;
      2	   6578 		dy = -1;
      1	   6579     }
      1	   6580     else
      2	   6581     {
      2	   6582 		y0 = 0;
      2	   6583 		y1 = info->height;
      2	   6584 		dy = 1;
      1	   6585     }
      1	   6586     
      1	   6587     for( y = y0; y != y1; y += dy )
      2	   6588     {
      2	   6589 		//point data at apropriate scanline
      2	   6590 		data = baseOfData + y * scanlineWidth;
      2	   6591 
      2	   6592 		for ( x = 0; x < info->width; x++ )
      3	   6593 		{
      3	   6594 	    	int r, g, b;
      3	   6595 	    	int inchar;
      3	   6596 	    	FxU32 color;
      3	   6597 	    
      3	   6598 	    	color = getc( stream );
      3	   6599 	    	if ( (inchar = getc( stream ))==EOF )
      4	   6600 	    	{
      4	   6601 				imgErrorString = "Unexpected end of file.";
      4	   6602 				return FXFALSE;
      3	   6603 	    	}
      3	   6604 	    	color |= (inchar << 8);
      3	   6605 	    
      3	   6606 	    	// Get sig bits
      3	   6607 	    	r = (color >> rShift ) & rMask;
      3	   6608 	    	g = (color >> gShift ) & gMask;
      3	   6609 	    	b = (color >> bShift ) & bMask;
      3	   6610 	    
      3	   6611 	    	// Expand to 8 bits/color
      3	   6612 			// Current implementation is only meaningful if 
      3	   6613 			// using more than 4Bits/Channel color precision.....
      3	   6614 			// Needs to be fixed, but this is much, much faster....
      3	   6615 	    	*data++ = _imgMSBReplicate( b, bLeftShift, bRightShift );

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   6616 	    	*data++ = _imgMSBReplicate( g, gLeftShift, gRightShift );
      3	   6617 	    	*data++ = _imgMSBReplicate( r, rLeftShift, rRightShift );
      3	   6618 	    	data++; // Blank A
      2	   6619 		}
      1	   6620     }
      1	   6621     return FXTRUE;
      1	   6622 }
	   6623 
	   6624 /* _imgReadP6Data
	   6625 **
	   6626 ** Summary: UNPUBLISHED - read data from a PPM
	   6627 ** PPM is RGB
	   6628 ** Memory format is B - G - R - A
	   6629 */
	   6630 FxBool _imgReadP6Data( FILE *stream, const P6Info *info, ImgData *data )
      1	   6631 {
      1	   6632     FxU32 numPixels;
      1	   6633     
      1	   6634     numPixels = info->width * info->height;
      1	   6635 
      1	   6636     if ( stream == NULL )
      2	   6637     {
      2	   6638 		imgErrorString = "Bad file handle.";
      2	   6639 		return FXFALSE;
      1	   6640     }
      1	   6641     
      1	   6642 	// Read in image data
      1	   6643     for( ;numPixels;numPixels-- )
      2	   6644     {
      2	   6645 		int r, g, b;
      2	   6646 		r = getc( stream );
      2	   6647 		g = getc( stream );
      2	   6648 		b = getc( stream );
      2	   6649 		if ( b == EOF )
      3	   6650 		{
      3	   6651 	    	imgErrorString = "Unexpected end of file.";
      3	   6652 	    	return FXFALSE;
      2	   6653 		}
      2	   6654 		*data++ = (ImgData)b;
      2	   6655 		*data++ = (ImgData)g;
      2	   6656 		*data++ = (ImgData)r;
      2	   6657 		data++; // A
      1	   6658     }
      1	   6659 
      1	   6660     return FXTRUE;
      1	   6661 }
	   6662 
	   6663 /* _imgReadSRLEHeader
	   6664 **
	   6665 ** Summary: UNPUBLISHED - read header and fill in header info
	   6666 ** The simple rle format is intended for glide test programs image comparison
	   6667 ** The file format is as follows:
	   6668 ** 4 bytes file signature
	   6669 ** 2 bytes image width
	   6670 ** 2 bytes image height
	   6671 ** 1 byte  image depth
	   6672 ** 1 byte  compression method (1 for rle compression)

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	   6673 ** image data
	   6674 **
	   6675 ** The image data started with a control byte and followed by pixel data
	   6676 ** Each control byte has two parts. Bit 7 (msb) equals to 1 indicates a run,
	   6677 ** 0 indicates a literal string. Bit 6 - 0 id the counter. It is zero based.
	   6678 */
	   6679 FxBool _imgReadSRLEHeader( FILE *stream,  SrleInfo *info )
      1	   6680 {
      1	   6681     FxU16 tmp16;
      1	   6682     FxU8  tmp8;
      1	   6683     
      1	   6684     if ( stream == NULL )
      2	   6685     {
      2	   6686       imgErrorString = "Bad file handle.";
      2	   6687       return FXFALSE;
      1	   6688     }
      1	   6689     
      1	   6690     fread(&tmp16, sizeof(FxU16), 1, stream);
      1	   6691     info->width = tmp16;
      1	   6692     fread(&tmp16, sizeof(FxU16), 1, stream);
      1	   6693     info->height = tmp16;
      1	   6694     fread(&tmp8, sizeof(FxU8), 1, stream);
      1	   6695     info->pixelsize = tmp8 / 8;
      1	   6696     fread(&tmp8 , sizeof(FxU8), 1, stream);
      1	   6697     info->c_type = tmp8;
      1	   6698     
      1	   6699     info->sizeInBytes = info->width * info->height * 4;
      1	   6700     
      1	   6701     return FXTRUE;
      1	   6702 }
	   6703 
	   6704 /* _imgReadSRLE
	   6705 **
	   6706 ** Summary: UNPUBLISHED - read data from a simple rle format
	   6707 */
	   6708 FxBool _imgReadSRLEData( FILE *stream, const SrleInfo *info, ImgData *data )
      1	   6709 {
      1	   6710     int   numPixels;
      1	   6711     FxU16 color;
      1	   6712     FxU8  r = 0, g = 0, b = 0, a = 0;
      1	   6713     FxU8  ctl, repeat, run;
      1	   6714     FxBool flag;
      1	   6715     
      1	   6716     numPixels = info->width * info->height;
      1	   6717 
      1	   6718     if ( stream == NULL )
      2	   6719     {
      2	   6720       imgErrorString = "Bad file handle.";
      2	   6721       return FXFALSE;
      1	   6722     }
      1	   6723 
      2	   6724     while (numPixels) {
      2	   6725       ctl = getc( stream );
      2	   6726       flag = ctl & 0x80;
      2	   6727       run = repeat = (ctl & 0x7f) + 1;
      2	   6728       numPixels -= repeat;
      3	   6729       while (repeat) {

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 26
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      3	   6730 	switch (info->pixelsize) 
      4	   6731 	  {
      4	   6732 	  case 2:
      4	   6733 	    if (((flag) && (repeat == run)) || (!flag))
      4	   6734 	      fread(&color,2,1,stream);
      4	   6735 	    r = ( color >> 11 ) & 0x1F;
      4	   6736 	    g = ( color >> 5 ) &  0x3F;
      4	   6737 	    b = ( color >> 0 ) &  0x1F;
      4	   6738 
      4	   6739 	    *data++ = _imgMSBReplicate( b, 3, 2 );
      4	   6740 	    *data++ = _imgMSBReplicate( g, 2, 4);
      4	   6741 	    *data++ = _imgMSBReplicate( r, 3, 2);
      4	   6742 	    *data++ = 0x0;
      4	   6743 	    break;
      4	   6744 	  case 4:
      5	   6745 	    if (((flag) && (repeat == run)) || (!flag)) {
      5	   6746 	      a = getc( stream );
      5	   6747 	      r = getc( stream );
      5	   6748 	      g = getc( stream );
      5	   6749 	      b = getc( stream );
      4	   6750 	    }
      4	   6751 	    *data++ = b;
      4	   6752 	    *data++ = g;
      4	   6753 	    *data++ = r;
      4	   6754 	    *data++ = a;
      4	   6755 	    break;
      3	   6756 	  }
      3	   6757 	repeat--;
      2	   6758       }
      2	   6759       if (numPixels < 0)
      2	   6760 	return FXFALSE;
      1	   6761     }
      1	   6762     return FXTRUE;
      1	   6763 }
	   6764 
	   6765 /* _imgWriteP6Header
	   6766 **
	   6767 ** Summary: UNPUBLISHED - write out formatted header for a P6
	   6768 */
	   6769 FxBool _imgWriteP6Header( FILE *stream, const P6Info *info )
      1	   6770 {
      1	   6771 	imgErrorString = "Image write error.";
      1	   6772 	if ( 0 > fprintf( stream, "P6\n" ) ) return FXFALSE;
      1	   6773 	if ( 0 > fprintf( stream, "# PPM Comment\n" ) ) return FXFALSE;
      1	   6774 	if ( 0 > fprintf( stream, "%u ", info->width ) ) return FXFALSE;
      1	   6775 	if ( 0 > fprintf( stream, "%u\n", info->height ) ) return FXFALSE;
      1	   6776 	if ( 0 > fprintf( stream, "255\n" ) ) return FXFALSE;
      1	   6777 	imgErrorString = "No error.";
      1	   6778 	return FXTRUE;
      1	   6779 }
	   6780 
	   6781 /* _imgWriteSbiHeader
	   6782 **
	   6783 ** Summary: UNPUBLISHED - write out formatted header for an SBI
	   6784 */
	   6785 FxBool _imgWriteSbiHeader( FILE *stream, const SbiInfo *info )
      1	   6786 {

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 27
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   6787 	imgErrorString = "Image write error.";
      1	   6788 	if ( 0 > fprintf( stream, "P9\n" ) ) return FXFALSE;
      1	   6789 	if ( 0 > !fprintf( stream, "Y%c\n", info->yOrigin? '+' : '-' ) ) return FXFALSE;
      1	   6790 	if ( 0 > !fprintf( stream, "%u ", info->width ) ) return FXFALSE;
      1	   6791 	if ( 0 > !fprintf( stream, "%u\n", info->height ) ) return FXFALSE;
      1	   6792 	if ( 0 > !fprintf( stream, "R %u ", info->redBits ) ) return FXFALSE;
      1	   6793 	if ( 0 > !fprintf( stream, "G %u ", info->greenBits ) ) return FXFALSE;
      1	   6794 	if ( 0 > !fprintf( stream, "B %u\n", info->blueBits ) ) return FXFALSE;
      1	   6795 	imgErrorString = "No Error.";
      1	   6796 	return FXTRUE;
      1	   6797 }
	   6798 
	   6799 /* _imgWriteP6Data
	   6800 **
	   6801 ** Summary: UNPUBLISHED - write P6 image data
	   6802 */
	   6803 FxBool _imgWriteP6Data( FILE *stream, const P6Info *info, const ImgData *data )
      1	   6804 {
      1	   6805 	FxU32 dataSize = info->width * info->height * 4;
      1	   6806 	const ImgData *dataEnd  = data + dataSize;
      1	   6807 
      1	   6808 	while( data < dataEnd )
      2	   6809 	{
      2	   6810 		ImgData r, g, b;
      2	   6811 		b = *data++;
      2	   6812 		g = *data++;
      2	   6813 		r = *data++;
      2	   6814 		data++;
      2	   6815 
      2	   6816 		putc( r, stream );
      2	   6817 		putc( g, stream );
      2	   6818 		if ( putc( b, stream ) == EOF )
      3	   6819 		{
      3	   6820 			imgErrorString = "Image write error.";
      3	   6821 			return FXFALSE;
      2	   6822 		}
      1	   6823 	}
      1	   6824 	return FXTRUE;
      1	   6825 }
	   6826 
	   6827 /* _imgWriteSbiData
	   6828 **
	   6829 ** Summary: UNPUBLISHED - write sbi image data
	   6830 */
	   6831 FxBool _imgWriteSbiData( FILE *stream, const SbiInfo *info, const ImgData *data )
      1	   6832 {
      1	   6833 	// convert each pixel, then write it out as two byte-writes
      1	   6834 	FxU32 x;
      1	   6835 	FxU32 y;
      1	   6836 	FxU32 sbiPixel;
      1	   6837 
      1	   6838 	FxI32 scanlineIncrement;
      1	   6839 
      1	   6840 	if ( info->yOrigin == 0 ) // Lower
      2	   6841 	{
      2	   6842 		scanlineIncrement = (4 * (-(long)info->width)) + 1;
      2	   6843 		// point at beginning of last SL

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 28
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   6844 		data = data + (( info->height - 2 ) * info->width * 4);
      1	   6845 	}
      1	   6846 	else // upper
      2	   6847 	{
      2	   6848 		scanlineIncrement = 0;
      1	   6849 	}
      1	   6850 
      1	   6851 	imgErrorString = "Image write error.";
      1	   6852 	for( y = 0; y < info->height; y++ )
      2	   6853 	{
      2	   6854 		for( x = 0; x < info->width; x++ )
      3	   6855 		{
      3	   6856 			FxU32 r, g, b;
      3	   6857 			b =  *data++ & 0xF8;
      3	   6858 			g =  *data++ & 0xFC;
      3	   6859 			r =  *data++ & 0xF8;
      3	   6860 			data++;
      3	   6861 			sbiPixel = (r << 8) | (g << 3) | (b >> 3);
      3	   6862 			
      3	   6863 			if ( putc( sbiPixel, stream ) == EOF ) return FXFALSE;
      3	   6864 			if ( putc( sbiPixel >> 8, stream ) == EOF ) return FXFALSE;
      2	   6865 		}
      2	   6866 		data += scanlineIncrement;
      1	   6867 	}
      1	   6868 	imgErrorString = "No error.";
      1	   6869 	return FXTRUE;
      1	   6870 }
	   6871 
	   6872 
	   6873 /* _imgWriteSbiDataWide
	   6874 **
	   6875 ** Summary: UNPUBLISHED - write sbi image data
	   6876 */
	   6877 FxBool _imgWriteSbiDataWide( FILE *stream, const SbiInfo *info, const ImgData *data, FxU32 slWidth )
      1	   6878 {
      1	   6879 	// convert each pixel, then write it out as two byte-writes
      1	   6880 	FxU32 x;
      1	   6881 	FxU32 y;
      1	   6882 	FxU32 sbiPixel;
      1	   6883 
      1	   6884 	FxI32 scanlineIncrement;
      1	   6885 
      1	   6886 	if ( info->yOrigin == 0 ) // Lower
      2	   6887 	{
      2	   6888 		scanlineIncrement = (4 * slWidth) + 1;
      2	   6889 		// point at beginning of last SL
      2	   6890 		data = data + (( info->height - 2 ) * info->width * 4);
      1	   6891 	}														
      1	   6891  
      1	   6892 	else // upper
      2	   6893 	{
      2	   6894 		scanlineIncrement = (slWidth * 4) - (4*info->width);
      1	   6895 	}
      1	   6896 
      1	   6897 	imgErrorString = "Image write error.";
      1	   6898 	for( y = 0; y < info->height; y++ )
      2	   6899 	{

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 29
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   6900 		for( x = 0; x < info->width; x++ )
      3	   6901 		{
      3	   6902 			FxU32 r, g, b;
      3	   6903 			b =  *data++ & 0xF8;
      3	   6904 			g =  *data++ & 0xFC;
      3	   6905 			r =  *data++ & 0xF8;
      3	   6906 			data++;
      3	   6907 
      3	   6908 			sbiPixel = (r << 8) | (g << 3) | (b >> 3);
      3	   6909 			
      3	   6910 			if ( putc( sbiPixel, stream ) == EOF ) return FXFALSE;
      3	   6911 			if ( putc( sbiPixel >> 8, stream ) == EOF ) return FXFALSE;
      2	   6912 		}
      2	   6913 		data += scanlineIncrement;
      1	   6914 	}
      1	   6915 	imgErrorString = "No error.";
      1	   6916 	return FXTRUE;
      1	   6917 }
	   6918 
	   6919 
	   6920 /*
	   6921 ** PUBLIC INTERFACE
	   6922 */
	   6923 
	   6924 /*
	   6925 ** PUBLIC DATA
	   6926 */
	   6927 
	   6928 const char *imgTypeString[] = 
	   6929 { 
	   6930 	"UNKNOWN", 
	   6931 	"SBI", 
	   6932 	"Binary PPM", 
	   6933 	"3DF", 
	   6934 	"RGT", 
	   6935 	"TGA32" 
	   6936 };
	   6937 
	   6938 const char *imgTxColorFormatNames[] =
	   6939 {
	   6940   "unknown",
	   6941   "true",
	   6942   "i8",
	   6943   "a8",
	   6944   "ai44",
	   6945   "yiq",
	   6946   "rgb332",
	   6947   "rgb565",
	   6948   "argb8332",
	   6949   "argb1555",
	   6950   "ayiq8422",
	   6951   "argb4444",
	   6952   "ai88",
	   6953   "argb8888"
	   6954 };
	   6955 
	   6956 

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 30
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	   6957 /* imgGetErrorString
	   6958 **
	   6959 ** Summary: Get a pointer to the buffer that contains a string describing
	   6960 **          the most recent error in the  Image Library
	   6961 **
	   6962 ** Returns: Point to an error description string.  Probably a bad idea to write
	   6963 **         to this address as it will likely be a static string.
	   6964 */
	   6965 const char *imgGetErrorString( void )
      1	   6966 {
      1	   6967     return imgErrorString;
      1	   6968 }
	   6969 
	   6970 /* imgReadInfo
	   6971 **
	   6972 ** Summary: Fill the Info union and return the proper image type
	   6973 **
	   6974 ** Parameters: info - pointer to an ImgInfo structure including type
	   6975 **             stream - pointer file stream
	   6976 **
	   6977 ** Returns: FXTRUE if header read in correctly.
	   6978 **          FXFALSE if header not read, error described
	   6979 **                  in string obtainable by sbiGetErrorString();
	   6980 */
	   6981 FxBool imgReadInfo( FILE *stream, ImgInfo *info )
      1	   6982 {
      1	   6983     if ( stream == NULL )
      2	   6984     {
      2	   6985 		imgErrorString = "Bad file handle.";
      2	   6986 		return FXFALSE;
      1	   6987     }
      1	   6988     
      1	   6989 	_fixStream( stream );
      1	   6990 	info->any.data = NULL;
      1	   6991 
      1	   6992     // Determine the Type of File and Fill The Appropriate Header Structure
      1	   6993     if ( _imgGuessType( stream, &info->any.type ) == FXFALSE ) return FXFALSE;
      1	   6994 
      1	   6995     switch( info->any.type )
      2	   6996     {
      2	   6997     	case IMG_SBI:
      2	   6998 			return _imgReadSbiHeader( stream, &(info->sbiInfo) );
      2	   6999       	case IMG_RGT:
      2	   7000 			return _imgReadRGTHeader( stream, &(info->rgtInfo) );
      2	   7001       	case IMG_TGA32:
      2	   7002 			return _imgReadTGAHeader( stream, &(info->tgaInfo) );
      2	   7003     	case IMG_P6:
      2	   7004 			return _imgReadP6Header( stream, &(info->p6Info) );
      2	   7005       	case IMG_3DF:
      2	   7006 			return _imgRead3DFHeader( stream, &(info->tdfInfo) );
      2	   7007       	case IMG_SRLE:
      2	   7008 			return _imgReadSRLEHeader( stream, &(info->srleInfo) );
      2	   7009       	case IMG_UNKNOWN:
      2	   7010       	default:
      2	   7011 			imgErrorString = "Unknown image file format.";
      2	   7012 			break;
      1	   7013     }

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 31
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   7014 	return FXFALSE;
      1	   7015 }
	   7016 
	   7017 /* imgReadData
	   7018 **
	   7019 ** Summary: Read all of the image data from an image stream given
	   7020 **          that the header has already been read by imgReadInfo.
	   7021 **
	   7022 ** Parameters: stream - a readable file stream
	   7023 **             info - pointer to filled info structure (except data)
	   7024 **					- if data is NULL then we malloc data large enough
	   7025 ** Returns: FXTRUE if data was read successfully
	   7026 **          FXFALSE if an error occured, reason may be
	   7027 **          obtained with imgGetErrorString().
	   7028 */
	   7029 FxBool imgReadData( FILE *stream, ImgInfo *info )
      1	   7030 {
      1	   7031     if ( stream == NULL )
      2	   7032     {
      2	   7033 		imgErrorString = "Bad file handle.";
      2	   7034 		return FXFALSE;
      1	   7035     }
      1	   7036     
      1	   7037 	_fixStream( stream );
      1	   7038 
      1	   7039 	// if data pointer is NULL then malloc something big enough
      2	   7040     if ( info->any.data == NULL ) {
      2	   7041 		info->any.data = (ImgData*) malloc( info->any.sizeInBytes );
      3	   7042 	    if ( info->any.data == NULL ) {
      3	   7043 			imgErrorString = "Malloc failed.";
      3	   7044 			return FXFALSE;
      2	   7045 		}
      1	   7046     }
      1	   7047 
      1	   7048     switch( info->any.type )
      2	   7049     {
      2	   7050     	case IMG_TGA32:
      2	   7051 			return _imgReadTGAData( stream, &(info->tgaInfo), info->any.data );
      2	   7052     	case IMG_RGT:
      2	   7053 			return _imgReadRGTData( stream, &(info->rgtInfo), info->any.data );
      2	   7054     	case IMG_3DF:
      2	   7055 			return _imgRead3DFData( stream, &(info->tdfInfo), info->any.data );
      2	   7056     	case IMG_SBI:
      2	   7057 			return _imgReadSbiData( stream, &(info->sbiInfo), info->any.data );
      2	   7058     	case IMG_P6:
      2	   7059 			return _imgReadP6Data( stream, &(info->p6Info), info->any.data );
      2	   7060     	case IMG_SRLE:
      2	   7061 			return _imgReadSRLEData( stream, &(info->srleInfo), info->any.data );
      2	   7062     	case IMG_UNKNOWN:
      2	   7063       default:
      2	   7064 		imgErrorString = "Unknown file type.";
      2	   7065       break;
      1	   7066     }
      1	   7067 	return FXFALSE;
      1	   7068 }
	   7069 
	   7070 /* imgWriteImage

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 32
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

	   7071 **
	   7072 ** Summary: Write out an image file in the format specified by *type.
	   7073 **
	   7074 ** Parameters: stream - a writeable file stream
	   7075 ** 		       info - pointer to initialized image info struct appropriate
	   7076 **                       to type described in *type
	   7077 ** 		       type - desired image type to write
	   7078 ** 		       data - pointer to 32BPP xRGB data in linear memory storage
	   7079 **
	   7080 ** Returns: FXTRUE if data was written sucessfully
	   7081 **          FXFALSE if an error occured, reason may be
	   7082 **          obtained with imgGetErrorString().
	   7083 */
	   7084 
	   7085 
	   7086 FxBool imgWriteImage( FILE *stream, const ImgInfo *info, const ImgType type, const ImgData *data )
      1	   7087 {
      1	   7088 	// Try to catch obvious bugs.
      1	   7089 	if ( stream == NULL )
      2	   7090 	{
      2	   7091 		imgErrorString = "Bad file handle.";
      2	   7092 		return FXFALSE;
      1	   7093 	}
      1	   7094 
      1	   7095 	_fixStream( stream );
      1	   7096 
      1	   7097 	if ( data == NULL )
      2	   7098 	{
      2	   7099 		imgErrorString = "Bad data pointer.";
      2	   7100 		return FXFALSE;
      1	   7101 	}
      1	   7102 
      1	   7103 	switch( type )
      2	   7104 	{
      2	   7105 		case IMG_SBI:
      2	   7106 			if ( !_imgWriteSbiHeader( stream, &(info->sbiInfo) ) )
      3	   7107 			{
      3	   7108 				imgErrorString = "Couldn't write SBI info.";
      3	   7109 				return FXFALSE;
      2	   7110 			}
      2	   7111 			return _imgWriteSbiData( stream, &(info->sbiInfo), data );
      2	   7112 		case IMG_P6:
      2	   7113 			if ( !_imgWriteP6Header( stream, &(info->p6Info)) )
      3	   7114 			{
      3	   7115 				imgErrorString = "Couldn't write P6 info.";
      3	   7116 				return FXFALSE;
      2	   7117 			}
      2	   7118 			return _imgWriteP6Data( stream, &(info->p6Info), data );
      2	   7119 		case IMG_RGT:
      2	   7120 			imgErrorString = "RGT writes unimplemented.";
      2	   7121 			break;
      2	   7122 		case IMG_TGA32:
      2	   7123 			if ( !_imgWriteTGAHeader( stream, &(info->tgaInfo)) )
      3	   7124 			{
      3	   7125 				imgErrorString = "Couldn't write tga info.";
      3	   7126 				return FXFALSE;
      2	   7127 			}

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 33
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   7128 			return _imgWriteTGAData( stream, &(info->tgaInfo), data );
      2	   7129 			break;
      2	   7130 		case IMG_UNKNOWN:
      2	   7131 		default:
      2	   7132 			imgErrorString = "Can't write unknown format.";
      2	   7133 			break;
      1	   7134 	}
      1	   7135 	
      1	   7136 	return FXFALSE;
      1	   7137 }
	   7138 
	   7139 /* imgWriteImageFromWideBuffer
	   7140 **
	   7141 ** Summary: Write out an image file in the format specified by *type give a pointer
	   7142 **          to an oversized buffer and a scanline width.  This is in here strictly for
	   7143 **          the c-simulator, and isn't published in the header file.
	   7144 **
	   7145 ** Parameters: stream - a writeable file stream
	   7146 ** 		       type - pointer to image desired image type to write
	   7147 ** 		       info - pointer to initialized image info struct appropriate
	   7148 **                       to type described in *type
	   7149 ** 		       data - pointer to 32BPP xRGB data in linear memory storage
	   7150 **             scanlineWidth - width of scanline in long-words.
	   7151 **
	   7152 ** Returns: FXTRUE if data was written sucessfully
	   7153 **          FXFALSE if an error occured, reason may be
	   7154 **          obtained with imgGetErrorString().
	   7155 */
	   7156 
	   7157 
	   7158 FxBool imgWriteImageFromWideBuffer( FILE *stream, const ImgInfo *info, 
	   7159 									const ImgData *data, FxU32 scanlineWidth )
      1	   7160 {
      1	   7161 	// Try to catch obvious bugs.
      1	   7162 	if ( stream == NULL )
      2	   7163 	{
      2	   7164 		imgErrorString = "Bad file handle.";
      2	   7165 		return FXFALSE;
      1	   7166 	}
      1	   7167 
      1	   7168 	_fixStream( stream );
      1	   7169 
      1	   7170 	if ( data == NULL )
      2	   7171 	{
      2	   7172 		imgErrorString = "Bad data pointer.";
      2	   7173 		return FXFALSE;
      1	   7174 	}
      1	   7175 
      1	   7176 	if ( scanlineWidth < info->any.width )
      2	   7177 	{
      2	   7178 		imgErrorString = "Output buffer is too small.";
      2	   7179 		return FXFALSE;
      1	   7180 	}
      1	   7181 
      1	   7182 	switch( info->any.type )
      2	   7183 	{
      2	   7184 		case IMG_SBI:

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 34
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      2	   7185 			if ( !_imgWriteSbiHeader( stream, &(info->sbiInfo) ) )
      3	   7186 			{
      3	   7187 				imgErrorString = "Couldn't write SBI info.";
      3	   7188 				return FXFALSE;
      2	   7189 			}
      2	   7190 			return _imgWriteSbiDataWide( stream, &(info->sbiInfo), data, scanlineWidth );
      2	   7191 		case IMG_P6:
      2	   7192 			imgErrorString = "P6 writes unimplemented.";
      2	   7193 			break;
      2	   7194 		case IMG_RGT:
      2	   7195 			imgErrorString = "RGT writes unimplemented.";
      2	   7196 			break;
      2	   7197 		case IMG_TGA32:
      2	   7198 			imgErrorString = "TGA32 writes unimplemented.";
      2	   7199 			break;
      2	   7200 		case IMG_UNKNOWN:
      2	   7201 		default:
      2	   7202 			imgErrorString = "Can't write unknown format.";
      2	   7203 			break;
      1	   7204 	}
      1	   7205 	
      1	   7206 	return FXFALSE;
      1	   7207 }
	   7208 
	   7209 // returns a 3-letter abbreviation for the image type
	   7210 const char *imgTypeName( const ImgInfo *info )
      1	   7211 {
      2	   7212 	switch( info->any.type ) {
      2	   7213 	    case IMG_UNKNOWN:	return "???";
      2	   7214 	    case IMG_P6:		return "ppm";
      2	   7215 	    case IMG_SBI:		return "sbi";
      2	   7216 	    case IMG_3DF:		return "3df";
      2	   7217 	    case IMG_TGA32:		return "tga";
      2	   7218 	    case IMG_SRLE:		return "srle";
      2	   7219 	    case IMG_RGT:
      2	   7220 	       	if (info->rgtInfo.rle) return "rle";
      2	   7221 	    	if (info->rgtInfo.bgr) return "bgr";
      2	   7222 	    	if (info->rgtInfo.rgb) return "rgb";
      2	   7223 	    	if (info->rgtInfo.ncc) return "ncc";
      2	   7224 
      2	   7225 		default:			return "ERR";
      1	   7226     }
      1	   7227 }
	   7228 
	   7229 //----------------------------------------------------------------------
	   7230 // high level routine: reads an image file thru a search path
	   7231 // exits upon failure, prints out trace messages
	   7232 //----------------------------------------------------------------------
	   7233 FxBool imgReadFile(const char *filename, ImgInfo *info)
      1	   7234 {
      1	   7235 	const char *prefix;
      1	   7236 	FILE *file;
      1	   7237 
      1	   7238 	file = fxFopenPath(filename,READ_ATTRIBS, getenv(IMAGE_PATH), &prefix);
      2	   7239 	if (file == NULL) {
      2	   7240 		fprintf(stderr,"Error: can't open input file %s\n",filename);
      2	   7241 		exit(2);

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 35
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

      1	   7242 	}
      2	   7243 	if ( imgReadInfo( file, info ) == FXFALSE ) {
      2	   7244 		fprintf(stderr,"Error: reading info for %s, %s\n",filename,imgGetErrorString());
      2	   7245 		exit(2);
      1	   7246 	}
      1	   7247 	fprintf(stderr,"Loading %s image file ", imgTypeName(info));
      2	   7248 	if (prefix) {					// if there's a path prefix
      2	   7249 	    char buf[1024], *p;
      2	   7250 	    strcpy(buf,prefix);			// copy and replace semicolon
      2	   7251 	    if ((p = strchr(buf,';')) != NULL) *p = '\0';
      2	   7252 	    fprintf(stderr,buf);
      2	   7253 	    fprintf(stderr,"/");
      1	   7254 	}
      1	   7255 	fprintf (stderr,"%s (%ux%u) ...", filename, info->any.width,info->any.height);
      1	   7256 	fflush(stderr);
      1	   7257 
      2	   7258 	if ( imgReadData( file, info ) == FXFALSE ) {
      2	   7259 		fprintf(stderr, "\nError: reading data for %s, %s\n",filename,imgGetErrorString());
      2	   7260 		exit(4);
      1	   7261 	}
      1	   7262 	fclose(file);
      1	   7263 	fprintf(stderr," done.\n");
      1	   7264 	fflush(stderr);
      1	   7265 	return FXTRUE;
      1	   7266 }
	   7267 
	   7268 //----------------------------------------------------------------------
	   7269 // high level routine: writes an image file
	   7270 // exits upon failure, prints out trace messages
	   7271 //----------------------------------------------------------------------
	   7272 FxBool imgWriteFile(const char *filename, const ImgInfo *info, const ImgType type, const ImgData *data)
      1	   7273 {
      1	   7274     FxBool retval;
      1	   7275     ImgInfo tempInfo = *info;		// make a local copy
      1	   7276     FILE *file;
      1	   7277 
      1	   7278     file = fopen(filename,WRITE_ATTRIBS);
      2	   7279     if (file == NULL) {
      2	   7280 	fprintf(stderr,"Error: can't open output file %s\n",filename);
      2	   7281 	exit(2);
      1	   7282     }
      1	   7283     tempInfo.any.type = type;		// set the new type
      1	   7284     fprintf(stderr,"Storing %s image file %s (%ux%u) ...",
      1	   7285 		imgTypeName(&tempInfo), filename, info->any.width,info->any.height);
      1	   7286     fflush(stderr);
      1	   7287 
      1	   7288     retval = imgWriteImage( file, info, type, data );
      1	   7289     fclose(file);
      1	   7290     fprintf(stderr,retval ? " done.\n" : " aborted.\n");
      1	   7291     fflush(stderr);
      1	   7292     return retval;
      1	   7293 }

FXIMG                           Source Listing                   9-MAY-2021 23:43:26  VSI C V7.4-002-50R2O              Page 36
V1.0                                                             2-FEB-2021 02:11:10  fximg.c;1

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.SWLIBS.FXMISC]FXIMG/OBJECT=[.OUT.DEBUG
.OBJ.GLIDE.SWLIBS.FXMISC]FXIMG.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC],[.
GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CVG.IN
IT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_HW_TR
I_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE.SWL
IBS.FXMISC]FXIMG.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:26"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


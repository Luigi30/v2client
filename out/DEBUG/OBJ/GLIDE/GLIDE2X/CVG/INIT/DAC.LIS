DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Initialization code for initializing supported SST-1 DACs
	     21 **
	     22 */
	     23 
	     24 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
	     25 
       X     26 #ifdef _MSC_VER
       X     27 #pragma optimize ("",off)
       X     28 #endif
	     29 #include <stdio.h>
	   1640 #include <stdlib.h>
	   3735 #include <math.h>
       X   4627 #ifdef BUILD_FOR_SST1
       X   4628 #include <sst.h>
       X   4629 #else
	   4630 #include <3dfx.h>
	   4761 #include <cvgregs.h>
	   4989 #include <cvgdefs.h>
	   5930 #endif
	   5931 #define FX_DLL_DEFINITION
	   5932 #include <fxdll.h>
	   6053 #include <sst1vid.h>
	   6163 #include <sst1init.h>
	   8801 
	   8802 #include "canopus.h"
	   8842 
	   8843 /*
	   8844 ** sst1InitDacRd():
	   8845 **  Read external DAC registers
	   8846 **  NOTE: The video unit of FBI must be in reset before calling this routine.
	   8847 **        The rendering engines of FBI and TREX must be idle before calling 
	   8848 **        this routine.
	   8849 **        fbiInit23 register remapping (PCI config. initEnable[2]=1) must be
	   8850 **        enabled before calling this routine
	   8851 **
	   8852 **  Valid addresses are 0 <= addr <= 3
	   8853 **
	   8854 */

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   8855 FX_EXPORT FxU32 FX_CSTYLE sst1InitDacRd(FxU32 *sstbase, FxU32 addr)
      1	   8856 {
      1	   8857     SstRegs *sst = (SstRegs *) sstbase;
      1	   8858     FxU32 retVal;
      1	   8859     static FxBool firstPass = FXTRUE;
      1	   8860     static int helper;
      1	   8861 
      2	   8862     if(firstPass == FXTRUE) {
      2	   8863         firstPass = FXFALSE;
      2	   8864         helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   8865     }
      1	   8866 
      1	   8867     ISET(sst->dacData, ((addr) << SST_DACDATA_ADDR_SHIFT) | SST_DACDATA_RD);
      1	   8868     sst1InitIdleFBINoNOP(sstbase);
      1	   8869     retVal = IGET(sst->fbiInit2) & SST_DACDATA_DATA;
      1	   8870     if(helper)
      1	   8871         INIT_PRINTF(("dacRd(0x%x,0x%x)\n", addr, retVal));
      1	   8872 
      1	   8873     return(retVal);
      1	   8874 }
	   8875 
	   8876 /*
	   8877 ** sst1InitDacWr():
	   8878 **  Write to external DAC registers
	   8879 **  NOTE: The video unit of FBI must be in reset before calling this routine.
	   8880 **        The rendering engines of FBI and TREX must be idle before calling 
	   8881 **        this routine.
	   8882 **
	   8883 **  Valid addresses are 0 <= addr <= 3
	   8884 **
	   8885 */
	   8886 FX_EXPORT void FX_CSTYLE sst1InitDacWr(FxU32 *sstbase, FxU32 addr, FxU32 data)
      1	   8887 {
      1	   8888     SstRegs *sst = (SstRegs *) sstbase;
      1	   8889     static FxBool firstPass = FXTRUE;
      1	   8890     static int helper;
      1	   8891 
      2	   8892     if(firstPass == FXTRUE) {
      2	   8893         firstPass = FXFALSE;
      2	   8894         helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   8895     }
      1	   8896 
      1	   8897     ISET(sst->dacData,
      1	   8898         (data & SST_DACDATA_DATA) |
      1	   8899         ((addr) << SST_DACDATA_ADDR_SHIFT) |
      1	   8900         SST_DACDATA_WR);
      1	   8901     sst1InitIdleFBINoNOP(sstbase);
      1	   8902 
      1	   8903     if(helper)
      1	   8904         INIT_PRINTF(("dacWr(0x%x,0x%x)\n", addr, data));
      1	   8905 }
	   8906 
	   8907 /*
	   8908 ** sst1InitExecuteDacRdWr():
	   8909 **  Execute DAC read/write command sequence defined in "voodoo2.ini" file
	   8910 **
	   8911 */

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   8912 FxBool sst1InitExecuteDacRdWr(FxU32 *sstbase, sst1InitDacRdWrStruct
	   8913   *dacRdWrBase)
      1	   8914 {
      1	   8915     sst1InitDacRdWrStruct *dacRdWrPtr = dacRdWrBase;
      1	   8916     FxU32 data;
      1	   8917     FxBool retVal = FXTRUE;
      1	   8918     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   8919 
      2	   8920     while(dacRdWrPtr) {
      3	   8921         if(dacRdWrPtr->type == DACRDWR_TYPE_WR) {
      3	   8922             sst1InitDacWr(sstbase, dacRdWrPtr->addr, dacRdWrPtr->data);
      3	   8923         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDMODWR) {
      3	   8924             data = sst1InitDacRd(sstbase, dacRdWrPtr->addr);
      3	   8925             if(helper)
      3	   8926                 INIT_PRINTF(("dacRdWr(Read=0x%x)\n", data));
      3	   8927             data &= dacRdWrPtr->mask;
      3	   8928             sst1InitDacWr(sstbase, dacRdWrPtr->addr, (data | dacRdWrPtr->data));
      3	   8929         } else if(dacRdWrPtr->type == DACRDWR_TYPE_WRMOD_POP) {
      3	   8930             data = iniStack[--iniStackPtr];
      4	   8931             if(iniStackPtr < 0) {
      4	   8932                 retVal = FXFALSE;
      4	   8933                 break;
      3	   8934             }
      3	   8935             if(helper)
      3	   8936                 INIT_PRINTF(("dacWrModPop(Stack=0x%x,Mask=0x%x)\n", data,
      3	   8937                     dacRdWrPtr->mask));
      3	   8938             data &= dacRdWrPtr->mask;
      3	   8939             sst1InitDacWr(sstbase, dacRdWrPtr->addr, (data | dacRdWrPtr->data));
      3	   8940         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDNOCHECK) {
      3	   8941             sst1InitDacRd(sstbase, dacRdWrPtr->addr);
      3	   8942         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDPUSH) {
      3	   8943             data = sst1InitDacRd(sstbase, dacRdWrPtr->addr);
      3	   8944             iniStack[iniStackPtr++] = data;
      4	   8945             if(iniStackPtr == DACRDWR_MAX_PUSH) {
      4	   8946                 retVal = FXFALSE;
      4	   8947                 break;
      3	   8948             }
      3	   8949         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDCHECK) {
      4	   8950             if(sst1InitDacRd(sstbase, dacRdWrPtr->addr) != dacRdWrPtr->data) {
      4	   8951                 retVal = FXFALSE;
      4	   8952                 break;
      3	   8953             }
      3	   8954         } else {
      3	   8955             retVal = FXFALSE;
      3	   8956             break;
      2	   8957         }
      2	   8958         dacRdWrPtr = dacRdWrPtr->nextRdWr;
      1	   8959     }
      1	   8960     return(retVal);
      1	   8961 }
	   8962 
	   8963 /*
	   8964 ** sst1InitDacDetect():
	   8965 **  Detect type of on-board DAC
	   8966 **  NOTE: sst1InitDacDetect() resets the PCI fifo and the graphics subsystem
	   8967 **   of FBI
	   8968 **

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   8969 */
	   8970 FX_EXPORT FxBool FX_CSTYLE sst1InitDacDetect(FxU32 * sstbase)
      1	   8971 {
      1	   8972     FxU32 n;
      1	   8973     FxU32 fbiInit1_save;
      1	   8974     FxU32 fbiInit2_save;
      1	   8975     SstRegs *sst = (SstRegs *) sstbase;
      1	   8976     FxBool retVal = FXFALSE;
      1	   8977     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   8978 
      1	   8979     if(!sst)
      1	   8980         return(FXFALSE);
      1	   8981 
      1	   8982     if(helper)
      1	   8983         INIT_PRINTF(("sst1InitDacDetect(): Entered...\n"));
      1	   8984   
      1	   8985     if (sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   8986         return (FXFALSE);
      1	   8987  
      1	   8988     /* check to see if we are a single board SLI slave, if
      1	   8989      * so we have no dac...
      1	   8990      */
      1	   8991     //if (sst1CurrentBoard->singleBrdSLISlave) {
      1	   8992     //    sst1CurrentBoard->fbiVideoDacType = SST_FBI_DACTYPE_PROXY;
      1	   8993     //    return FXTRUE;
      1	   8994     //}
      1	   8995 
      1	   8996     sst1InitIdleFBINoNOP(sstbase);
      1	   8997 
      1	   8998     /* Save init register states before overwriting them */
      1	   8999     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9000     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9001 
      1	   9002     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9003     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9004     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9005     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9006     sst1InitIdleFBINoNOP(sstbase);
      1	   9007 
      1	   9008     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9009     /* Disallow writes to pass through the PCI FIFO */
      1	   9010     PCICFG_WR(SST1_PCI_INIT_ENABLE, SST_INITWR_EN | SST_FBIINIT23_REMAP);
      1	   9011     sst1InitIdleFBINoNOP(sstbase);
      1	   9012 
      2	   9013     if(sst1InitUseVoodooFile == FXTRUE) {
      2	   9014         retVal = sst1InitDacDetectINI(sstbase);
      2	   9015     } else {
      2	   9016         if((retVal = sst1InitDacDetectICS(sstbase)) == FXTRUE)
      2	   9017             goto done;
      2	   9018         if((retVal = sst1InitDacDetectATT(sstbase)) == FXTRUE)
      2	   9019             goto done;
      2	   9020         retVal = sst1InitDacDetectTI(sstbase);
      1	   9021     }
      1	   9022 
      1	   9023 done:
      1	   9024     /* Disable fbiinit23 address remapping */
      1	   9025     PCICFG_WR(SST1_PCI_INIT_ENABLE, SST_INITWR_EN | SST_PCI_FIFOWR_EN);

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9026 
      1	   9027     /* Restore init register states */
      1	   9028     sst1InitIdleFBINoNOP(sstbase);
      1	   9029     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9030     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9031     sst1InitIdleFBINoNOP(sstbase);
      1	   9032     return(retVal);
      1	   9033 }
	   9034 
	   9035 /*
	   9036 ** sst1InitDacDetectINI():
	   9037 **  Detect DAC based on rules supplied in "voodoo2.ini"
	   9038 **
	   9039 */
	   9040 FxBool sst1InitDacDetectINI(FxU32 * sstbase)
      1	   9041 {
      1	   9042     sst1InitDacStruct *dacPtr;
      1	   9043     FxU32 j;
      1	   9044     FxBool retVal = FXFALSE;
      1	   9045 
      1	   9046     dacPtr = dacStructBase;
      2	   9047     while(dacPtr) {
      3	   9048         if(dacPtr->detect) {
      3	   9049             /* Loop multiple times, as some DACs go into never-never land... */
      4	   9050             for(j=0; j<100; j++) {
      4	   9051                 if((retVal = sst1InitExecuteDacRdWr(sstbase, dacPtr->detect))
      5	   9052                   == FXTRUE) {
      5	   9053                     iniDac = dacPtr;
      5	   9054                     break;
      4	   9055                 }
      3	   9056             }
      3	   9057             if(retVal == FXTRUE)
      3	   9058                 break;
      2	   9059         }
      2	   9060         dacPtr = dacPtr->nextDac;
      1	   9061     }
      1	   9062     return(retVal);
      1	   9063 }
	   9064 
	   9065 FxBool sst1InitDacDetectATT(FxU32 * sstbase)
      1	   9066 {
      1	   9067     FxU32 n, j, dacmir, dacdir;
      1	   9068     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9069 
      1	   9070     if(helper)
      1	   9071         INIT_PRINTF(("sst1InitDacDetectATT(): Entered...\n"));
      1	   9072 
      1	   9073     /* Detect ATT */
      1	   9074     /* Sometimes the DACs seem to go into never-never land, so */
      1	   9075     /* try and initialize the DAC multiple times */
      1	   9076     n = 0;
      2	   9077     while(1) {
      2	   9078         if(++n > 100)
      2	   9079             break;
      2	   9080 
      2	   9081         /* Must guarantee that no rendering is being performed */
      2	   9082         sst1InitIdleFBINoNOP(sstbase);

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      2	   9083 
      2	   9084         /* Reset current state of DAC command register 0 (CR0) via the read */
      2	   9085         /* mask register (RMR) */
      2	   9086         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	   9087         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 5 times */
      2	   9088         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9089         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9090         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9091         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* Returns contents of CR0 */
      2	   9092 
      2	   9093         /* Enable indexed programming by setting CR0[0] = 1 */
      2	   9094         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	   9095         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 4 times */
      2	   9096         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9097         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9098         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9099         sst1InitDacWr(sstbase, SST_DACREG_RMR,
      2	   9100             SST_DACREG_CR0_INDEXED_ADDRESSING | SST_DACREG_CR0_8BITDAC);
      2	   9101 
      2	   9102         /* NOW DAC IS IN INDEXED ADDRESS MODE... */
      2	   9103 
      2	   9104         /* Check the manufacturing ID */
      2	   9105         j = 0;
      2	   9106         DAC_INDEXWRADDR(SST_DACREG_INDEX_MIR);
      2	   9107         dacmir = DAC_INDEXRD();
      2	   9108         if(dacmir == SST_DACREG_INDEX_MIR_ATT_DEFAULT)
      2	   9109             j++;
      2	   9110         else
      2	   9111             continue;
      2	   9112 
      2	   9113         /* Check the device ID */
      2	   9114         DAC_INDEXWRADDR(SST_DACREG_INDEX_DIR);
      2	   9115         dacdir = DAC_INDEXRD();
      2	   9116         if(dacmir == SST_DACREG_INDEX_MIR_ATT_DEFAULT &&
      2	   9117            dacdir == SST_DACREG_INDEX_DIR_ATT_DEFAULT)
      2	   9118             j++;
      2	   9119         else
      2	   9120             continue;
      3	   9121         if(j == 2) {
      3	   9122             /* Found ATT DAC... */
      3	   9123             sst1CurrentBoard->fbiVideoDacType = SST_FBI_DACTYPE_ATT;
      3	   9124             sst1InitIdleFBINoNOP(sstbase);
      3	   9125             /* Disable indexed-mode addressing */
      3	   9126             sst1InitDacWr(sstbase, SST_DACREG_INDEXADDR, SST_DACREG_INDEX_CR0);
      3	   9127             sst1InitDacWr(sstbase, SST_DACREG_INDEXDATA,
      3	   9128                 sst1InitDacRd(sstbase, SST_DACREG_INDEXDATA) &
      3	   9129                 ~SST_DACREG_CR0_INDEXED_ADDRESSING);
      3	   9130            if(helper)
      3	   9131                INIT_PRINTF(("sst1InitDacDetectATT(): Exiting...\n"));
      3	   9132             return(FXTRUE);
      2	   9133         }
      1	   9134     }
      1	   9135     if(helper)
      1	   9136         INIT_PRINTF(("sst1InitDacDetectATT(): Exiting...\n"));
      1	   9137     return(FXFALSE);
      1	   9138 }
	   9139 

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   9140 FxBool sst1InitDacDetectTI(FxU32 * sstbase)
      1	   9141 {
      1	   9142     FxU32 n, j, dacmir, dacdir;
      1	   9143     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9144 
      1	   9145     if(helper)
      1	   9146         INIT_PRINTF(("sst1InitDacDetectTI(): Entered...\n"));
      1	   9147 
      1	   9148     /* Detect TI */
      1	   9149     /* Sometimes the DACs seem to go into never-never land, so */
      1	   9150     /* try and initialize the DAC multiple times */
      1	   9151     n = 0;
      2	   9152     while(1) {
      2	   9153         if(++n > 100)
      2	   9154             break;
      2	   9155 
      2	   9156         /* Must guarantee that no rendering is being performed */
      2	   9157         sst1InitIdleFBINoNOP(sstbase);
      2	   9158 
      2	   9159         /* Reset current state of DAC command register 0 (CR0) via the read */
      2	   9160         /* mask register (RMR) */
      2	   9161         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	   9162         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 5 times */
      2	   9163         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9164         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9165         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9166         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* Returns contents of CR0 */
      2	   9167 
      2	   9168         /* Enable indexed programming by setting CR0[0] = 1 */
      2	   9169         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	   9170         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 4 times */
      2	   9171         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9172         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9173         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	   9174         sst1InitDacWr(sstbase, SST_DACREG_RMR,
      2	   9175             SST_DACREG_CR0_INDEXED_ADDRESSING | SST_DACREG_CR0_8BITDAC);
      2	   9176 
      2	   9177         /* NOW DAC IS IN INDEXED ADDRESS MODE... */
      2	   9178 
      2	   9179         /* Check the manufacturing ID */
      2	   9180         j = 0;
      2	   9181         DAC_INDEXWRADDR(SST_DACREG_INDEX_MIR);
      2	   9182         dacmir = DAC_INDEXRD();
      2	   9183         if(dacmir == SST_DACREG_INDEX_MIR_TI_DEFAULT)
      2	   9184             j++;
      2	   9185         else
      2	   9186             continue;
      2	   9187 
      2	   9188         /* Check the device ID */
      2	   9189         DAC_INDEXWRADDR(SST_DACREG_INDEX_DIR);
      2	   9190         dacdir = DAC_INDEXRD();
      2	   9191         if(dacmir == SST_DACREG_INDEX_MIR_TI_DEFAULT &&
      2	   9192            dacdir == SST_DACREG_INDEX_DIR_TI_DEFAULT)
      2	   9193             j++;
      2	   9194         else
      2	   9195             continue;
      3	   9196         if(j == 2) {

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      3	   9197             /* Found TI DAC... */
      3	   9198             sst1CurrentBoard->fbiVideoDacType = SST_FBI_DACTYPE_TI;
      3	   9199             sst1InitIdleFBINoNOP(sstbase);
      3	   9200             /* Disable indexed-mode addressing */
      3	   9201             sst1InitDacWr(sstbase, SST_DACREG_INDEXADDR, SST_DACREG_INDEX_CR0);
      3	   9202             sst1InitDacWr(sstbase, SST_DACREG_INDEXDATA,
      3	   9203                 sst1InitDacRd(sstbase, SST_DACREG_INDEXDATA) &
      3	   9204                 ~SST_DACREG_CR0_INDEXED_ADDRESSING);
      3	   9205             if(helper)
      3	   9206                 INIT_PRINTF(("sst1InitDacDetectTI(): Exiting...\n"));
      3	   9207             return(FXTRUE);
      2	   9208         }
      1	   9209     }
      1	   9210     if(helper)
      1	   9211         INIT_PRINTF(("sst1InitDacDetectTI(): Exiting...\n"));
      1	   9212     return(FXFALSE);
      1	   9213 }
	   9214 
	   9215 FxBool sst1InitDacDetectICS(FxU32 * sstbase)
      1	   9216 {
      1	   9217     FxU32 n;
      1	   9218     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9219 
      1	   9220     if(helper)
      1	   9221         INIT_PRINTF(("sst1InitDacDetectICS(): Entered...\n"));
      1	   9222 
      1	   9223     /* Detect ICS... */
      1	   9224     /* Sometimes the DACs seem to go into never-never land, so */
      1	   9225     /* try and initialize the DAC multiple times */
      1	   9226     n = 0;
      2	   9227     while(1) {
      2	   9228         FxU32 gclk1, vclk1, vclk7;
      2	   9229 
      2	   9230         if(++n > 100)
      2	   9231             break;
      2	   9232         /* Must guarantee that no rendering is being performed */
      2	   9233         sst1InitIdleFBINoNOP(sstbase);
      2	   9234 
      2	   9235         sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_RD,
      2	   9236             SST_DACREG_ICS_PLLADDR_GCLK1);
      2	   9237         gclk1 = sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9238         sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9239         sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_RD,
      2	   9240             SST_DACREG_ICS_PLLADDR_VCLK1);
      2	   9241         vclk1 = sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9242         sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9243         sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_RD,
      2	   9244             SST_DACREG_ICS_PLLADDR_VCLK7);
      2	   9245         vclk7 = sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9246         sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      2	   9247         if((gclk1 == SST_DACREG_ICS_PLLADDR_GCLK1_DEFAULT) &&
      2	   9248            (vclk1 == SST_DACREG_ICS_PLLADDR_VCLK1_DEFAULT) &&
      3	   9249            (vclk7 == SST_DACREG_ICS_PLLADDR_VCLK7_DEFAULT)) {
      3	   9250             /* found ICS DAC... */
      3	   9251             sst1CurrentBoard->fbiVideoDacType = SST_FBI_DACTYPE_ICS;
      3	   9252             if(helper)
      3	   9253                 INIT_PRINTF(("sst1InitDacDetectICS(): Exiting...\n"));

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      3	   9254             return(FXTRUE);
      2	   9255         }
      1	   9256     }
      1	   9257 
      1	   9258 
      1	   9259     if(helper)
      1	   9260         INIT_PRINTF(("sst1InitDacDetectICS(): Exiting...\n"));
      1	   9261     return(FXFALSE);
      1	   9262 }
	   9263 
	   9264 /*
	   9265 ** sst1InitCalcGrxClk():
	   9266 **  Determine graphics clock frequency
	   9267 **  NOTE: sst1InitCalcGrxClk() must be called prior to sst1InitGrxClk()
	   9268 **
	   9269 */
	   9270 FX_EXPORT FxBool FX_CSTYLE sst1InitCalcGrxClk(FxU32 *sstbase)
      1	   9271 {
      1	   9272     FxU32 clkFreq;
      1	   9273     SstRegs *sst = (SstRegs *) sstbase;
      1	   9274 
      1	   9275     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9276         return(FXFALSE);
      1	   9277 
      2	   9278     if(GETENV(("SSTV2_GRXCLK"))) {
      2	   9279         INIT_PRINTF(("sst1InitCalcGrxClk(): Overriding default clk frequency with SST_GRXCLK\n"));
      2	   9280         clkFreq = ATOI(GETENV(("SSTV2_GRXCLK")));
      2	   9281         if(clkFreq < 16)
      2	   9282             clkFreq = 16;
      2	   9283     } else {
      2	   9284         if(sst1CurrentBoard->numberTmus == 1 &&
      2	   9285            sst1CurrentBoard->fbiMemSize == 2 &&
      2	   9286            sst1CurrentBoard->tmuMemSize[0] == 2)
      2	   9287               clkFreq = 83;
      2	   9288         else
      2	   9289            // clkFreq = 50 + (value of fb_data[63:58] latched during reset)
      2	   9290            clkFreq = 50 + ((IGET(sst->fbiInit7) >> 2) & 0x3f);
      1	   9291     }
      1	   9292     sst1CurrentBoard->fbiGrxClkFreq = clkFreq;
      1	   9293     sst1CurrentBoard->tmuGrxClkFreq = clkFreq;
      1	   9294     return(FXTRUE);
      1	   9295 }
	   9296 
	   9297 /*
	   9298 ** sst1InitGrxClk():
	   9299 **  Initialize FBI and TREX Memory clocks
	   9300 **  NOTE: sst1InitCalcGrxClk() must be called prior to sst1InitGrxClk()
	   9301 **  NOTE: sst1InitGrxClk() resets the PCI fifo and the graphics subsystem of FBI
	   9302 **
	   9303 */
	   9304 FX_EXPORT FxBool FX_CSTYLE sst1InitGrxClk(FxU32 *sstbase)
      1	   9305 {
      1	   9306     sst1ClkTimingStruct sstGrxClk;
      1	   9307 
      1	   9308     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9309         return(FXFALSE);
      1	   9310     if(sst1CurrentBoard->initGrxClkDone)

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9311         return(FXTRUE);
      1	   9312     sst1CurrentBoard->initGrxClkDone = 1;
      1	   9313 
      1	   9314     INIT_PRINTF(("sst1InitGrxClk(): Setting up %d MHz Graphics Clock...\n",
      1	   9315         sst1CurrentBoard->fbiGrxClkFreq));
      2	   9316     if(sst1CurrentBoard->sliDetected) {
      2	   9317         sst1CurrentBoard->fbiGrxClkFreq -= 5;
      2	   9318         sst1CurrentBoard->tmuGrxClkFreq -= 5;
      1	   9319     }
      1	   9320     if(sst1InitComputeClkParams((float) sst1CurrentBoard->fbiGrxClkFreq,
      1	   9321       &sstGrxClk) == FXFALSE)
      1	   9322         return(FXFALSE);
      1	   9323 
      1	   9324     return(sst1InitSetGrxClk(sstbase, &sstGrxClk));
      1	   9325 }
	   9326 
	   9327 /*
	   9328 ** sst1InitComputeClkParams():
	   9329 **  Compute PLL parameters for given clock frequency
	   9330 **
	   9331 */
	   9332 FX_EXPORT FxBool FX_CSTYLE 
	   9333 sst1InitComputeClkParams(float freq, sst1ClkTimingStruct* clkTiming)
      1	   9334 {
      1	   9335   /* If we're using a canopus board then we need to use the
      1	   9336    * integer-ized version of the clock parameter computation. This
      1	   9337    * only supports the att dac.
      1	   9338    * 
      1	   9339    * NB: The bits in fbiInit5 are only moderatly documented as being
      1	   9340    * the value of the power-on strapping bits. fbiInit5[8:5] is what
      1	   9341    * sst1GetFbiInfo uses to set the internal fbiBoardID, but the
      1	   9342    * canopus board currently does not seem to have these set to
      1	   9343    * anything while other boards (including the reference design)
      1	   9344    * return non-zero values.
      1	   9345    *
      1	   9346    * NB: There is also a possible race condition here in reading these
      1	   9347    * bits before the hw is actually reset. I don't think it could
      1	   9348    * happen, but the value could be whacky if the hw was in some
      1	   9349    * really horrible state when this is called to set the initial
      1	   9350    * clock to 16mhz before doing the rest of the reset.  
      1	   9351    */
      1	   9352   sst1CurrentBoard->fbiBoardID = ((IGET(sst1CurrentBoard->virtAddr[0]->fbiInit5) >> 0x05UL) & 0x0FUL);
      2	   9353   if (sst1CurrentBoard->fbiBoardID == CANOPUS_ID) {
      2	   9354     return sst1InitComputeClkParamsATT_Int((FFLOAT)(freq * CLOCK_MULTIPLIER), clkTiming);
      2	   9355   } else if(sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_TI) {
      2	   9356     return sst1InitComputeClkParamsTI(freq, clkTiming);
      2	   9357   } else if (sst1CurrentBoard->fbiVideoDacType == SST_FBI_DACTYPE_PROXY) {
      2	   9358     FxU32 i;
      2	   9359     FxBool retval = FXTRUE;
      2	   9360     sst1DeviceInfoStruct *saveBoard;
      2	   9361     
      2	   9362     /* if we are a single board SLI (proxy dac) we need to do all changes
      2	   9363      * to the master's dac, since it's also ours... 
      2	   9364      */
      3	   9365     for (i=0;i<boardsInSystem;i++) {
      4	   9366       if ((i > 0) && (&sst1BoardInfo[i] == sst1CurrentBoard)) {
      4	   9367         saveBoard = sst1CurrentBoard;

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      4	   9368         sst1CurrentBoard = &sst1BoardInfo[i-1];
      4	   9369         retval = sst1InitComputeClkParams(freq, clkTiming);
      4	   9370         sst1CurrentBoard = saveBoard;
      3	   9371       }
      2	   9372     }
      2	   9373 
      2	   9374     return retval;
      2	   9375   } else {
      2	   9376     return sst1InitComputeClkParamsATT(freq, clkTiming);
      1	   9377   }
      1	   9378 }
	   9379 
	   9380 /*
	   9381 ** sst1InitComputeClkParamsATT():
	   9382 **  Compute PLL parameters for given clock frequency (ATT DACs)
	   9383 **
	   9384 */
	   9385 FxBool sst1InitComputeClkParamsATT(float freq, sst1ClkTimingStruct
	   9386     *clkTiming)
      1	   9387 {
      1	   9388     float vcoFreqDivide = 0.0f, freqMultRatio, clkError;
      1	   9389     float clkErrorMin;
      1	   9390     FxU32 p, n, m, nPlusTwo;
      1	   9391     int mPlusTwo;
      1	   9392 
      1	   9393     /* Calculate P parameter */
      1	   9394     p = 4;
      1	   9395     if(((freq * (float) 1.) >= (float) 120.) &&
      2	   9396        ((freq * (float) 1.) <= (float) 240.)) {
      2	   9397            vcoFreqDivide = (float) 1.;
      2	   9398            p = 0;
      1	   9399     }
      1	   9400     if(((freq * (float) 2.) >= (float) 120.) &&
      2	   9401        ((freq * (float) 2.) <= (float) 240.)) {
      2	   9402            vcoFreqDivide = (float) 2.;
      2	   9403            p = 1;
      1	   9404     }
      1	   9405     if(((freq * (float) 4.) >= (float) 120.) &&
      2	   9406        ((freq * (float) 4.) <= (float) 240.)) {
      2	   9407            vcoFreqDivide = (float) 4.;
      2	   9408            p = 2;
      1	   9409     }
      1	   9410     if(((freq * (float) 8.) >= (float) 120.) &&
      2	   9411        ((freq * (float) 8.) <= (float) 240.)) {
      2	   9412            vcoFreqDivide = (float) 8.;
      2	   9413            p = 3;
      1	   9414     }
      1	   9415     if(p > 3)
      1	   9416         return(FXFALSE);
      1	   9417 
      1	   9418     /* Divide by 14.318 */
      1	   9419     freqMultRatio = (freq * vcoFreqDivide) * (float) 0.06984216;
      1	   9420 
      1	   9421     /* Calculate proper N and M parameters which yield the lowest error */
      1	   9422     clkErrorMin = (float) 9999.; n = 0; m = 0;
      2	   9423     for(nPlusTwo = 3; nPlusTwo < 32; nPlusTwo++) {
      2X   9424 #ifdef DIRECTX

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      2X   9425         mPlusTwo = FTOL( (((float) nPlusTwo * freqMultRatio) + (float) 0.5) );
      2X   9426         clkError = ((float) mPlusTwo * ITOF_INV( nPlusTwo ) ) - freqMultRatio;
      2X   9427 #else
      2	   9428         mPlusTwo = (int) (((float) nPlusTwo * freqMultRatio) + (float) 0.5);
      2	   9429         clkError = ((float) mPlusTwo / (float) nPlusTwo) - freqMultRatio;
      2	   9430 #endif
      2	   9431         if(clkError < (float) 0.0)
      2	   9432             clkError = -clkError;
      3	   9433         if((clkError < clkErrorMin) && ((mPlusTwo - 2) < 127)) {
      3	   9434             clkErrorMin = clkError;
      3	   9435             n = nPlusTwo - 2;
      3	   9436             m = mPlusTwo - 2;
      2	   9437         }
      1	   9438     }
      1	   9439     if(n == 0)
      1	   9440         return(FXFALSE);
      1	   9441 
      1	   9442     clkTiming->freq = freq;
      1	   9443     clkTiming->clkTiming_M = m;
      1	   9444     clkTiming->clkTiming_P = p;
      1	   9445     clkTiming->clkTiming_N = n;
      2	   9446     if(freq < (float) 37.) {
      2	   9447         clkTiming->clkTiming_L = 0xa;
      2	   9448         clkTiming->clkTiming_IB = 0x6;
      2	   9449     } else if(freq < (float) 45.) {
      2	   9450         clkTiming->clkTiming_L = 0xc;
      2	   9451         clkTiming->clkTiming_IB = 0x4;
      2	   9452     } else if(freq < (float) 58.) {
      2	   9453         clkTiming->clkTiming_L = 0x8;
      2	   9454         clkTiming->clkTiming_IB = 0x4;
      2	   9455     } else if(freq < (float) 66.) {
      2	   9456         clkTiming->clkTiming_L = 0xa;
      2	   9457         clkTiming->clkTiming_IB = 0x6;
      2	   9458     } else {
      2	   9459         clkTiming->clkTiming_L = 0xa;
      2	   9460         clkTiming->clkTiming_IB = 0x8;
      1	   9461     }
      1X   9462 #if 0
      1X   9463     {
      1X   9464         float calc;
      1X   9465         
      1X   9466         calc = ((float) 14.318 * (float) (m + 2)) /
      1X   9467             ((float) (n + 2) * vcoFreqDivide);
      1X   9468         printf("freq:%.3f  calc:%.3f\n", freq, calc);
      1X   9469         printf("m:%d p:%d n:%d\n", m, p, n);
      1X   9470         fflush(stdout);
      1X   9471     }
      1X   9472 #endif
      1	   9473     return(FXTRUE);
      1	   9474 }
	   9475 
	   9476 /*
	   9477 ** sst1InitComputeClkParamsTI():
	   9478 **  Compute PLL parameters for given clock frequency (TI DACs)
	   9479 **
	   9480 */
	   9481 FxBool sst1InitComputeClkParamsTI(float freq, sst1ClkTimingStruct

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   9482     *clkTiming)
      1	   9483 {
      1	   9484     float clkError, clkErrorMin;
      1	   9485     FxU32 p, n, m, pBest, nBest, mBest;
      1	   9486     float lowVCO, highVCO;
      1	   9487 
      1	   9488     //lowVCO = (float) 120.; highVCO = (float) 240.;
      1	   9489     lowVCO = (float) 80.; highVCO = (float) 150.;
      1	   9490 
      1	   9491     /* Loop through all the possible combinations and find the frequency
      1	   9492        with the least error */
      1	   9493     clkErrorMin = (float) 9999.; pBest = 9999; nBest = 9999; mBest = 9999;
      2	   9494     for(p=0; p<4; p++) {
      3	   9495       for(m=0; m<64; m++) {
      4	   9496         for(n=0; n<5; n++) {
      4	   9497           float clkFreq, vcoFreq;
      4	   9498           float pFreqDivide;
      4	   9499           float mPlusTwo = (float) m + (float) 2.0;
      4	   9500           float nPlusTwo = (float) n + (float) 2.0;
      4	   9501 
      4	   9502           if(p == 0) pFreqDivide = (float) 1.0;
      4	   9503           else if(p == 1) pFreqDivide = (float) 2.0;
      4	   9504           else if(p == 2) pFreqDivide = (float) 4.0;
      4	   9505           else pFreqDivide = (float) 8.0;
      4	   9506 
      4	   9507           clkFreq = ((float) 14.31818 * mPlusTwo) / (nPlusTwo * pFreqDivide);
      4	   9508           vcoFreq = ((float) 14.31818 * mPlusTwo) / (nPlusTwo);
      4	   9509           clkError = freq - clkFreq;
      4	   9510           if(clkError < (float) 0.0)
      4	   9511              clkError = -clkError;
      4	   9512           if(clkError < clkErrorMin && vcoFreq >= lowVCO &&
      5	   9513            vcoFreq <= highVCO) {
      5	   9514              clkErrorMin = clkError;
      5	   9515              pBest = p;
      5	   9516              mBest = m;
      5	   9517              nBest = n;
      4	   9518            }
      3	   9519         }
      2	   9520       }
      1	   9521     }
      1	   9522 
      1	   9523     if(nBest == 9999) return(FXFALSE);
      1	   9524 
      1	   9525     clkTiming->freq = freq;
      1	   9526     clkTiming->clkTiming_M = mBest;
      1	   9527     clkTiming->clkTiming_P = pBest;
      1	   9528     clkTiming->clkTiming_N = nBest;
      1	   9529     // L and IB params are not used by TI DACs...
      1	   9530     clkTiming->clkTiming_L = 0;
      1	   9531     clkTiming->clkTiming_IB = 0;
      1	   9532 
      1X   9533 #if 0
      1X   9534     {
      1X   9535         float clkFreq, vcoFreq, pFreqDivide;
      1X   9536 
      1X   9537         if(clkTiming->clkTiming_P == 0) pFreqDivide = (float) 1.0;
      1X   9538         else if(clkTiming->clkTiming_P == 1) pFreqDivide = (float) 2.0;

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1X   9539         else if(clkTiming->clkTiming_P == 2) pFreqDivide = (float) 4.0;
      1X   9540         else pFreqDivide = (float) 8.0;
      1X   9541 
      1X   9542         clkFreq = ((float) 14.31818 * (float) (clkTiming->clkTiming_M + 2)) /
      1X   9543           ((float) (clkTiming->clkTiming_N + 2) * pFreqDivide);
      1X   9544         vcoFreq = ((float) 14.31818 * (float) (clkTiming->clkTiming_M + 2)) /
      1X   9545           ((float) (clkTiming->clkTiming_N + 2));
      1X   9546         
      1X   9547         printf("freq:%.3f  calc:%.3f\n", freq, clkFreq);
      1X   9548         printf("m:%d p:%d n:%d vco:%.2f\n", clkTiming->clkTiming_M,
      1X   9549           clkTiming->clkTiming_P, clkTiming->clkTiming_N, vcoFreq);
      1X   9550         printf("lowVCO:%.2f  highVCO:%.2f\n", lowVCO, highVCO);
      1X   9551         fflush(stdout);
      1X   9552     }
      1X   9553 #endif
      1	   9554     return(FXTRUE);
      1	   9555 }
	   9556 
	   9557 /*
	   9558 ** sst1InitSetVidClkATT():
	   9559 **  Set video clock for ATT Dacs
	   9560 **
	   9561 */
	   9562 FxBool sst1InitSetVidClkATT(FxU32 *sstbase, sst1ClkTimingStruct
	   9563     *sstVidClk)
      1	   9564 {
      1	   9565     if(sst1InitDacIndexedEnable(sstbase, 1) == FXFALSE)
      1	   9566         return(FXFALSE);
      1	   9567 
      1	   9568     DAC_INDEXWRADDR(SST_DACREG_INDEX_AD0);
      1	   9569     DAC_INDEXWR((sstVidClk->clkTiming_M) << SST_DACREG_CLKREG_MSHIFT);
      1	   9570     DAC_INDEXWRADDR(SST_DACREG_INDEX_AD1);
      1	   9571     DAC_INDEXWR(((sstVidClk->clkTiming_P) << SST_DACREG_CLKREG_PSHIFT) |
      1	   9572         ((sstVidClk->clkTiming_N)
      1	   9573            << SST_DACREG_CLKREG_NSHIFT));
      1	   9574     DAC_INDEXWRADDR(SST_DACREG_INDEX_AD2);
      1	   9575     DAC_INDEXWR(((sstVidClk->clkTiming_L) << SST_DACREG_CLKREG_LSHIFT) |
      1	   9576         ((sstVidClk->clkTiming_IB) << SST_DACREG_CLKREG_IBSHIFT));
      1	   9577     DAC_INDEXWRADDR(SST_DACREG_INDEX_CC);
      1	   9578     DAC_INDEXWR((DAC_INDEXRD() | (0x3 << SST_DACREG_CC_ACLK_SEL_SHIFT) |
      1	   9579         SST_DACREG_CC_ACLK_SELECT_AD));
      1	   9580     DAC_INDEXWRADDR(SST_DACREG_INDEX_CC);
      1	   9581 
      1	   9582     if(sst1InitDacIndexedEnable(sstbase, 0) == FXFALSE)
      1	   9583         return(FXFALSE);
      1	   9584 
      1	   9585     return(FXTRUE);
      1	   9586 }
	   9587 
	   9588 /*
	   9589 ** sst1InitSetVidClkICS():
	   9590 **  Set video clock for ICS Dacs
	   9591 **
	   9592 */
	   9593 FxBool sst1InitSetVidClkICS(FxU32 *sstbase, sst1ClkTimingStruct
	   9594     *sstVidClk)
      1	   9595 {

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9596     FxU32 n, fbiInit1_save, fbiInit2_save, pllCtrl, cfgInitEnable;
      1	   9597     SstRegs *sst = (SstRegs *) sstbase;
      1	   9598 
      1	   9599     sst1InitIdleFBINoNOP(sstbase);
      1	   9600 
      1	   9601     /* Save init register states before overwriting them */
      1	   9602     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9603     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9604 
      1	   9605     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9606     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9607     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9608     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9609     sst1InitIdleFBINoNOP(sstbase);
      1	   9610 
      1	   9611     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9612     /* Disallow writes to pass through the PCI FIFO */
      1	   9613     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9614     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	   9615     sst1InitIdleFBINoNOP(sstbase);
      1	   9616 
      1	   9617     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_RD,
      1	   9618         SST_DACREG_ICS_PLLADDR_CTRL);
      1	   9619     pllCtrl = sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      1	   9620 
      1	   9621     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_WR,
      1	   9622         SST_DACREG_ICS_PLLADDR_VCLK0);
      1	   9623     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9624         sstVidClk->clkTiming_M);
      1	   9625     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9626         (((sstVidClk->clkTiming_P) << 5) | sstVidClk->clkTiming_N));
      1	   9627     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_WR,
      1	   9628         SST_DACREG_ICS_PLLADDR_CTRL);
      1	   9629     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9630         ((pllCtrl & ~SST_DACREG_ICS_PLLCTRL_CLK0FREQ) |
      1	   9631           SST_DACREG_ICS_PLLCTRL_CLK0SEL));
      1	   9632     sst1InitIdleFBINoNOP(sstbase);
      1	   9633 
      1	   9634     /* Disable fbiinit23 address remapping */
      1	   9635     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9636 
      1	   9637     /* Restore init register states */
      1	   9638     sst1InitIdleFBINoNOP(sstbase);
      1	   9639     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9640     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9641     sst1InitIdleFBINoNOP(sstbase);
      1	   9642 
      1	   9643     return(FXTRUE);
      1	   9644 }
	   9645 
	   9646 /*
	   9647 ** sst1InitSetVidClkINI():
	   9648 **  Set video clock for DACs defined in "voodoo2.ini"
	   9649 **
	   9650 */
	   9651 FxBool sst1InitSetVidClkINI(FxU32 *sstbase, FxU32 width,
	   9652   FxU32 height, FxU32 refresh, FxU32 video16BPP)

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9653 {
      1	   9654     FxU32 n, fbiInit1_save, fbiInit2_save, cfgInitEnable;
      1	   9655     sst1InitDacSetVideoStruct *setVideo;
      1	   9656     SstRegs *sst = (SstRegs *) sstbase;
      1	   9657     int helper = (GETENV(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   9658     FxBool retVal = FXFALSE;
      1	   9659 
      1	   9660     if(helper)
      1	   9661         INIT_PRINTF(("sst1InitSetVidClkINI(): Entered...\n"));
      1	   9662 
      1	   9663     if(iniDac == (sst1InitDacStruct *) NULL)
      1	   9664         return(FXFALSE);
      1	   9665 
      1	   9666     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9667         return(FXFALSE);
      1	   9668 
      1	   9669     sst1InitIdleFBINoNOP(sstbase);
      1	   9670 
      1	   9671     /* Save init register states before overwriting them */
      1	   9672     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9673     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9674 
      1	   9675     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9676     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9677     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9678     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9679     sst1InitIdleFBINoNOP(sstbase);
      1	   9680 
      1	   9681     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9682     /* Disallow writes to pass through the PCI FIFO */
      1	   9683     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9684     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	   9685     sst1InitIdleFBINoNOP(sstbase);
      1	   9686 
      1	   9687     setVideo = iniDac->setVideo;
      2	   9688     while(setVideo) {
      2	   9689         if((setVideo->width == width) && (setVideo->height == height) &&
      2	   9690            (setVideo->refresh == refresh) &&
      3	   9691            (setVideo->video16BPP == video16BPP)) {
      3	   9692             if((retVal = sst1InitExecuteDacRdWr(sstbase,
      4	   9693               setVideo->setVideoRdWr)) == FXTRUE) {
      4	   9694                 retVal = FXTRUE;
      4	   9695                 break;
      3	   9696             }
      2	   9697         }
      2	   9698         setVideo = setVideo->nextSetVideo;
      1	   9699     }
      1	   9700 
      1	   9701     /* Disable fbiinit23 address remapping */
      1	   9702     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9703 
      1	   9704     /* Restore init register states */
      1	   9705     sst1InitIdleFBINoNOP(sstbase);
      1	   9706     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9707     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9708     sst1InitIdleFBINoNOP(sstbase);
      1	   9709 

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9710     return(retVal);
      1	   9711 }
	   9712 
	   9713 /*
	   9714 ** sst1InitSetGrxClkATT():
	   9715 **  Set graphics clock for ATT Dacs
	   9716 **  NOTE: sst1InitSetGrxClkATT() resets the PCI fifo and the graphics subsystem
	   9717 **  of FBI
	   9718 **
	   9719 */
	   9720 FxBool sst1InitSetGrxClkATT(FxU32 *sstbase, sst1ClkTimingStruct
	   9721     *sstGrxClk)
      1	   9722 {
      1	   9723     FxU32 n;
      1	   9724     SstRegs *sst = (SstRegs *) sstbase;
      1	   9725 
      1	   9726     /* Reset graphics unit before we change grx clk */
      1	   9727     ISET(sst->fbiInit0, IGET(sst->fbiInit0) |
      1	   9728       (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      1	   9729     sst1InitIdleFBINoNOP(sstbase);
      1	   9730 
      1	   9731     /* Enable DAC indexed addressing */
      1	   9732     /* sst1InitDacIndexedEnable resets the video module, turns off dram refresh */
      1	   9733     /* and disallows writes to the PCI fifo */
      1	   9734     if(sst1InitDacIndexedEnable(sstbase, 1) == FXFALSE)
      1	   9735         return(FXFALSE);
      1	   9736 
      1	   9737     DAC_INDEXWRADDR(SST_DACREG_INDEX_BD0);
      1	   9738     DAC_INDEXWR((sstGrxClk->clkTiming_M) << SST_DACREG_CLKREG_MSHIFT);
      1	   9739     DAC_INDEXWRADDR(SST_DACREG_INDEX_BD1);
      1	   9740     DAC_INDEXWR(((sstGrxClk->clkTiming_P) << SST_DACREG_CLKREG_PSHIFT) |
      1	   9741                 ((sstGrxClk->clkTiming_N) << SST_DACREG_CLKREG_NSHIFT));
      1	   9742     DAC_INDEXWRADDR(SST_DACREG_INDEX_BD2);
      1	   9743     DAC_INDEXWR(((sstGrxClk->clkTiming_L) << SST_DACREG_CLKREG_LSHIFT) |
      1	   9744                 ((sstGrxClk->clkTiming_IB) << SST_DACREG_CLKREG_IBSHIFT));
      1	   9745     DAC_INDEXWRADDR(SST_DACREG_INDEX_CC);
      1	   9746     DAC_INDEXWR((DAC_INDEXRD() | (0x3 << SST_DACREG_CC_BCLK_SEL_SHIFT) |
      1	   9747         SST_DACREG_CC_BCLK_SELECT_BD));
      1	   9748     sst1InitIdleFBINoNOP(sstbase);
      1	   9749 
      1	   9750     /* Turn off DAC indexed addressing */
      1	   9751 
      1	   9752     /* Disabling dac indexed mode re-enables writes to pass through the */
      1	   9753     /* PCI fifo (and restores video refresh and dram refresh if previously */
      1	   9754     /* enabled) */
      1	   9755     if(sst1InitDacIndexedEnable(sstbase, 0) == FXFALSE)
      1	   9756         return(FXFALSE);
      1	   9757 
      1	   9758     /* Wait for graphics clock to stabilize */
      1	   9759     for(n=0; n<200000; n++)
      1	   9760         sst1InitReturnStatus(sstbase);
      1	   9761 
      1	   9762     /* Unreset PCI FIFO and graphic subsystem */
      1	   9763     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      1	   9764     sst1InitIdleFBINoNOP(sstbase);
      1	   9765     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      1	   9766     sst1InitIdleFBINoNOP(sstbase);

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9767 
      1	   9768     return(FXTRUE);
      1	   9769 }
	   9770 
	   9771 /*
	   9772 ** sst1InitSetGrxClkICS():
	   9773 **  Set graphics clock for ICS Dacs
	   9774 **  NOTE: sst1InitSetGrxClkICS() resets the PCI fifo and the graphics subsystem
	   9775 **  of FBI
	   9776 **
	   9777 */
	   9778 FxBool sst1InitSetGrxClkICS(FxU32 *sstbase, sst1ClkTimingStruct
	   9779     *sstGrxClk)
      1	   9780 {
      1	   9781     FxU32 n, fbiInit1_save, fbiInit2_save, pllCtrl, cfgInitEnable;
      1	   9782     SstRegs *sst = (SstRegs *) sstbase;
      1	   9783 
      1	   9784     /* Reset graphics unit before we change grx clk */
      1	   9785     ISET(sst->fbiInit0, IGET(sst->fbiInit0) |
      1	   9786       (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      1	   9787     sst1InitIdleFBINoNOP(sstbase);
      1	   9788 
      1	   9789     /* Save init register states before overwriting them */
      1	   9790     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9791     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9792 
      1	   9793     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9794     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9795     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9796     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9797     sst1InitIdleFBINoNOP(sstbase);
      1	   9798 
      1	   9799     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9800     /* Disallow writes to pass through the PCI FIFO */
      1	   9801     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9802     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	   9803     sst1InitIdleFBINoNOP(sstbase);
      1	   9804 
      1	   9805     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_RD,
      1	   9806         SST_DACREG_ICS_PLLADDR_CTRL);
      1	   9807     pllCtrl = sst1InitDacRd(sstbase,  SST_DACREG_ICS_PLLADDR_DATA);
      1	   9808 
      1	   9809     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_WR,
      1	   9810         SST_DACREG_ICS_PLLADDR_GCLK0);
      1	   9811     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9812         sstGrxClk->clkTiming_M);
      1	   9813     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9814         (((sstGrxClk->clkTiming_P) << 5) | sstGrxClk->clkTiming_N));
      1	   9815     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_WR,
      1	   9816         SST_DACREG_ICS_PLLADDR_CTRL);
      1	   9817     sst1InitDacWr(sstbase, SST_DACREG_ICS_PLLADDR_DATA,
      1	   9818         (pllCtrl & ~SST_DACREG_ICS_PLLCTRL_CLK1SEL));
      1	   9819     sst1InitIdleFBINoNOP(sstbase);
      1	   9820 
      1	   9821     /* Disable fbiinit23 address remapping */
      1	   9822     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9823 

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9824     /* Restore init register states */
      1	   9825     sst1InitIdleFBINoNOP(sstbase);
      1	   9826     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9827     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9828     sst1InitIdleFBINoNOP(sstbase);
      1	   9829 
      1	   9830     /* Wait for graphics clock to stabilize */
      1	   9831     for(n=0; n<200000; n++)
      1	   9832         sst1InitReturnStatus(sstbase);
      1	   9833 
      1	   9834     /* Unreset PCI FIFO and graphic subsystem */
      1	   9835     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      1	   9836     sst1InitIdleFBINoNOP(sstbase);
      1	   9837     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      1	   9838     sst1InitIdleFBINoNOP(sstbase);
      1	   9839 
      1	   9840     return(FXTRUE);
      1	   9841 }
	   9842 
	   9843 /*
	   9844 ** sst1InitSetGrxClkINI():
	   9845 **  Set graphics clock for dac specified in "voodoo2.ini" file
	   9846 **  NOTE: sst1InitSetGrxClkINI() resets the PCI fifo and the graphics subsystem
	   9847 **  of FBI
	   9848 **
	   9849 */
	   9850 FxBool sst1InitSetGrxClkINI(FxU32 *sstbase, sst1ClkTimingStruct
	   9851     *sstGrxClk)
      1	   9852 {
      1	   9853     FxU32 n, fbiInit1_save, fbiInit2_save, cfgInitEnable;
      1	   9854     sst1InitDacSetMemClkStruct *setMemClk;
      1	   9855     FxBool retVal = FXFALSE;
      1	   9856     SstRegs *sst = (SstRegs *) sstbase;
      1	   9857 
      1	   9858     if(iniDac == (sst1InitDacStruct *) NULL)
      1	   9859         return(FXFALSE);
      1	   9860 
      1	   9861     /* Reset graphics unit before we change grx clk */
      1	   9862     ISET(sst->fbiInit0, IGET(sst->fbiInit0) |
      1	   9863       (SST_GRX_RESET | SST_PCI_FIFO_RESET));
      1	   9864     sst1InitIdleFBINoNOP(sstbase);
      1	   9865 
      1	   9866     /* Save init register states before overwriting them */
      1	   9867     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9868     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9869 
      1	   9870     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9871     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9872     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9873     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9874     sst1InitIdleFBINoNOP(sstbase);
      1	   9875 
      1	   9876     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9877     /* Disallow writes to pass through the PCI FIFO */
      1	   9878     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9879     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	   9880     sst1InitIdleFBINoNOP(sstbase);

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9881 
      1	   9882     setMemClk = iniDac->setMemClk;
      2	   9883     while(setMemClk) {
      3	   9884         if(setMemClk->frequency == (FxU32) sstGrxClk->freq) {
      3	   9885             if((retVal = sst1InitExecuteDacRdWr(sstbase,
      4	   9886               setMemClk->setMemClkRdWr)) == FXTRUE) {
      4	   9887                 retVal = FXTRUE;
      4	   9888                 break;
      3	   9889             }
      2	   9890         }
      2	   9891         setMemClk = setMemClk->nextSetMemClk;
      1	   9892     }
      1	   9893     /* Disable fbiinit23 address remapping */
      1	   9894     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9895 
      1	   9896     /* Restore init register states */
      1	   9897     sst1InitIdleFBINoNOP(sstbase);
      1	   9898     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9899 
      1	   9900     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9901     sst1InitIdleFBINoNOP(sstbase);
      1	   9902 
      1	   9903     /* Wait for graphics clock to stabilize */
      2	   9904     if(retVal == FXTRUE) {
      2	   9905         for(n=0; n<200000; n++)
      2	   9906             sst1InitReturnStatus(sstbase);
      1	   9907     }
      1	   9908 
      1	   9909     /* Unreset PCI FIFO and graphic subsystem */
      1	   9910     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_PCI_FIFO_RESET);
      1	   9911     sst1InitIdleFBINoNOP(sstbase);
      1	   9912     ISET(sst->fbiInit0, IGET(sst->fbiInit0) & ~SST_GRX_RESET);
      1	   9913     sst1InitIdleFBINoNOP(sstbase);
      1	   9914 
      1	   9915     return(retVal);
      1	   9916 }
	   9917 
	   9918 /*
	   9919 ** sst1InitSetVidModeATT():
	   9920 **  Set video Mode for ATT dacs
	   9921 **
	   9922 */
	   9923 FxBool sst1InitSetVidModeATT(FxU32 *sstbase, FxU32 video16BPP)
      1	   9924 {
      1	   9925     if(sst1InitDacIndexedEnable(sstbase, 1) == FXFALSE)
      1	   9926         return(FXFALSE);
      1	   9927 
      1	   9928     /* Set 16 or 24-bit pixel output */
      2	   9929     if(video16BPP) {
      2	   9930        DAC_INDEXWRADDR(SST_DACREG_INDEX_CR0);
      2	   9931        DAC_INDEXWR((DAC_INDEXRD() & ~SST_DACREG_CR0_COLOR_MODE) |
      2	   9932            SST_DACREG_CR0_COLOR_MODE_16BPP | SST_DACREG_CR0_8BITDAC);
      2	   9933     } else {
      2	   9934        DAC_INDEXWRADDR(SST_DACREG_INDEX_CR0);
      2	   9935        DAC_INDEXWR((DAC_INDEXRD() & ~SST_DACREG_CR0_COLOR_MODE) |
      2	   9936            SST_DACREG_CR0_COLOR_MODE_24BPP | SST_DACREG_CR0_8BITDAC);
      1	   9937     }

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	   9938 
      1	   9939     if(sst1InitDacIndexedEnable(sstbase, 0) == FXFALSE)
      1	   9940         return(FXFALSE);
      1	   9941 
      1	   9942 
      1	   9943     return(FXTRUE);
      1	   9944 }
	   9945 
	   9946 /*
	   9947 ** sst1InitSetVidModeICS():
	   9948 **  Set video Mode for ICS dacs
	   9949 **
	   9950 */
	   9951 FxBool sst1InitSetVidModeICS(FxU32 *sstbase, FxU32 video16BPP)
      1	   9952 {
      1	   9953     FxU32 n, fbiInit1_save, fbiInit2_save, cfgInitEnable;
      1	   9954     SstRegs *sst = (SstRegs *) sstbase;
      1	   9955 
      1	   9956     sst1InitIdleFBINoNOP(sstbase);
      1	   9957 
      1	   9958     /* Save init register states before overwriting them */
      1	   9959     fbiInit1_save = IGET(sst->fbiInit1);
      1	   9960     fbiInit2_save = IGET(sst->fbiInit2);
      1	   9961 
      1	   9962     /* Reset video unit to guarantee no contentions on the memory bus */
      1	   9963     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	   9964     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	   9965     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	   9966     sst1InitIdleFBINoNOP(sstbase);
      1	   9967 
      1	   9968     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	   9969     /* Disallow writes to pass through the PCI FIFO */
      1	   9970     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9971     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	   9972     sst1InitIdleFBINoNOP(sstbase);
      1	   9973 
      1	   9974     if(video16BPP)
      1	   9975         sst1InitDacWr(sstbase, SST_DACREG_ICS_CMD,
      1	   9976             SST_DACREG_ICS_COLORMODE_16BPP);
      1	   9977     else
      1	   9978         sst1InitDacWr(sstbase, SST_DACREG_ICS_CMD,
      1	   9979             SST_DACREG_ICS_COLORMODE_24BPP);
      1	   9980     sst1InitIdleFBINoNOP(sstbase);
      1	   9981 
      1	   9982     /* Disable fbiinit23 address remapping */
      1	   9983     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	   9984 
      1	   9985     /* Restore init register states */
      1	   9986     sst1InitIdleFBINoNOP(sstbase);
      1	   9987     ISET(sst->fbiInit1, fbiInit1_save);
      1	   9988     ISET(sst->fbiInit2, fbiInit2_save);
      1	   9989     sst1InitIdleFBINoNOP(sstbase);
      1	   9990 
      1	   9991     return(FXTRUE);
      1	   9992 }
	   9993 
	   9994 /*

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	   9995 ** sst1InitSetVidModeINI():
	   9996 **  Set video Mode for DACs defined in "voodoo2.ini"
	   9997 **
	   9998 */
	   9999 FxBool sst1InitSetVidModeINI(FxU32 *sstbase, FxU32 video16BPP)
      1	  10000 {
      1	  10001     FxU32 n, fbiInit1_save, fbiInit2_save, cfgInitEnable;
      1	  10002     sst1InitDacSetVideoModeStruct *setVideoMode;
      1	  10003     FxBool retVal = FXFALSE;
      1	  10004     SstRegs *sst = (SstRegs *) sstbase;
      1	  10005 
      1	  10006     if(iniDac == (sst1InitDacStruct *) NULL)
      1	  10007         return(FXFALSE);
      1	  10008 
      1	  10009     sst1InitIdleFBINoNOP(sstbase);
      1	  10010 
      1	  10011     /* Save init register states before overwriting them */
      1	  10012     fbiInit1_save = IGET(sst->fbiInit1);
      1	  10013     fbiInit2_save = IGET(sst->fbiInit2);
      1	  10014 
      1	  10015     /* Reset video unit to guarantee no contentions on the memory bus */
      1	  10016     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	  10017     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	  10018     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	  10019     sst1InitIdleFBINoNOP(sstbase);
      1	  10020 
      1	  10021     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	  10022     /* Disallow writes to pass through the PCI FIFO */
      1	  10023     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	  10024     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	  10025     sst1InitIdleFBINoNOP(sstbase);
      1	  10026 
      1	  10027     setVideoMode = iniDac->setVideoMode;
      2	  10028     while(setVideoMode) {
      3	  10029         if(setVideoMode->video16BPP == video16BPP) {
      3	  10030             if((retVal = sst1InitExecuteDacRdWr(sstbase,
      4	  10031               setVideoMode->setVideoModeRdWr)) == FXTRUE) {
      4	  10032                 retVal = FXTRUE;
      4	  10033                 break;
      3	  10034             }
      2	  10035         }
      2	  10036         setVideoMode = setVideoMode->nextSetVideoMode;
      1	  10037     }
      1	  10038     sst1InitIdleFBINoNOP(sstbase);
      1	  10039 
      1	  10040     /* Disable fbiinit23 address remapping */
      1	  10041     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	  10042 
      1	  10043     /* Restore init register states */
      1	  10044     sst1InitIdleFBINoNOP(sstbase);
      1	  10045     ISET(sst->fbiInit1, fbiInit1_save);
      1	  10046     ISET(sst->fbiInit2, fbiInit2_save);
      1	  10047     sst1InitIdleFBINoNOP(sstbase);
      1	  10048 
      1	  10049     return(retVal);
      1	  10050 }
	  10051 

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

	  10052 /*
	  10053 ** sst1InitDacIndexedEnable():
	  10054 **  Initialize DAC for indexed-mode addressing
	  10055 **  NOTE: When DAC indexed-mode addressing is enabled, video timing and
	  10056 **   DRAM refresh are both reset (disabled)
	  10057 **
	  10058 */
	  10059 FX_EXPORT FxBool FX_CSTYLE sst1InitDacIndexedEnable(FxU32 *sstbase,
	  10060   FxU32 Enable)
      1	  10061 {
      1	  10062     FxU32 n, j, dacmir, dacdir, cr0_save;
      1	  10063     static FxU32 fbiInit1_save = 0;
      1	  10064     static FxU32 fbiInit2_save = 0;
      1	  10065     static FxU32 cfgInitEnable;
      1	  10066     SstRegs *sst = (SstRegs *) sstbase;
      1	  10067 
      1	  10068     if(!sst)
      1	  10069         return(FXFALSE);
      1	  10070 
      1	  10071     sst1InitIdleFBINoNOP(sstbase);
      2	  10072     if(!Enable) {
      2	  10073         /* Disable indexed-mode addressing */
      2	  10074         sst1InitDacWr(sstbase, SST_DACREG_INDEXADDR, SST_DACREG_INDEX_CR0);
      2	  10075         sst1InitDacWr(sstbase, SST_DACREG_INDEXDATA,
      2	  10076             sst1InitDacRd(sstbase, SST_DACREG_INDEXDATA) &
      2	  10077              ~SST_DACREG_CR0_INDEXED_ADDRESSING);
      2	  10078 
      2	  10079         /* Disable fbiinit23 address remapping */
      2	  10080         PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      2	  10081 
      2	  10082         /* Restore init register states */
      2	  10083         sst1InitIdleFBINoNOP(sstbase);
      2	  10084         if(fbiInit1_save)  /* Have we previously enabled indexed addressing? */
      2	  10085             ISET(sst->fbiInit1, fbiInit1_save);
      2	  10086         if(fbiInit2_save)  /* Have we previously enabled indexed addressing? */
      2	  10087             ISET(sst->fbiInit2, fbiInit2_save);
      2	  10088         sst1InitIdleFBINoNOP(sstbase);
      2	  10089         return(FXTRUE);
      1	  10090     }
      1	  10091 
      1	  10092     /* Save init register states before overwriting them */
      1	  10093     fbiInit1_save = IGET(sst->fbiInit1);
      1	  10094     fbiInit2_save = IGET(sst->fbiInit2);
      1	  10095 
      1	  10096     /* Reset video unit to guarantee no contentions on the memory bus */
      1	  10097     ISET(sst->fbiInit1, IGET(sst->fbiInit1) | SST_VIDEO_RESET);
      1	  10098     /* Turn off dram refresh to guarantee no contentions on the memory bus */
      1	  10099     ISET(sst->fbiInit2, IGET(sst->fbiInit2) & ~SST_EN_DRAM_REFRESH);
      1	  10100     sst1InitIdleFBINoNOP(sstbase);
      1	  10101 
      1	  10102     /* Enable reads from the DAC (multiplexed on the fbiInit2 address) */
      1	  10103     /* Disallow writes to pass through the PCI FIFO */
      1	  10104     PCICFG_RD(SST1_PCI_INIT_ENABLE, cfgInitEnable);
      1	  10105     PCICFG_WR(SST1_PCI_INIT_ENABLE, cfgInitEnable | SST_FBIINIT23_REMAP);
      1	  10106     sst1InitIdleFBINoNOP(sstbase);
      1	  10107 
      1	  10108     /* Sometimes the DACs seem to go into never-never land, so */

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	  10109     /* try and initialize the DAC multiple times */
      1	  10110     n = 0;
      2	  10111     while(1) {
      3	  10112         if(++n > 100) {
      3	  10113             INIT_PRINTF(("sst1InitDacIndexedEnable() ERROR: Could not Initialize DAC\n"));
      3	  10114             return(FXFALSE);
      2	  10115         }
      2	  10116 
      2	  10117         /* Must guarantee that no rendering is being performed */
      2	  10118         sst1InitIdleFBINoNOP(sstbase);
      2	  10119 
      2	  10120         /* Reset current state of DAC command register 0 (CR0) via the read */
      2	  10121         /* mask register (RMR) */
      2	  10122         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	  10123         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 5 times */
      2	  10124         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10125         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10126         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10127         cr0_save = sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10128 
      2	  10129         /* Enable indexed programming by setting CR0[0] = 1 */
      2	  10130         sst1InitDacWr(sstbase, SST_DACREG_WMA, 0x0); /* reset backdoor fsm */
      2	  10131         sst1InitDacRd(sstbase, SST_DACREG_RMR);      /* RMR must be read 4 times */
      2	  10132         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10133         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10134         sst1InitDacRd(sstbase, SST_DACREG_RMR);
      2	  10135         sst1InitDacWr(sstbase, SST_DACREG_RMR, ((cr0_save & 0xf0) |
      2	  10136             SST_DACREG_CR0_INDEXED_ADDRESSING | SST_DACREG_CR0_8BITDAC));
      2	  10137 
      2	  10138         /* NOW DAC IS IN INDEXED ADDRESS MODE... */
      2	  10139 
      2	  10140         /* Check the manufacturing ID for sanity */
      2	  10141         j = 0;
      2	  10142         DAC_INDEXWRADDR(SST_DACREG_INDEX_MIR);
      2	  10143         dacmir = DAC_INDEXRD();
      2	  10144 
      2	  10145         if((dacmir == SST_DACREG_INDEX_MIR_ATT_DEFAULT) ||
      2	  10146            (dacmir == SST_DACREG_INDEX_MIR_TI_DEFAULT))
      2	  10147             j++;
      2	  10148         else
      2	  10149             continue;
      2	  10150 
      2	  10151         /* Check the device ID for sanity */
      2	  10152         DAC_INDEXWRADDR(SST_DACREG_INDEX_DIR);
      2	  10153         dacdir = DAC_INDEXRD();
      2	  10154         if((dacmir == SST_DACREG_INDEX_MIR_ATT_DEFAULT &&
      2	  10155             dacdir == SST_DACREG_INDEX_DIR_ATT_DEFAULT) ||
      2	  10156            (dacmir == SST_DACREG_INDEX_MIR_TI_DEFAULT &&
      2	  10157             dacdir == SST_DACREG_INDEX_DIR_TI_DEFAULT))
      2	  10158             j++;
      2	  10159         else
      2	  10160             continue;
      2	  10161         if(j == 2)
      2	  10162             break;
      1	  10163     }
      1	  10164     sst1InitIdleFBINoNOP(sstbase);
      1	  10165     return(FXTRUE);

DAC                             Source Listing                   9-MAY-2021 23:43:14  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             2-FEB-2021 02:11:10  dac.c;1

      1	  10166 }
	  10167 
       X  10168 #ifdef _MSC_VER
       X  10169 #pragma optimize ("",on)
       X  10170 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]DAC/OBJECT=[.OUT.DEBU
G.OBJ.GLIDE.GLIDE2X.CVG.INIT]DAC.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC],
[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CVG.
INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_HW_
TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE.G
LIDE2X.CVG.INIT]DAC.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:14"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


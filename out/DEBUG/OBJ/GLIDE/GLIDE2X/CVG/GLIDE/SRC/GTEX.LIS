GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** 42    6/24/98 5:19p Peter
	     21 ** cleanedup version merged w/ banshee
	     22 ** 
	     23 ** 41    6/23/98 5:39p Peter
	     24 ** gary's trilinear hell bug
	     25 ** 
	     26 ** 40    6/06/98 12:06p Peter
	     27 ** gmt's trilinear hell bug
	     28 ** 
	     29 ** 39    5/18/98 12:14p Peter
	     30 ** crybaby check in grTexCombine
	     31 ** 
	     32 ** 38    5/07/98 4:12p Peter
	     33 ** lbe texture thing
	     34 ** 
	     35 ** 37    4/16/98 3:54p Peter
	     36 ** 1x1 lod fix, sorry John
	     37 ** 
	     38 ** 36    4/01/98 1:51p Peter
	     39 ** fixed resetting unused tmu muckage
	     40 ** 
	     41 ** 35    3/13/98 1:27p Peter
	     42 ** lodDither vs tri-linear
	     43 ** 
	     44 ** 34    2/20/98 5:31p Peter
	     45 ** crybaby glide
	     46 ** 
	     47 ** 33    2/20/98 11:00a Peter
	     48 ** removed glide3 from glid2 tree
	     49  * 
	     50  * 32    1/13/98 12:42p Atai
	     51  * fixed grtexinfo, grVertexLayout, and draw triangle
	     52  * 
	     53  * 31    1/09/98 6:48p Atai
	     54  * grTexInfo, GR_LOD_* and GR_ASPECT_*
	     55  * 
	     56  * 30    1/08/98 7:09p Peter
	     57  * real hw stuff modulo makefile change

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

	     58  * 
	     59  * 29    1/08/98 4:58p Atai
	     60  * tex table broadcast, grVertexLayout enable/disable, stq, and some
	     61  * defines
	     62  * 
	     63  * 28    1/07/98 10:22a Peter
	     64  * lod dithering env var
	     65  * 
	     66  * 27    1/05/98 6:06p Atai
	     67  * glide extension stuff
	     68  * 
	     69  * 26    12/18/97 10:52a Atai
	     70  * fixed grGet(GR_VIDEO_POS)
	     71  * 
	     72  * 25    12/17/97 4:45p Peter
	     73  * groundwork for CrybabyGlide
	     74  * 
	     75  * 24    12/11/97 4:15p Peter
	     76  * fixed assertions
	     77  * 
	     78  * 23    12/05/97 4:26p Peter
	     79  * watcom warnings
	     80  * 
	     81  * 22    11/20/97 6:57p Dow
	     82  * baseaddress for banshee
	     83  * 
	     84  * 21    11/18/97 4:36p Peter
	     85  * chipfield stuff cleanup and w/ direct writes
	     86  * 
	     87  * 20    11/17/97 4:55p Peter
	     88  * watcom warnings/chipfield stuff
	     89  * 
	     90  * 19    11/03/97 3:43p Peter
	     91  * h3/cvg cataclysm
	     92  * 
	     93  * 18    9/15/97 7:31p Peter
	     94  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	     95  * place, lfb's are on, Hmmmm.. probably more
	     96  * 
	     97  * 17    9/05/97 12:31p Peter
	     98  * more reg write grouping
	     99  * 
	    100  * 16    7/08/97 2:48p Peter
	    101  * 
	    102  * 15    6/06/97 10:47a Peter
	    103  * texture downloading, fixed 640x480 dimension, changed cvg dep to be the
	    104  * same as sst1
	    105  * 
	    106  * 14    5/27/97 1:16p Peter
	    107  * Basic cvg, w/o cmd fifo stuff. 
	    108  * 
	    109  * 13    5/21/97 6:05a Peter
	    110  * 
	    111  * 12    3/04/97 9:08p Dow
	    112  * 
	    113  * 11    3/03/97 10:58a Jdt
	    114  * Fixe for 2-pass trilinear

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

	    115  * 
	    116  * 10    12/23/96 1:37p Dow
	    117  * chagnes for multiplatform glide
	    118 **
	    119 */
	    120 
	    121 #include <3dfx.h>
	    252 
	    253 #define FX_DLL_DEFINITION
	    254 #include <fxdll.h>
	    375 #include <glide.h>
	   2317 #include "fxglide.h"
	  14209 
	  14210 extern const int _grMipMapHostWH[GR_ASPECT_1x8 + 1][GR_LOD_1 + 1][2];
	  14211 extern FxU32 _grMipMapHostSize[][16];
	  14212 extern FxU32 _gr_aspect_index_table[];
	  14213 extern FxU32 _gr_evenOdd_xlate_table[];
	  14214 extern FxU32 _gr_aspect_xlate_table[];
	  14215 
	  14216 /* Make sure that the trilinear blending bits are set in a
	  14217  * consistent manner across the tmu's.  This only really matters if
	  14218  * we have multiple tmu's, but this state is really setup across
	  14219  * multiple calls (grTexCombine, grTexMipMapMode, and
	  14220  * grTexSource).  
	  14221  * 
	  14222  * NB: This must be called after the shadows are updated because
	  14223  * _grTexCheckTriLinear() will use the shadow register values
	  14224  * to determine the current state of trilinearness. 
	  14225  *
	  14226  * FixMe: This should eventually get merged in w/ the texture
	  14227  * statemonster. When/If that ever happens.
	  14228  */
	  14229 static void
	  14230 _grTexCheckTriLinear(GrChipID_t tmu)
      1	  14231 {
      1	  14232 #define FN_NAME "_grTexCheckTriLinear"
      1	  14233   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
      1	  14234   GDBG_INFO_MORE(gc->myLevel, "(0x%X)\n", tmu);
      1	  14235 
      1X  14236 #if (GLIDE_NUM_TMU > 2)
      1X  14237 #error "(GLIDE_NUM_TMU > 2): Write this code"
      1X  14238 #endif
      1	  14239 
      1	  14240 /* NB: The factor mask needs to include the factor bits as
      1	  14241  * well as the reverse bit so that we can differentiate
      1	  14242  * between the lodfrac and the (1 - lodfrac) case.
      1	  14243  */
      1	  14244 #define SST_TC_FACTOR_MASK (SST_TC_MSELECT | SST_TC_REVERSE_BLEND)
      1	  14245 
      1	  14246 #define SST_MIPMAP_LEVEL_MASK (SST_LOD_ODD | SST_LOD_TSPLIT)
      1	  14247 
      1	  14248   /* Is this tmu on? */
      2	  14249   if (!gc->hwDep.cvgDep.tmuLodDisable[tmu]) {
      2	  14250     const struct tmu_config_t* tmu0 = gc->state.tmu_config;
      2	  14251     const struct tmu_config_t* tmu1 = gc->state.tmu_config + 1;
      2	  14252     const struct tmu_config_t* curTmu = gc->state.tmu_config + tmu;
      2	  14253     const struct tmu_config_t* otherTmu = gc->state.tmu_config + !tmu;

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      2	  14254 
      2	  14255     /* This is the 'tricky' state where we have to manage the states
      2	  14256      * of teh tmu's together to get the correct effect. Within this
      2	  14257      * state there are two sub-states: two-pass trilinear and single
      2	  14258      * pass using both tmu's w/ split levels.  
      2	  14259      *
      2	  14260      * Case 1 - TMU set for lod blending and has both even/odd levels
      2	  14261      */
      2	  14262     if (((curTmu->textureMode & SST_TRILINEAR) == SST_TRILINEAR) &&
      3	  14263         (curTmu->evenOdd == GR_MIPMAPLEVELMASK_BOTH)) {
      3	  14264       
      3	  14265       /* Check the 'other' tmu to see if it is active, if not then we
      3	  14266        * are doing two pass trilinear so check that we have the
      3	  14267        * correct even/odd things set based on the factor where one
      3	  14268        * pass will use GR_COMBINE_FACTOR_LOD_FRACTION and the other
      3	  14269        * will use (1 - GR_COMBINE_FACTOR_LOD_FRACTION).
      3	  14270        */
      4	  14271       if (gc->hwDep.cvgDep.tmuLodDisable[!tmu]) {
      4	  14272         /* NB: In this case the rgb/alpha factors need to match so
      4	  14273          * checking for only one of them is fine.
      4	  14274          */
      4	  14275         const FxU32 levelMask = (((curTmu->textureMode & SST_TC_FACTOR_MASK) == SST_TC_MLODFRAC)
      4	  14276                                  ? SST_LOD_ODD
      4	  14277                                  : 0);
      4	  14278         
      4	  14279         GDBG_INFO(gc->myLevel, FN_NAME": Two-pass trilinear fixup (0x%X) : tLOD : (0x%X : 0x%X)\n",
      4	  14280                   tmu, curTmu->tLOD, ((curTmu->tLOD & ~SST_MIPMAP_LEVEL_MASK) | levelMask));
      4	  14281         
      4	  14282         GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      4	  14283         GR_SET(eChipTMU0, SST_TMU(hw, 0), tLOD, 
      4	  14284                ((curTmu->tLOD & ~SST_MIPMAP_LEVEL_MASK) | levelMask));
      4	  14285         GR_CHECK_SIZE();
      4	  14286       } else {
      4	  14287         /* One pass trilinear
      4	  14288          *
      4	  14289          * Make sure that the tmu's have the levels split across the
      4	  14290          * two tmu's. There are basically three cases based on what
      4	  14291          * the user might have already set on the other tmu.
      4	  14292          */        
      4	  14293         if (((tmu0->textureMode & SST_TC_BLEND) == SST_TC_BLEND) &&
      5	  14294             ((tmu1->textureMode & SST_TC_REPLACE) == SST_TC_REPLACE)) {
      5	  14295           FxU32  evenOdd[GLIDE_NUM_TMU];
      5	  14296           FxU32* curEvenOdd = evenOdd + tmu;
      5	  14297           
      6	  14298           {
      6	  14299             FxU32 i;
      6	  14300             
      7	  14301             for(i = 0; i < GLIDE_NUM_TMU; i++) {
      7	  14302               evenOdd[i] = gc->state.tmu_config[i].tLOD & SST_LOD_ODD;
      6	  14303             }
      5	  14304           }
      5	  14305               
      5	  14306           /* 1 - The other tmu already has the even levels. */
      5	  14307           if ((otherTmu->evenOdd == GR_MIPMAPLEVELMASK_EVEN) &&
      6	  14308               (curTmu->evenOdd != GR_MIPMAPLEVELMASK_ODD)) {
      6	  14309             *curEvenOdd = SST_LOD_ODD;
      6	  14310             goto __tmuRegUpdate;

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      5	  14311           }
      5	  14312 
      5	  14313           /* 2 - The other tmu already has the odd levels. */
      5	  14314           if ((otherTmu->evenOdd == GR_MIPMAPLEVELMASK_ODD) &&
      6	  14315               (curTmu->evenOdd != GR_MIPMAPLEVELMASK_EVEN)) {
      6	  14316             *curEvenOdd = 0;
      6	  14317             goto __tmuRegUpdate;
      5	  14318           }
      5	  14319 
      5	  14320           /* 3 - The other tmu already has both the levels. If the
      5	  14321            * downstream tmu's factor is lodFrac then the upstream tmu
      5	  14322            * needs to be (1 - lodFrac) and vice-versa.  
      5	  14323            */
      6	  14324           if (otherTmu->evenOdd == GR_MIPMAPLEVELMASK_BOTH) {
      6	  14325             evenOdd[0] = (((tmu0->textureMode & SST_TC_FACTOR_MASK) == SST_TC_MLODFRAC)
      6	  14326                           ? 0
      6	  14327                           : SST_LOD_ODD);
      6	  14328             evenOdd[1] = ~evenOdd[0] & SST_LOD_ODD;
      6	  14329 
      6	  14330             goto __tmuRegUpdate;
      5	  14331           }
      5	  14332 
      5	  14333           /* Do the register updates */
      6	  14334           if (0) {
      6	  14335         __tmuRegUpdate:
      6	  14336             GDBG_INFO(gc->myLevel, FN_NAME": Tri-linear fixup (0x%X : 0x%X) : (0x%X : 0x%X)\n",
      6	  14337                       tmu0->tLOD, tmu1->tLOD,
      6	  14338                       ((tmu0->tLOD & ~SST_MIPMAP_LEVEL_MASK) | evenOdd[0]),
      6	  14339                       ((tmu1->tLOD & ~SST_MIPMAP_LEVEL_MASK) | evenOdd[1]));
      6	  14340 
      6	  14341             GR_SET_EXPECTED_SIZE((sizeof(FxU32) << 1), 2);
      7	  14342             {
      7	  14343               GR_SET(eChipTMU0, SST_TMU(hw, 0), tLOD, 
      7	  14344                      ((tmu0->tLOD & ~SST_MIPMAP_LEVEL_MASK) | evenOdd[0]));
      7	  14345               GR_SET(eChipTMU1, SST_TMU(hw, 1), tLOD, 
      7	  14346                      ((tmu1->tLOD & ~SST_MIPMAP_LEVEL_MASK) | evenOdd[1]));
      6	  14347             }
      6	  14348             GR_CHECK_SIZE();
      5	  14349           }
      4	  14350         }
      3	  14351       }
      2	  14352     }
      1	  14353   }
      1	  14354   
      1	  14355   GR_END();
      1	  14356 #undef FN_NAME
      1	  14357 }
	  14358 
	  14359 /*---------------------------------------------------------------------------
	  14360 ** grTexClampMode
	  14361 */
	  14362 GR_ENTRY(grTexClampMode, void, 
	  14363          (GrChipID_t tmu, 
	  14364           GrTextureClampMode_t s_clamp_mode, GrTextureClampMode_t t_clamp_mode))
      1	  14365 {
      1	  14366 #define FN_NAME "grTexClampMode"
      1	  14367   FxU32 texturemode;

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14368   FxU32 clampMode =((s_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPS : 0) |
      1	  14369                     (t_clamp_mode == GR_TEXTURECLAMP_CLAMP ? SST_TCLAMPT : 0));
      1	  14370 
      1	  14371   GR_BEGIN("grTexClampMode",88,4, 1);
      1	  14372   GDBG_INFO_MORE(gc->myLevel,"(%d, %d,%d)\n",tmu,s_clamp_mode,t_clamp_mode);
      1	  14373   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14374   
      1	  14375   texturemode  = gc->state.tmu_config[tmu].textureMode;
      1	  14376   texturemode &= ~(SST_TCLAMPS | SST_TCLAMPT);
      1	  14377   texturemode |=  clampMode;
      1	  14378 
      1	  14379   GR_SET((0x02UL << tmu), SST_TMU(hw, tmu), textureMode, texturemode);
      1	  14380   gc->state.tmu_config[tmu].textureMode = texturemode;
      1	  14381   GR_END();
      1	  14382 #undef FN_NAME
      1	  14383 } /* grTexClampMode */
	  14384 
	  14385 /*---------------------------------------------------------------------------
	  14386 ** grTexCombine
	  14387 */
	  14388 GR_ENTRY(grTexCombine, void, 
	  14389          (GrChipID_t tmu,
	  14390           GrCombineFunction_t rgb_function, GrCombineFactor_t rgb_factor,  
	  14391           GrCombineFunction_t alpha_function, GrCombineFactor_t alpha_factor, 
	  14392           FxBool rgb_invert, FxBool alpha_invert))
      1	  14393 {
      1	  14394 #define FN_NAME "grTexCombine"
      1	  14395   FxU32 texturemode;
      1	  14396   FxU32 tLod;
      1	  14397   FxU32 tmuMask;
      1	  14398   FxBool localColorP = FXFALSE;
      1	  14399   FxBool localAlphaP = FXFALSE;
      1	  14400 
      1	  14401   GR_BEGIN_NOFIFOCHECK("grTexCombine",88);
      1	  14402   GDBG_INFO_MORE(gc->myLevel,"(%d, %d,%d, %d,%d, %d,%d)\n",
      1	  14403                  tmu, rgb_function, rgb_factor, 
      1	  14404                  alpha_function, alpha_factor,
      1	  14405                  rgb_invert, alpha_invert);
      1	  14406   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14407   GR_CHECK_W(FN_NAME,
      1	  14408              rgb_function < GR_COMBINE_FUNCTION_ZERO ||
      1	  14409              rgb_function > GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA,
      1	  14410              "unsupported texture color combine function");
      1	  14411   GR_CHECK_W(FN_NAME,
      1	  14412              alpha_function < GR_COMBINE_FUNCTION_ZERO ||
      1	  14413              alpha_function > GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA,
      1	  14414              "unsupported texture alpha combine function");
      1	  14415   GR_CHECK_W(FN_NAME,
      1	  14416              (rgb_factor & 0x7) < GR_COMBINE_FACTOR_ZERO ||
      1	  14417              (rgb_factor & 0x7) > GR_COMBINE_FACTOR_LOD_FRACTION ||
      1	  14418              rgb_factor > GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION,
      1	  14419              "unsupported texture color combine scale factor");
      1	  14420   GR_CHECK_W(FN_NAME,
      1	  14421              (alpha_factor & 0x7) < GR_COMBINE_FACTOR_ZERO ||
      1	  14422              (alpha_factor & 0x7) > GR_COMBINE_FACTOR_LOD_FRACTION ||
      1	  14423              alpha_factor > GR_COMBINE_FACTOR_ONE_MINUS_LOD_FRACTION,
      1	  14424              "unsupported texture alpha combine scale factor");

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14425 
      1	  14426 
      1	  14427   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  14428                          (rgb_factor != alpha_factor) &&
      1	  14429                          (((rgb_factor & 0x07UL) == GR_COMBINE_FACTOR_DETAIL_FACTOR) ||
      1	  14430                           ((rgb_factor & 0x07UL) == GR_COMBINE_FACTOR_LOD_FRACTION)) &&
      1	  14431                          (((alpha_factor & 0x07UL) == GR_COMBINE_FACTOR_DETAIL_FACTOR) ||
      1	  14432                           ((alpha_factor & 0x07UL) == GR_COMBINE_FACTOR_LOD_FRACTION)),
      1	  14433                          "Incompatible texture combine factors (rgb vs alpha) based on lod");
      1	  14434   
      1	  14435   texturemode = gc->state.tmu_config[tmu].textureMode;
      1	  14436   texturemode &= ~(SST_TCOMBINE | SST_TACOMBINE);
      1	  14437   tLod = gc->state.tmu_config[tmu].tLOD;
      1	  14438   tLod &= ~(SST_LOD_ODD);
      1	  14439 
      1	  14440   /* tmuMask tells grColorCombineFunction what to turn off an on if
      1	  14441    * the ccFunc requires texture mapping 
      1	  14442    */
      1	  14443   tmuMask = GR_TMUMASK_TMU0 << tmu;
      1	  14444   gc->state.tmuMask &= ~tmuMask;
      1	  14445 
      1	  14446   /* setup scale factor bits */
      1	  14447   texturemode |= (rgb_factor & 0x7) << SST_TC_MSELECT_SHIFT;
      1	  14448   if (!(rgb_factor & 0x8)) texturemode |= SST_TC_REVERSE_BLEND;
      1	  14449   if (((rgb_factor & 0x7) == GR_COMBINE_FACTOR_LOCAL) ||
      1	  14450        ((rgb_factor & 0x7) == GR_COMBINE_FACTOR_LOCAL_ALPHA))
      1	  14451     gc->state.tmuMask |= tmuMask;
      1	  14452 
      1	  14453   texturemode |= (alpha_factor & 0x7) << SST_TCA_MSELECT_SHIFT;
      1	  14454   if (!(alpha_factor & 0x8)) texturemode |= SST_TCA_REVERSE_BLEND;
      1	  14455   if (((alpha_factor & 0x7) == GR_COMBINE_FACTOR_LOCAL) ||
      1	  14456        ((alpha_factor & 0x7) == GR_COMBINE_FACTOR_LOCAL_ALPHA))
      1	  14457     gc->state.tmuMask |= tmuMask;
      1	  14458 
      1	  14459   /* setup invert output bits */
      1	  14460   if (rgb_invert) texturemode |= SST_TC_INVERT_OUTPUT;
      1	  14461   if (alpha_invert) texturemode |= SST_TCA_INVERT_OUTPUT;
      1	  14462 
      1	  14463   /* setup core color combine unit bits */
      2	  14464   switch (rgb_function) {
      2	  14465   case GR_COMBINE_FUNCTION_ZERO:
      2	  14466     texturemode |= SST_TC_ZERO_OTHER;
      2	  14467     localColorP = FXTRUE;
      2	  14468     break;
      2	  14469 
      2	  14470   case GR_COMBINE_FUNCTION_LOCAL:
      2	  14471     texturemode |= SST_TC_ZERO_OTHER | SST_TC_ADD_CLOCAL;
      2	  14472     gc->state.tmuMask |= tmuMask;
      2	  14473     localColorP = FXTRUE;
      2	  14474     break;
      2	  14475 
      2	  14476   case GR_COMBINE_FUNCTION_LOCAL_ALPHA:
      2	  14477     texturemode |= SST_TC_ZERO_OTHER | SST_TC_ADD_ALOCAL;
      2	  14478     gc->state.tmuMask |= tmuMask;
      2	  14479     localColorP = FXTRUE;
      2	  14480     break;
      2	  14481 

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      2	  14482   case GR_COMBINE_FUNCTION_SCALE_OTHER:
      2	  14483     break;
      2	  14484 
      2	  14485   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL:
      2	  14486     texturemode |= SST_TC_ADD_CLOCAL;
      2	  14487     gc->state.tmuMask |= tmuMask;
      2	  14488     break;
      2	  14489 
      2	  14490   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA:
      2	  14491     texturemode |= SST_TC_ADD_ALOCAL;
      2	  14492     gc->state.tmuMask |= tmuMask;
      2	  14493     break;
      2	  14494 
      2	  14495   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL:
      2	  14496     texturemode |= SST_TC_SUB_CLOCAL;
      2	  14497     gc->state.tmuMask |= tmuMask;
      2	  14498     break;
      2	  14499 
      2	  14500   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL:
      2	  14501     texturemode |= SST_TC_SUB_CLOCAL | SST_TC_ADD_CLOCAL;
      2	  14502     gc->state.tmuMask |= tmuMask;
      2	  14503     break;
      2	  14504 
      2	  14505   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14506     texturemode |= SST_TC_SUB_CLOCAL | SST_TC_ADD_ALOCAL;
      2	  14507     gc->state.tmuMask |= tmuMask;
      2	  14508     break;
      2	  14509 
      2	  14510   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL:
      2	  14511     texturemode |= SST_TC_ZERO_OTHER | SST_TC_SUB_CLOCAL | SST_TC_ADD_CLOCAL;
      2	  14512     gc->state.tmuMask |= tmuMask;
      2	  14513     localColorP = ((rgb_factor & 0x07UL) != GR_COMBINE_FACTOR_OTHER_ALPHA);
      2	  14514     break;
      2	  14515 
      2	  14516   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14517     texturemode |= SST_TC_ZERO_OTHER | SST_TC_SUB_CLOCAL | SST_TC_ADD_ALOCAL;
      2	  14518     gc->state.tmuMask |= tmuMask;
      2	  14519     localColorP = ((rgb_factor & 0x07UL) != GR_COMBINE_FACTOR_OTHER_ALPHA);
      2	  14520     break;
      1	  14521   }
      1	  14522   
      2	  14523   switch (alpha_function) {
      2	  14524   case GR_COMBINE_FUNCTION_ZERO:
      2	  14525     texturemode |= SST_TCA_ZERO_OTHER;
      2	  14526     localAlphaP = FXTRUE;
      2	  14527     break;
      2	  14528 
      2	  14529   case GR_COMBINE_FUNCTION_LOCAL:
      2	  14530     texturemode |= SST_TCA_ZERO_OTHER | SST_TCA_ADD_CLOCAL;
      2	  14531     gc->state.tmuMask |= tmuMask;
      2	  14532     localAlphaP = FXTRUE;
      2	  14533     break;
      2	  14534 
      2	  14535   case GR_COMBINE_FUNCTION_LOCAL_ALPHA:
      2	  14536     texturemode |= SST_TCA_ZERO_OTHER | SST_TCA_ADD_ALOCAL;
      2	  14537     gc->state.tmuMask |= tmuMask;
      2	  14538     localAlphaP = FXTRUE;

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      2	  14539     break;
      2	  14540 
      2	  14541   case GR_COMBINE_FUNCTION_SCALE_OTHER:
      2	  14542     break;
      2	  14543 
      2	  14544   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL:
      2	  14545     texturemode |= SST_TCA_ADD_CLOCAL;
      2	  14546     gc->state.tmuMask |= tmuMask;
      2	  14547     break;
      2	  14548 
      2	  14549   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA:
      2	  14550     texturemode |= SST_TCA_ADD_ALOCAL;
      2	  14551     gc->state.tmuMask |= tmuMask;
      2	  14552     break;
      2	  14553 
      2	  14554   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL:
      2	  14555     texturemode |= SST_TCA_SUB_CLOCAL;
      2	  14556     gc->state.tmuMask |= tmuMask;
      2	  14557     break;
      2	  14558 
      2	  14559   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL:
      2	  14560     texturemode |= SST_TCA_SUB_CLOCAL | SST_TCA_ADD_CLOCAL;
      2	  14561     gc->state.tmuMask |= tmuMask;
      2	  14562     break;
      2	  14563 
      2	  14564   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14565     texturemode |= SST_TCA_SUB_CLOCAL | SST_TCA_ADD_ALOCAL;
      2	  14566     gc->state.tmuMask |= tmuMask;
      2	  14567     break;
      2	  14568 
      2	  14569   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL:
      2	  14570     texturemode |= SST_TCA_ZERO_OTHER | SST_TCA_SUB_CLOCAL | SST_TCA_ADD_CLOCAL;
      2	  14571     gc->state.tmuMask |= tmuMask;
      2	  14572     localAlphaP = ((alpha_factor & 0x07UL) != GR_COMBINE_FACTOR_OTHER_ALPHA);
      2	  14573     break;
      2	  14574 
      2	  14575   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14576     texturemode |= SST_TCA_ZERO_OTHER | SST_TCA_SUB_CLOCAL | SST_TCA_ADD_ALOCAL;
      2	  14577     gc->state.tmuMask |= tmuMask;
      2	  14578     localAlphaP = ((alpha_factor & 0x07UL) != GR_COMBINE_FACTOR_OTHER_ALPHA);
      2	  14579     break;
      1	  14580   }
      1	  14581   
      1	  14582   /* Hack to enable TWO-PASS Trilinear */
      2	  14583   if (texturemode & SST_TRILINEAR) {
      2	  14584     if ((texturemode & SST_TC_ZERO_OTHER) &&
      2	  14585          (texturemode & SST_TC_BLEND_LODFRAC) &&
      3	  14586          !(texturemode & SST_TC_REVERSE_BLEND)) {
      3	  14587         tLod |= SST_LOD_ODD;
      2	  14588     }
      1	  14589   }
      1	  14590   tLod |= _gr_evenOdd_xlate_table[gc->state.tmu_config[tmu].evenOdd];
      1	  14591 
      1	  14592   /* Update shadows */
      1	  14593   gc->state.tmu_config[tmu].textureMode = texturemode;
      1	  14594   gc->state.tmu_config[tmu].tLOD = tLod;
      1	  14595 

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14596 #if 1
      1	  14597   /* If the state of a tmu changes from active then make sure that it
      1	  14598    * is addressing some valid tiny texture so taht it does not spend
      1	  14599    * time thrashing on a large texture access.
      1	  14600    *
      1	  14601    * NB: We don't update the shadow here so the other bits in the
      1	  14602    * register shadow should be unchanged.
      1	  14603    */
      2	  14604   {
      2	  14605     const FxI32 upstreamTmu = tmu + 1;
      2	  14606 
      3	  14607     if (upstreamTmu < gc->num_tmu) {
      4	  14608       if (localColorP && localAlphaP) {
      4	  14609         SstRegs* tmuHw = SST_TMU(hw, upstreamTmu);
      4	  14610         
      4	  14611         GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      4	  14612         GR_SET((0x02UL << upstreamTmu), tmuHw, tLOD, SST_TLOD_MINMAX_INT(GR_LOD_1, GR_LOD_1));
      4	  14613         GR_CHECK_SIZE();
      4	  14614         
      4	  14615         gc->hwDep.cvgDep.tmuLodDisable[upstreamTmu] = FXTRUE;
      4	  14616         
      4	  14617         GDBG_INFO(gc->myLevel, FN_NAME": Disabling tmu(%ld) : (0x%X : 0x%X)\n", 
      4	  14618                   upstreamTmu, rgb_function, alpha_function);
      4	  14619       } else if (gc->hwDep.cvgDep.tmuLodDisable[upstreamTmu]) {
      4	  14620         SstRegs* tmuHw = SST_TMU(hw, upstreamTmu);
      4	  14621         
      4	  14622         GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      4	  14623         GR_SET((0x02UL << upstreamTmu), tmuHw, tLOD, gc->state.tmu_config[upstreamTmu].tLOD);
      4	  14624         GR_CHECK_SIZE();
      4	  14625         
      4	  14626         gc->hwDep.cvgDep.tmuLodDisable[upstreamTmu] = FXFALSE;
      3	  14627       }
      2	  14628     }
      2	  14629     /* If this tmu is inactive then also do the reset for the register
      2	  14630      * write, but not in the shadow so that the remaining bits are
      2	  14631      * retained.
      2	  14632      */
      3	  14633     if ((gc->state.tmuMask & tmuMask) == 0) {
      3	  14634       tLod = SST_TLOD_MINMAX_INT(GR_LOD_1, GR_LOD_1);
      2	  14635     }
      1	  14636   }
      1	  14637 #endif
      1	  14638 
      1	  14639   /* update register */
      2	  14640   {
      2	  14641     SstRegs* tmuHw = SST_TMU(hw, tmu);
      2	  14642     
      3	  14643     REG_GROUP_BEGIN((0x02 << tmu), textureMode, 2, 0x3);
      4	  14644     {
      4	  14645       REG_GROUP_SET(tmuHw, textureMode , texturemode);
      4	  14646       REG_GROUP_SET(tmuHw, tLOD, tLod);
      3	  14647     }
      2	  14648     REG_GROUP_END();
      1	  14649   }
      1	  14650 
      1	  14651   /* Make sure that the trilinear blending bits are set in a
      1	  14652    * consistent manner across the tmu's.  This only really matters if

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14653    * we have multiple tmu's, but this state is really setup across
      1	  14654    * multiple calls (grTexCombine, grTexMipMapMode, and
      1	  14655    * grTexSource).  
      1	  14656    * 
      1	  14657    * NB: This must happen after the shadows are updated because
      1	  14658    * _grTexCheckTriLinear() will use the shadow register values
      1	  14659    * to determine the current state of trilinearness.
      1	  14660    */
      1	  14661   if (gc->num_tmu > 1) _grTexCheckTriLinear(tmu);
      1	  14662 
      1	  14663   /* update paramIndex */
      1	  14664   _grUpdateParamIndex();
      1	  14665 
      1	  14666   GR_END();
      1	  14667 #undef FN_NAME
      1	  14668 } /* grTexCombine */
	  14669 
	  14670 /*
	  14671 ** _grTexDetailControl, NOTE: its up to caller to account for bytes
	  14672 */
	  14673 GR_DDFUNC(_grTexDetailControl, void, (GrChipID_t tmu, FxU32 detail))
      1	  14674 {
      1	  14675 #define FN_NAME "_grTexDetailControl"
      1	  14676   GR_BEGIN(FN_NAME,88,4, 1);
      1	  14677   GDBG_INFO_MORE(gc->myLevel, "(%d, 0x%X)\n", tmu, detail);
      1	  14678   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14679 
      1	  14680   GR_SET((0x02UL << tmu), SST_TMU(hw, tmu), tDetail, detail);
      1	  14681   gc->state.tmu_config[tmu].tDetail = detail;
      1	  14682 
      1	  14683   GR_END();
      1	  14684 #undef FN_NAME
      1	  14685 } /* _grTexDetailControl */
	  14686 
	  14687 /*---------------------------------------------------------------------------
	  14688 ** grTexFilterMode
	  14689 */
	  14690 
	  14691 GR_ENTRY(grTexFilterMode, void, 
	  14692          (GrChipID_t tmu, GrTextureFilterMode_t minfilter, GrTextureFilterMode_t magfilter))
      1	  14693 {
      1	  14694 #define FN_NAME "grTexFilterMode"
      1	  14695   FxU32 texMode;
      1	  14696 
      1	  14697   GR_BEGIN("grTexFilterMode",99,4, 1);
      1	  14698   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,%d)\n",tmu,minfilter,magfilter);
      1	  14699   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14700 
      1	  14701   texMode  = gc->state.tmu_config[tmu].textureMode;
      1	  14702   texMode &= ~(SST_TMINFILTER | SST_TMAGFILTER);
      1	  14703   texMode |= (minfilter == GR_TEXTUREFILTER_BILINEAR ? SST_TMINFILTER : 0) |
      1	  14704              (magfilter == GR_TEXTUREFILTER_BILINEAR ? SST_TMAGFILTER : 0);
      1	  14705 
      1	  14706   GR_SET((0x02UL << tmu), SST_TMU(hw, tmu), textureMode, texMode);
      1	  14707   gc->state.tmu_config[tmu].textureMode = texMode;
      1	  14708 
      1	  14709   GR_END();

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14710 #undef FN_NAME
      1	  14711 } /* grTexFilterMode */
	  14712 
	  14713 /*---------------------------------------------------------------------------
	  14714 ** grTexLodBiasValue
	  14715 */
	  14716 
	  14717 GR_ENTRY(grTexLodBiasValue, void, 
	  14718          (GrChipID_t tmu, float fvalue))
      1	  14719 {
      1	  14720 #define FN_NAME "grTexLodBiasValue"
      1	  14721   FxU32 tLod;
      1	  14722   
      1	  14723   GR_BEGIN("grTexLodBiasValue",88,4, 1);
      1	  14724   GDBG_INFO_MORE(gc->myLevel,"(%d,%g)\n",tmu,fvalue);
      1	  14725   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14726   
      1	  14727   tLod = gc->state.tmu_config[tmu].tLOD;
      1	  14728   tLod &= ~(SST_LODBIAS);
      1	  14729   tLod |= _grTexFloatLODToFixedLOD(fvalue) << SST_LODBIAS_SHIFT;
      1	  14730 
      1	  14731   GR_SET((0x02 << tmu), SST_TMU(hw, tmu), tLOD, tLod);
      1	  14732   gc->state.tmu_config[tmu].tLOD = tLod;
      1	  14733 
      1	  14734   GR_END();
      1	  14735 #undef FN_NAME
      1	  14736 } /* grTexLodBiasValue */
	  14737 
	  14738 /*-------------------------------------------------------------------
	  14739   Function: grTexMipMapMode
	  14740   Date: 6/2
	  14741   Implementor(s): GaryMcT, Jdt
	  14742   Library: glide
	  14743   Description:
	  14744     Sets the mip map mode for the specified TMU
	  14745     "Ex" because glide's grTexMipMapMode is inadequate for 
	  14746     low level texture memory management
	  14747   Arguments:
	  14748     tmu       - tmu to update
	  14749     mmMode   - mipmap mode 
	  14750       One of:
	  14751         GR_MIPMAP_DISABLE
	  14752         GR_MIPMAP_NEAREST
	  14753         GR_MIPMAP_NEAREST_DITHER
	  14754     lodBlend - enable lodBlending
	  14755       FXTRUE  - enabled
	  14756       FXFALSE - disabled
	  14757   Return:
	  14758   none
	  14759   -------------------------------------------------------------------*/
	  14760 
	  14761 GR_ENTRY(grTexMipMapMode, void, 
	  14762          (GrChipID_t tmu, GrMipMapMode_t mmMode, FxBool lodBlend))
      1	  14763 {
      1	  14764 #define FN_NAME "grTexMipMapMode"
      1	  14765   FxU32
      1	  14766     tLod,

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14767     texMode;
      1	  14768 
      1	  14769   GR_BEGIN_NOFIFOCHECK("grTexMipMapMode",88);
      1	  14770   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,%d)\n",tmu,mmMode,lodBlend);
      1	  14771   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14772 
      1	  14773   /*--------------------------------------------------------------
      1	  14774     Get Current tLod and texMode register values
      1	  14775     --------------------------------------------------------------*/
      1	  14776   tLod  = gc->state.tmu_config[tmu].tLOD;
      1	  14777   texMode = gc->state.tmu_config[tmu].textureMode;
      1	  14778 
      1	  14779   /*--------------------------------------------------------------
      1	  14780     Clear LODMIN, LODMAX and LODDITHER
      1	  14781     --------------------------------------------------------------*/
      1	  14782   tLod    &= ~(SST_LODMIN | SST_LODMAX | SST_LOD_ODD);
      1	  14783   texMode &= ~(SST_TLODDITHER | SST_TRILINEAR);
      1	  14784 
      1	  14785   /*--------------------------------------------------------------
      1	  14786     Encode Mipmap Mode Bits
      1	  14787     --------------------------------------------------------------*/
      2	  14788   switch (mmMode) {
      2	  14789   case GR_MIPMAP_DISABLE:
      2	  14790     /*----------------------------------------------------------
      2	  14791       To disable mipmapping set the min and max lods to the same
      2	  14792       value
      2	  14793       ----------------------------------------------------------*/
      2	  14794     tLod |= SST_TLOD_MINMAX_INT(gc->state.tmu_config[tmu].largeLod,
      2	  14795                                 gc->state.tmu_config[tmu].largeLod);
      2	  14796     break;
      2	  14797 
      2	  14798   case GR_MIPMAP_NEAREST_DITHER:
      2	  14799     if (gc->state.allowLODdither) texMode |= SST_TLODDITHER;
      2	  14800     /* intentional fall-through to set lodmin and lodmax values */
      2	  14801 
      2	  14802   case GR_MIPMAP_NEAREST:
      2	  14803     /*----------------------------------------------------------
      2	  14804       Set LODMIN and LODMAX in the tLod register to the 
      2	  14805       actual min and max LODs of the current texture.
      2	  14806       ----------------------------------------------------------*/
      2	  14807     tLod |= SST_TLOD_MINMAX_INT(gc->state.tmu_config[tmu].largeLod,
      2	  14808                                 gc->state.tmu_config[tmu].smallLod);
      2	  14809     break;
      2	  14810 
      2	  14811   default:
      2	  14812     GrErrorCallback("grTexMipMapMode:  invalid mode passed", FXFALSE);
      2	  14813     break;
      1	  14814   }
      1	  14815   gc->state.tmu_config[tmu].mmMode = mmMode;
      1	  14816 
      1	  14817   /* Force LOD dithering if the user asked for it.
      1	  14818    *
      1	  14819    * NB: There is a performance hit for this, but it does
      1	  14820    * look better.
      1	  14821    */
      1	  14822   texMode |= _GlideRoot.environment.texLodDither;
      1	  14823 

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14824   /*--------------------------------------------------------------
      1	  14825     Fix trilinear and evenOdd bits -
      1	  14826 
      1	  14827     This is a bit of a hack to make two pass trilinear work with
      1	  14828     full textures.  The assumption here is that the only reason
      1	  14829     you would ever set up Multiply by LODFRAC w/o REVERSE BLEND
      1	  14830     is for the ODD pass of trilinear.  
      1	  14831     --------------------------------------------------------------*/
      2	  14832   if (lodBlend) {
      2	  14833     /* If we're doing trilinear for real then nuke the lod dithering
      2	  14834      * at the same time because it just looks bad.  
      2	  14835      */
      2	  14836     texMode = ((texMode & ~SST_TLODDITHER) | SST_TRILINEAR);
      2	  14837 
      2	  14838     if ((texMode & SST_TC_ZERO_OTHER) &&
      2	  14839         (texMode & SST_TC_BLEND_LODFRAC) &&
      3	  14840         !(texMode & SST_TC_REVERSE_BLEND)) {
      3	  14841         tLod |= SST_LOD_ODD;
      2	  14842     }
      1	  14843   }
      1	  14844   tLod |= _gr_evenOdd_xlate_table[gc->state.tmu_config[tmu].evenOdd];
      1	  14845   
      1	  14846   /*--------------------------------------------------------------
      1	  14847     Write State To Hardware and Update Glide Shadow State
      1	  14848     --------------------------------------------------------------*/
      1	  14849   hw = SST_TMU(hw, tmu);
      2	  14850   REG_GROUP_BEGIN((0x02UL << tmu), textureMode, 2, 0x03);
      3	  14851   {
      3	  14852     REG_GROUP_SET(hw, textureMode , texMode);
      3	  14853     REG_GROUP_SET(hw, tLOD , tLod);
      2	  14854   }
      1	  14855   REG_GROUP_END();
      1	  14856 
      1	  14857   gc->state.tmu_config[tmu].tLOD        = tLod;
      1	  14858   gc->state.tmu_config[tmu].textureMode = texMode;
      1	  14859 
      1	  14860   /* Make sure that the trilinear blending bits are set in a
      1	  14861    * consistent manner across the tmu's.  This only really matters if
      1	  14862    * we have multiple tmu's, but this state is really setup across
      1	  14863    * multiple calls (grTexCombine, grTexMipMapMode, and
      1	  14864    * grTexSource).  
      1	  14865    * 
      1	  14866    * NB: This must happen after the shadows are updated because
      1	  14867    * _grTexCheckTriLinear() will use the shadow register values
      1	  14868    * to determine the current state of trilinearness.
      1	  14869    */
      1	  14870   if (gc->num_tmu > 1) _grTexCheckTriLinear(tmu);
      1	  14871 
      1	  14872   GR_END();
      1	  14873 #undef FN_NAME
      1	  14874 } /* grTexMipMapMode */
	  14875 
	  14876 /*-------------------------------------------------------------------
	  14877   Function: grTexMinAddress
	  14878   Date: 6/2
	  14879   Implementor(s): GaryMcT, Jdt
	  14880   Library: glide

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

	  14881   Description:
	  14882     Returns address of start of texture ram for a TMU
	  14883   Arguments:
	  14884     tmu
	  14885   Return:
	  14886     integer texture base address, this pointer is not to be dereferenced
	  14887     by the application, it is on to be used by grTexDownload(),
	  14888     and grTExDownloadLevel()
	  14889   -------------------------------------------------------------------*/
	  14890 /*-------------------------------------------------------------------
	  14891   Function: grTexNCCTable
	  14892   Date: 6/3
	  14893   Implementor(s): jdt
	  14894   Library: glide
	  14895   Description:
	  14896     select one of the two NCC tables
	  14897   Arguments:
	  14898     tmu - which tmu
	  14899     table - which table to select
	  14900         One of:
	  14901             GR_TEXTABLE_NCC0
	  14902             GR_TEXTABLE_NCC1
	  14903             GR_TEXTABLE_PALETTE
	  14904   Return:
	  14905     none
	  14906   -------------------------------------------------------------------*/
	  14907 
	  14908 GR_ENTRY(grTexNCCTable, void, 
	  14909          (GrChipID_t tmu, GrNCCTable_t table))
      1	  14910 {
      1	  14911 #define FN_NAME "grTexNCCTable"
      1	  14912   FxU32 texMode;
      1	  14913   
      1	  14914   GR_BEGIN("grTexNCCTable",88,4, 1);
      1	  14915   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",tmu);
      1	  14916   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14917   GR_CHECK_F(FN_NAME, table > GR_TEXTABLE_PALETTE, "invalid ncc table specified");
      1	  14918 
      1	  14919   /*------------------------------------------------------------------
      1	  14920     Update local state
      1	  14921     ------------------------------------------------------------------*/
      1	  14922   gc->state.tmu_config[tmu].nccTable = table;
      1	  14923   
      1	  14924   /*------------------------------------------------------------------
      1	  14925     Grab shadow texMode, update TexMode, update shadow/real register
      1	  14926     ------------------------------------------------------------------*/
      1	  14927   texMode  = gc->state.tmu_config[tmu].textureMode;
      1	  14928   texMode &= ~(SST_TNCCSELECT);
      1	  14929   if (table == GR_TEXTABLE_NCC1)
      1	  14930     texMode |= SST_TNCCSELECT;
      1	  14931   else 
      1	  14932     texMode &= ~(SST_TNCCSELECT);
      1	  14933 
      1	  14934   GR_SET((0x02UL << tmu), SST_TMU(hw, tmu), textureMode, texMode);
      1	  14935   gc->state.tmu_config[tmu].textureMode = texMode;
      1	  14936 
      1	  14937   GR_END();

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14938 #undef FN_NAME
      1	  14939 } /* grTexNCCTable */
	  14940 
	  14941 /*-------------------------------------------------------------------
	  14942   Function: grTexSource
	  14943   Date: 6/2
	  14944   Implementor(s): GaryMcT, Jdt
	  14945   Library: glide
	  14946   Description:
	  14947     Sets up the current texture for texture mapping on the specified
	  14948     TMU.
	  14949   Arguments:
	  14950     tmu          - which tmu
	  14951     startAddress - texture start address
	  14952     evenOdd  - which set of mipmap levels have been downloaded for
	  14953                 the selected texture
	  14954                 One of:
	  14955                   GR_MIPMAPLEVELMASK_EVEN 
	  14956                   GR_MIPMAPLEVELMASK_ODD
	  14957                   GR_MIPMAPLEVELMASK_BOTH
	  14958     info         - pointer to GrTexInfo structure containing
	  14959                    texture dimensions
	  14960   Return:
	  14961     none
	  14962   -------------------------------------------------------------------*/
	  14963 GR_ENTRY(grTexSource, void, 
	  14964          (GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info))
      1	  14965 {
      1	  14966 #define FN_NAME "grTexSource"
      1	  14967   FxU32 baseAddress, texMode, tLod;
      1	  14968 
      1	  14969   GR_BEGIN_NOFIFOCHECK("grTexSource",88);
      1	  14970   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x,%d,0x%x)\n",tmu,startAddress,evenOdd,info);
      1	  14971   GR_CHECK_TMU(FN_NAME, tmu);
      1	  14972   GR_CHECK_COMPATABILITY(FN_NAME, 
      1	  14973                          startAddress >= gc->tmu_state[tmu].total_mem, 
      1	  14974                          "invalid startAddress");
      1	  14975 
      1	  14976   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  14977                          (startAddress + grTexTextureMemRequired(evenOdd, info) >= 
      1	  14978                           gc->tmu_state[tmu].total_mem),
      1	  14979                          "insufficient texture ram at startAddress");
      1	  14980   GR_CHECK_F(FN_NAME, evenOdd > 0x3 || evenOdd == 0, "evenOdd mask invalid");
      1	  14981   GR_CHECK_F(FN_NAME, !info, "invalid info pointer");
      1	  14982   
      1	  14983   /*-------------------------------------------------------------
      1	  14984     Update Texture Unit State
      1	  14985     -------------------------------------------------------------*/
      1	  14986   gc->state.tmu_config[tmu].smallLod = info->smallLod;
      1	  14987   gc->state.tmu_config[tmu].largeLod = info->largeLod;
      1	  14988   gc->state.tmu_config[tmu].evenOdd  = evenOdd; 
      1	  14989   
      1	  14990   /*-------------------------------------------------------------
      1	  14991     Calculate Base Address
      1	  14992     -------------------------------------------------------------*/
      1	  14993   baseAddress = _grTexCalcBaseAddress(startAddress,
      1	  14994                                       info->largeLod,

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  14995                                       info->aspectRatio,
      1	  14996                                       info->format,
      1	  14997                                       evenOdd) >> 3;
      1X  14998 #if (GLIDE_PLATFORM & GLIDE_HW_H3)
      1X  14999   baseAddress = ((baseAddress << 3) & ~0x0F);
      1X  15000   baseAddress += 0x200000;
      1X  15001 #endif
      1	  15002   
      1	  15003   /*-------------------------------------------------------------
      1	  15004     Update Texture Mode
      1	  15005     -------------------------------------------------------------*/
      1	  15006   texMode = gc->state.tmu_config[tmu].textureMode;
      1	  15007   texMode &= ~SST_TFORMAT;
      1	  15008   texMode |= (info->format << SST_TFORMAT_SHIFT) | SST_TPERSP_ST | SST_TCLAMPW;
      1	  15009   
      1	  15010   /*-------------------------------------------------------------
      1	  15011     Compute TLOD (keep LODBIAS in tact)
      1	  15012     -------------------------------------------------------------*/
      1	  15013   tLod = gc->state.tmu_config[tmu].tLOD;
      1	  15014   tLod &= ~(SST_LODMIN | 
      1	  15015             SST_LODMAX | 
      1	  15016             SST_LOD_ASPECT |
      1	  15017             SST_LOD_TSPLIT | 
      1	  15018             SST_LOD_ODD | 
      1	  15019             SST_LOD_S_IS_WIDER);
      1	  15020   tLod |= SST_TLOD_MINMAX_INT(info->largeLod,
      1	  15021                               ((gc->state.tmu_config[tmu].mmMode == GR_MIPMAP_DISABLE)
      1	  15022                                ? info->largeLod
      1	  15023                                : info->smallLod));
      1	  15024   tLod |= _gr_evenOdd_xlate_table[evenOdd];
      1	  15025   tLod |= _gr_aspect_xlate_table[info->aspectRatio];
      1	  15026 
      1	  15027   /* Write relevant registers out to hardware */
      1	  15028   hw = SST_TMU(hw, tmu);
      2	  15029   REG_GROUP_BEGIN((0x02UL << tmu), textureMode, 3, 0x0B);
      3	  15030   {
      3	  15031     REG_GROUP_SET(hw, textureMode , texMode);
      3	  15032     REG_GROUP_SET(hw, tLOD , tLod);
      3	  15033     REG_GROUP_SET(hw, texBaseAddr , baseAddress);
      2	  15034   }
      1	  15035   REG_GROUP_END();
      1	  15036   
      1	  15037   /* update shadows */
      1	  15038   gc->state.tmu_config[tmu].texBaseAddr = baseAddress; 
      1	  15039   gc->state.tmu_config[tmu].textureMode = texMode; 
      1	  15040   gc->state.tmu_config[tmu].tLOD        = tLod; 
      1	  15041 
      1	  15042   /* Make sure that the trilinear blending bits are set in a
      1	  15043    * consistent manner across the tmu's.  This only really matters if
      1	  15044    * we have multiple tmu's, but this state is really setup across
      1	  15045    * multiple calls (grTexCombine, grTexMipMapMode, and
      1	  15046    * grTexSource).  
      1	  15047    * 
      1	  15048    * NB: This must happen after the shadows are updated because
      1	  15049    * _grTexCheckTriLinear() will use the shadow register values
      1	  15050    * to determine the current state of trilinearness.
      1	  15051    */

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      1	  15052   if (gc->num_tmu > 1) _grTexCheckTriLinear(tmu);
      1	  15053   
      1	  15054   GR_END();
      1	  15055 #undef FN_NAME
      1	  15056 }
	  15057 
	  15058 /*-------------------------------------------------------------------
	  15059   Function: grTexMultibase
	  15060   Date: 11/4/96
	  15061   Implementor(s): gmt
	  15062   Library: Glide
	  15063   Description:
	  15064     Enable multiple base addresses for texturing.
	  15065   Arguments:
	  15066     tmu    - which tmu
	  15067     enable - flag which enables/disables multibase
	  15068   Return:
	  15069     none
	  15070   -------------------------------------------------------------------*/
	  15071 
	  15072 GR_ENTRY(grTexMultibase, void, 
	  15073          (GrChipID_t tmu, FxBool enable))
      1	  15074 {
      1	  15075 #define FN_NAME "grTexMultibase"
      1	  15076   FxU32 tLod;
      1	  15077     
      1	  15078   GR_BEGIN("grTexMultibase",88,4,1);
      1	  15079   GDBG_INFO_MORE(gc->myLevel,"(%d,%d)\n",tmu,enable);
      1	  15080   GR_CHECK_TMU(FN_NAME,tmu);
      1	  15081   
      1	  15082   tLod  = gc->state.tmu_config[tmu].tLOD;
      1	  15083   if (enable)
      1	  15084     tLod |= SST_TMULTIBASEADDR;
      1	  15085   else
      1	  15086     tLod &= ~SST_TMULTIBASEADDR;
      1	  15087   /*--------------------------------------------------------------
      1	  15088     Write State To Hardware and Update Glide Shadow State
      1	  15089     --------------------------------------------------------------*/
      1	  15090   GR_SET((0x02UL << tmu), SST_TMU(hw, tmu), tLOD, tLod);
      1	  15091   gc->state.tmu_config[tmu].tLOD = tLod;
      1	  15092 
      1	  15093   GR_END();
      1	  15094 #undef FN_NAME
      1	  15095 } /* grTexMultibase */
	  15096 
	  15097 /*-------------------------------------------------------------------
	  15098   Function: grTexMultibaseAddress
	  15099   Date: 11/4/96
	  15100   Implementor(s): gmt
	  15101   Library: Glide
	  15102   Description:
	  15103     Set the base address for a particular set of mipmaps
	  15104   Arguments:
	  15105     tmu    - which tmu
	  15106     range  - range of lods that are based at this starting address
	  15107              One of:
	  15108              GR_TEXBASE_256

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

	  15109              GR_TEXBASE_128
	  15110              GR_TEXBASE_64
	  15111              GR_TEXBASE_32_TO_1
	  15112     startAddress - start address that data was downloaded to 
	  15113                     hardware with using grTexDownload/Level
	  15114     info         - pointer to GrTexInfo structure containing
	  15115                    texture dimensions
	  15116   Return:
	  15117     none
	  15118   -------------------------------------------------------------------*/
	  15119 
	  15120 GR_ENTRY(grTexMultibaseAddress, void, 
	  15121          (GrChipID_t tmu, GrTexBaseRange_t range, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info))
      1	  15122 {
      1	  15123 #define FN_NAME "grTexMultibaseAddress"
      1	  15124   FxU32 baseAddress;
      1	  15125   const FifoChipField tmuChip = (FifoChipField)(0x02UL << tmu);
      1	  15126   GR_BEGIN("grTexMultibaseAddress",88,4,1);
      1	  15127   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,0x%x)\n",tmu,range,startAddress);
      1	  15128   GR_CHECK_TMU(FN_NAME, tmu);
      1	  15129   GR_CHECK_F(FN_NAME, range > GR_TEXBASE_32_TO_1, "invalid range");
      1	  15130   GR_CHECK_F(FN_NAME, startAddress >= gc->tmu_state[tmu].total_mem, "invalid startAddress");
      1	  15131   GR_CHECK_F(FN_NAME, evenOdd > 0x3, "evenOdd mask invalid");
      1	  15132   GR_CHECK_F(FN_NAME, info, "invalid info pointer");
      1	  15133   
      1	  15134 
      1	  15135   /* Write relevant registers out to hardware and shadows */
      1	  15136   hw = SST_TMU(hw,tmu);
      2	  15137   switch (range) {
      2	  15138     case GR_TEXBASE_256:
      2	  15139       baseAddress = _grTexCalcBaseAddress(startAddress,
      2	  15140                                           GR_LOD_256,
      2	  15141                                           info->aspectRatio,
      2	  15142                                           info->format,
      2	  15143                                           evenOdd) >> 3;
      2	  15144       GR_SET(tmuChip, hw, texBaseAddr, baseAddress);
      2	  15145       gc->state.tmu_config[tmu].texBaseAddr = baseAddress; 
      2	  15146       break;
      2	  15147 
      2	  15148     case GR_TEXBASE_128:
      2	  15149       baseAddress = _grTexCalcBaseAddress(startAddress,
      2	  15150                                           GR_LOD_128,
      2	  15151                                           info->aspectRatio,
      2	  15152                                           info->format,
      2	  15153                                           evenOdd) >> 3;
      2	  15154       GR_SET(tmuChip, hw, texBaseAddr1, baseAddress);
      2	  15155       gc->state.tmu_config[tmu].texBaseAddr_1 = baseAddress; 
      2	  15156       break;
      2	  15157 
      2	  15158     case GR_TEXBASE_64:
      2	  15159       baseAddress = _grTexCalcBaseAddress(startAddress,
      2	  15160                                           GR_LOD_64,
      2	  15161                                           info->aspectRatio,
      2	  15162                                           info->format,
      2	  15163                                           evenOdd) >> 3;
      2	  15164       GR_SET(tmuChip, hw, texBaseAddr2, baseAddress);
      2	  15165       gc->state.tmu_config[tmu].texBaseAddr_2 = baseAddress; 

GTEX                            Source Listing                   9-MAY-2021 23:43:04  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  gtex.c;1

      2	  15166       break;
      2	  15167 
      2	  15168     case GR_TEXBASE_32_TO_1:
      2	  15169       baseAddress = _grTexCalcBaseAddress(startAddress,
      2	  15170                                           GR_LOD_32,
      2	  15171                                           info->aspectRatio,
      2	  15172                                           info->format,
      2	  15173                                           evenOdd) >> 3;
      2	  15174       GR_SET(tmuChip, hw, texBaseAddr38, baseAddress);
      2	  15175       gc->state.tmu_config[tmu].texBaseAddr_3_8 = baseAddress; 
      2	  15176       break;
      1	  15177   }
      1	  15178 
      1	  15179   GR_END();
      1	  15180 #undef FN_NAME
      1	  15181 } /* grTexMultibaseAddress */


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEX/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEX.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GTEX.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:04"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


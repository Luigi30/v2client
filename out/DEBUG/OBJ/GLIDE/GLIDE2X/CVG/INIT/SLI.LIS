SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Initialization code for initializing scanline interleaving
	     21 **
	     22 */
	     23 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
       X     24 #ifdef _MSC_VER
       X     25 #pragma optimize ("",off)
       X     26 #endif
	     27 #include <stdio.h>
	   1638 #include <stdlib.h>
	   3733 #include <math.h>
       X   4625 #ifdef BUILD_FOR_SST1
       X   4626 #include <sst.h>
       X   4627 #else
	   4628 #include <3dfx.h>
	   4759 #include <cvgregs.h>
	   4987 #include <cvgdefs.h>
	   5928 #endif
	   5929 #define FX_DLL_DEFINITION
	   5930 #include <fxdll.h>
	   6051 #include <sst1vid.h>
	   6161 #include <sst1init.h>
	   8799 
	   8800 /*
	   8801 ** sst1InitSli():
	   8802 **  Setup Multiple SST-1 subsystems for Scanline Interleaving
	   8803 **  sstbase0 defined to be the SLI Master
	   8804 **  sstbase1 defined to be the SLI Slave
	   8805 **
	   8806 */
	   8807 FX_EXPORT FxBool FX_CSTYLE sst1InitSli(FxU32 *sstbase0, FxU32 *sstbase1)
      1	   8808 {
      1	   8809     FxU32 j, n, MasterPhysAddr, cntr;
      1	   8810     SstRegs *sstMaster = (SstRegs *) sstbase0;
      1	   8811     SstRegs *sstSlave = (SstRegs *) sstbase1;
      1	   8812     FxU32 masterVInClkDel, masterVOutClkDel;
      1	   8813     FxU32 slaveVInClkDel, slaveVOutClkDel;
      1	   8814     FxU32 masterPVOutClkDel, slavePVOutClkDel;
      1	   8815     FxU32 pciFifoLwm, memFifoLwm;

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   8816     FxU32 memOffsetOrig, tilesInXOrig;
      1	   8817     FxU32 memOffsetNew;
      1	   8818     int memFifoEntriesNew;
      1	   8819     FxU32 memSizeInPages;
      1	   8820     FxU32 memFifoRowBaseNew;
      1	   8821     FxU32 swapAlgorithm = SST_SWAP_SLISYNC;
      1	   8822     FxU32 videoWindowActive = 0x1;
      1	   8823     FxU32 videoWindowActiveDrag = 0xf;
      1	   8824     sst1DeviceInfoStruct *sst1M, *sst1S;
      1	   8825     int i;
      1	   8826 
      1	   8827     if(sst1InitCheckBoard(sstbase1) == FXFALSE)
      1	   8828         return(FXFALSE);
      1	   8829     if(!sst1CurrentBoard->sliDetected)
      1	   8830         return(FXFALSE);
      1	   8831     sst1S = sst1CurrentBoard;
      1	   8832 
      1	   8833     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   8834         return(FXFALSE);
      1	   8835     if(!sst1CurrentBoard->sliDetected)
      1	   8836         return(FXFALSE);
      1	   8837     sst1M = sst1CurrentBoard;
      1	   8838 
      1	   8839     // Verify that the board configurations are identical
      1	   8840     //
      1	   8841     // NB: Some of the tests are no longer necessary because
      1	   8842     // the init code clients are doing the magic to make the
      1	   8843     // board appear as the minimum value for things like memory.
      1	   8844     if(/* (sst1M->fbiMemSize != sst1S->fbiMemSize) || */
      1	   8845        /*(sst1M->tmuMemSize[0] != sst1S->tmuMemSize[0]) || */
      1	   8846        (sst1M->numberTmus != sst1S->numberTmus) ||
      1	   8847         /* [koolsmoky] mismatched SLI support */
      1	   8848        (!GETENV(("SSTV2_MISMATCHED_SLI")) && (sst1M->fbiBoardID != sst1S->fbiBoardID)) ||
      1	   8849        /* (sst1M->fbiRevision != sst1S->fbiRevision) || */
      1	   8850        /* (sst1M->tmuRevision != sst1S->tmuRevision) || */
      2	   8851        (sst1M->fbiVideoStruct != sst1S->fbiVideoStruct)) {
      2	   8852          INIT_PRINTF(("sst1InitSli() ERROR: Boards types must be identical...\n"));
      2	   8853          return(FXFALSE);
      1	   8854     }
      1	   8855 
      1	   8856     // Verify that no video scanline doubling is being used...
      2	   8857     if(sst1M->fbiVideoStruct->miscCtrl & BIT(1)) {
      2	   8858        INIT_PRINTF(("sst1InitSli() ERROR: Scanline doubling not supported with SLI...\n"));
      2	   8859        return(FXFALSE);
      1	   8860     }
      1	   8861 
      1	   8862     INIT_PRINTF(("sst1InitSli(): Enabling Scanline Interleaving...\n"));
      1	   8863 
      1	   8864     // sst1Initidle() routines must be properly executed...
      1	   8865     initIdleEnabled = 1;
      1	   8866 
      1	   8867     // User override of swap algorithm...
      2	   8868     if(GETENV(("SSTV2_SLISWAP"))) {
      2	   8869        FxU32 swapAlg = ATOI(GETENV(("SSTV2_SLISWAP")));
      2	   8870 
      3	   8871        if(swapAlg == 1) {
      3	   8872           INIT_PRINTF(("sst1InitSli(): Using dac_data[0] for swapping(%d, %d)...\n", videoWindowActive, videoWindowA

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      3	   8872 ctiveDrag));
      3	   8873           swapAlgorithm = SST_SWAP_DACDATA0;
      2	   8874        }
      1	   8875     }
      1	   8876 
      1	   8877     // Get values setup by sst1InitVideo()...
      1	   8878     memOffsetOrig = (IGET(sstMaster->fbiInit2) & SST_VIDEO_BUFFER_OFFSET) >>
      1	   8879        SST_VIDEO_BUFFER_OFFSET_SHIFT;
      1	   8880     tilesInXOrig = (IGET(sstMaster->fbiInit1) & SST_VIDEO_TILES_IN_X) >>
      1	   8881        SST_VIDEO_TILES_IN_X_SHIFT;
      1	   8882     if(IGET(sstMaster->fbiInit1) & SST_VIDEO_TILES_IN_X_MSB)
      1	   8883        tilesInXOrig += 16;
      1	   8884 
      2	   8885     if(tilesInXOrig & 0x1) {
      2	   8886        // (e.g. 800x600 resolution)
      2	   8887        /*
      2	   8888          Integer formula for:
      2	   8889             memOffset =
      2	   8890                (TRUNC((xDimension/64)+.99) *
      2	   8891                 TRUNC((((yDimension/2)+1)/32)+.99))
      2	   8892        */
      2	   8893        memOffsetNew = (tilesInXOrig *
      2	   8894          ((((sst1CurrentBoard->fbiVideoHeight>>1)+1) + 31) >> 5));
      2	   8895     } else {
      2	   8896        // (e.g. 640x480 resolution)
      2	   8897        // Calculate number of tiles in the vertical dimension
      2	   8898        // Must add entire row of tiles at the bottom for fixes for
      2	   8899        // Y-Origin at lower left
      2	   8900        memOffsetNew = tilesInXOrig *
      2	   8901          (((sst1CurrentBoard->fbiVideoHeight >> 1) + 32) >> 5);
      1	   8902     }
      1	   8903 
      1	   8904     if(sst1CurrentBoard->fbiMemSize == 1)
      1	   8905       memSizeInPages = 256;
      1	   8906     else if(sst1CurrentBoard->fbiMemSize == 2)
      1	   8907       memSizeInPages = 512;
      1	   8908     else
      1	   8909       memSizeInPages = 1024;
      1	   8910 
      1	   8911     memFifoRowBaseNew = (sst1CurrentBoard->fbiVideoColBuffs +
      1	   8912       sst1CurrentBoard->fbiVideoAuxBuffs) * memOffsetNew;
      1	   8913 
      1	   8914     memFifoEntriesNew = (65536 - (int)
      1	   8915       (((int) (memSizeInPages - 1) -
      1	   8916         (int) memFifoRowBaseNew) * 512)) >> 5;
      1	   8917     if(memFifoEntriesNew <= 256)
      1	   8918       memFifoEntriesNew = 0x100; // max. memory fifo size...
      2	   8919     else if(memFifoEntriesNew >= 2048) {
      2	   8920       INIT_PRINTF(("sst1InitSli(): Invalid memFifoEntriesNew 0x%x\n",
      2	   8921         memFifoEntriesNew));
      2	   8922       return(FXFALSE);
      1	   8923     }
      1	   8924 
      1	   8925     INIT_PRINTF(("sst1InitSli(): Allocating %d Color Buffers and %d Aux Buffer(s)...\n", sst1CurrentBoard->fbiVideoC
      1	   8925 olBuffs, sst1CurrentBoard->fbiVideoAuxBuffs));
      1	   8926     INIT_PRINTF(("sst1InitSli(): Allocating Memory/Command Fifo starting at page %d...\n", memFifoRowBaseNew));
      1	   8927     INIT_PRINTF(("sst1InitSli(): Memory FIFO Entries: %d...\n",

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   8928       65536 - (memFifoEntriesNew << 5)));
      1X   8929 #if 0
      1X   8930     INIT_PRINTF(("sst1InitSli(): memOffsetOrig:%d, tilesInXOrig:%d\n",
      1X   8931       memOffsetOrig, tilesInXOrig));
      1X   8932     INIT_PRINTF(("sst1InitSli(): memOffsetNew:%d, memFifoEntriesNew:0x%x\n",
      1X   8933       memOffsetNew, memFifoEntriesNew));
      1X   8934 #endif
      1	   8935 
      1	   8936     // Setup SLI Slave...
      1	   8937     cntr = 0;
      2	   8938     while(1) {
      2	   8939         if(sst1InitCheckBoard(sstbase1) == FXFALSE)
      2	   8940             return(FXFALSE);
      2	   8941         PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      2	   8942         PCICFG_WR(SST1_PCI_INIT_ENABLE,
      2	   8943             ((j & ~SST_SCANLINE_SLV_OWNPCI) | SST_SCANLINE_SLI_SLV));
      2	   8944         ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) |
      2	   8945           (SST_VIDEO_RESET | SST_EN_SCANLINE_INTERLEAVE));
      2	   8946         sst1InitIdleFBINoNOP(sstbase1);
      2	   8947         ISET(SST_TREX(sstSlave,0)->trexInit1, sst1CurrentBoard->tmuInit1[0] |
      2	   8948             SST_EN_TEX_SCANLINE_INTERLEAVE | SST_TEX_SCANLINE_INTERLEAVE_SLAVE);
      2	   8949         sst1InitIdle(sstbase1);
      2	   8950         ISET(SST_TREX(sstSlave,1)->trexInit1, sst1CurrentBoard->tmuInit1[1] |
      2	   8951             SST_EN_TEX_SCANLINE_INTERLEAVE | SST_TEX_SCANLINE_INTERLEAVE_SLAVE);
      2	   8952         sst1InitIdle(sstbase1);
      2	   8953         ISET(SST_TREX(sstSlave,2)->trexInit1, sst1CurrentBoard->tmuInit1[2] |
      2	   8954             SST_EN_TEX_SCANLINE_INTERLEAVE | SST_TEX_SCANLINE_INTERLEAVE_SLAVE);
      2	   8955         sst1InitIdle(sstbase1);
      2	   8956         sst1InitIdleFBINoNOP(sstbase1);
      2	   8957         ISET(sstSlave->fbiInit2, (IGET(sstSlave->fbiInit2) &
      2	   8958           ~SST_SWAP_ALGORITHM) | swapAlgorithm);
      2	   8959         sst1InitIdleFBINoNOP(sstbase1);
      2	   8960         // Initialize Y-Origin
      2	   8961         ISET(sstSlave->fbiInit3, (IGET(sstSlave->fbiInit3) & ~SST_YORIGIN_TOP) |
      2	   8962             (sst1CurrentBoard->fbiVideoHeight << SST_YORIGIN_TOP_SHIFT));
      2	   8963         sst1InitIdleFBINoNOP(sstbase1);
      2	   8964         ISET(sstSlave->fbiInit2, (IGET(sstSlave->fbiInit2) &
      2	   8965           ~SST_VIDEO_BUFFER_OFFSET) |
      2	   8966           (memOffsetNew << SST_VIDEO_BUFFER_OFFSET_SHIFT));
      2	   8967         sst1CurrentBoard->fbiVideoMemOffset = memOffsetNew;
      2	   8968         sst1InitIdleFBINoNOP(sstbase1);
      2	   8969         // Initialize memory fifo
      2	   8970         ISET(sstSlave->fbiInit0, (IGET(sstSlave->fbiInit0) &
      2	   8971           ~SST_MEM_FIFO_HWM) | (memFifoEntriesNew << SST_MEM_FIFO_HWM_SHIFT));
      2	   8972         sst1InitIdleFBINoNOP(sstbase1);
      2	   8973         ISET(sstSlave->fbiInit4, (IGET(sstSlave->fbiInit4) &
      2	   8974           ~SST_MEM_FIFO_ROW_BASE) |
      2	   8975           (memFifoRowBaseNew << SST_MEM_FIFO_ROW_BASE_SHIFT));
      2	   8976         sst1InitIdleFBINoNOP(sstbase1);
      2	   8977         // Fix video dimensions
      2	   8978         ISET(sstSlave->videoDimensions,
      2	   8979           (((sst1CurrentBoard->fbiVideoHeight+2) << SST_VIDEO_YDIM_SHIFT) |
      2	   8980            ((sst1CurrentBoard->fbiVideoWidth-1) << SST_VIDEO_XDIM_SHIFT)));
      2	   8981         sst1InitIdleFBINoNOP(sstbase1);
      2	   8982         // Setup video clocks
      2	   8983         ISET(sstSlave->fbiInit5, (IGET(sstSlave->fbiInit5) &
      2	   8984           ~(SST_VIDEO_CLK_SLAVE_OE_EN | SST_VID_CLK_2X_OUT_OE_EN)) |

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      2	   8985           SST_VID_CLK_DAC_DATA16_SEL);
      2	   8986         ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) &
      2	   8987           ~SST_VIDEO_VID_CLK_SLAVE);
      2	   8988         sst1CurrentBoard->fbiInit6 &= ~SST_SLI_SYNC_MASTER;
      2	   8989         sst1CurrentBoard->fbiInit6 = ((sst1CurrentBoard->fbiInit6 &
      2	   8990           ~(SST_SLI_SWAP_VACTIVE | SST_SLI_SWAP_VACTIVE_DRAG)) |
      2	   8991           (videoWindowActive<<SST_SLI_SWAP_VACTIVE_SHIFT) |
      2	   8992           (videoWindowActiveDrag<<SST_SLI_SWAP_VACTIVE_DRAG_SHIFT));
      2	   8993         ISET(sstSlave->fbiInit6, sst1CurrentBoard->fbiInit6);
      2	   8994 
      2	   8995         slaveVInClkDel = 0;
      2	   8996         slaveVOutClkDel = 0;
      2	   8997         slavePVOutClkDel = 0;
      2	   8998 
      2	   8999         if(GETENV(("SSTV2_SLIS_VOUT_CLKDEL")) &&
      2	   9000            (SSCANF(GETENV(("SSTV2_SLIS_VOUT_CLKDEL")), "%i", &i) == 1))
      2	   9001             slaveVOutClkDel = i;
      2	   9002         if(GETENV(("SSTV2_SLIS_PVOUT_CLKDEL")) &&
      2	   9003            (SSCANF(GETENV(("SSTV2_SLIS_PVOUT_CLKDEL")), "%i", &i) == 1))
      2	   9004             slavePVOutClkDel = i;
      2	   9005         if(GETENV(("SSTV2_SLIS_VIN_CLKDEL")) &&
      2	   9006            (SSCANF(GETENV(("SSTV2_SLIS_VIN_CLKDEL")), "%i", &i) == 1))
      2	   9007             slaveVInClkDel = i;
      2	   9008         INIT_PRINTF(("sst1InitSli(): slaveVinClkdel=0x%x, slaveVOutClkDel=0x%x, slavePVOutClkDel=0x%x\n",
      2	   9009             slaveVInClkDel, slaveVOutClkDel, slavePVOutClkDel));
      2	   9010         if(sst1CurrentBoard->fbiVideo16BPP)
      2	   9011             // 16-bit Video Output
      2	   9012             ISET(sstSlave->fbiInit1, (IGET(sstSlave->fbiInit1) &
      2	   9013                     ~(SST_VIDEO_VCLK_2X_OUTPUT_DEL | SST_VIDEO_VCLK_DEL |
      2	   9014                       SST_VIDEO_VCLK_SEL | SST_VIDEO_VCLK_2X_INPUT_DEL)) | 
      2	   9015                 SST_EN_SCANLINE_INTERLEAVE |
      2	   9016                 // SST_VIDEO_VID_CLK_SLAVE |
      2	   9017                 // SST_VIDEO_VID_CLK_2X |
      2	   9018                 // SST_VIDEO_INVERT_VID_CLK_2X | 
      2	   9019                 SST_VIDEO_VCLK_SEL |
      2	   9020                 SST_PCI_WRWS_1 |
      2	   9021                 (slaveVInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      2	   9022                 (slaveVOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2	   9023                 (slavePVOutClkDel << SST_VIDEO_VCLK_2X_INPUT_DEL_SHIFT));
      2	   9024         else
      2	   9025             // 24-bit Video Output
      2	   9026             ISET(sstSlave->fbiInit1, (IGET(sstSlave->fbiInit1) &
      2	   9027                     ~(SST_VIDEO_VCLK_2X_OUTPUT_DEL | SST_VIDEO_VCLK_DEL |
      2	   9028                       SST_VIDEO_VCLK_SEL | SST_VIDEO_VCLK_2X_INPUT_DEL)) | 
      2	   9029                 SST_EN_SCANLINE_INTERLEAVE |
      2	   9030                 // SST_VIDEO_VID_CLK_SLAVE |
      2	   9031                 // SST_VIDEO_VID_CLK_2X |
      2	   9032                 // SST_VIDEO_INVERT_VID_CLK_2X |
      2	   9033                 (0x0 << SST_VIDEO_VCLK_SEL_SHIFT) |
      2	   9034                 SST_PCI_WRWS_1 |
      2	   9035                 (slaveVInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      2	   9036                 (slaveVOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2	   9037                 (slavePVOutClkDel << SST_VIDEO_VCLK_2X_INPUT_DEL_SHIFT));
      2	   9038         sst1InitIdleFBINoNOP(sstbase1);
      2	   9039         ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) &
      2	   9040                                   ~(SST_VIDEO_DATA_OE_EN |
      2	   9041                                     SST_VIDEO_BLANK_OE_EN |

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      2	   9042                                     SST_VIDEO_BLANK_EN |
      2	   9043                                     SST_VIDEO_DCLK_OE_EN |
      2	   9044                                     SST_VIDEO_HVSYNC_OE_EN));
      2	   9045         sst1InitIdleFBINoNOP(sstbase1);
      2	   9046         // Initialize pci and memory fifos...
      2	   9047         pciFifoLwm = 16;
      2	   9048         memFifoLwm = 26;
      2	   9049         if(!GETENV(("SSTV2_PCIFIFO_LWM")))
      2	   9050             ISET(sstSlave->fbiInit0, (IGET(sstSlave->fbiInit0) &
      2	   9051               ~SST_PCI_FIFO_LWM) | (pciFifoLwm << SST_PCI_FIFO_LWM_SHIFT));
      2	   9052         sst1InitIdleFBINoNOP(sstbase1);
      2	   9053         if(!GETENV(("SSTV2_MEMFIFO_LWM")))
      2	   9054             ISET(sstSlave->fbiInit4, (IGET(sstSlave->fbiInit4) &
      2	   9055               ~SST_MEM_FIFO_LWM) | (memFifoLwm << SST_MEM_FIFO_LWM_SHIFT));
      2	   9056         sst1InitIdleFBINoNOP(sstbase1);
      2	   9057         INIT_PRINTF(("sst1InitSli(): Slave pciFifoLwm:%d, memFifoLwm:%d\n",
      2	   9058           ((IGET(sstSlave->fbiInit0) & SST_PCI_FIFO_LWM) >>
      2	   9059             SST_PCI_FIFO_LWM_SHIFT),
      2	   9060           ((IGET(sstSlave->fbiInit4) & SST_MEM_FIFO_LWM) >>
      2	   9061             SST_MEM_FIFO_LWM_SHIFT)));
      2	   9062         sst1InitIdleFBINoNOP(sstbase1);
      2	   9063         sst1InitIdleFBINoNOP(sstbase1);
      2	   9064         ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) |
      2	   9065           (SST_EN_SCANLINE_INTERLEAVE | SST_VIDEO_RESET));
      2	   9066         sst1InitIdleFBINoNOP(sstbase1);
      2	   9067         sst1InitIdleFBINoNOP(sstbase1);
      2	   9068         sst1InitIdleFBINoNOP(sstbase1);
      2	   9069         ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) & ~SST_VIDEO_RESET);
      2	   9070         sst1InitIdleFBINoNOP(sstbase1);
      2	   9071         sst1InitIdleFBINoNOP(sstbase1);
      3	   9072         if(IGET(sstSlave->fbiInit1) & SST_VIDEO_RESET) {
      3	   9073             INIT_PRINTF(("sst1InitSli(): Could not unReset Slave Video...\n"));
      3	   9074             if(++cntr < 10)
      3	   9075                 continue;
      3	   9076             else
      3	   9077                 return(FXFALSE);
      2	   9078         }
      3	   9079         if(!(IGET(sstSlave->fbiInit1) & SST_EN_SCANLINE_INTERLEAVE)) {
      3	   9080             INIT_PRINTF(("sst1InitSli(): Could not setup SLI Slave...\n"));
      3	   9081             if(++cntr < 10)
      3	   9082                 continue;
      3	   9083             else
      3	   9084                 return(FXFALSE);
      2	   9085         }
      2	   9086         break;
      1	   9087     }
      1	   9088 
      1	   9089     // Setup SLI Master...
      1	   9090     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9091         return(FXFALSE);
      1	   9092     ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) | SST_VIDEO_RESET);
      1	   9093     ISET(SST_TREX(sstMaster,0)->trexInit1, sst1CurrentBoard->tmuInit1[0] |
      1	   9094         SST_EN_TEX_SCANLINE_INTERLEAVE);
      1	   9095     sst1InitIdle(sstbase0);
      1	   9096     ISET(SST_TREX(sstMaster,1)->trexInit1, sst1CurrentBoard->tmuInit1[1] |
      1	   9097         SST_EN_TEX_SCANLINE_INTERLEAVE);
      1	   9098     sst1InitIdle(sstbase0);

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9099     ISET(SST_TREX(sstMaster,2)->trexInit1, sst1CurrentBoard->tmuInit1[2] |
      1	   9100         SST_EN_TEX_SCANLINE_INTERLEAVE);
      1	   9101     sst1InitIdle(sstbase0);
      1	   9102     sst1InitIdleFBINoNOP(sstbase0);
      1	   9103     ISET(sstMaster->fbiInit2, (IGET(sstMaster->fbiInit2) &
      1	   9104       ~SST_SWAP_ALGORITHM) | swapAlgorithm);
      1	   9105     sst1InitIdleFBINoNOP(sstbase0);
      1	   9106     // Initialize Y-Origin
      1	   9107     ISET(sstMaster->fbiInit3, (IGET(sstMaster->fbiInit3) & ~SST_YORIGIN_TOP) |
      1	   9108         ((sst1CurrentBoard->fbiVideoHeight) << SST_YORIGIN_TOP_SHIFT));
      1	   9109     sst1InitIdleFBINoNOP(sstbase0);
      1	   9110     if(sst1CurrentBoard->fbiVideoWidth == 960)
      1	   9111         ISET(sstMaster->fbiInit0, IGET(sstMaster->fbiInit0) & ~SST_MEM_FIFO_EN);
      1	   9112     ISET(sstMaster->fbiInit2, (IGET(sstMaster->fbiInit2) &
      1	   9113         ~SST_VIDEO_BUFFER_OFFSET) |
      1	   9114       (memOffsetNew << SST_VIDEO_BUFFER_OFFSET_SHIFT));
      1	   9115     sst1CurrentBoard->fbiVideoMemOffset = memOffsetNew;
      1	   9116     sst1InitIdleFBINoNOP(sstbase0);
      1	   9117     // // Initialize memory fifo
      1	   9118     ISET(sstMaster->fbiInit0, (IGET(sstMaster->fbiInit0) & ~SST_MEM_FIFO_HWM) |
      1	   9119         (memFifoEntriesNew << SST_MEM_FIFO_HWM_SHIFT));
      1	   9120     sst1InitIdleFBINoNOP(sstbase0);
      1	   9121     ISET(sstMaster->fbiInit4, (IGET(sstMaster->fbiInit4) &
      1	   9122         ~SST_MEM_FIFO_ROW_BASE) |
      1	   9123       (memFifoRowBaseNew << SST_MEM_FIFO_ROW_BASE_SHIFT));
      1	   9124     sst1InitIdleFBINoNOP(sstbase0);
      1	   9125     // Fix video dimensions
      1	   9126     ISET(sstMaster->videoDimensions,
      1	   9127       (((sst1CurrentBoard->fbiVideoHeight+2) << SST_VIDEO_YDIM_SHIFT) |
      1	   9128        ((sst1CurrentBoard->fbiVideoWidth-1) << SST_VIDEO_XDIM_SHIFT)));
      1	   9129     sst1InitIdleFBINoNOP(sstbase0);
      1	   9130     // Setup video clocks
      1	   9131     ISET(sstMaster->fbiInit5, IGET(sstMaster->fbiInit5) |
      1	   9132       SST_VIDEO_CLK_SLAVE_OE_EN | SST_VID_CLK_2X_OUT_OE_EN |
      1	   9133       SST_VID_CLK_DAC_DATA16_SEL);
      1	   9134     ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) &
      1	   9135       ~SST_VIDEO_VID_CLK_SLAVE);
      1	   9136     sst1CurrentBoard->fbiInit6 |= SST_SLI_SYNC_MASTER;
      1	   9137     sst1CurrentBoard->fbiInit6 = ((sst1CurrentBoard->fbiInit6 &
      1	   9138       ~(SST_SLI_SWAP_VACTIVE | SST_SLI_SWAP_VACTIVE_DRAG)) |
      1	   9139       (videoWindowActive<<SST_SLI_SWAP_VACTIVE_SHIFT) |
      1	   9140       (videoWindowActiveDrag<<SST_SLI_SWAP_VACTIVE_DRAG_SHIFT));
      1	   9141     ISET(sstMaster->fbiInit6, sst1CurrentBoard->fbiInit6);
      1	   9142 
      1	   9143     // Following work well up to around 100 MHz...
      1	   9144     // masterVInClkDel = 2;
      1	   9145     // masterVOutClkDel = 0;
      1	   9146     // masterPVOutClkDel = 0;
      1	   9147     // Following seem to work up to 800x600@85 Hz (112 MHz)
      1	   9148     masterVInClkDel = 3;
      1	   9149     masterVOutClkDel = 2;
      1	   9150     masterPVOutClkDel = 0;
      1	   9151     if(GETENV(("SSTV2_SLIM_VOUT_CLKDEL")) &&
      1	   9152        (SSCANF(GETENV(("SSTV2_SLIM_VOUT_CLKDEL")), "%i", &i) == 1))
      1	   9153         masterVOutClkDel = i;
      1	   9154     if(GETENV(("SSTV2_SLIM_PVOUT_CLKDEL")) &&
      1	   9155        (SSCANF(GETENV(("SSTV2_SLIM_PVOUT_CLKDEL")), "%i", &i) == 1))

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9156         masterPVOutClkDel = i;
      1	   9157     if(GETENV(("SSTV2_SLIM_VIN_CLKDEL")) &&
      1	   9158        (SSCANF(GETENV(("SSTV2_SLIM_VIN_CLKDEL")), "%i", &i) == 1))
      1	   9159         masterVInClkDel = i;
      1	   9160     INIT_PRINTF(("sst1InitSli(): masterVinClkdel=0x%x, masterVOutClkDel=0x%x, masterPVOutClkDel=0x%x\n",
      1	   9161         masterVInClkDel, masterVOutClkDel, masterPVOutClkDel));
      1	   9162     if(sst1CurrentBoard->fbiVideo16BPP)
      1	   9163         // 16-bit Video Output
      1	   9164         ISET(sstMaster->fbiInit1, (IGET(sstMaster->fbiInit1) &
      1	   9165                 ~(SST_VIDEO_VCLK_2X_OUTPUT_DEL | SST_VIDEO_VCLK_DEL |
      1	   9166                   SST_VIDEO_VCLK_SEL | SST_VIDEO_VCLK_2X_INPUT_DEL |
      1	   9167                   SST_VIDEO_BLANK_EN)) | 
      1	   9168             SST_EN_SCANLINE_INTERLEAVE |
      1	   9169             // SST_VIDEO_VID_CLK_2X |
      1	   9170             // SST_VIDEO_INVERT_VID_CLK_2X |
      1	   9171             SST_VIDEO_VCLK_SEL |
      1	   9172             SST_PCI_WRWS_1 |
      1	   9173             SST_VIDEO_DATA_OE_EN |
      1	   9174             SST_VIDEO_DCLK_OE_EN |
      1	   9175             SST_VIDEO_HVSYNC_OE_EN |
      1	   9176             (masterVInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      1	   9177             (masterVOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      1	   9178             (masterPVOutClkDel << SST_VIDEO_VCLK_2X_INPUT_DEL_SHIFT));
      2	   9179     else {
      2	   9180         // 24-bit Video Output
      2	   9181         ISET(sstMaster->fbiInit1, (IGET(sstMaster->fbiInit1) &
      2	   9182                 ~(SST_VIDEO_VCLK_2X_OUTPUT_DEL | SST_VIDEO_VCLK_DEL |
      2	   9183                   SST_VIDEO_VCLK_SEL | SST_VIDEO_VCLK_2X_INPUT_DEL |
      2	   9184                   SST_VIDEO_BLANK_EN)) | 
      2	   9185             SST_EN_SCANLINE_INTERLEAVE |
      2	   9186             // SST_VIDEO_VID_CLK_2X |
      2	   9187             // SST_VIDEO_INVERT_VID_CLK_2X |
      2	   9188             (0x0 << SST_VIDEO_VCLK_SEL_SHIFT) |
      2	   9189             SST_PCI_WRWS_1 |
      2	   9190             SST_VIDEO_DATA_OE_EN |
      2	   9191             SST_VIDEO_DCLK_OE_EN |
      2	   9192             SST_VIDEO_HVSYNC_OE_EN |
      2	   9193             (masterVInClkDel << SST_VIDEO_VCLK_DEL_SHIFT) |
      2	   9194             (masterVOutClkDel << SST_VIDEO_VCLK_2X_OUTPUT_DEL_SHIFT) |
      2	   9195             (masterPVOutClkDel << SST_VIDEO_VCLK_2X_INPUT_DEL_SHIFT));
      2	   9196             sst1InitReturnStatus(sstbase0);
      2	   9197             ISET(sstMaster->fbiInit5, IGET(sstMaster->fbiInit5) |
      2	   9198               SST_VIDEO_CLK_SLAVE_OE_EN | SST_VID_CLK_2X_OUT_OE_EN);
      1	   9199     }
      1	   9200     sst1InitIdleFBINoNOP(sstbase0);
      1	   9201     // Initialize pci and memory fifos...
      1	   9202     pciFifoLwm = 16;
      1	   9203     memFifoLwm = 26;
      1	   9204     if(!GETENV(("SSTV2_PCIFIFO_LWM")))
      1	   9205         ISET(sstMaster->fbiInit0, (IGET(sstMaster->fbiInit0) &
      1	   9206           ~SST_PCI_FIFO_LWM) | (pciFifoLwm << SST_PCI_FIFO_LWM_SHIFT));
      1	   9207     sst1InitIdleFBINoNOP(sstbase0);
      1	   9208     if(!GETENV(("SSTV2_MEMFIFO_LWM")))
      1	   9209         ISET(sstMaster->fbiInit4, (IGET(sstMaster->fbiInit4) &
      1	   9210           ~SST_MEM_FIFO_LWM) | (memFifoLwm << SST_MEM_FIFO_LWM_SHIFT));
      1	   9211     sst1InitIdleFBINoNOP(sstbase0);
      1	   9212     INIT_PRINTF(("sst1InitSli(): Master pciFifoLwm:%d, memFifoLwm:%d\n",

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9213       ((IGET(sstMaster->fbiInit0) & SST_PCI_FIFO_LWM) >>
      1	   9214         SST_PCI_FIFO_LWM_SHIFT),
      1	   9215       ((IGET(sstMaster->fbiInit4) & SST_MEM_FIFO_LWM) >>
      1	   9216         SST_MEM_FIFO_LWM_SHIFT)));
      1	   9217     ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) & ~SST_VIDEO_RESET);
      1	   9218     sst1InitIdleFBINoNOP(sstbase0);
      1	   9219 
      1	   9220     // Master
      1	   9221     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9222         return(FXFALSE);
      1	   9223     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9224     PCICFG_WR(SST1_PCI_INIT_ENABLE,
      1	   9225         (j & ~(SST_SCANLINE_SLV_OWNPCI | SST_SCANLINE_SLI_SLV)));
      1	   9226     MasterPhysAddr = sst1CurrentBoard->physAddr[0];
      1	   9227     sst1InitReturnStatus(sstbase0); // flush pci packer with reads
      1	   9228     sst1InitReturnStatus(sstbase0);
      1	   9229     sst1InitReturnStatus(sstbase0);
      1	   9230 
      1	   9231     // Slave
      1	   9232     if(sst1InitCheckBoard(sstbase1) == FXFALSE)
      1	   9233         return(FXFALSE);
      1	   9234     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9235     PCICFG_WR(SST1_PCI_INIT_ENABLE,
      1	   9236         ((j & ~(SST_SCANLINE_SLV_OWNPCI)) | SST_SCANLINE_SLI_SLV));
      1	   9237 
      1	   9238     /* dpc - 19 may 1998 - FixMe
      1	   9239      * Min the clock values for the two boards so that they are
      1	   9240      * happy running together.
      1	   9241      */
      1	   9242 #define MIN(__a, __b) (((__a) < (__b)) ? (__a) : (__b))
      2	   9243     {
      2	   9244       sst1DeviceInfoStruct* infoMaster;
      2	   9245       sst1DeviceInfoStruct* infoSlave;
      2	   9246 
      2	   9247       if (!sst1InitCheckBoard(sstbase0)) return FXFALSE;
      2	   9248       infoMaster = sst1CurrentBoard;
      2	   9249 
      2	   9250       if (!sst1InitCheckBoard(sstbase1)) return FXFALSE;
      2	   9251       infoSlave = sst1CurrentBoard;
      2	   9252       
      2	   9253       /* fbi and tmu clock freqs should be equal since they are
      2	   9254        * both set from sst1InitCalcGrxClk.
      2	   9255        */
      3	   9256       if (infoMaster->fbiGrxClkFreq != infoSlave->fbiGrxClkFreq) {
      3	   9257         /* Recompute the actual clock rates before any clocking down
      3	   9258          * due to sli for some board revisions.  
      3	   9259          */
      3	   9260         if (!sst1InitCalcGrxClk(sstbase0)) return FXFALSE;
      3	   9261         if (!sst1InitCalcGrxClk(sstbase1)) return FXFALSE;
      3	   9262 
      3	   9263         /* Save the min clock of the two boards */
      3	   9264         infoMaster->fbiGrxClkFreq =
      3	   9265         infoMaster->tmuGrxClkFreq =
      3	   9266         infoSlave->fbiGrxClkFreq  =
      3	   9267         infoSlave->tmuGrxClkFreq  = MIN(infoMaster->fbiGrxClkFreq, infoSlave->fbiGrxClkFreq);
      3	   9268 
      3	   9269         /* Clear the clock setting bits */

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      3	   9270         infoMaster->initGrxClkDone =
      3	   9271         infoSlave->initGrxClkDone  = FXFALSE;
      3	   9272 
      3	   9273         /* Reset the clocks for each board */
      3	   9274         if (!sst1InitGrxClk(sstbase0)) return FXFALSE;
      3	   9275         if (!sst1InitGrxClk(sstbase1)) return FXFALSE;
      3	   9276 
      3	   9277         /* Now check for the memory configurations of the devices.
      3	   9278          * They no longer need to match, but any future calls to
      3	   9279          * sst1InitGetDeviceInfo should now reflect the current
      3	   9280          * minimized state of the world.  
      3	   9281          */
      4	   9282         {
      4	   9283           FxU32 memSize, i;
      4	   9284 
      5	   9285           if (infoMaster->fbiMemSize != infoSlave->fbiMemSize) {
      5	   9286             memSize = MIN(infoMaster->fbiMemSize, infoSlave->fbiMemSize);
      5	   9287             infoMaster->fbiMemSize = 
      5	   9288             infoSlave->fbiMemSize  = memSize;
      4	   9289           }
      4	   9290 
      5	   9291           for(i = 0; i < infoMaster->numberTmus; i++) {
      6	   9292             if (infoMaster->tmuMemSize[i] != infoSlave->tmuMemSize[i]) {
      6	   9293               memSize = MIN(infoMaster->tmuMemSize[i], infoSlave->tmuMemSize[i]);
      6	   9294               infoMaster->tmuMemSize[i] =
      6	   9295               infoSlave->tmuMemSize[i]  = memSize;
      5	   9296             }
      4	   9297           }
      3	   9298         }
      2	   9299       }
      1	   9300     }
      1	   9301 #undef MIN
      1	   9302 
      1	   9303     // Enable SLI Bus Snooping for the Slave
      1	   9304     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9305     PCICFG_WR(SST1_PCI_INIT_ENABLE, (j & ~SST_SLI_SNOOP_MEMBASE) |
      1	   9306         ((MasterPhysAddr>>24 & 0xff) << SST_SLI_SNOOP_MEMBASE_SHIFT));
      1	   9307     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9308     PCICFG_WR(SST1_PCI_INIT_ENABLE, j | SST_SLI_SNOOP_EN);
      1	   9309     sst1InitReturnStatus(sstbase1); // flush pci packer with reads
      1	   9310     sst1InitReturnStatus(sstbase1);
      1	   9311     sst1InitReturnStatus(sstbase1);
      1	   9312 
      1	   9313     // Reset video unit in both Master and Slave
      1	   9314     // Then, reset graphics unit in both Master and Slave
      1	   9315     // Finally, deassert both resets to guarantee that Master and Slave
      1	   9316     // see the same vsyncs (and maintain the same swap buffer counter)
      1	   9317 
      1	   9318     // Probit writes to PCI fifo while resetting graphics core
      1	   9319     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9320         return(FXFALSE);
      1	   9321     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9322     PCICFG_WR(SST1_PCI_INIT_ENABLE, j & ~SST_PCI_FIFOWR_EN);
      1	   9323     if(sst1InitCheckBoard(sstbase1) == FXFALSE)
      1	   9324         return(FXFALSE);
      1	   9325     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9326     PCICFG_WR(SST1_PCI_INIT_ENABLE, j & ~SST_PCI_FIFOWR_EN);

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9327 
      1	   9328     // Reset Video core...
      1	   9329     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9330         return(FXFALSE);
      1	   9331     ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) | SST_VIDEO_RESET);
      1	   9332     sst1InitReturnStatus(sstbase0);
      1	   9333     ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) | SST_VIDEO_RESET);
      1	   9334     sst1InitReturnStatus(sstbase1);
      1	   9335 
      1	   9336     // Reset Graphics core...
      1	   9337     ISET(sstMaster->fbiInit0, IGET(sstMaster->fbiInit0) | SST_GRX_RESET);
      1	   9338     sst1InitReturnStatus(sstbase0);
      1	   9339     ISET(sstSlave->fbiInit0, IGET(sstSlave->fbiInit0) | SST_GRX_RESET);
      1	   9340     sst1InitReturnStatus(sstbase1);
      1	   9341 
      1	   9342     // Allow resets to propogate...
      1	   9343     sst1InitReturnStatus(sstbase0);
      1	   9344     sst1InitReturnStatus(sstbase1);
      1	   9345     sst1InitReturnStatus(sstbase0);
      1	   9346     sst1InitReturnStatus(sstbase1);
      1	   9347 
      1	   9348     // De-assert reset to Graphics core...
      1	   9349     ISET(sstMaster->fbiInit0, IGET(sstMaster->fbiInit0) & ~SST_GRX_RESET);
      1	   9350     sst1InitReturnStatus(sstbase0);
      1	   9351     ISET(sstSlave->fbiInit0, IGET(sstSlave->fbiInit0) & ~SST_GRX_RESET);
      1	   9352     sst1InitReturnStatus(sstbase1);
      1	   9353 
      1	   9354     // De-assert reset to Video core...
      1	   9355     ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) & ~SST_VIDEO_RESET);
      1	   9356     sst1InitReturnStatus(sstbase0);
      1	   9357     ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) & ~SST_VIDEO_RESET);
      1	   9358     sst1InitReturnStatus(sstbase1);
      1	   9359 
      1	   9360     // Allow writes to PCI fifo...
      1	   9361     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9362         return(FXFALSE);
      1	   9363     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9364     PCICFG_WR(SST1_PCI_INIT_ENABLE, j | SST_PCI_FIFOWR_EN);
      1	   9365     // Update info structure for initEnable
      1	   9366     sst1CurrentBoard->fbiInitEnable = j | SST_PCI_FIFOWR_EN;
      1	   9367 
      1	   9368     if(sst1InitCheckBoard(sstbase1) == FXFALSE)
      1	   9369         return(FXFALSE);
      1	   9370     PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      1	   9371     PCICFG_WR(SST1_PCI_INIT_ENABLE, j | SST_PCI_FIFOWR_EN);
      1	   9372     // Update info structure for initEnable
      1	   9373     sst1CurrentBoard->fbiInitEnable = j | SST_PCI_FIFOWR_EN;
      1	   9374 
      1	   9375     if(sst1InitCheckBoard(sstbase0) == FXFALSE)
      1	   9376         return(FXFALSE);
      1	   9377 
      1	   9378     // Clear fbistat registers after clearing screen
      1	   9379     ISET(sstMaster->nopCMD, 0x1);
      1	   9380 
      1	   9381     sst1CurrentBoard->sliSlaveVirtAddr = sstbase1;
      1	   9382 
      1	   9383     sst1InitIdle(sstbase0);

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9384 
      1	   9385     // Synchronize Boards
      2	   9386     for(j=0; j<3; j++) {
      2	   9387         while(!(sst1InitReturnStatus(sstbase0) & SST_VRETRACE))
      2	   9388             ;
      2	   9389         IGET(sstMaster->status);
      2	   9390         ISET(sstMaster->swapbufferCMD, 0x0); // Do not wait for vRetrace...
      2	   9391         IGET(sstMaster->status);
      2	   9392         sst1InitIdle(sstbase0);
      1	   9393     }
      1	   9394     while(!(sst1InitReturnStatus(sstbase0) & SST_VRETRACE))
      1	   9395         ;
      1	   9396     IGET(sstMaster->status);
      1	   9397     ISET(sstMaster->swapbufferCMD, 0x1);     // Sync to vRetrace...
      1	   9398     IGET(sstMaster->status);
      1	   9399     sst1InitIdle(sstbase0);
      1	   9400 
      1	   9401     if(GETENV(("SSTV2_IGNORE_IDLE")))
      1	   9402        initIdleEnabled = 0;
      1	   9403 
      1	   9404     INIT_PRINTF(("sst1InitSli() exiting with status %d...\n", FXTRUE));
      1	   9405     return(FXTRUE);
      1	   9406 }
	   9407 
	   9408 /*
	   9409 ** sst1InitShutdownSli():
	   9410 **  Shutdown SLI configuration
	   9411 **
	   9412 */
	   9413 FX_EXPORT FxBool FX_CSTYLE sst1InitShutdownSli(FxU32 *sstbase)
      1	   9414 {
      1	   9415     SstRegs *sstMaster = (SstRegs *) sstbase;
      1	   9416     SstRegs *sstSlave;
      1	   9417     FxU32 n, j, cntr;
      1	   9418 
      1	   9419     if(sst1InitCheckBoard(sstbase) == FXFALSE)
      1	   9420         return(FXFALSE);
      1	   9421 
      1	   9422     sstSlave = (SstRegs *) sst1CurrentBoard->sliSlaveVirtAddr;
      1	   9423 
      2	   9424     if(sst1CurrentBoard->sliSlaveVirtAddr != (FxU32 *) NULL) {
      2	   9425         INIT_PRINTF(("sst1InitShutdownSli(): Disabling Scanline Interleaving...\n"));
      2	   9426         sst1CurrentBoard->sliSlaveVirtAddr = (FxU32 *) NULL;
      2	   9427 
      2	   9428         cntr = 0;
      3	   9429         while(1) {
      3	   9430             if(sst1InitCheckBoard((FxU32 *) sstSlave) == FXFALSE)
      3	   9431                 return(FXFALSE);
      3	   9432             // Turn off scanline interleaving and snooping in slave...
      3	   9433             PCICFG_RD(SST1_PCI_INIT_ENABLE, j);
      3	   9434             PCICFG_WR(SST1_PCI_INIT_ENABLE, j & ~(SST_SCANLINE_SLV_OWNPCI |
      3	   9435               SST_SCANLINE_SLI_SLV | SST_SLI_SNOOP_EN |
      3	   9436               SST_SLI_SNOOP_MEMBASE));
      3	   9437             ISET(sstSlave->fbiInit1, IGET(sstSlave->fbiInit1) &
      3	   9438               ~SST_EN_SCANLINE_INTERLEAVE);
      3	   9439             sst1InitIdle((FxU32 *) sstSlave);
      3	   9440 

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      4	   9441             if(IGET(sstSlave->fbiInit1) & SST_EN_SCANLINE_INTERLEAVE) {
      4	   9442                 if(++cntr < 10)
      4	   9443                     continue;
      5	   9444                 else {
      5	   9445                     INIT_PRINTF(("sst1InitShutdown(): Could not disable Slave SLI...\n"));
      5	   9446                     return(FXFALSE);
      4	   9447                 }
      3	   9448             }
      3	   9449             break;
      2	   9450         }
      2	   9451         if(sst1InitCheckBoard((FxU32 *) sstMaster) == FXFALSE)
      2	   9452             return(FXFALSE);
      2	   9453         ISET(sstMaster->fbiInit1, IGET(sstMaster->fbiInit1) &
      2	   9454           ~SST_EN_SCANLINE_INTERLEAVE);
      2	   9455         sst1InitIdle((FxU32 *) sstMaster);
      1	   9456     }
      1	   9457     return(FXTRUE);
      1	   9458 }
	   9459 
	   9460 /*
	   9461 ** sst1InitSliDetect():
	   9462 **  Determine if scanline interleave has been detected (either through
	   9463 **   power-up settings or through SST_SLIDETECT)
	   9464 **
	   9465 */
	   9466 FX_ENTRY FxU32 FX_CALL sst1InitSliDetect(FxU32 *sstbase)
      1	   9467 {
      1	   9468     FxU32 sliDetected;
      1	   9469     
      1	   9470     if(GETENV(("SSTV2_SLIDETECT")))
      1	   9471       sliDetected = ATOI(GETENV(("SSTV2_SLIDETECT")));
      1	   9472     else
      1	   9473       sliDetected = sst1InitSliPaired(sstbase);
      1	   9474 
      1	   9475     return sliDetected;
      1	   9476 }
	   9477 
	   9478 /*
	   9479 ** sst1InitSliPaired():
	   9480 **  Determine if scanline interleave has been detected through
	   9481 **  power-up settings.
	   9482 **
	   9483 */
	   9484 FX_ENTRY FxU32 FX_CALL 
	   9485 sst1InitSliPaired(FxU32 *sstbase)
      1	   9486 {
      1	   9487     static int firstTime = 1;
      1	   9488     static FxU32 sliPaired = 0;
      1	   9489 
      2	   9490     if(firstTime) {
      2	   9491       SstRegs* sst = (SstRegs *) sstbase;
      2	   9492       
      2	   9493       sliPaired = (((IGET(sst->fbiInit5) & SST_SLI_DETECT) == SST_SLI_DETECT) &&
      2	   9494                    (boardsInSystem > 1));
      2	   9495       firstTime = 0;
      1	   9496     }
      1	   9497 

SLI                             Source Listing                   9-MAY-2021 23:43:20  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  sli.c;1

      1	   9498     return sliPaired;
      1	   9499 }
	   9500 
       X   9501 #ifdef _MSC_VER
       X   9502 #pragma optimize ("",on)
       X   9503 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]SLI/OBJECT=[.OUT.DEBU
G.OBJ.GLIDE.GLIDE2X.CVG.INIT]SLI.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMISC],
[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.CVG.
INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE_HW_
TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLIDE.G
LIDE2X.CVG.INIT]SLI.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:20"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


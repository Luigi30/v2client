GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.2.2.6  2007/05/19 08:37:25  koolsmoky
	     21 ** packed rgb fixes
	     22 ** force 4x4 dither with alpha dither subtraction
	     23 **
	     24 ** Revision 1.2.2.5  2005/01/22 14:52:02  koolsmoky
	     25 ** enabled packed argb for cmd packet type 3
	     26 **
	     27 ** Revision 1.2.2.4  2004/12/27 20:46:37  koolsmoky
	     28 ** added dll entry point to call grGlideShutdown when a process is detached
	     29 **
	     30 ** Revision 1.2.2.3  2004/12/23 21:03:14  koolsmoky
	     31 ** swapinterval
	     32 **
	     33 ** Revision 1.2.2.2  2004/12/23 20:45:56  koolsmoky
	     34 ** converted to nasm syntax
	     35 ** added x86 asm, 3dnow! triangle and mmx, 3dnow! texture download optimizations
	     36 **
	     37 ** Revision 1.2.2.1  2004/12/12 15:24:40  koolsmoky
	     38 ** grDitherMode(): force 2x2 dithering for 4x1 dither
	     39 ** grBufferSwap(): enable vsync and set swapbufferinterval to 0 for tripple buffering.
	     40 **
	     41 ** Revision 1.2  2000/10/03 18:28:33  mercury
	     42 ** 003-clean_up_cvg-000, cvg tree cleanup.
	     43 **
	     44 ** Revision 1.1.1.1  1999/12/07 21:49:10  joseph
	     45 ** Initial checkin into SourceForge.
	     46 **
	     47 ** 
	     48 ** 168   7/02/98 6:59p Peter
	     49 ** Fixed merge problem from previous checkin
	     50 ** 
	     51 ** 167   6/30/98 6:08p Jeske
	     52 ** fixed bug where we tried to setup MTRRs on old (<p6) systems which
	     53 ** didn't have them. 
	     54 ** 
	     55 ** 165   6/11/98 3:59p Peter
	     56 ** sli buffer swap needs to be max of app setting vs forcing sync
	     57 ** 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	     58 ** 164   6/03/98 6:31p Peter
	     59 ** clearing single scanlines
	     60 ** 
	     61 ** 163   5/28/98 2:52p Peter
	     62 ** fixed wrong checking w/ h3
	     63 ** 
	     64 ** 162   5/27/98 9:41a Peter
	     65 ** grBufferClear is constrained by clipping
	     66 ** 
	     67 ** 161   5/18/98 12:16p Peter
	     68 ** culling enabling
	     69 ** 
	     70 ** 160   4/16/98 3:54p Peter
	     71 ** 1x1 lod fix, sorry John
	     72 ** 
	     73 ** 159   4/08/98 3:52p Peter
	     74 ** fixed resetting of unused tmu to small lod
	     75 ** 
	     76 ** 158   4/01/98 1:51p Peter
	     77 ** fixed resetting unused tmu muckage/sli origin thing vs grRenderBuffer
	     78 ** 
	     79 ** 157   3/31/98 6:09p Peter
	     80 ** sli origin everywhere (I think) and grLfbReadRegion/grRenderBuffer vs
	     81 ** triple buffering
	     82 ** 
	     83 ** 156   3/30/98 4:56p Peter
	     84 ** fog table monotonicity
	     85 ** 
	     86 ** 155   3/29/98 1:07p Peter
	     87 ** removed shutdown cruft and yet another sli origin thing
	     88 ** 
	     89 ** 154   3/23/98 4:21p Jdt
	     90 ** Fixed texture state validation bug in grColorCombine
	     91 ** 
	     92 ** 153   3/20/98 11:02a Peter
	     93 ** inactive tmu reset
	     94 ** 
	     95 ** 152   3/04/98 9:10p Peter
	     96 ** properly restore fbzMode for the sli swapping thing
	     97 ** 
	     98 ** 151   3/03/98 9:37p Peter
	     99 ** more sli origin fun
	    100 ** 
	    101 ** 150   3/02/98 7:22p Peter
	    102 ** more crybaby stuff
	    103 ** 
	    104 ** 149   2/21/98 8:33a Peter
	    105 ** mixed case ini vars
	    106 ** 
	    107 ** 148   2/20/98 5:31p Peter
	    108 ** crybaby glide
	    109 ** 
	    110 ** 147   2/20/98 2:16p Peter
	    111 ** shutting down hw should clear hwInit and open
	    112 ** 
	    113 ** 146   2/20/98 11:00a Peter
	    114 ** removed glide3 from glid2 tree

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	    115 ** 
	    116 ** 145   2/20/98 9:05a Peter
	    117 ** removed remnants of comdex grot
	    118 ** 
	    119 ** 144   2/17/98 12:40p Peter
	    120 ** fog table fix
	    121 ** 
	    122 ** 143   2/12/98 3:40p Peter
	    123 ** single buffering for opengl
	    124 ** 
	    125 ** 142   2/11/98 5:23p Peter
	    126 ** fixed grRenderBuffer vs blit clear
	    127 ** 
	    128 ** 141   1/30/98 4:19p Peter
	    129 ** sli/y-origin blit clear
	    130 ** 
	    131 ** 140   1/23/98 3:02p Peter
	    132 ** uswc nightmare
	    133 ** 
	    134 ** 139   1/19/98 1:43p Atai
	    135 ** fixed non-debug mode assignement
	    136 ** 
	    137 ** 138   1/19/98 11:00a Atai
	    138 ** remove assignment before validate the state
	    139  * 
	    140  * 137   1/15/98 1:12p Peter
	    141  * only one culler please
	    142  * 
	    143  * 136   1/13/98 7:48p Atai
	    144  * fixed gu3dfGetInfo, grBufferClear, and GrState size
	    145  * 
	    146  * 135   1/13/98 12:42p Atai
	    147  * fixed grtexinfo, grVertexLayout, and draw triangle
	    148  * 
	    149  * 134   1/09/98 7:29p Atai
	    150  * fixed grBufferSwap for glide3
	    151  * 
	    152  * 133   1/08/98 9:25p Peter
	    153  * infinite recurrsion in debugging assert
	    154  * 
	    155  * 132   1/08/98 9:23p Peter
	    156  * fixed macro muckage
	    157  * 
	    158  * 131   1/08/98 7:09p Peter
	    159  * real hw stuff modulo makefile change
	    160 **
	    161 */
	    162 
	    163 #include <string.h>
	   1162 #include <3dfx.h>
	   1293 #include <glidesys.h>
	   1425 
	   1426 #define FX_DLL_DEFINITION
	   1427 #include <fxdll.h>
	   1548 #include <glide.h>
	   3359 
	   3360 #include "fxglide.h"

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  14704 //#include "fxinline.h"
	  14705 
	  14706 #if GLIDE_HW_TRI_SETUP
	  14707 static void
	  14708 _grUpdateTriPacketHdr(FxU32 paramMask, 
	  14709                       const GrCullMode_t mode);
	  14710 #endif /* GLIDE_HW_TRI_SETUP */
	  14711 
	  14712 /*---------------------------------------------------------------------------
	  14713 ** grAlphaBlendFunction
	  14714 **
	  14715 ** GMT: BUG if grColorMask() turns off alphaplanes then destination alpha
	  14716 **          blending wont work!
	  14717 */
	  14718 
	  14719 GR_STATE_ENTRY(grAlphaBlendFunction, void, 
	  14720                (GrAlphaBlendFnc_t rgb_sf, GrAlphaBlendFnc_t rgb_df, 
	  14721                 GrAlphaBlendFnc_t alpha_sf, GrAlphaBlendFnc_t alpha_df))
      1	  14722 {
      1	  14723 #define FN_NAME "grAlphaBlendFunction"
      1	  14724   FxU32 alphamode;
      1	  14725   GR_BEGIN_NOFIFOCHECK("grAlphaBlendFunction", 85);
      1	  14726   GDBG_INFO_MORE(gc->myLevel, "(%d,%d,%d,%d)\n",
      1	  14727                  rgb_sf, rgb_df, alpha_sf, alpha_df);
      1	  14728 
      1	  14729   alphamode = gc->state.fbi_config.alphaMode;
      2	  14730   if (alpha_sf != GR_BLEND_ONE && alpha_sf != GR_BLEND_ZERO) {
      2	  14731     GR_CHECK_W(myName, 1, "unsupported alpha source blend function");
      2	  14732     alpha_sf = GR_BLEND_ONE;
      1	  14733   }
      1	  14734 
      2	  14735   if (alpha_df != GR_BLEND_ONE && alpha_df != GR_BLEND_ZERO) {
      2	  14736     GR_CHECK_W(myName, 1, "unsupported alpha destination blend function");
      2	  14737     alpha_df = GR_BLEND_ZERO;
      1	  14738   }
      1	  14739 
      1	  14740   if (rgb_sf   == GR_BLEND_ONE && rgb_df   == GR_BLEND_ZERO &&
      1	  14741       alpha_sf == GR_BLEND_ONE && alpha_df == GR_BLEND_ZERO)
      1	  14742     alphamode &= ~SST_ENALPHABLEND;
      1	  14743   else
      1	  14744     alphamode |=  SST_ENALPHABLEND;
      1	  14745   
      1	  14746   alphamode &= ~(SST_RGBSRCFACT | SST_RGBDSTFACT | SST_ASRCFACT | SST_ADSTFACT);
      1	  14747   
      1	  14748   alphamode |= ((((FxU32) rgb_sf) << SST_RGBSRCFACT_SHIFT) |
      1	  14749                 (((FxU32) rgb_df) << SST_RGBDSTFACT_SHIFT) |
      1	  14750                 (((FxU32) alpha_sf) << SST_ASRCFACT_SHIFT) |
      1	  14751                 (((FxU32) alpha_df) << SST_ADSTFACT_SHIFT));
      1	  14752 
      1	  14753   gc->state.fbi_config.alphaMode = alphamode;
      1	  14754 
      1	  14755   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  14756   GR_SET(BROADCAST_ID, hw, alphaMode, alphamode);
      1	  14757   GR_CHECK_SIZE();
      1	  14758 #undef FN_NAME
      1	  14759 } /* grAlphaBlendFunction */
	  14760 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  14761 /*---------------------------------------------------------------------------
	  14762 ** grAlphaCombine
	  14763 */
	  14764 
	  14765 GR_STATE_ENTRY(grAlphaCombine, void, 
	  14766                (GrCombineFunction_t function, GrCombineFactor_t factor, 
	  14767                 GrCombineLocal_t local, GrCombineOther_t other, FxBool invert))
      1	  14768 {
      1	  14769 #define FN_NAME "grAlphaCombine"
      1	  14770   FxU32 fbzColorPath;
      1	  14771   FxU32 oldTextureEnabled;
      1	  14772 
      1	  14773   GR_BEGIN_NOFIFOCHECK("grAlphaCombine",85);
      1	  14774   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,%d,%d,%d)\n",function,factor,local,other,invert);
      1	  14775   GR_CHECK_W(myName,
      1	  14776              function < GR_COMBINE_FUNCTION_ZERO ||
      1	  14777              function > GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA,
      1	  14778              "unsupported alpha combine function");
      1	  14779   GR_CHECK_W(myName,
      1	  14780              (factor & 0x7) < GR_COMBINE_FACTOR_ZERO ||
      1	  14781              (factor & 0x7) > GR_COMBINE_FACTOR_TEXTURE_ALPHA ||
      1	  14782              factor > GR_COMBINE_FACTOR_ONE_MINUS_TEXTURE_ALPHA,
      1	  14783              "unsupported alpha combine scale factor");
      1	  14784 
      1	  14785   GR_CHECK_W(myName,
      1	  14786              local < GR_COMBINE_LOCAL_ITERATED || local > GR_COMBINE_LOCAL_DEPTH,
      1	  14787              "unsupported alpha combine local color");
      1	  14788   GR_CHECK_W(myName,
      1	  14789              other < GR_COMBINE_OTHER_ITERATED || other > GR_COMBINE_OTHER_CONSTANT,
      1	  14790              "unsupported alpha combine other color");
      1	  14791 
      1	  14792   fbzColorPath = gc->state.fbi_config.fbzColorPath;
      1	  14793   oldTextureEnabled = fbzColorPath & SST_ENTEXTUREMAP;
      1	  14794   fbzColorPath &= ~(SST_ENTEXTUREMAP |
      1	  14795                     SST_ASELECT |
      1	  14796                     SST_ALOCALSELECT |
      1	  14797                     SST_CCA_ZERO_OTHER |
      1	  14798                     SST_CCA_SUB_CLOCAL |
      1	  14799                     SST_CCA_MSELECT |
      1	  14800                     SST_CCA_REVERSE_BLEND |
      1	  14801                     SST_CCA_ADD_CLOCAL |
      1	  14802                     SST_CCA_ADD_ALOCAL |
      1	  14803                     SST_CCA_INVERT_OUTPUT);
      1	  14804   
      1	  14805   /* setup reverse blending first, then strip off the the high bit */
      1	  14806   if ((factor & 0x8) == 0)
      1	  14807     fbzColorPath |= SST_CCA_REVERSE_BLEND;
      1	  14808   factor &= 0x7;
      1	  14809 
      1	  14810   /* NOTE: we use boolean OR instead of logical to avoid branches */
      1	  14811   gc->state.ac_requires_texture = ((factor == GR_COMBINE_FACTOR_TEXTURE_ALPHA) |
      1	  14812                                    (other == GR_COMBINE_OTHER_TEXTURE));
      1	  14813   gc->state.ac_requires_it_alpha = ((local == GR_COMBINE_LOCAL_ITERATED) |
      1	  14814                                     (other == GR_COMBINE_OTHER_ITERATED));
      1	  14815   
      1	  14816   /* setup scale factor bits */
      1	  14817   fbzColorPath |= factor << SST_CCA_MSELECT_SHIFT;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  14818 
      1	  14819   /* setup local color bits */
      1	  14820   fbzColorPath |= local << SST_ALOCALSELECT_SHIFT;
      1	  14821   
      1	  14822   /* setup other color bits */
      1	  14823   fbzColorPath |= other << SST_ASELECT_SHIFT;
      1	  14824   
      1	  14825   
      1	  14826   /* setup invert output bits */
      1	  14827   if (invert)
      1	  14828     fbzColorPath |= SST_CCA_INVERT_OUTPUT;
      1	  14829   
      1	  14830   /* setup core color combine unit bits */
      2	  14831   switch (function) {
      2	  14832   case GR_COMBINE_FUNCTION_ZERO:
      2	  14833     fbzColorPath |= SST_CCA_ZERO_OTHER;
      2	  14834     break;
      2	  14835     
      2	  14836   case GR_COMBINE_FUNCTION_LOCAL:
      2	  14837   case GR_COMBINE_FUNCTION_LOCAL_ALPHA:
      2	  14838     fbzColorPath |= SST_CCA_ZERO_OTHER | SST_CCA_ADD_ALOCAL;
      2	  14839     break;
      2	  14840     
      2	  14841   case GR_COMBINE_FUNCTION_SCALE_OTHER:
      2	  14842     break;
      2	  14843     
      2	  14844   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL:
      2	  14845   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA:
      2	  14846     fbzColorPath |= SST_CCA_ADD_ALOCAL;
      2	  14847     break;
      2	  14848     
      2	  14849   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL:
      2	  14850     fbzColorPath |= SST_CCA_SUB_CLOCAL;
      2	  14851     break;
      2	  14852     
      2	  14853   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL:
      2	  14854   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14855     fbzColorPath |= SST_CCA_SUB_CLOCAL | SST_CCA_ADD_ALOCAL;
      2	  14856     break;
      2	  14857     
      2	  14858   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL:
      2	  14859   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  14860     fbzColorPath |= SST_CCA_ZERO_OTHER | SST_CCA_SUB_CLOCAL | SST_CCA_ADD_ALOCAL;
      2	  14861     break;
      1	  14862   }
      1	  14863 
      1	  14864   /* if either color or alpha combine requires texture then enable it */
      1	  14865   if (gc->state.cc_requires_texture || gc->state.ac_requires_texture)
      1	  14866     fbzColorPath |= SST_ENTEXTUREMAP;
      1	  14867   gc->state.fbi_config.fbzColorPath = fbzColorPath;
      1	  14868 
      2	  14869   {
      2	  14870     const FxBool texTransP = (oldTextureEnabled != (fbzColorPath & SST_ENTEXTUREMAP));
      2	  14871 
      2	  14872     GR_SET_EXPECTED_SIZE(sizeof(FxU32) + (texTransP ? sizeof(FxU32) : 0),
      2	  14873                          1 + texTransP);
      2	  14874 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  14875     /* transition into/out of texturing ... add nopCMD */
      2	  14876     if (texTransP) GR_SET(BROADCAST_ID, hw, nopCMD, 0);
      2	  14877     GR_SET(BROADCAST_ID, hw, fbzColorPath,  fbzColorPath);
      2	  14878     GR_CHECK_SIZE();
      1	  14879   }
      1	  14880 
      1	  14881   /* setup paramIndex bits */
      1	  14882   _grUpdateParamIndex();
      1	  14883 #undef FN_NAME
      1	  14884 } /* grAlphaCombine */
	  14885 
	  14886 /*---------------------------------------------------------------------------
	  14887 ** grAlphaControlsITRGBLighting
	  14888 ** 
	  14889 ** Determines whether the LSB of alpha controls what lighting is used--
	  14890 ** Specifically whether grConstantColorValu or the interated RGB values are used
	  14891 ** during TEXTURE_TIMES_itrgb & TEXTURE_TIMES_ITRGB_DELTA0 color combine modes.
	  14892 **
	  14893 */  
	  14894 
	  14895 GR_STATE_ENTRY(grAlphaControlsITRGBLighting, void, (FxBool enable))
      1	  14896 {
      1	  14897 #define FN_NAME "grAlphaControlsITRGBLighting"
      1	  14898   FxU32 fbzColorPath;
      1	  14899   GR_BEGIN_NOFIFOCHECK("grAlphaControlsITRGBLighting", 85);
      1	  14900   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", enable);
      1	  14901 
      1	  14902   fbzColorPath = gc->state.fbi_config.fbzColorPath;
      2	  14903   if (enable) {
      2	  14904     fbzColorPath |= SST_LOCALSELECT_OVERRIDE_WITH_ATEX;
      2	  14905   } else {
      2	  14906     fbzColorPath &= ~SST_LOCALSELECT_OVERRIDE_WITH_ATEX;
      1	  14907   }
      1	  14908 
      1	  14909   gc->state.fbi_config.fbzColorPath = fbzColorPath;
      1	  14910 
      1	  14911   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  14912   GR_SET(BROADCAST_ID, hw, fbzColorPath, fbzColorPath);
      1	  14913   GR_CHECK_SIZE();
      1	  14914 #undef FN_NAME
      1	  14915 } /* grAlphaControlsITRGBLighting() */
	  14916 
	  14917 /*---------------------------------------------------------------------------
	  14918 ** grAlphaTestFunction
	  14919 */
	  14920 
	  14921 GR_STATE_ENTRY(grAlphaTestFunction, void, (GrCmpFnc_t fnc))
      1	  14922 {
      1	  14923 #define FN_NAME "grAlphaTestFunction"
      1	  14924   FxU32 alphamode;
      1	  14925   GR_BEGIN_NOFIFOCHECK("grAlphaTestFunction", 85);
      1	  14926   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",fnc);
      1	  14927 
      1	  14928   alphamode = gc->state.fbi_config.alphaMode;
      1	  14929   alphamode &= ~(SST_ALPHAFUNC | SST_ENALPHAFUNC);
      1	  14930   if (fnc != GR_CMP_ALWAYS)
      1	  14931     alphamode |= ((fnc << SST_ALPHAFUNC_SHIFT) | SST_ENALPHAFUNC);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  14932 
      1	  14933   gc->state.fbi_config.alphaMode = alphamode;
      1	  14934 
      1	  14935   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  14936   GR_SET(BROADCAST_ID, hw, alphaMode, alphamode);
      1	  14937   GR_CHECK_SIZE();
      1	  14938 #undef FN_NAME
      1	  14939 } /* grAlphaTestFunction */
	  14940 
	  14941 /*---------------------------------------------------------------------------
	  14942 ** grAlphaTestReferenceValue
	  14943 */
	  14944 
	  14945 GR_STATE_ENTRY(grAlphaTestReferenceValue, void, (GrAlpha_t value))
      1	  14946 {
      1	  14947 #define FN_NAME "grAlphaTestReferenceValue"
      1	  14948   FxU32 alphamode;
      1	  14949   GR_BEGIN_NOFIFOCHECK("grAlphaTestReferenceValue", 85);
      1	  14950   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",value);
      1	  14951 
      1	  14952   alphamode = gc->state.fbi_config.alphaMode;
      1	  14953   alphamode &= ~SST_ALPHAREF;
      1	  14954   alphamode |= (((FxU32) value) << SST_ALPHAREF_SHIFT);
      1	  14955 
      1	  14956   gc->state.fbi_config.alphaMode = alphamode;
      1	  14957 
      1	  14958   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  14959   GR_SET(BROADCAST_ID, hw, alphaMode,  alphamode);
      1	  14960   GR_CHECK_SIZE();
      1	  14961 #undef FN_NAME
      1	  14962 } /* grAlphaTestReferenceValue */
	  14963 
	  14964 /*---------------------------------------------------------------------------
	  14965 ** grBufferClear
	  14966 */
	  14967 
	  14968 GR_ENTRY(grBufferClear, void, (GrColor_t color, GrAlpha_t alpha, FxU16 depth))
      1	  14969 {
      1	  14970 #define FN_NAME "grBufferClear"
      1	  14971   GR_BEGIN_NOFIFOCHECK("grBufferClear", 86);
      1	  14972   GDBG_INFO_MORE(gc->myLevel, "(0x%x,0x%x,0x%x)\n", color, alpha, depth);
      1	  14973 
      2	  14974   {
      2	  14975     const GrColor_t oldc1 = gc->state.fbi_config.color1;
      2	  14976     const FxU32 oldzacolor = gc->state.fbi_config.zaColor;
      2	  14977     const FxU32 fbzMode = gc->state.fbi_config.fbzMode;
      2	  14978     FxU32 zacolor = oldzacolor;
      2	  14979     FxBool doneP = FXFALSE;
      2	  14980     FxBool doColorP = ((fbzMode & SST_RGBWRMASK) != 0);
      2	  14981     FxBool doAuxP = FXFALSE;
      2	  14982 
      2X  14983 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR
      2X  14984     const FxU32 clipBottomTop = gc->state.fbi_config.clipBottomTop;
      2X  14985     const FxU32 bottomOriginP = ((fbzMode & SST_YORIGIN) == SST_YORIGIN);
      2X  14986     FxBool didClipP = FXFALSE;
      2X  14987 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR */
      2	  14988 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  14989     /* Setup source registers */
      2	  14990     if (doColorP) _grSwizzleColor(&color);
      3	  14991     if ((fbzMode & SST_ZAWRMASK) != 0) {
      4	  14992       if ((fbzMode & SST_ENALPHABUFFER) != 0) {
      4	  14993         doAuxP = FXTRUE;
      4	  14994 
      4	  14995         zacolor &= ~SST_ZACOLOR_ALPHA;
      4	  14996         zacolor |= (((FxU32) alpha) << SST_ZACOLOR_ALPHA_SHIFT);
      4	  14997       } else if ((fbzMode & SST_ENDEPTHBUFFER) != 0) {
      4	  14998         doAuxP = FXTRUE;
      4	  14999 
      4	  15000         zacolor &= ~SST_ZACOLOR_DEPTH;
      4	  15001         zacolor |= (((FxU32) depth) << SST_ZACOLOR_DEPTH_SHIFT);
      3	  15002       }
      2	  15003     }
      2	  15004 
      2	  15005     /* Why were we called? */
      2	  15006     if (!doColorP && !doAuxP) return;
      2	  15007 
      2X  15008 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR
      2	  15009     /* If the width clipping is the same as the screen resolution
      2	  15010      * then we can use the sgram fill rect to clear the page aligned
      2	  15011      * region, and then use the fastFillCmd to clear the remainder.
      2	  15012      * 
      2	  15013      * NB: The test really does check against (clipLeft == 0) &&
      2	  15014      * (clipright == screenWidth) since screenWidth should have 0
      2	  15015      * in its upper bits.
      2	  15016      *
      2	  15017      * First we convert the vertical clipping from pixel coordinates
      2	  15018      * to tile coordinates. (The top coordinate is rounded up to the
      2	  15019      * next page, and the bottom coordinate is rounded down.) A page
      2	  15020      * (4k) is composed of two tiles layed out horizontally. We then
      2	  15021      * map this into fbi memory based on the current screen
      2	  15022      * resolution, set in grSstWinOpen, scaled into tile space as
      2	  15023      * well. Ick!
      2	  15024      *
      2	  15025      * To top it all of we have this 'special' case thanks to sli and
      2	  15026      * y origin flipping. The problem is that each card is responsible
      2	  15027      * for rendering its set of scanlines, regardless or the location
      2	  15028      * of the y origin. However, if the origin is 'flipped' then it
      2	  15029      * can be the case that the 'first' scanline on the screen is
      2	  15030      * actually odd. To get around this the hw implicitly adds two
      2	  15031      * invisible (they're always black) scanlines to the renderable
      2	  15032      * area. If the y origin is at the top of the screen then
      2	  15033      * scanlines screenHeight and (screenHeight + 1) are not
      2	  15034      * rendered. If the origin is 'flipped' then scanlines 0 and
      2	  15035      * (screenHeight + 1) are not rendered.
      2X  15036      */
      2X  15037     if (gc->state.fbi_config.clipLeftRight == gc->state.screen_width) {
      2X  15038       const FxU32 screenHeightAdjust = (gc->scanline_interleaved && bottomOriginP ? 1 : 0);
      2X  15039       const FxU32 screenHeight = gc->state.screen_height + screenHeightAdjust;
      2X  15040       const FxU32 yTileShift = gc->hwDep.cvgDep.yTileShift;
      2X  15041       const FxU32 yTileMask = ((0x01 << yTileShift) - 1);
      2X  15042       const FxU32 regBottom = ((clipBottomTop >> SST_CLIPBOTTOM_SHIFT) & 0x0FFF);
      2X  15043       const FxU32 regTop = ((clipBottomTop >> SST_CLIPTOP_SHIFT) & 0x0FFF);
      2X  15044       const FxU32 clipLow = (bottomOriginP ? screenHeight - regTop : regBottom);
      2X  15045       const FxU32 clipHi = (bottomOriginP ? screenHeight - regBottom : regTop);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2X  15046       const FxU32 tileLow = ((clipLow >> yTileShift) + (((clipLow & yTileMask) == 0) ? 0 : 1));
      2X  15047       const FxU32 tileHi = (clipHi >> yTileShift);
      2X  15048 
      2X  15049       /* If they're both in the same tile then just clear using a
      2X  15050        * fastFillCmd 
      2X  15051        */
      2X  15052       if (tileHi <= tileLow) goto __skipBlitClear;
      2X  15053 
      2X  15054       /* Column size is always a full page size divided by the #
      2X  15055        * of points in a tile row (2 tiles). 
      2X  15056        *
      2X  15057        * NB: This set is 'lifted' out of the groupings below because
      2X  15058        * it is common and stays set accross blit invocations.
      2X  15059        */
      2X  15060       {
      2X  15061         GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      2X  15062         GR_SET(BROADCAST_ID, hw, bltSize,  
      2X  15063                (((((tileHi - tileLow) * gc->hwDep.cvgDep.xTilePages) - 1) << 16) | 511));/* 511 == (0x1000 >> 3) - 1
      2X  15063  */
      2X  15064         GR_CHECK_SIZE();
      2X  15065       }
      2X  15066 
      2X  15067       /* Clear the current buffer */
      2X  15068       if (doColorP) {
      2X  15069         const FxU32 tileBuffer = (gc->hwDep.cvgDep.numBufferPages * gc->hwDep.cvgDep.renderBuf);
      2X  15070 
      2X  15071         REG_GROUP_BEGIN(BROADCAST_ID, bltDstXY, 3, 0x29);
      2X  15072         {
      2X  15073           /* Starting point of the blit. We always do a full page in x. */
      2X  15074           REG_GROUP_SET(hw, bltDstXY, 
      2X  15075                         (((tileBuffer + (tileLow * gc->hwDep.cvgDep.xTilePages)) << 16) | 0x00UL));
      2X  15076 
      2X  15077           /* dpc - 27 aug 1997 - FixMe!
      2X  15078            * What is the right way of converting the 888 color that we're
      2X  15079            * passed into a 565 color?
      2X  15080            */
      2X  15081           REG_GROUP_SET(hw, bltColor, (((color & 0xF8UL) >> (3 + 0)) |      /* blue [4:0] */
      2X  15082                                        ((color & 0xFC00UL) >> (2 + 3)) |    /* green [10:5] */
      2X  15083                                        ((color & 0xF80000UL) >> (3 + 5)))); /* red [15:11] */
      2X  15084 
      2X  15085           REG_GROUP_SET(hw, bltCommand, (SSTG_FRECTFILL | /* SGRAM Fill command */
      2X  15086                                          0x80000000));    /* Start blit signal */
      2X  15087         }
      2X  15088         REG_GROUP_END();
      2X  15089       }
      2X  15090 
      2X  15091       /* Clear the aux buffer */
      2X  15092       if (doAuxP) {
      2X  15093         const FxU32 tileBuffer = (gc->hwDep.cvgDep.numBufferPages * gc->state.num_buffers);
      2X  15094            
      2X  15095         REG_GROUP_BEGIN(BROADCAST_ID, bltDstXY, 3, 0x29);
      2X  15096         {
      2X  15097           REG_GROUP_SET(hw, bltDstXY, (((tileBuffer + (tileLow * gc->hwDep.cvgDep.xTilePages)) << 16) |
      2X  15098                                        0x00UL));
      2X  15099           REG_GROUP_SET(hw, bltColor, zacolor);
      2X  15100           REG_GROUP_SET(hw, bltCommand, (SSTG_FRECTFILL | /* SGRAM Fill command */
      2X  15101                                          0x80000000));    /* Start blit signal */

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2X  15102         }
      2X  15103         REG_GROUP_END();
      2X  15104       }
      2X  15105 
      2X  15106   __skipBlitClear:
      2X  15107       /* Did we round off crap to page align the top part of
      2X  15108        * clipping? If so then reset the hw clipping and use
      2X  15109        * the normal fastFillCmd on this region. 
      2X  15110        */
      2X  15111       didClipP = ((tileLow << yTileShift) > clipLow);
      2X  15112       if (didClipP) {
      2X  15113         REG_GROUP_BEGIN(BROADCAST_ID, zaColor, 2, 0x41UL);
      2X  15114         {
      2X  15115           /* Set the colors */
      2X  15116           REG_GROUP_SET(hw, zaColor, zacolor);
      2X  15117           REG_GROUP_SET(hw, c1, color);
      2X  15118         }
      2X  15119         REG_GROUP_END();
      2X  15120 
      2X  15121         REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 
      2X  15122                         2 + bottomOriginP, (bottomOriginP | 0x28UL));
      2X  15123         {
      2X  15124           /* Put the origin in our canonical clipping form */
      2X  15125           if (bottomOriginP) REG_GROUP_SET(hw, fbzMode, fbzMode & ~SST_YORIGIN);
      2X  15126 
      2X  15127           /* Reset the clipping to have the same top clipping and
      2X  15128            * our rounded clip value as the bottom.
      2X  15129            */
      2X  15130           REG_GROUP_SET(hw, clipBottomTop, ((clipLow << SST_CLIPBOTTOM_SHIFT) |
      2X  15131                                             MIN(((tileLow << yTileShift) << SST_CLIPTOP_SHIFT), clipHi)));
      2X  15132           
      2X  15133           /* Execute the FASTFILL command */
      2X  15134           REG_GROUP_SET(hw, fastfillCMD, 1);
      2X  15135         }
      2X  15136         REG_GROUP_END();
      2X  15137       }       
      2X  15138          
      2X  15139       /* If we're done then we have to restore the color registers.
      2X  15140        * Otherwise, leave them set for the next fastFillCmd, and
      2X  15141        * reset the clipping for the bottom rounding error.
      2X  15142        */
      2X  15143       doneP = ((tileLow > tileHi) |
      2X  15144                ((tileHi << yTileShift) == clipHi));
      2X  15145       if (doneP && didClipP) {
      2X  15146         REG_GROUP_BEGIN(BROADCAST_ID, zaColor, 2, 0x41);
      2X  15147         {
      2X  15148           REG_GROUP_SET(hw, zaColor, oldzacolor);
      2X  15149           REG_GROUP_SET(hw, c1, oldc1);
      2X  15150         }
      2X  15151         REG_GROUP_END();
      2X  15152       } else if (!doneP) {
      2X  15153         const FxBool origSetP = (bottomOriginP & !didClipP);
      2X  15154 
      2X  15155         REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 1 + origSetP, (origSetP | 0x8UL));
      2X  15156         {
      2X  15157           if (origSetP) REG_GROUP_SET(hw, fbzMode, fbzMode & ~SST_YORIGIN);
      2X  15158 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2X  15159           /* Reset the clipping to have the same bottom clipping and
      2X  15160            * our rounded clip value as the top.
      2X  15161            */
      2X  15162           REG_GROUP_SET(hw, clipBottomTop, (((tileHi << yTileShift) << SST_CLIPBOTTOM_SHIFT) |
      2X  15163                                             (clipHi << SST_CLIPTOP_SHIFT)));
      2X  15164         }
      2X  15165         REG_GROUP_END();
      2X  15166 
      2X  15167         /* Clear the color sense flags so that we don't waste
      2X  15168          * time sending them again, and always set the clip flag.
      2X  15169          */
      2X  15170         doColorP = 
      2X  15171         doAuxP   = FXFALSE;
      2X  15172         didClipP = FXTRUE;
      2X  15173       }
      2X  15174     }
      2X  15175 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR */
      2	  15176     
      3	  15177     if (!doneP) {
      4	  15178       REG_GROUP_BEGIN(BROADCAST_ID, zaColor, 2, 0x41);
      5	  15179       {
      5	  15180         REG_GROUP_SET(hw, zaColor, zacolor);
      5	  15181         REG_GROUP_SET(hw, c1, color);
      4	  15182       }
      3	  15183       REG_GROUP_END();
      3	  15184       
      4	  15185       REG_GROUP_BEGIN(BROADCAST_ID, fastfillCMD, 3, 0x209);
      5	  15186       {
      5	  15187         /* Execute the FASTFILL command */
      5	  15188         REG_GROUP_SET(hw, fastfillCMD, 1);
      5	  15189         
      5	  15190         /* Restore C1 and ZACOLOR */
      5	  15191         REG_GROUP_SET(hw, zaColor, oldzacolor);
      5	  15192         REG_GROUP_SET(hw, c1, oldc1);
      4	  15193       }
      3	  15194       REG_GROUP_END();
      2	  15195     }
      2	  15196 
      2X  15197 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR
      2X  15198     /* Restore clipping */
      2X  15199     if (didClipP) {
      2X  15200       REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 
      2X  15201                       bottomOriginP + 1, (bottomOriginP | 0x8UL));
      2X  15202       {
      2X  15203         if (bottomOriginP) REG_GROUP_SET(hw, fbzMode, fbzMode);
      2X  15204         REG_GROUP_SET(hw, clipBottomTop, clipBottomTop);
      2X  15205       }
      2X  15206       REG_GROUP_END();
      2X  15207     }
      2X  15208 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR */
      1	  15209   }
      1	  15210 
      1	  15211 #undef FN_NAME
      1	  15212 } /* grBufferClear */
	  15213 
	  15214 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
	  15215 /* Sli has an 'interesting' feature where the physical scanlines

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  15216  * that are being rendered is dependent on the location of the y
	  15217  * origin. We always clear the overlap bit to black here so that
	  15218  * no one ever notices. This needs to be done for all of the allocated
	  15219  * color buffers that could have possibly have been rendered to since
	  15220  * the last origin swap. Rather than beeing really tricky I just do
	  15221  * it for every allocated color buffer.
	  15222  *
	  15223  * Origin_Lower_Left: 0:Black [1 .. screenRezY]:Rendered screenRez+1:Black
	  15224  * Origin_Upper_Left: [0 .. screenRezY - 1]:Rendered [screenRez-screenRez+1]:Black
	  15225  */
	  15226 void
	  15227 _grSliOriginClear(void)
      1	  15228 {
      1	  15229 #define FN_NAME "_grSliOriginClear"
      1	  15230   GR_BEGIN_NOFIFOCHECK(FN_NAME, 86);
      1	  15231 
      1	  15232   GR_ASSERT(gc->scanline_interleaved);
      1	  15233   GR_ASSERT(gc->hwDep.cvgDep.sliOriginBufCount != 0);
      1	  15234 
      1	  15235   /* Setup the two pixel high area to clear */
      2	  15236   REG_GROUP_BEGIN(BROADCAST_ID, clipLeftRight, 3, 0x1003UL);
      3	  15237   {
      3	  15238     REG_GROUP_SET(hw, clipLeftRight, gc->state.screen_width);
      3	  15239     REG_GROUP_SET(hw, clipBottomTop, 0x01UL);
      3	  15240     REG_GROUP_SET(hw, c1, 0x00UL);
      2	  15241   }
      1	  15242   REG_GROUP_END();
      1	  15243   
      1	  15244   /* Do the clear */
      2	  15245   REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 2, 0x21UL);
      3	  15246   {
      3	  15247     REG_GROUP_SET(hw, fbzMode, 
      3	  15248                   ((gc->state.fbi_config.fbzMode & ~SST_YORIGIN) | 
      3	  15249                    (~gc->state.fbi_config.fbzMode & SST_YORIGIN) |
      3	  15250                    SST_RGBWRMASK));
      3	  15251     REG_GROUP_SET(hw, fastfillCMD, 0x01UL);
      2	  15252   }
      1	  15253   REG_GROUP_END();
      1	  15254 
      2	  15255   REG_GROUP_BEGIN(BROADCAST_ID, fbzMode, 2, 0x21UL);
      3	  15256   {
      3	  15257     REG_GROUP_SET(hw, fbzMode, 
      3	  15258                   (gc->state.fbi_config.fbzMode | SST_RGBWRMASK));
      3	  15259     REG_GROUP_SET(hw, fastfillCMD, 0x01UL);
      2	  15260   }
      1	  15261   REG_GROUP_END();
      1	  15262   
      1	  15263   /* Restore the initial glide state.
      1	  15264    * NB: Cannot be done in one packet. Wah!
      1	  15265    */
      1	  15266   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15267   GR_SET(BROADCAST_ID, hw, fbzMode, gc->state.fbi_config.fbzMode);
      1	  15268   GR_CHECK_SIZE();
      1	  15269 
      2	  15270   REG_GROUP_BEGIN(BROADCAST_ID, clipLeftRight, 3, 0x1003UL);
      3	  15271   {
      3	  15272     REG_GROUP_SET(hw, clipLeftRight, gc->state.fbi_config.clipLeftRight);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      3	  15273     REG_GROUP_SET(hw, clipBottomTop, gc->state.fbi_config.clipBottomTop);
      3	  15274     REG_GROUP_SET(hw, c1, gc->state.fbi_config.color1);
      2	  15275   }
      1	  15276   REG_GROUP_END();
      1	  15277 
      1	  15278   gc->hwDep.cvgDep.sliOriginBufCount--;
      1	  15279 #undef FN_NAME
      1	  15280 }
	  15281 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
	  15282 
	  15283 /*---------------------------------------------------------------------------
	  15284 ** grBufferSwap
	  15285 **
	  15286 ** NOTE:        This routine should be COMPLETELY device-independant,
	  15287 **              but it isn't right now because we need to move all the
	  15288 **              code for the splash screen into the init library.
	  15289 */
	  15290 GR_ENTRY(grBufferSwap, void, (int swapInterval))
      1	  15291 {
      1	  15292 #define FN_NAME "grBufferSwap"
      1	  15293   int vSync;
      1	  15294 
      1	  15295   GR_BEGIN_NOFIFOCHECK(FN_NAME, 88);
      1	  15296   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",swapInterval);
      1	  15297 
      1	  15298 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      1	  15299   if (gc->hwDep.cvgDep.singleBufferP) return;
      1	  15300 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      1	  15301 
      1	  15302 #if ((GLIDE_PLATFORM & GLIDE_HW_CVG) || (GLIDE_PLATFORM & GLIDE_HW_H3))
      1X  15303   #ifdef GLIDE_PLUG
      1X  15304   /* optionally display the 3Dfx powerfield logo overlay */
      1X  15305   if (_GlideRoot.environment.shamelessPlug) _grShamelessPlug();
      1X  15306   #endif
      1	  15307 
      1	  15308   /* check for environmental override.
      1	  15309    * 
      1	  15310    * NB: If we are sli, the application passes in 0, and the user has
      1	  15311    * elected to not sync to retrace then we honor the user's
      1	  15312    * choice. Otherwise we force syncing because most apps don't know
      1	  15313    * any better. If, however, the user has not chosen, but the app
      1	  15314    * wants something other than 0 then we need to honor their choice.  
      1	  15315    */
      1	  15316   swapInterval = ((_GlideRoot.environment.swapInterval >= 0)
      1	  15317                   ? _GlideRoot.environment.swapInterval
      1	  15318                   : (gc->scanline_interleaved ? MAX(swapInterval, 1) : swapInterval));
      1	  15319   
      1	  15320   GR_CHECK_F(myName,
      1	  15321              (swapInterval > 255) || (swapInterval < 0),
      1	  15322              "swap_interval out of range");
      1	  15323 
      1	  15324   /* Wait until there's 6 or fewer buffer swaps pending.  the hardware
      1	  15325    * counter is only 3 bits so we don't want it to overflow also the
      1	  15326    * latency gets too long.
      1	  15327    */
      1	  15328   while (grBufferNumPending() > 6)
      1	  15329     ;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15330   
      1	  15331   /* if the interval is non-zero turn on VSYNC waiting */
      1	  15332   vSync = (swapInterval > 0);
      1	  15333 
      1	  15334   /* when triple buffering, vsync must be enabled and swapbuffer interval must be 0 */
      1	  15335   /*if (gc->grColBuf >= 3) {
      1	  15336     vSync = FXTRUE;
      1	  15337     swapInterval = 0;
      1	  15338   }*/
      1	  15339   
      1	  15340   if (swapInterval > 0) swapInterval--;
      1	  15341   
      1	  15342     /* NOTE: we need a PCI read before and after the swap command */
      1	  15343     /* but since we already called grBufferNumPending() we've done a read */
      2	  15344   {
      2	  15345     const FxU32 swapCmdVal = (swapInterval << 1) | vSync;
      2	  15346 
      2X  15347 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && USE_PACKET_FIFO
      2	  15348     /* When the command fifo is enabled we need to do a naked
      2	  15349      * set to the command register too so that the num swaps pending
      2	  15350      * field in status is kept in sync w/ reality.
      2	  15351      *
      2	  15352      * NB: This must be done before the fifo write to avoid a race
      2	  15353      * condition if the hw is on our ass.
      2	  15354      *
      2	  15355      * NB: We fence here just in case since we are hopefully going to
      2	  15356      * figure out the damn uswc problem soon.
      2X  15357      */
      2X  15358     SET(hw->swapbufferCMD, swapCmdVal);
      2X  15359     P6FENCE;
      2X  15360 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && USE_PACKET_FIFO */
      2	  15361 
      2	  15362     GR_SET_EXPECTED_SIZE(4, 1);
      2	  15363     GR_SET(BROADCAST_ID, hw, swapbufferCMD,  swapCmdVal);
      2	  15364     GR_CHECK_SIZE();
      1	  15365   }
      1	  15366   
      1X  15367 #ifdef GLIDE_DEBUG
      1X  15368   if ((FxI32)_GlideRoot.environment.snapshot > 0) {
      1X  15369     static char saveDBG[GDBG_MAX_LEVELS];
      1X  15370     int i;
      1X  15371     
      1X  15372     /* turn off tracing after frame 0 and the snapshot frame */
      1X  15373     if ((_GlideRoot.stats.bufferSwaps == 0) || 
      1X  15374         (_GlideRoot.stats.bufferSwaps == _GlideRoot.environment.snapshot + 3)) {
      1X  15375       GDBG_PRINTF(FN_NAME": FX_SNAPSHOT (%ld)\n", _GlideRoot.stats.bufferSwaps);
      1X  15376       for (i = 1; i < GDBG_MAX_LEVELS; i++) {
      1X  15377         if (_GlideRoot.stats.bufferSwaps == 0) saveDBG[i] = (char)GDBG_GET_DEBUGLEVEL(i);
      1X  15378         GDBG_SET_DEBUGLEVEL(i, 0);
      1X  15379       }
      1X  15380     }
      1X  15381 
      1X  15382     /* turn on tracing after the snapshot frame */
      1X  15383     if (_GlideRoot.stats.bufferSwaps == _GlideRoot.environment.snapshot) {
      1X  15384       GDBG_PRINTF(FN_NAME": FX_SNAPSHOT (%ld)\n", _GlideRoot.stats.bufferSwaps);
      1X  15385       for (i = 1; i < GDBG_MAX_LEVELS; i++) {
      1X  15386         GDBG_SET_DEBUGLEVEL(i, saveDBG[i]);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1X  15387       }
      1X  15388     }
      1X  15389   }
      1X  15390 #endif /* GLIDE_DEBUG */
      1	  15391 
      1	  15392 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      1	  15393   if (gc->hwDep.cvgDep.sliOriginBufCount != 0) _grSliOriginClear();
      1	  15394 
      1X  15395 #if GLIDE_BLIT_CLEAR
      1X  15396   {
      1X  15397     const FxU32 numBufs = gc->state.num_buffers;
      1X  15398     FxU32* bufPtrs[3];
      1X  15399     FxU32 i;
      1X  15400 
      1X  15401     bufPtrs[0] = &gc->hwDep.cvgDep.renderBuf;
      1X  15402     bufPtrs[1] = &gc->hwDep.cvgDep.frontBuf;
      1X  15403     bufPtrs[2] = &gc->hwDep.cvgDep.backBuf;
      1X  15404 
      1X  15405     for(i = 0; i < sizeof(bufPtrs) / sizeof(*bufPtrs); i++) {
      1X  15406       *bufPtrs[i] = (*bufPtrs[i] + 1) % numBufs;
      1X  15407     }
      1X  15408 
      1X  15409     GDBG_INFO(gc->myLevel, 
      1X  15410               "\trenderBuf: 0x%X\n",
      1X  15411               gc->hwDep.cvgDep.renderBuf);
      1X  15412   }
      1X  15413 #endif /* GLIDE_BLIT_CLEAR */
      1	  15414 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      1	  15415 
      1	  15416   grSstStatus();        /* special bug workaround       */
      1X  15417 #else
      1X  15418 #    error "Need to implement swap." 
      1X  15419 #endif /* GLIDE_PLATFORM & GLIDE_HW_SST1 */
      1	  15420   
      1	  15421   _GlideRoot.stats.bufferSwaps++;
      1	  15422   
      1	  15423   GR_END();
      1	  15424 #undef FN_NAME  
      1	  15425 } /* grBufferSwap */
	  15426 
	  15427 /*---------------------------------------------------------------------------
	  15428 ** grBufferNumPending
	  15429 */
	  15430 
	  15431 GR_ENTRY(grBufferNumPending, int, (void))
      1	  15432 {
      1	  15433   int pend;                       /* Num Swaps pending */
      1	  15434 
      2	  15435   {
      2	  15436     FxU32 status = grSstStatus();
      2	  15437     
      2	  15438 #if ((GLIDE_PLATFORM & GLIDE_HW_CVG) || (GLIDE_PLATFORM & GLIDE_HW_H3))
      2	  15439     pend = ((status & SST_SWAPBUFPENDING) >> SST_SWAPBUFPENDING_SHIFT);
      2X  15440 #else
      2X  15441 #error "Implement BufferNumPending for this hardware"
      2X  15442 #endif
      1	  15443   }

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15444 
      1	  15445   GDBG_INFO(86,"grBufferNumPending() => %d\n", pend);
      1	  15446 
      1	  15447   return pend;
      1	  15448 } /* grBufferNumPending */
	  15449 
	  15450 /*---------------------------------------------------------------------------
	  15451 ** grChromakeyMode
	  15452 */
	  15453 
	  15454 GR_STATE_ENTRY(grChromakeyMode, void, (GrChromakeyMode_t mode))
      1	  15455 {
      1	  15456 #define FN_NAME "grChromakeyMode"
      1	  15457   FxU32 fbzMode;
      1	  15458   GR_BEGIN_NOFIFOCHECK("grChromakeyMode", 85);
      1	  15459   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", mode);
      1	  15460 
      1	  15461   fbzMode = gc->state.fbi_config.fbzMode;
      1	  15462   if (mode == GR_CHROMAKEY_ENABLE)
      1	  15463     fbzMode |= SST_ENCHROMAKEY;
      1	  15464   else
      1	  15465     fbzMode &= ~SST_ENCHROMAKEY;
      1	  15466 
      1	  15467   gc->state.fbi_config.fbzMode = fbzMode;
      1	  15468 
      1	  15469   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15470   GR_SET(eChipFBI, hw, fbzMode,  fbzMode);
      1	  15471   GR_CHECK_SIZE();
      1	  15472 #undef FN_NAME
      1	  15473 } /* grChromaKeyMode */
	  15474 
	  15475 /*---------------------------------------------------------------------------
	  15476 ** grChromakeyValue
	  15477 */
	  15478 GR_STATE_ENTRY(grChromakeyValue, void, (GrColor_t color))
      1	  15479 {
      1	  15480 #define FN_NAME "grChromakeyValue"
      1	  15481   GR_BEGIN_NOFIFOCHECK("grChromakeyValue", 10);
      1	  15482   GDBG_INFO_MORE(gc->myLevel, "(0x%x)\n", color);
      1	  15483 
      1	  15484   _grSwizzleColor(&color);
      1	  15485   gc->state.fbi_config.chromaKey = color;
      1	  15486 
      1	  15487 #if 1
      1	  15488   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15489   GR_SET(eChipFBI, hw, chromaKey,  color);
      1	  15490   GR_CHECK_SIZE();
      1X  15491 #else
      1	  15492   /* Experimental fix to see if the increased precison of v^2 bilinear
      1	  15493    * blending (.4 to .8) was causing more grief to developers who did
      1	  15494    * the hacky by turning on chroma w/ bilinear.
      1X  15495    */
      1X  15496 #define kChromaOffset 2
      1X  15497   {
      1X  15498     const FxI32 compR = (color >> 16) & 0xFF;
      1X  15499     const FxI32 compG = (color >>  8) & 0xFF;
      1X  15500     const FxI32 compB = (color >>  0) & 0xFF;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1X  15501     const FxU32 chromaMin = ((MAX(compR - kChromaOffset, 0x00) << 16) |
      1X  15502                              (MAX(compG - kChromaOffset, 0x00) <<  8) |
      1X  15503                              (MAX(compB - kChromaOffset, 0x00) <<  0));
      1X  15504     const FxU32 chromaMax = ((MIN(compR + kChromaOffset, 0xFF) << 16) |
      1X  15505                              (MIN(compG + kChromaOffset, 0xFF) <<  8) |
      1X  15506                              (MIN(compB + kChromaOffset, 0xFF) <<  0));
      1X  15507 
      1X  15508     REG_GROUP_BEGIN(eChipFBI, chromaKey, 2, 0x03UL);
      1X  15509     {
      1X  15510       REG_GROUP_SET(hw, chromaKey, chromaMin);
      1X  15511       REG_GROUP_SET(hw, chromaRange, chromaMax | SST_ENCHROMARANGE);
      1X  15512     }
      1X  15513     REG_GROUP_END();
      1X  15514   }
      1X  15515 #undef kChromaOffset
      1X  15516 #endif
      1	  15517 #undef FN_NAME
      1	  15518 } /* grChromaKeyValue */
	  15519 
	  15520 /*---------------------------------------------------------------------------
	  15521 ** _grClipNormalizeAndGenerateRegValues
	  15522 **
	  15523 ** This routine normalizes clip variables to screen_width and
	  15524 ** screen_height, then generates the values to be written to the
	  15525 ** registers clipLeftRight and clipBottomTop.   The reason for its
	  15526 ** existence is that BOTH grClipWindow() and grSstControl() need to
	  15527 ** write these registers.
	  15528 */
	  15529 void
	  15530 _grClipNormalizeAndGenerateRegValues(FxU32 minx, FxU32 miny, FxU32 maxx,
	  15531                                      FxU32 maxy, FxU32 *clipLeftRight,
	  15532                                      FxU32 *clipBottomTop)
      1	  15533 {
      1	  15534 #define FN_NAME "_grClipNormalizeAndGenerateRegValues"
      1	  15535   GR_DCL_GC;
      1	  15536 
      1	  15537   GDBG_INFO(85, "%s:  minx = %d, maxx = %d, miny = %d, maxy = %d\n",
      1	  15538             FN_NAME, minx, maxx, miny, maxy);
      1	  15539 
      1	  15540   GR_CHECK_COMPATABILITY(FN_NAME, 
      1	  15541                          ((maxx > gc->state.screen_width) || (maxy > gc->state.screen_height)),
      1	  15542                          "Max clip coordinate > screen size");
      1	  15543   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15544                          ((minx > LONG_MAX) || (miny > LONG_MAX)),
      1	  15545                          "Negative min clip coordinate");
      1	  15546 
      1	  15547   /* don't allow bogus clip coords!!! */
      1	  15548   if (maxx > gc->state.screen_width) maxx = gc->state.screen_width;
      1	  15549   if (maxy > gc->state.screen_height) maxy = gc->state.screen_height;
      1	  15550   if (minx > maxx) minx = maxx;
      1	  15551   if (miny > maxy) miny = maxy;
      1	  15552 
      1	  15553   GDBG_INFO(85, "%s: normalized  minx = %d, maxx = %d, miny = %d, maxy = %d\n",
      1	  15554             FN_NAME, minx, maxx, miny, maxy);
      1	  15555 
      1	  15556   *clipLeftRight = (minx << SST_CLIPLEFT_SHIFT) | (maxx << SST_CLIPRIGHT_SHIFT); 
      1	  15557   *clipBottomTop = (miny << SST_CLIPBOTTOM_SHIFT) | (maxy << SST_CLIPTOP_SHIFT);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15558 
      1	  15559   GDBG_INFO(85, "%s:  clipLeftRight = 0x%x, clipBottomTop = 0x%x\n",
      1	  15560             FN_NAME, clipLeftRight, clipBottomTop);
      1	  15561 
      1	  15562 #undef FN_NAME 
      1	  15563 } /* _grClipNormalizeAndGenerateRegValues */
	  15564 
	  15565 /*---------------------------------------------------------------------------
	  15566 ** grClipWindow
	  15567 */
	  15568 GR_STATE_ENTRY(grClipWindow, void, (FxU32 minx, FxU32 miny, 
	  15569                                     FxU32 maxx, FxU32 maxy)) 
      1	  15570 {
      1	  15571 #define FN_NAME "grClipWindow"
      1	  15572   FxU32
      1	  15573     clipLeftRight,              /* SST Clipping Registers */
      1	  15574     clipBottomTop;
      1	  15575 
      1	  15576   GR_BEGIN_NOFIFOCHECK("grClipWindow",83);
      1	  15577   GDBG_INFO_MORE(gc->myLevel,"(%d,%d %d,%d)\n",minx,miny,maxx,maxy);
      1	  15578 
      1	  15579   _grClipNormalizeAndGenerateRegValues(minx, miny, maxx, maxy,
      1	  15580                                        &clipLeftRight, &clipBottomTop);
      1	  15581 
      2	  15582   REG_GROUP_BEGIN(BROADCAST_ID, clipLeftRight, 2, 0x03);
      3	  15583   {
      3	  15584     REG_GROUP_SET(hw, clipLeftRight, clipLeftRight);
      3	  15585     REG_GROUP_SET(hw, clipBottomTop, clipBottomTop);
      2	  15586   }
      1	  15587   REG_GROUP_END();
      1	  15588 
      1	  15589   gc->state.fbi_config.clipLeftRight = clipLeftRight;
      1	  15590   gc->state.fbi_config.clipBottomTop = clipBottomTop;
      1	  15591 
      1	  15592   gc->state.clipwindowf_xmin = (float) minx;
      1	  15593   gc->state.clipwindowf_xmax = (float) maxx;
      1	  15594   gc->state.clipwindowf_ymin = (float) miny;
      1	  15595   gc->state.clipwindowf_ymax = (float) maxy;
      1	  15596 
      1	  15597   GR_END();
      1	  15598 #undef FN_NAME
      1	  15599 } /* grClipWindow */
	  15600 
	  15601 /*---------------------------------------------------------------------------
	  15602 ** grColorCombine
	  15603 */
	  15604 
	  15605 GR_STATE_ENTRY(grColorCombine, void, 
	  15606                (GrCombineFunction_t function, GrCombineFactor_t factor,
	  15607                 GrCombineLocal_t local, GrCombineOther_t other, FxBool invert))
      1	  15608 {
      1	  15609 #define FN_NAME "grColorCombine"
      1	  15610   FxU32 fbzColorPath;
      1	  15611   FxU32 oldTextureEnabled;
      1	  15612 
      1	  15613   GR_BEGIN_NOFIFOCHECK("grColorCombine",85);
      1	  15614   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,%d,%d,%d)\n",function,factor,local,other,invert);

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15615 
      1	  15616   GR_CHECK_W(myName,
      1	  15617              function < GR_COMBINE_FUNCTION_ZERO ||
      1	  15618              function > GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA ,
      1	  15619              "unsupported color combine function");
      1	  15620 
      1	  15621   /* Starting w/ Voodoo^2 the ccu has texture RGB mode as well. */
      1	  15622   GR_CHECK_W(myName,
      1	  15623              (factor & 0x7) < GR_COMBINE_FACTOR_ZERO ||
      1	  15624              (factor & 0x7) > GR_COMBINE_FACTOR_TEXTURE_RGB ||
      1	  15625              factor > GR_COMBINE_FACTOR_ONE_MINUS_TEXTURE_ALPHA,
      1	  15626              "unsupported color combine scale factor");
      1	  15627   GR_CHECK_W(myName,
      1	  15628              local < GR_COMBINE_LOCAL_ITERATED || local > GR_COMBINE_LOCAL_DEPTH,
      1	  15629              "unsupported color combine local color");
      1	  15630   GR_CHECK_W(myName,
      1	  15631              other < GR_COMBINE_OTHER_ITERATED || other > GR_COMBINE_OTHER_CONSTANT,
      1	  15632              "unsupported color combine other color");
      1	  15633 
      1	  15634   fbzColorPath = gc->state.fbi_config.fbzColorPath;
      1	  15635   oldTextureEnabled = fbzColorPath & SST_ENTEXTUREMAP;
      1	  15636   fbzColorPath &= ~(SST_ENTEXTUREMAP |
      1	  15637                     SST_RGBSELECT |
      1	  15638                     SST_LOCALSELECT |
      1	  15639                     SST_CC_ZERO_OTHER |
      1	  15640                     SST_CC_SUB_CLOCAL |
      1	  15641                     SST_CC_MSELECT |
      1	  15642                     SST_CC_REVERSE_BLEND |
      1	  15643                     SST_CC_ADD_CLOCAL |
      1	  15644                     SST_CC_ADD_ALOCAL |
      1	  15645                     SST_CC_INVERT_OUTPUT);
      1	  15646 
      1	  15647   /* this is bogus, it should be done once, somewhere. */
      1	  15648   fbzColorPath |= SST_PARMADJUST;
      1	  15649 
      1	  15650   /* setup reverse blending first, then strip off the the high bit */
      1	  15651   if ((factor & 0x8) == 0)
      1	  15652     fbzColorPath |= SST_CC_REVERSE_BLEND;
      1	  15653   factor &= 0x7;
      1	  15654 
      1	  15655   /* NOTE: we use boolean OR instead of logical to avoid branches */
      1	  15656   gc->state.cc_requires_texture = ((factor == GR_COMBINE_FACTOR_TEXTURE_ALPHA) |
      1	  15657                                    (factor == GR_COMBINE_FACTOR_TEXTURE_RGB) |
      1	  15658                                    (other == GR_COMBINE_OTHER_TEXTURE));
      1	  15659   gc->state.cc_requires_it_rgb = ((local == GR_COMBINE_LOCAL_ITERATED) |
      1	  15660                                   (other == GR_COMBINE_OTHER_ITERATED));
      1	  15661 
      1	  15662   /* setup scale factor bits */
      1	  15663   fbzColorPath |= factor << SST_CC_MSELECT_SHIFT;
      1	  15664 
      1	  15665   /* setup local color bits */
      1	  15666   fbzColorPath |= local << SST_LOCALSELECT_SHIFT;
      1	  15667 
      1	  15668   /* setup other color bits */
      1	  15669   fbzColorPath |= other << SST_RGBSELECT_SHIFT;
      1	  15670 
      1	  15671   /* setup invert output bits */

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15672   if (invert)
      1	  15673     fbzColorPath |= SST_CC_INVERT_OUTPUT;
      1	  15674 
      1	  15675   /* setup core color combine unit bits */
      2	  15676   switch (function) {
      2	  15677   case GR_COMBINE_FUNCTION_ZERO:
      2	  15678     fbzColorPath |= SST_CC_ZERO_OTHER;
      2	  15679     break;
      2	  15680 
      2	  15681   case GR_COMBINE_FUNCTION_LOCAL:
      2	  15682     fbzColorPath |= SST_CC_ZERO_OTHER | SST_CC_ADD_CLOCAL;
      2	  15683     break;
      2	  15684 
      2	  15685   case GR_COMBINE_FUNCTION_LOCAL_ALPHA:
      2	  15686     fbzColorPath |= SST_CC_ZERO_OTHER | SST_CC_ADD_ALOCAL;
      2	  15687     break;
      2	  15688 
      2	  15689   case GR_COMBINE_FUNCTION_SCALE_OTHER:
      2	  15690     break;
      2	  15691 
      2	  15692   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL:
      2	  15693     fbzColorPath |= SST_CC_ADD_CLOCAL;
      2	  15694     break;
      2	  15695 
      2	  15696   case GR_COMBINE_FUNCTION_SCALE_OTHER_ADD_LOCAL_ALPHA:
      2	  15697     fbzColorPath |= SST_CC_ADD_ALOCAL;
      2	  15698     break;
      2	  15699 
      2	  15700   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL:
      2	  15701     fbzColorPath |= SST_CC_SUB_CLOCAL;
      2	  15702     break;
      2	  15703 
      2	  15704   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL:
      2	  15705     fbzColorPath |= SST_CC_SUB_CLOCAL | SST_CC_ADD_CLOCAL;
      2	  15706     break;
      2	  15707 
      2	  15708   case GR_COMBINE_FUNCTION_SCALE_OTHER_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  15709     fbzColorPath |= SST_CC_SUB_CLOCAL | SST_CC_ADD_ALOCAL;
      2	  15710     break;
      2	  15711 
      2	  15712   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL:
      2	  15713     fbzColorPath |= SST_CC_ZERO_OTHER | SST_CC_SUB_CLOCAL | SST_CC_ADD_CLOCAL;
      2	  15714     break;
      2	  15715 
      2	  15716   case GR_COMBINE_FUNCTION_SCALE_MINUS_LOCAL_ADD_LOCAL_ALPHA:
      2	  15717     fbzColorPath |= SST_CC_ZERO_OTHER | SST_CC_SUB_CLOCAL | SST_CC_ADD_ALOCAL;
      2	  15718     break;
      1	  15719   }
      1	  15720 
      1	  15721   /* if either color or alpha combine requires texture then enable it */
      1	  15722   if (gc->state.cc_requires_texture || gc->state.ac_requires_texture)
      1	  15723     fbzColorPath |= SST_ENTEXTUREMAP;
      1	  15724   gc->state.fbi_config.fbzColorPath = fbzColorPath;
      1	  15725 
      2	  15726   {
      2	  15727     const FxBool texTransP = (oldTextureEnabled != (fbzColorPath & SST_ENTEXTUREMAP));
      2	  15728 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  15729     GR_SET_EXPECTED_SIZE(sizeof(FxU32) + (texTransP ? sizeof(FxU32) : 0),
      2	  15730                          1 + texTransP);
      2	  15731     
      2	  15732     /* transition into/out of texturing ... add nopCMD */
      2	  15733     if (texTransP) GR_SET(BROADCAST_ID, hw, nopCMD, 0);
      2	  15734     GR_SET(BROADCAST_ID, hw, fbzColorPath,  fbzColorPath);
      2	  15735     GR_CHECK_SIZE();
      1	  15736   }
      1	  15737 
      1	  15738   /* setup paramIndex bits */
      1	  15739   _grUpdateParamIndex();
      1	  15740 
      1	  15741   GR_END();
      1	  15742 #undef FN_NAME
      1	  15743 } /* grColorCombine */
	  15744 
	  15745 /*---------------------------------------------------------------------------
	  15746 ** grColorMask
	  15747 */
	  15748 
	  15749 GR_STATE_ENTRY(grColorMask, void, (FxBool rgb, FxBool alpha))
      1	  15750 {
      1	  15751 #define FN_NAME "grColorMask"
      1	  15752   FxU32 fbzMode;
      1	  15753   GR_BEGIN_NOFIFOCHECK("grColorMask", 85);
      1	  15754   GDBG_INFO_MORE(gc->myLevel, "(0x%x,0x%x)\n", rgb, alpha);
      1	  15755 
      1	  15756   fbzMode = gc->state.fbi_config.fbzMode;
      1	  15757 
      1X  15758 #if 0
      1X  15759   GR_CHECK_W(myName,
      1X  15760              (fbzMode & SST_ENDEPTHBUFFER) && alpha,
      1X  15761              "alpha writes enabled even though depth buffering");
      1X  15762 #endif
      1	  15763 
      1	  15764   /* This is fatal because they could stomp on the cmd fifo. */
      1	  15765   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15766                          (alpha && (gc->grAuxBuf == 0)),
      1	  15767                          "cannot enable alpha buffering w/o allocating one");
      1	  15768 
      1	  15769   if (rgb)
      1	  15770     fbzMode |= SST_RGBWRMASK;
      1	  15771   else
      1	  15772     fbzMode &= ~SST_RGBWRMASK;
      1	  15773 
      1	  15774   /* GMT: BUG leave SST_ENALPHABUFFER on if dest. alpha being used */
      1	  15775   /* Don't do anything if depth buffering on */
      1	  15776   /* XXX Should check for triple buffering too */
      1	  15777 
      2	  15778   if (!(fbzMode & SST_ENDEPTHBUFFER) && (gc->state.num_buffers != 3)) {
      2	  15779     if (alpha)
      2	  15780       fbzMode |= SST_ENALPHABUFFER | SST_ZAWRMASK;
      2	  15781     else
      2	  15782       fbzMode &= ~(SST_ENALPHABUFFER | SST_ZAWRMASK);
      1	  15783   }
      1	  15784 
      1	  15785   gc->state.fbi_config.fbzMode = fbzMode;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15786 
      1	  15787   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15788   GR_SET(BROADCAST_ID, hw, fbzMode,  fbzMode);
      1	  15789   GR_CHECK_SIZE();
      1	  15790 #undef FN_NAME
      1	  15791 } /* grColorMask */
	  15792 
	  15793 /*---------------------------------------------------------------------------
	  15794 ** grConstantColorValue
	  15795 */
	  15796 
	  15797 GR_STATE_ENTRY(grConstantColorValue, void, (GrColor_t color))
      1	  15798 {
      1	  15799 #define FN_NAME "grConstantColorValue"
      1	  15800   GR_BEGIN_NOFIFOCHECK("grConstantColorValue",85);
      1	  15801   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",color);
      1	  15802 
      1	  15803   _grSwizzleColor(&color);
      1	  15804 
      2	  15805   REG_GROUP_BEGIN(BROADCAST_ID, c0, 2, 0x03);
      3	  15806   {
      3	  15807     REG_GROUP_SET(hw, c0, color);
      3	  15808     REG_GROUP_SET(hw, c1, color);
      2	  15809   }
      1	  15810   REG_GROUP_END();
      1	  15811 
      1	  15812   gc->state.fbi_config.color0 = color;
      1	  15813   gc->state.fbi_config.color1 = color;
      1	  15814 
      1	  15815   GR_END();
      1	  15816 #undef FN_NAME
      1	  15817 } /* grConstanColorValue */
	  15818 
	  15819 /*---------------------------------------------------------------------------
	  15820 ** grConstantColorValue4
	  15821 **           GMT: obsolete routine
	  15822 **           GMT: send values to hardware immediately
	  15823 */
	  15824 
	  15825 GR_ENTRY(grConstantColorValue4, void, (float a, float r, float g, float b))
      1	  15826 {
      1	  15827 #define FN_NAME "grConstantColorValue4"
      1	  15828   GR_BEGIN_NOFIFOCHECK("grConstantColorValue4",85);
      1	  15829   GDBG_INFO_MORE(gc->myLevel,"(%d,%d,%d,%d)\n",a,r,g,b);
      1	  15830   gc->state.a = a;
      1	  15831   gc->state.r = r;
      1	  15832   gc->state.g = g;
      1	  15833   gc->state.b = b;
      1	  15834 
      2	  15835   if (gc->state.cc_delta0mode) {
      3	  15836     REG_GROUP_BEGIN(BROADCAST_ID, Fr, 3, 0x07);
      4	  15837     {
      4	  15838       REG_GROUP_SETF(hw, Fr, r);
      4	  15839       REG_GROUP_SETF(hw, Fg, g);
      4	  15840       REG_GROUP_SETF(hw, Fb, b);
      3	  15841     }
      2	  15842     REG_GROUP_END();

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15843   }
      1	  15844 
      1	  15845   GR_END();
      1	  15846 #undef FN_NAME
      1	  15847 } /* grConstantColorValue4 */
	  15848 
	  15849 /*---------------------------------------------------------------------------
	  15850 ** grCullMode
	  15851 **
	  15852 ** GMT: warning - gaa.c has the guts of this in-line
	  15853 */
	  15854 
	  15855 GR_ENTRY(grCullMode, void, (GrCullMode_t mode))
      1	  15856 {
      1	  15857 #define FN_NAME "grCullMode"
      1	  15858   GR_BEGIN_NOFIFOCHECK("grCullMode",85);
      1	  15859   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",mode);
      1	  15860   gc->state.cull_mode = mode;
      1	  15861 
      1	  15862 #if GLIDE_HW_TRI_SETUP
      1	  15863   _grUpdateTriPacketHdr(gc->cmdTransportInfo.paramMask, mode);
      1	  15864 #endif /* GLIDE_HW_TRI_SETUP */
      1	  15865 
      1	  15866   GR_END();
      1	  15867 #undef FN_NAME
      1	  15868 } /* grCullMode */
	  15869 
	  15870 /*---------------------------------------------------------------------------
	  15871 ** grDepthBiasLevel
	  15872 **
	  15873 ** Sets the depth bias level.
	  15874 */
	  15875 
	  15876 GR_STATE_ENTRY(grDepthBiasLevel, void, (FxI16 level))
      1	  15877 {
      1	  15878 #define FN_NAME "grDepthBiasLevel"
      1	  15879   FxU32 zacolor;
      1	  15880   GR_BEGIN_NOFIFOCHECK("grDepthBiasLevel", 85);
      1	  15881   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",level);
      1	  15882 
      1	  15883   zacolor = gc->state.fbi_config.zaColor;
      1	  15884   zacolor = (zacolor & ~SST_ZACOLOR_DEPTH) | (level & SST_ZACOLOR_DEPTH);
      1	  15885 
      1	  15886   gc->state.fbi_config.zaColor = zacolor;
      1	  15887 
      1	  15888   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15889   GR_SET(BROADCAST_ID, hw, zaColor,  zacolor);
      1	  15890   GR_CHECK_SIZE();
      1	  15891 #undef FN_NAME
      1	  15892 } /* grDepthBiasLevel */
	  15893 
	  15894 /*---------------------------------------------------------------------------
	  15895 ** grDepthBufferFunction
	  15896 */
	  15897 
	  15898 GR_STATE_ENTRY(grDepthBufferFunction, void, (GrCmpFnc_t fnc))
      1	  15899 {

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  15900 #define FN_NAME "grDepthBufferFunction"
      1	  15901   FxU32 fbzMode;
      1	  15902 
      1	  15903   GR_BEGIN_NOFIFOCHECK("grDepthBufferFunction",85);
      1	  15904   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",fnc);
      1	  15905 
      1	  15906   fbzMode = gc->state.fbi_config.fbzMode;
      1	  15907   fbzMode &= ~SST_ZFUNC;
      1	  15908   fbzMode |= (fnc << SST_ZFUNC_SHIFT);
      1	  15909 
      1	  15910   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15911   GR_SET(BROADCAST_ID, hw, fbzMode,  fbzMode);
      1	  15912   GR_CHECK_SIZE();
      1	  15913 
      1	  15914   gc->state.fbi_config.fbzMode = fbzMode;
      1	  15915   GR_END();
      1	  15916 #undef FN_NAME
      1	  15917 } /* grDepthBufferFunction */
	  15918 
	  15919 /*---------------------------------------------------------------------------
	  15920 ** grDepthBufferMode
	  15921 */
	  15922 
	  15923 GR_STATE_ENTRY(grDepthBufferMode, void, (GrDepthBufferMode_t mode))
      1	  15924 {
      1	  15925 #define FN_NAME "grDepthBufferMode"
      1	  15926   FxU32 fbzMode;
      1	  15927   GR_BEGIN_NOFIFOCHECK("grDepthBufferMode", 85);
      1	  15928   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", mode);
      1	  15929 
      1	  15930   /* This is fatal because they could stomp on the cmd fifo. */
      1	  15931   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15932                          (mode != GR_DEPTHBUFFER_DISABLE) && (gc->grAuxBuf == 0),
      1	  15933                          "cannot enable depth buffer w/o allocating one");
      1	  15934 
      1	  15935   /* turn off all the bits and then turn them back on selectively */
      1	  15936   fbzMode = gc->state.fbi_config.fbzMode;
      1	  15937   fbzMode &= ~(SST_ENDEPTHBUFFER | 
      1	  15938                SST_WBUFFER | 
      1	  15939                SST_ENZBIAS | 
      1	  15940                SST_ZCOMPARE_TO_ZACOLOR);
      1	  15941 
      2	  15942   switch (mode) {
      2	  15943   case GR_DEPTHBUFFER_DISABLE:
      2	  15944     break;
      2	  15945     
      2	  15946   case GR_DEPTHBUFFER_ZBUFFER:
      2	  15947     fbzMode |= SST_ENDEPTHBUFFER | SST_ENZBIAS;
      2	  15948     break;
      2	  15949 
      2	  15950   case GR_DEPTHBUFFER_WBUFFER:
      2	  15951     fbzMode |= SST_ENDEPTHBUFFER | SST_WBUFFER | SST_ENZBIAS;
      2	  15952     break;
      2	  15953 
      2	  15954   case GR_DEPTHBUFFER_ZBUFFER_COMPARE_TO_BIAS:
      2	  15955     fbzMode |= SST_ENDEPTHBUFFER | SST_ZCOMPARE_TO_ZACOLOR;
      2	  15956     break;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 26
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  15957 
      2	  15958   case GR_DEPTHBUFFER_WBUFFER_COMPARE_TO_BIAS:
      2	  15959     fbzMode |= SST_ENDEPTHBUFFER | SST_WBUFFER | SST_ZCOMPARE_TO_ZACOLOR;
      2	  15960     break;
      1	  15961   }
      1	  15962 
      1	  15963   /*
      1	  15964   ** Update hardware and Glide state
      1	  15965   */
      1	  15966   gc->state.fbi_config.fbzMode = fbzMode;
      1	  15967 
      1	  15968   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  15969   GR_SET(BROADCAST_ID, hw, fbzMode,  fbzMode);
      1	  15970   GR_CHECK_SIZE();
      1	  15971 
      1	  15972   _grUpdateParamIndex();
      1	  15973 #undef FN_NAME
      1	  15974 } /* grDepthBufferMode */
	  15975 
	  15976 /*---------------------------------------------------------------------------
	  15977 ** No Comment
	  15978 */
       X  15979 #ifdef GLIDE_DEBUG
       X  15980 FxBool
       X  15981 _grCanSupportDepthBuffer(void)
       X  15982 {
       X  15983   GR_DCL_GC;
       X  15984   if (gc->state.screen_height == 640) {
       X  15985     if (gc->fbuf_size == 1) {
       X  15986       return FXFALSE;
       X  15987     }
       X  15988   } else if (gc->state.screen_width == 800) {
       X  15989     if ((gc->fbuf_size == 1) ||
       X  15990         (gc->fbuf_size == 2)) {
       X  15991       return FXFALSE;
       X  15992     }
       X  15993   }
       X  15994   return FXTRUE;
       X  15995 } /* _grCanSupportDepthBuffer */
       X  15996 #endif
	  15997 
	  15998 /*---------------------------------------------------------------------------
	  15999 ** grDepthMask
	  16000 */
	  16001 GR_STATE_ENTRY(grDepthMask, void, (FxBool enable))
      1	  16002 {
      1	  16003 #define FN_NAME "grDepthMask"
      1	  16004   FxU32 fbzMode;
      1	  16005   GR_BEGIN_NOFIFOCHECK("grDepthMask", 85);
      1	  16006   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", enable);
      1	  16007 
      1	  16008   fbzMode = gc->state.fbi_config.fbzMode;
      1	  16009   GR_CHECK_F(myName,
      1	  16010              enable && !_grCanSupportDepthBuffer(),
      1	  16011              "called in a non-depthbufferable configuration");
      1	  16012 
      1	  16013   if (enable)

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 27
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16014     fbzMode |= SST_ZAWRMASK;
      1	  16015   else
      1	  16016     fbzMode &= ~SST_ZAWRMASK;
      1	  16017 
      1	  16018   gc->state.fbi_config.fbzMode = fbzMode;
      1	  16019 
      1	  16020   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  16021   GR_SET(BROADCAST_ID, hw, fbzMode,  fbzMode);
      1	  16022   GR_CHECK_SIZE();
      1	  16023 #undef FN_NAME
      1	  16024 } /* grDepthMask */
	  16025 
	  16026 /*---------------------------------------------------------------------------
	  16027 ** grDisableAllEffects
	  16028 */
	  16029 
	  16030 GR_ENTRY(grDisableAllEffects, void, (void))
      1	  16031 {
      1	  16032   GDBG_INFO(87,"grDisableAllEffects()\n");
      1	  16033   grAlphaBlendFunction(GR_BLEND_ONE, GR_BLEND_ZERO, GR_BLEND_ONE, GR_BLEND_ZERO);
      1	  16034   grAlphaTestFunction(GR_CMP_ALWAYS);
      1	  16035   grChromakeyMode(GR_CHROMAKEY_DISABLE);
      1	  16036   grDepthBiasLevel(0);
      1	  16037   grDepthBufferMode(GR_DEPTHBUFFER_DISABLE);
      1	  16038   grFogMode(GR_FOG_DISABLE);
      1	  16039 } /* grDisableAllEffects */
	  16040 
	  16041 /*---------------------------------------------------------------------------
	  16042 ** grDitherMode
	  16043 */
	  16044 
	  16045 GR_STATE_ENTRY(grDitherMode, void, (GrDitherMode_t mode))
      1	  16046 {
      1	  16047 #define FN_NAME "grDitherMode"
      1	  16048   FxU32 fbzMode;
      1	  16049   GR_BEGIN_NOFIFOCHECK("grDitherMode", 85);
      1	  16050   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", mode);
      1	  16051 
      1	  16052   fbzMode = gc->state.fbi_config.fbzMode;
      1	  16053   fbzMode &= ~(SST_ENDITHER | SST_DITHER2x2 | SST_ENDITHERSUBTRACT);
      1	  16054 
      2	  16055   switch (mode) {
      2	  16056   case GR_DITHER_DISABLE:
      2	  16057     /* alpha dither subtract should be disabled */
      2	  16058     break;
      2	  16059 
      2	  16060   case GR_DITHER_2x2:
      2	  16061   case GR_DITHER_4x4:
      2	  16062     /* force 4x4 dither with alpha dither subtraction */
      2	  16063     fbzMode |= (SST_ENDITHER | SST_ENDITHERSUBTRACT);
      2	  16064 
      2	  16065     /* disable alpha blending dither subtraction according to user request */
      3	  16066     if (_GlideRoot.environment.disableDitherSub == FXTRUE) {
      3	  16067       /* without alpha dither subtraction, 2x2 dither looks better */
      3	  16068       fbzMode |= SST_DITHER2x2;
      3	  16069       fbzMode &= ~(SST_ENDITHERSUBTRACT);
      2	  16070     }

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 28
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16071     break;
      1	  16072   }
      1	  16073 
      1	  16074   gc->state.fbi_config.fbzMode = fbzMode;
      1	  16075 
      1	  16076   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  16077   GR_SET(BROADCAST_ID, hw, fbzMode,  fbzMode);
      1	  16078   GR_CHECK_SIZE();
      1	  16079 #undef FN_NAME
      1	  16080 } /* grDitherMode */
	  16081 
	  16082 /*---------------------------------------------------------------------------
	  16083 ** grFogMode
	  16084 */
	  16085 
	  16086 GR_STATE_ENTRY(grFogMode, void, (GrFogMode_t mode))
      1	  16087 {
      1	  16088 #define FN_NAME "grFogMode"
      1	  16089   FxU32 fogmode;
      1	  16090   GR_BEGIN_NOFIFOCHECK("grFogMode", 85);
      1	  16091   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",mode);
      1	  16092 
      1	  16093   fogmode = gc->state.fbi_config.fogMode;
      1	  16094   fogmode &= ~(SST_ENFOGGING | 
      1	  16095                SST_FOGADD | 
      1	  16096                SST_FOGMULT | 
      1	  16097                SST_FOG_ALPHA | 
      1	  16098                SST_FOG_Z | 
      1	  16099                SST_FOG_CONSTANT);
      1	  16100 
      2	  16101   switch (mode & 0xFF) {    /* switch based on lower 8 bits */
      2	  16102   case GR_FOG_DISABLE:
      2	  16103     break;
      2	  16104 
      2	  16105   case GR_FOG_WITH_ITERATED_ALPHA:
      2	  16106     fogmode |= (SST_ENFOGGING | SST_FOG_ALPHA);
      2	  16107     break;
      2	  16108 
      2	  16109   case GR_FOG_WITH_ITERATED_Z:        /* Bug 735 */
      2	  16110     fogmode |= (SST_ENFOGGING | SST_FOG_Z);
      2	  16111     break;
      2	  16112 
      2	  16113   case GR_FOG_WITH_TABLE:
      2	  16114     fogmode |= (SST_ENFOGGING);
      2	  16115     break;
      1	  16116   }
      1	  16117   if (mode &  GR_FOG_MULT2) fogmode |= SST_FOGMULT;
      1	  16118   if (mode &  GR_FOG_ADD2) fogmode |= SST_FOGADD;
      1	  16119 
      1	  16120   /* GMT says that this should be enabled for CVG.  It is always safe
      1	  16121    * to enable these even when fogging is not enabled.  
      1	  16122    */
      1	  16123   fogmode |= (SST_FOG_DITHER | SST_FOG_ZONES);
      1	  16124 
      1	  16125   /*
      1	  16126   ** Update the hardware and Glide state
      1	  16127   */

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 29
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16128   gc->state.fbi_config.fogMode = fogmode;
      1	  16129 
      1	  16130   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  16131   GR_SET(BROADCAST_ID, hw, fogMode,  fogmode);
      1	  16132   GR_CHECK_SIZE();
      1	  16133 
      1	  16134   _grUpdateParamIndex();
      1	  16135 #undef FN_NAME
      1	  16136 } /* grFogMode */
	  16137 
	  16138 /*---------------------------------------------------------------------------
	  16139 ** grFogColorValue
	  16140 */
	  16141 
	  16142 GR_STATE_ENTRY(grFogColorValue, void, (GrColor_t color))
      1	  16143 {
      1	  16144 #define FN_NAME "grFogColorValue"
      1	  16145   GR_BEGIN_NOFIFOCHECK("grFogColorValue", 85);
      1	  16146   GDBG_INFO_MORE(gc->myLevel, "(0x%x)\n", color);
      1	  16147 
      1	  16148   _grSwizzleColor(&color);
      1	  16149 
      1	  16150   gc->state.fbi_config.fogColor = color;
      1	  16151 
      1	  16152   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  16153   GR_SET(BROADCAST_ID, hw, fogColor,  color);
      1	  16154   GR_CHECK_SIZE();
      1	  16155 #undef FN_NAME
      1	  16156 } /* grFogColorValue */
	  16157 
	  16158 /*---------------------------------------------------------------------------
	  16159 ** grFogTable
	  16160 */
	  16161 
	  16162 // ???
	  16163 #define kInternalFogTableEntryCount 64
	  16164 
	  16165 GR_ENTRY(grFogTable, void, (const GrFog_t fogtable[]))
      1	  16166 {
      1	  16167 #define FN_NAME "grFogTable"
      1	  16168   const GrFog_t *locTable = fogtable;
      1	  16169   const int iend = (kInternalFogTableEntryCount >> 1);
      1	  16170   GR_BEGIN_NOFIFOCHECK("grFogTable",85);
      1	  16171   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",fogtable);
      1	  16172   GR_ASSERT(fogtable != NULL);
      1	  16173   GR_ASSERT(kInternalFogTableEntryCount == 64);
      1	  16174 
      2	  16175   REG_GROUP_LONG_BEGIN(BROADCAST_ID, fogTable[0], 32);
      3	  16176   {
      3	  16177     int j;
      3	  16178     
      4	  16179     for (j = 0; j < iend; j++) {
      4	  16180       FxU32 e0, e1, d0, d1;
      4	  16181       
      4	  16182       e0 = locTable[0];                     /* lower entry */
      4	  16183       e1 = locTable[1];                     /* upper entry */
      4	  16184 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 30
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      4	  16185       GR_CHECK_COMPATABILITY(FN_NAME, 
      4	  16186                              (e1 < e0), 
      4	  16187                              "Invalid fog table entry. (Must be monotonically increasing)");
      4	  16188       GR_CHECK_COMPATABILITY(FN_NAME, 
      4	  16189                              ((j > 0) ? (e0 < locTable[-1]) : 0),
      4	  16190                              "Invalid fog table entry. (Must be monotonically increasing)");
      4	  16191       
      4	  16192       /* del0 in .2 format */
      4	  16193       d0 = ((e1 - e0) << 2); 
      4	  16194 
      4	  16195       /* del1 in .2 format - don't access beyond end of table */
      4	  16196       d1 = ((j == (iend - 1)) ? e1 : locTable[2]);
      4	  16197       d1 = (d1 - e1) << 2;
      4	  16198       
      4	  16199       REG_GROUP_SET(hw, fogTable[j], 
      4	  16200                     ((e1 << 24) | (d1 << 16) | (e0 << 8) | d0));
      4	  16201       GDBG_INFO(gc->myLevel + 200, "fogTable[%ld]: 0x%X\n",
      4	  16202                 j, ((e1 << 24) | (d1 << 16) | (e0 << 8) | d0));
      4	  16203       locTable += 2;
      3	  16204     }
      2	  16205   }
      1	  16206   REG_GROUP_END();
      1	  16207 
      1	  16208   GR_END();
      1	  16209 #undef FN_NAME
      1	  16210 } /* grFogTable */
	  16211 
	  16212 /*-------------------------------------------------------------------
	  16213   Function: grGlideShutdown
	  16214   Date: 3/16
	  16215   Implementor(s): dow, gmt, jdt
	  16216   Library: Glide
	  16217   Description:
	  16218   Shutdown the Glide Library.  Iterate through all hardware and 
	  16219   call grSstWinClose().  Call InitShutdown() which unmaps all
	  16220   hardware from linear memory.
	  16221   Arguments:
	  16222   none
	  16223   Return:
	  16224   none
	  16225   -------------------------------------------------------------------*/
	  16226 
	  16227 GR_ENTRY(grGlideShutdown, void, (void))
      1	  16228 {
      1	  16229   _GlideRoot.windowsInit = FXFALSE;
      1	  16230 
      1	  16231   if (!_GlideRoot.initialized) return;  /* never made it thru startup */
      1	  16232 
      1X  16233 #if GLIDE_SANITY_SIZE
      1X  16234   /* GMT: reset the counter so we can proceed without assertions */
      1X  16235   {
      1X  16236     GR_DCL_GC;
      1X  16237     gc->counter = gc->expected_counter = 0;
      1X  16238   }
      1X  16239 #endif /* GLIDE_SANITY_SIZE */
      1	  16240 
      2	  16241   {

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 31
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16242     int i;
      2	  16243     GR_BEGIN_NOFIFOCHECK("grGlideShutdown\n", 80);
      2	  16244 
      3	  16245     for(i = 0; i < _GlideRoot.hwConfig.num_sst; i++) {
      3	  16246       grSstSelect(i);
      3	  16247       grSstWinClose();
      2	  16248     }
      2	  16249 
      2X  16250 #if GLIDE_INIT_HAL
      2X  16251     fxHalShutdownAll();
      2X  16252 #else /* !GLIDE_INIT_HAL */
      2	  16253     /* dpc - 5 sep 1997 - FixMe!
      2	  16254      * Move this to the new initCode world some time.
      2	  16255      * 
      2	  16256      * initClose();
      2	  16257      *
      2	  16258      * NB: This is only necessary to properly shtudown the hw and vxd
      2	  16259      * if the application never called grSstWinOpen because they are
      2	  16260      * doing some sort of hw/dll detection before trying to run w/
      2	  16261      * glide.  
      2	  16262      */
      3	  16263     for(i = 0; i < _GlideRoot.hwConfig.num_sst; i++) {
      4	  16264       if (_GlideRoot.GCs[i].hwInitP) {
      4	  16265         /*if (_GlideRoot.CPUType.family >= 6) {*/
      4	  16266         sst1InitCaching(_GlideRoot.GCs[i].base_ptr, FXFALSE);
      4	  16267         /*}*/
      4	  16268         sst1InitShutdown(_GlideRoot.GCs[i].base_ptr);
      4	  16269 
      4	  16270         _GlideRoot.GCs[i].hwInitP = FXFALSE;
      3	  16271       }
      2	  16272     }
      2	  16273 #endif /* !GLIDE_INIT_HAL */
      2	  16274 
      2	  16275     _grDisplayStats();
      2	  16276     gc->grSstRez = GR_RESOLUTION_NONE;
      2	  16277     gc->grSstRefresh = GR_REFRESH_NONE;
      1	  16278   }
      1	  16279 
      1	  16280   _GlideRoot.initialized = FXFALSE;
      1	  16281 } /* grGlideShutdown */
	  16282 
	  16283 
	  16284 /*-------------------------------------------------------------------
	  16285   Function: _grFlushCommonStateRegs
	  16286   Date: 14-Oct-97
	  16287   Implementor(s): dpc
	  16288   Description:
	  16289         Flushes all State Monster regs.  If we're not doing Glide 3,
	  16290         then it's still used by grGlideSetState()
	  16291   Arguments:
	  16292   
	  16293   Return:
	  16294   -------------------------------------------------------------------*/
	  16295 void
	  16296 _grFlushCommonStateRegs()
      1	  16297 {
      1	  16298 #define FN_NAME "_grFlushCommonStateRegs"

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 32
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16299   GR_BEGIN("_grFlushCommonStateRegs", 97, 13 * sizeof(FxU32), 2);
      1	  16300 
      1	  16301   /* NB: This logical write must be split into two writes since the
      1	  16302    * registers are non-contiguous (not good for packet 1) and are the
      1	  16303    * register span is larget (greater than the 14 register mask size
      1	  16304    * for packet 4).
      1	  16305    */
      2	  16306   REG_GROUP_NO_CHECK_BEGIN(BROADCAST_ID, fbzColorPath, 10, 0x1C7F);
      3	  16307   {
      3	  16308     REG_GROUP_SET(hw, fbzColorPath, gc->state.fbi_config.fbzColorPath);
      3	  16309     REG_GROUP_SET(hw, fogMode, gc->state.fbi_config.fogMode);
      3	  16310     REG_GROUP_SET(hw, alphaMode, gc->state.fbi_config.alphaMode);
      3	  16311     REG_GROUP_SET(hw, fbzMode, gc->state.fbi_config.fbzMode);
      3	  16312     
      3	  16313     REG_GROUP_SET(hw, lfbMode, gc->state.fbi_config.lfbMode);
      3	  16314     REG_GROUP_SET(hw, clipLeftRight, gc->state.fbi_config.clipLeftRight);
      3	  16315     REG_GROUP_SET(hw, clipBottomTop, gc->state.fbi_config.clipBottomTop);
      3	  16316     
      3	  16317     REG_GROUP_SET(hw, fogColor, gc->state.fbi_config.fogColor);
      3	  16318     REG_GROUP_SET(hw, zaColor, gc->state.fbi_config.zaColor);
      3	  16319     REG_GROUP_SET(hw, chromaKey, gc->state.fbi_config.chromaKey);
      2	  16320   }
      1	  16321   REG_GROUP_NO_CHECK_END();
      1	  16322   
      2	  16323   REG_GROUP_NO_CHECK_BEGIN(BROADCAST_ID, stipple, 3, 0x07);
      3	  16324   {
      3	  16325     REG_GROUP_SET(hw, stipple, gc->state.fbi_config.stipple);
      3	  16326     REG_GROUP_SET(hw, c0, gc->state.fbi_config.color0);
      3	  16327     REG_GROUP_SET(hw, c1, gc->state.fbi_config.color1);
      2	  16328   }
      1	  16329   REG_GROUP_NO_CHECK_END();
      1	  16330 
      1	  16331 
      1	  16332   GR_END();
      1	  16333 
      1	  16334 #undef FN_NAME
      1	  16335 } /* _grFlushCommonStateRegs */
	  16336 
	  16337 /*---------------------------------------------------------------------------
	  16338 ** grGlideSetState
	  16339 */
	  16340 GR_ENTRY(grGlideSetState, void, (const GrState *state))
      1	  16341 {
      1	  16342 #define FN_NAME "grGlideSetState"
      1	  16343   GR_BEGIN_NOFIFOCHECK(FN_NAME, 87);
      1	  16344   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",state);
      1	  16345 
      1	  16346   GR_ASSERT(state != NULL);
      1	  16347   
      1	  16348   /* if texture mapping changed then we need to issue a NOP command*/
      2	  16349   {
      2	  16350     const FxBool texChangeP = (((gc->state.fbi_config.fbzColorPath ^ state->fbi_config.fbzColorPath) & 
      2	  16351                                 SST_ENTEXTUREMAP) != 0);
      3	  16352     if (texChangeP) {
      3	  16353       GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      3	  16354       GR_SET(BROADCAST_ID, hw, nopCMD,  0);
      3	  16355       GR_CHECK_SIZE();

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 33
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16356     }
      1	  16357   }
      1	  16358 
      1	  16359 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      1	  16360   /* If we're on sli and the new state includes changing the origin
      1	  16361    * that we clear the slop lines at the bottom of the screen.  
      1	  16362    */
      1	  16363   if (gc->scanline_interleaved) gc->hwDep.cvgDep.sliOriginBufCount = gc->grColBuf;
      1	  16364 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      1	  16365 
      1	  16366   /* copy all the state */
      1	  16367   gc->state = *state;
      1	  16368 
      1	  16369   /* Update the hardware state from the saved state. */
      1	  16370   _grFlushCommonStateRegs();
      1	  16371   
      1	  16372   GR_SET_EXPECTED_SIZE((7 * sizeof(FxU32)) * gc->num_tmu, gc->num_tmu);
      2	  16373   {
      2	  16374     int tmu;
      2	  16375     
      3	  16376     for (tmu = 0; tmu < gc->num_tmu; tmu++) {
      3	  16377       SstRegs* tmuregs = SST_TMU(hw, tmu);
      3	  16378       const FifoChipField chipField = (FifoChipField)(0x02UL << tmu);
      3	  16379       
      4	  16380       REG_GROUP_NO_CHECK_BEGIN(chipField, textureMode, 7, 0x7F);
      5	  16381       {
      5	  16382         REG_GROUP_SET(tmuregs, textureMode, gc->state.tmu_config[tmu].textureMode);
      5	  16383         REG_GROUP_SET(tmuregs, tLOD, gc->state.tmu_config[tmu].tLOD);
      5	  16384         REG_GROUP_SET(tmuregs, tDetail, gc->state.tmu_config[tmu].tDetail);
      5	  16385         REG_GROUP_SET(tmuregs, texBaseAddr, gc->state.tmu_config[tmu].texBaseAddr);
      5	  16386         
      5	  16387         REG_GROUP_SET(tmuregs, texBaseAddr1, gc->state.tmu_config[tmu].texBaseAddr_1);
      5	  16388         REG_GROUP_SET(tmuregs, texBaseAddr2, gc->state.tmu_config[tmu].texBaseAddr_2);
      5	  16389         REG_GROUP_SET(tmuregs, texBaseAddr38, gc->state.tmu_config[tmu].texBaseAddr_3_8);
      4	  16390       }
      3	  16391       REG_GROUP_NO_CHECK_END();
      2	  16392     }
      1	  16393   }
      1	  16394   GR_CHECK_SIZE();
      1	  16395 
      1	  16396   /* NOTE: since glide state includes things like hints and all cached
      1	  16397    * variables like paramIndex we needn't recompute these, BUT: we do
      1	  16398    * need to rebuild stuff that depends on them!!! 
      1	  16399    */
      1	  16400   _grUpdateParamIndex();
      1	  16401 
      1	  16402   GR_END();
      1	  16403 #undef FN_NAME
      1	  16404 } /* grGlideSetState */
	  16405 
	  16406 /*---------------------------------------------------------------------------
	  16407 ** grRenderBuffer
	  16408 **
	  16409 **  Although SST1 supports triple buffering, it's a hack in the hardware,
	  16410 **  and the only drawbuffer modes supported by the fbzMode register are 0
	  16411 **  (back) and 1 (front)
	  16412 */

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 34
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  16413 
	  16414 GR_STATE_ENTRY(grRenderBuffer, void, (GrBuffer_t buffer))
      1	  16415 {
      1	  16416 #define FN_NAME "grRenderBuffer"
      1	  16417   GR_BEGIN_NOFIFOCHECK("grRenderBuffer", 85);
      1	  16418   GDBG_INFO_MORE(gc->myLevel,"(%d)\n",buffer);
      1	  16419   GR_CHECK_F(myName, buffer >= GR_BUFFER_AUXBUFFER, "invalid buffer");
      1	  16420 
      2	  16421   {
      2	  16422     FxU32 fbzMode;
      2	  16423     
      2	  16424     fbzMode = gc->state.fbi_config.fbzMode;
      2	  16425     fbzMode &= ~(SST_DRAWBUFFER);
      2	  16426     fbzMode |= ((buffer == GR_BUFFER_FRONTBUFFER)
      2	  16427                 ? SST_DRAWBUFFER_FRONT 
      2	  16428                 : SST_DRAWBUFFER_BACK);
      2	  16429     
      2	  16430     GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      2	  16431     GR_SET(BROADCAST_ID, hw, fbzMode, fbzMode);
      2	  16432     GR_CHECK_SIZE();
      2	  16433 
      2	  16434     gc->state.fbi_config.fbzMode = fbzMode;
      1	  16435   }
      1	  16436 
      1X  16437 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR 
      1	  16438     /* Setting the render buffer means we need to adjust
      1	  16439      * our current pointer to the render buffer's physical
      1	  16440      * address if we're doing blit clears.
      1X  16441      */
      1X  16442     {
      1X  16443       const FxU32 oldRenderBuf = gc->hwDep.cvgDep.renderBuf;
      1X  16444 
      1X  16445       gc->hwDep.cvgDep.renderBuf = ((buffer == GR_BUFFER_FRONTBUFFER)
      1X  16446                                     ? gc->hwDep.cvgDep.frontBuf
      1X  16447                                     : gc->hwDep.cvgDep.backBuf);
      1X  16448       if ((gc->hwDep.cvgDep.renderBuf != oldRenderBuf) &&
      1X  16449           (gc->hwDep.cvgDep.sliOriginBufCount != 0)) _grSliOriginClear();
      1X  16450     }
      1X  16451 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR */
      1	  16452 
      1	  16453   GR_END();
      1	  16454 #undef FN_NAME
      1	  16455 } /* grRenderBuffer */
	  16456 
	  16457 GR_ENTRY(grCheckForRoom, void, (FxI32 n))
      1	  16458 {
      1	  16459   GR_DCL_GC;
      1	  16460 
      1	  16461   /* dpc - 13 sep 1997 - FixMe!
      1	  16462    * Setting one packet for now.
      1	  16463    */
      1	  16464   GR_CHECK_FOR_ROOM(n, 1);
      1	  16465 }
	  16466 
	  16467 /*---------------------------------------------------------------------------
	  16468 ** _grUpdateParamIndex
	  16469 **

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 35
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  16470 ** Updates the paramIndex bits based on Glide state and the hints.
	  16471 **
	  16472 */
	  16473 GR_DDFUNC(_grUpdateParamIndex, void, (void))
      1	  16474 {
      1	  16475 #define FN_NAME "_grUpdateParamIndex"
      1	  16476   GR_DCL_GC;
      1	  16477   FxU32 paramIndex = 0;
      1	  16478   const FxU32 hints = gc->state.paramHints;
      1	  16479   const FxU32 fbzColorPath = gc->state.fbi_config.fbzColorPath;
      1	  16480   const FxU32 fogMode = gc->state.fbi_config.fogMode;
      1	  16481   const FxU32 fbzMode = gc->state.fbi_config.fbzMode;
      1	  16482 
      1	  16483   /*
      1	  16484   ** First, turn on every bit that we think we need. We can prune them
      1	  16485   ** back later.
      1	  16486   */
      1	  16487 
      1	  16488   /* Turn on the texture bits based on what grTexCombine set */
      2	  16489   if (fbzColorPath & SST_ENTEXTUREMAP) {
      2	  16490     /* No matter what, we need oow from the main grvertex structure */
      2	  16491     static FxU32 paramI_array[] = {
      2	  16492       /* 0 */
      2	  16493       STATE_REQUIRES_OOW_FBI,
      2	  16494       
      2	  16495       /* 1 */
      2	  16496       STATE_REQUIRES_OOW_FBI | 
      2	  16497       STATE_REQUIRES_W_TMU0 | STATE_REQUIRES_ST_TMU0,
      2	  16498 
      2	  16499       /* 2 */
      2	  16500       STATE_REQUIRES_OOW_FBI | 
      2	  16501       STATE_REQUIRES_W_TMU1 | STATE_REQUIRES_ST_TMU1,
      2	  16502 
      2	  16503       /* 3 */
      2	  16504       STATE_REQUIRES_OOW_FBI | 
      2	  16505       STATE_REQUIRES_W_TMU0 | STATE_REQUIRES_ST_TMU0 | 
      2	  16506       STATE_REQUIRES_W_TMU1 | STATE_REQUIRES_ST_TMU1,
      2	  16507 
      2	  16508       /* 4 */
      2	  16509       STATE_REQUIRES_OOW_FBI | 
      2	  16510       STATE_REQUIRES_W_TMU2 | STATE_REQUIRES_ST_TMU2,
      2	  16511 
      2	  16512       /* 5 */
      2	  16513       STATE_REQUIRES_OOW_FBI | 
      2	  16514       STATE_REQUIRES_W_TMU0 | STATE_REQUIRES_ST_TMU0 |
      2	  16515       STATE_REQUIRES_W_TMU2 | STATE_REQUIRES_ST_TMU2,
      2	  16516 
      2	  16517       /* 6 */
      2	  16518       STATE_REQUIRES_OOW_FBI | 
      2	  16519       STATE_REQUIRES_W_TMU1 | STATE_REQUIRES_ST_TMU1 |
      2	  16520       STATE_REQUIRES_W_TMU2 | STATE_REQUIRES_ST_TMU2,
      2	  16521 
      2	  16522       /* 7 */
      2	  16523       STATE_REQUIRES_OOW_FBI | 
      2	  16524       STATE_REQUIRES_W_TMU0 | STATE_REQUIRES_ST_TMU0 |
      2	  16525       STATE_REQUIRES_W_TMU1 | STATE_REQUIRES_ST_TMU1 |
      2	  16526       STATE_REQUIRES_W_TMU2 | STATE_REQUIRES_ST_TMU2,

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 36
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16527     };
      2	  16528 
      2	  16529     GR_ASSERT(gc->state.tmuMask < sizeof(paramI_array)/sizeof(paramI_array[0]));
      2	  16530     paramIndex |= paramI_array[gc->state.tmuMask];
      1	  16531   }  
      1	  16532 
      1	  16533   /* See if we need iterated RGB */
      2	  16534   if (gc->state.cc_requires_it_rgb && !gc->state.cc_delta0mode) {
      2	  16535     paramIndex |= STATE_REQUIRES_IT_DRGB;
      1	  16536   }
      1	  16537 
      1	  16538   /* See if we need to iterate alpha based on the value of
      1	  16539      ac_requires_it_alpha */ 
      2	  16540   if (gc->state.ac_requires_it_alpha) {
      2	  16541     paramIndex |= STATE_REQUIRES_IT_ALPHA;
      1	  16542   }
      1	  16543 
      1	  16544   /* See what fbzColorPath contributes - BUG 1084*/
      2	  16545   if (( fbzColorPath & SST_ALOCALSELECT ) == SST_ALOCAL_Z ) {
      2	  16546       paramIndex |= STATE_REQUIRES_OOZ;
      1	  16547   }
      1	  16548 
      1	  16549   /* See what fbzMode contributes */
      2	  16550   if (fbzMode & SST_ENDEPTHBUFFER) {
      3	  16551     if (fbzMode & SST_WBUFFER) {
      3	  16552       paramIndex |= STATE_REQUIRES_OOW_FBI;
      3	  16553     } else {
      3	  16554       paramIndex |= STATE_REQUIRES_OOZ;
      2	  16555     }
      1	  16556   }
      1	  16557 
      1	  16558   /* See what fogMode contributes */
      2	  16559   if (fogMode & SST_ENFOGGING) {
      3	  16560     if (fogMode & SST_FOG_Z) {
      3	  16561       paramIndex |= STATE_REQUIRES_OOZ;
      3	  16562     } else {
      4	  16563       if (fogMode & SST_FOG_ALPHA) {
      4	  16564         paramIndex |= STATE_REQUIRES_IT_ALPHA;
      4	  16565       } else {
      4	  16566         paramIndex |= STATE_REQUIRES_OOW_FBI;
      3	  16567       }
      2	  16568     }
      1	  16569   }
      1	  16570 
      1	  16571   /*
      1	  16572   **  Now we know everything that needs to be iterated.  Prune back
      1	  16573   **  the stuff that isn't explicitly different
      1	  16574   **
      1	  16575   **  NOTE: by GMT, STATE_REQUIRES_OOW_FBI is set whenever texture mapping
      1	  16576   **        is enabled
      1	  16577   */
      1	  16578   /* Turn off W for TMU0 if we don't have a hint */
      2	  16579   if (paramIndex & STATE_REQUIRES_W_TMU0) {
      2	  16580     GR_ASSERT(paramIndex & STATE_REQUIRES_OOW_FBI);
      2	  16581     if (!(hints & GR_STWHINT_W_DIFF_TMU0))
      2	  16582       paramIndex &= ~STATE_REQUIRES_W_TMU0;
      1	  16583   }

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 37
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16584   
      1	  16585   /* Turn off ST for TMU1 if TMU0 is active and TMU1 is not different */
      1	  16586   if (((paramIndex & (STATE_REQUIRES_ST_TMU0 | STATE_REQUIRES_ST_TMU1)) ==
      1	  16587        (STATE_REQUIRES_ST_TMU0 | STATE_REQUIRES_ST_TMU1)) &&
      1	  16588       !(hints & GR_STWHINT_ST_DIFF_TMU1))
      1	  16589     paramIndex &= ~STATE_REQUIRES_ST_TMU1;
      1	  16590   
      1	  16591   /* Turn off W for TMU1 if we have a previous W, and don't have a hint */ 
      1	  16592   if ((paramIndex & STATE_REQUIRES_W_TMU1) && !(hints & GR_STWHINT_W_DIFF_TMU1))
      1	  16593     paramIndex &= ~STATE_REQUIRES_W_TMU1;
      1	  16594 
      1X  16595 #if (GLIDE_NUM_TMU > 2)
      1X  16596   /* Turn off ST for TMU1 if it's not different & any other is set up.  */ 
      1X  16597   if ((paramIndex & (STATE_REQUIRES_ST_TMU0 | STATE_REQURES_ST_TMU1)) &&
      1X  16598       (paramIndex & STATE_REQUIRES_ST_TMU2) &&
      1X  16599       !(hints & GR_STWHINT_ST_DIFF_TMU2))
      1X  16600     paramIndex &= ~STATE_REQUIRES_ST_TMU2;
      1X  16601   
      1X  16602   /* Turn off W for TMU2 if we have a previous W, and don't have a hint */ 
      1X  16603   if ((paramIndex & STATE_REQUIRES_W_TMU2) && !(hints & GR_STWHINT_W_DIFF_TMU2))
      1X  16604     paramIndex &= ~STATE_REQUIRES_W_TMU2;
      1X  16605 #endif
      1	  16606   
      1	  16607   gc->state.paramIndex = paramIndex;
      1	  16608 
      1	  16609   _grRebuildDataList();
      1	  16610 #undef FN_NAME
      1	  16611 } /* _grUpdateParamIndex */
	  16612 
       X  16613 #if defined(GLIDE_USE_ALT_REGMAP)
       X  16614 #define RED   Fr_ALT
       X  16615 #define DRDX  Fdrdx_ALT
       X  16616 #define DRDY  Fdrdy_ALT
       X  16617 #define GRN   Fg_ALT
       X  16618 #define DGDX  Fdgdx_ALT
       X  16619 #define DGDY  Fdgdy_ALT
       X  16620 #define BLU   Fb_ALT
       X  16621 #define DBDX  Fdbdx_ALT
       X  16622 #define DBDY  Fdbdy_ALT
       X  16623 #define ALF   Fa_ALT
       X  16624 #define DADX  Fdadx_ALT
       X  16625 #define DADY  Fdady_ALT
       X  16626 #define Z     Fz_ALT
       X  16627 #define DZDX  Fdzdx_ALT
       X  16628 #define DZDY  Fdzdy_ALT
       X  16629 #define S     Fs_ALT
       X  16630 #define DSDX  Fdsdx_ALT
       X  16631 #define DSDY  Fdsdy_ALT
       X  16632 #define T     Ft_ALT
       X  16633 #define DTDX  Fdtdx_ALT
       X  16634 #define DTDY  Fdtdy_ALT
       X  16635 #define W     Fw_ALT
       X  16636 #define DWDX  Fdwdx_ALT
       X  16637 #define DWDY  Fdwdy_ALT
       X  16638 #else
	  16639 #define RED   Fr
	  16640 #define DRDX  Fdrdx

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 38
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

	  16641 #define DRDY  Fdrdy
	  16642 #define GRN   Fg
	  16643 #define DGDX  Fdgdx
	  16644 #define DGDY  Fdgdy
	  16645 #define BLU   Fb
	  16646 #define DBDX  Fdbdx
	  16647 #define DBDY  Fdbdy
	  16648 #define ALF   Fa
	  16649 #define DADX  Fdadx
	  16650 #define DADY  Fdady
	  16651 #define Z     Fz
	  16652 #define DZDX  Fdzdx
	  16653 #define DZDY  Fdzdy
	  16654 #define S     Fs
	  16655 #define DSDX  Fdsdx
	  16656 #define DSDY  Fdsdy
	  16657 #define T     Ft
	  16658 #define DTDX  Fdtdx
	  16659 #define DTDY  Fdtdy
	  16660 #define W     Fw
	  16661 #define DWDX  Fdwdx
	  16662 #define DWDY  Fdwdy
	  16663 #endif
	  16664 
	  16665 #if GLIDE_HW_TRI_SETUP
	  16666 static void
	  16667 _grUpdateTriPacketHdr(FxU32 paramMask, 
	  16668                       const GrCullMode_t cullMode)
      1	  16669 {
      1	  16670   GR_DCL_GC;
      1	  16671   FxU32 sMode = ((cullMode != GR_CULL_DISABLE) 
      1	  16672                  ? kSetupCullEnable 
      1	  16673                  : kSetupPingPongDisable);
      1	  16674   if (sMode != kSetupPingPongDisable) sMode |= ((cullMode == GR_CULL_POSITIVE) 
      1	  16675                                                 ? kSetupCullPositive 
      1	  16676                                                 : kSetupCullNegative);
      1	  16677 
      1	  16678 #define COLOR_COMP_ARGB ((SST_SETUP_RGB | SST_SETUP_A) << SSTCP_PKT3_PMASK_SHIFT)
      1	  16679 #define COLOR_COMP_RGB  (SST_SETUP_RGB << SSTCP_PKT3_PMASK_SHIFT)
      1	  16680 #define COLOR_COMP_MASK COLOR_COMP_ARGB 
      1	  16681 
      1X  16682 #if GLIDE_DISPATCH_SETUP
      1	  16683   /* Setup custom triangle/strip procs.
      1	  16684    *
      1	  16685    * NB: Currently this selection is based entirely on if
      1	  16686    * we're sending color information. We should possibly
      1	  16687    * select on cpu type as well to determine if we should
      1	  16688    * do sw culling or not.
      1X  16689    */
      1X  16690   {
      1X  16691     GrTriSetupProcVector* curTriProcVector = TRISETUP_NORGB;
      1X  16692 
      1X  16693 #if GLIDE_PACKED_RGB
      1X  16694     if ((paramMask & SSTCP_PKT3_PACKEDCOLOR) == SSTCP_PKT3_PACKEDCOLOR) {
      1X  16695       const FxU32 colorComp = paramMask & COLOR_COMP_MASK;
      1X  16696 
      1X  16697       switch(colorComp) {

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 39
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1X  16698       case COLOR_COMP_ARGB:
      1X  16699         curTriProcVector = TRISETUP_ARGB;
      1X  16700         break;
      1X  16701 
      1X  16702       case COLOR_COMP_RGB:
      1X  16703         curTriProcVector = TRISETUP_RGB;
      1X  16704         break;
      1X  16705 
      1X  16706         /* If no rgb data then it is not worthwhile to pack
      1X  16707          * just alpha so just mask off the packed color bit
      1X  16708          * and just use the looping proc.
      1X  16709          */
      1X  16710       default:
      1X  16711         curTriProcVector = TRISETUP_NORGB;
      1X  16712         paramMask &= ~SSTCP_PKT3_PACKEDCOLOR;
      1X  16713         break;
      1X  16714       }
      1X  16715     }
      1X  16716 #endif
      1X  16717 
      1X  16718     gc->curArchProcs.triSetupProc = PROC_SELECT_TRISETUP(*curTriProcVector, cullMode);
      1X  16719   }
      1X  16720 #else
      1X  16721 #if GLIDE_PACKED_RGB
      1X  16722     if ((paramMask & SSTCP_PKT3_PACKEDCOLOR) == SSTCP_PKT3_PACKEDCOLOR) {
      1X  16723       const FxU32 colorComp = paramMask & COLOR_COMP_MASK;
      1X  16724 
      1X  16725       switch(colorComp) {
      1X  16726       case COLOR_COMP_ARGB:
      1X  16727       case COLOR_COMP_RGB:
      1X  16728         break;
      1X  16729       default:
      1X  16730         paramMask &= ~SSTCP_PKT3_PACKEDCOLOR;
      1X  16731         break;
      1X  16732       }
      1X  16733     }
      1X  16734 #endif
      1	  16735 #endif /* GLIDE_DISPATCH_SETUP */
      1	  16736 
      1	  16737   gc->cmdTransportInfo.paramMask = paramMask;
      1	  16738 
      1	  16739   /* Compute the common case packet 3 header which just needs
      1	  16740    * the vertex count and strip/command type to be completed.
      1	  16741    */
      1	  16742   gc->cmdTransportInfo.cullStripHdr = ((sMode << SSTCP_PKT3_SMODE_SHIFT) |
      1	  16743                                        paramMask |
      1	  16744                                        SSTCP_PKT3);
      1	  16745   
      1	  16746   /* Independent triangle hdr for grDrawTriangle */
      1	  16747   gc->cmdTransportInfo.triPacketHdr = (gc->cmdTransportInfo.cullStripHdr |
      1	  16748                                        (0x3UL << SSTCP_PKT3_NUMVERTEX_SHIFT) |
      1	  16749                                        SSTCP_PKT3_BDDBDD);
      1	  16750 
      1	  16751 #if GLIDE_TRI_CULLING
      1	  16752   /* If we're doing sw culling for independent triangles then turn off
      1	  16753    * the hw culling so we're consistent. HW culling, however, remains
      1	  16754    * enabled for things using strips/fans.

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 40
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16755    */
      2	  16756   if (cullMode != GR_CULL_DISABLE) {
      2	  16757     gc->cmdTransportInfo.triPacketHdr &= ~(kSetupCullEnable << SSTCP_PKT3_SMODE_SHIFT);
      1	  16758   }
      1	  16759 #endif /* GLIDE_TRI_CULLING */
      1	  16760 }
	  16761 #endif /* GLIDE_HW_TRI_SETUP */
	  16762 
	  16763 /*---------------------------------------------------------------------------
	  16764  * _grRebuildDataList
	  16765  *
	  16766  * NB: For CVG is *IMPERATIVE* that the writes to the parameter
	  16767  * dataList remain in the order below otherwise the parameters
	  16768  * will get written to the command packet in the wrong order.
	  16769  */
	  16770 GR_DDFUNC(_grRebuildDataList, void, (void))
      1	  16771 {
      1	  16772 #define FN_NAME "_grRebuildDataList"
      1	  16773   GR_DCL_GC;
      1	  16774   GR_DCL_HW;
      1	  16775   int curTriSize, params;
      1	  16776   FxU32 i;
      1	  16777   SstRegs *tmu0;
      1	  16778   SstRegs *tmu1;
      1	  16779 
      1X  16780 #if GLIDE_PACKED_RGB
      1X  16781   FxBool packedRGB = FXFALSE;
      1X  16782 #endif /* GLIDE_PACKED_RGB */
      1	  16783     
      1X  16784 #ifdef GLIDE_DEBUG
      1X  16785   static char *p_str[] = {"x","y","z","r","g","b","ooz","a","oow",
      1X  16786                           "s0","t0","w0","s1","t1","w1","s2","t2","w2"};
      1X  16787 #endif /* GLIDE_DEBUG */
      1	  16788   
      1	  16789   GDBG_INFO(85,"(s) paramHints=0x%x paramIndex=0x%x\n", FN_NAME,
      1	  16790             gc->state.paramHints,gc->state.paramIndex);
      1	  16791   
      1	  16792   curTriSize = params = 0;
      1	  16793   i = gc->state.paramIndex;
      1X  16794 #ifdef GLIDE_USE_ALT_REGMAP
      1X  16795   hw = SST_WRAP(hw,128);        /* wrap 128-257 are ALTernate register mappings */
      1X  16796 #endif /* GLIDE_USE_ALT_REGMAP */
      1	  16797 
      1	  16798   tmu0 = SST_CHIP(hw,0xE); /* tmu 0,1,2 */
      1	  16799   tmu1 = SST_CHIP(hw,0xC); /* tmu 1,2 */
      1	  16800 
      1	  16801 #if GLIDE_HW_TRI_SETUP
      1	  16802   gc->cmdTransportInfo.paramMask = 0x00;
      1	  16803 #endif /* GLIDE_HW_TRI_SETUP */
      1	  16804 
      2	  16805   if (i & STATE_REQUIRES_IT_DRGB) {
      2	  16806 #if GLIDE_HW_TRI_SETUP
      2	  16807     gc->cmdTransportInfo.paramMask  |= SST_SETUP_RGB;
      2	  16808     gc->tsuDataList[curTriSize + 0] = GR_VERTEX_R_OFFSET << 2;
      2	  16809 
      2	  16810     /* When using packed color we only add *ONE* item to the data list
      2	  16811      * and this signals the entire color set since it is not possible

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 41
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16812      * to specify a single color component in any packet.  
      2	  16813      */
      2	  16814 #if !GLIDE_PACKED_RGB
      2	  16815     gc->tsuDataList[curTriSize + 1] = GR_VERTEX_G_OFFSET << 2;
      2	  16816     gc->tsuDataList[curTriSize + 2] = GR_VERTEX_B_OFFSET << 2;
      2	  16817 #endif /* !GLIDE_PACKED_RGB */
      2	  16818 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16819 
      2	  16820 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16821     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_R_OFFSET << 2;
      2	  16822     gc->regDataList[curTriSize + 1].i    = GR_VERTEX_G_OFFSET << 2;
      2	  16823     gc->regDataList[curTriSize + 2].i    = GR_VERTEX_B_OFFSET << 2;
      2	  16824 
      2	  16825     gc->regDataList[curTriSize + 0].addr = (float*)&hw->RED;
      2	  16826     gc->regDataList[curTriSize + 1].addr = (float*)&hw->GRN;
      2	  16827     gc->regDataList[curTriSize + 2].addr = (float*)&hw->BLU;
      2	  16828 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16829 
      2X  16830 #if GLIDE_PACKED_RGB
      2X  16831     curTriSize += 1;
      2X  16832     params += 1;
      2X  16833 
      2X  16834     packedRGB = FXTRUE;
      2X  16835 #else /* !GLIDE_PACKED_RGB */
      2	  16836     curTriSize += 3;
      2	  16837     params += 3;
      2	  16838 #endif /* !GLIDE_PACKED_RGB */
      1	  16839   }
      1	  16840 
      2	  16841   if (i & STATE_REQUIRES_IT_ALPHA) {
      2	  16842 #if GLIDE_HW_TRI_SETUP
      2	  16843     gc->cmdTransportInfo.paramMask   |= SST_SETUP_A;
      2	  16844     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_A_OFFSET << 2;
      2	  16845 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16846 
      2	  16847 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16848     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_A_OFFSET << 2;
      2	  16849     gc->regDataList[curTriSize + 0].addr = (float*)&hw->ALF;
      2	  16850 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16851 
      2	  16852     curTriSize += 1;
      2	  16853 
      2X  16854 #if GLIDE_PACKED_RGB
      2X  16855     {
      2X  16856       /* Only increment the parameter packet size if we have not already
      2X  16857        * added the rgb fields.  
      2X  16858        */
      2X  16859       if ((i & STATE_REQUIRES_IT_DRGB) == 0) params += 1;
      2X  16860       packedRGB = FXTRUE;
      2X  16861     }
      2X  16862 #else /* !GLIDE_PACKED_RGB */
      2	  16863     params += 1;
      2	  16864 #endif /* !GLIDE_PACKED_RGB */
      1	  16865   }
      1	  16866   
      2	  16867   if (i & STATE_REQUIRES_OOZ) {
      2	  16868 #if GLIDE_HW_TRI_SETUP

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 42
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16869     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_OOZ_OFFSET << 2;
      2	  16870     gc->cmdTransportInfo.paramMask      |= SST_SETUP_Z;
      2	  16871 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16872 
      2	  16873 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16874     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_OOZ_OFFSET << 2;
      2	  16875     gc->regDataList[curTriSize + 0].addr = (float*)&hw->Z;
      2	  16876 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16877 
      2	  16878     curTriSize += 1;
      2	  16879     params += 1;
      1	  16880   }
      1	  16881 
      1	  16882   /* we squeeze FBI.OOW in here for sequential writes in the simple case */
      2	  16883   if (i & STATE_REQUIRES_OOW_FBI) {
      2	  16884 #if GLIDE_HW_TRI_SETUP
      2	  16885     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_OOW_OFFSET << 2;
      2	  16886     gc->cmdTransportInfo.paramMask      |= SST_SETUP_Wfbi;
      2	  16887 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16888 
      2	  16889 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16890     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_OOW_OFFSET << 2;
      2	  16891     gc->regDataList[curTriSize + 0].addr = (float*)&hw->W;
      2	  16892 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16893 
      2	  16894     curTriSize += 1;
      2	  16895     params += 1;
      1	  16896   }
      1	  16897 
      1X  16898 #if GLIDE_FP_CLAMP_TEX
      1X  16899 #if !GLIDE_FP_CLAMP || !GLIDE_HW_TRI_SETUP
      1X  16900 #error "Does not make sense to have GLIDE_FP_CLAMP_TEX w/o GLIDE_FP_CLAMP or GLIDE_HW_TRI_SETUP"
      1X  16901 #endif /* !GLIDE_FP_CLAMP || !GLIDE_HW_TRI_SETUP */
      1X  16902 
      1X  16903   /* Simplify the test for clamping only the texture parameters by
      1X  16904    * sticking an extra empty slot into the data list.
      1X  16905    *
      1X  16906    * NB: This means that the code that runs through the parameter list
      1X  16907    * needs to increment the datalist pointer before moving onto the
      1X  16908    * texture parameters.
      1X  16909    */
      1X  16910   gc->tsuDataList[curTriSize++] = 0;
      1X  16911 #endif /* GLIDE_FP_CLAMP_TEX */
      1	  16912   
      1	  16913   /* NOTE: this is the first */
      2	  16914   if (i & STATE_REQUIRES_W_TMU0) {
      2	  16915 #if GLIDE_HW_TRI_SETUP
      2	  16916     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_OOW_TMU0_OFFSET << 2;
      2	  16917     gc->cmdTransportInfo.paramMask      |= SST_SETUP_W0;
      2	  16918 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16919 
      2	  16920 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16921     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_OOW_TMU0_OFFSET << 2;
      2	  16922     gc->regDataList[curTriSize + 0].addr = (float*)&tmu0->W;
      2	  16923 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16924 
      2	  16925     curTriSize += 1;

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 43
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      2	  16926     params += 1;
      1	  16927   }
      1	  16928   
      1	  16929   /* TMU0 --------------------------------- */
      1	  16930   /* always output to ALL chips, saves from having to change CHIP field */
      2	  16931   if (i & STATE_REQUIRES_ST_TMU0) {
      2	  16932 #if GLIDE_HW_TRI_SETUP
      2	  16933     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_SOW_TMU0_OFFSET << 2;
      2	  16934     gc->tsuDataList[curTriSize + 1]      = GR_VERTEX_TOW_TMU0_OFFSET << 2;
      2	  16935     gc->cmdTransportInfo.paramMask      |= SST_SETUP_ST0;
      2	  16936 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16937 
      2	  16938 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16939     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_SOW_TMU0_OFFSET << 2;
      2	  16940     gc->regDataList[curTriSize + 1].i    = GR_VERTEX_TOW_TMU0_OFFSET << 2;
      2	  16941     gc->regDataList[curTriSize + 0].addr = (float*)&tmu0->S;
      2	  16942     gc->regDataList[curTriSize + 1].addr = (float*)&tmu0->T;
      2	  16943 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16944 
      2	  16945     curTriSize += 2;
      2	  16946     params += 2;
      1	  16947   }
      1	  16948     
      1	  16949   /* TMU1 --------------------------------- */
      2	  16950   if (i & STATE_REQUIRES_W_TMU1) {
      2	  16951 #if GLIDE_HW_TRI_SETUP
      2	  16952     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_OOW_TMU1_OFFSET << 2;
      2	  16953     gc->cmdTransportInfo.paramMask      |= SST_SETUP_W1;
      2	  16954 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16955 
      2	  16956 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16957     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_OOW_TMU1_OFFSET << 2;
      2	  16958     gc->regDataList[curTriSize + 0].addr = (float*)&tmu1->W;
      2	  16959 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16960 
      2	  16961     curTriSize += 1;
      2	  16962     params += 1;
      2	  16963 
      1	  16964   }
      1	  16965 
      2	  16966   if (i & STATE_REQUIRES_ST_TMU1) {
      2	  16967 #if GLIDE_HW_TRI_SETUP
      2	  16968     gc->tsuDataList[curTriSize + 0]      = GR_VERTEX_SOW_TMU1_OFFSET << 2;
      2	  16969     gc->tsuDataList[curTriSize + 1]      = GR_VERTEX_TOW_TMU1_OFFSET << 2;
      2	  16970     gc->cmdTransportInfo.paramMask      |= SST_SETUP_ST1;
      2	  16971 #endif /* GLIDE_HW_TRI_SETUP */
      2	  16972 
      2	  16973 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      2	  16974     gc->regDataList[curTriSize + 0].i    = GR_VERTEX_SOW_TMU1_OFFSET << 2;
      2	  16975     gc->regDataList[curTriSize + 0].addr = (float*)&tmu1->S;
      2	  16976     gc->regDataList[curTriSize + 1].i    = GR_VERTEX_TOW_TMU1_OFFSET << 2;
      2	  16977     gc->regDataList[curTriSize + 1].addr = (float*)&tmu1->T;
      2	  16978 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      2	  16979 
      2	  16980     curTriSize += 2;
      2	  16981     params += 2;
      1	  16982   }

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 44
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1	  16983   
      1X  16984 #if (GLIDE_NUM_TMU > 2)
      1X  16985 #error "GLIDE_NUM_TMU > 2: Write this code."
      1X  16986 #endif
      1	  16987 
      1	  16988 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      1	  16989   gc->regDataList[curTriSize].i = 0;     /* terminate the list with 0,*      */
      1	  16990 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      1	  16991 
      1	  16992 #if GLIDE_HW_TRI_SETUP
      1	  16993   gc->tsuDataList[curTriSize]   = 0;
      1	  16994 #endif /* GLIDE_HW_TRI_SETUP */
      1	  16995 
      1	  16996   curTriSize++;
      1	  16997 
      1	  16998 #if GLIDE_HW_TRI_SETUP
      1	  16999   /* Per vertex size: (xy [required] + parameters) * param size (32 bit word) */
      1	  17000   _GlideRoot.curVertexSize = ((2 + params) << 2);
      1	  17001 
      1	  17002   /* Packet size: 3 * vertex size */
      1	  17003   _GlideRoot.curTriSize = (_GlideRoot.curVertexSize << 1) + _GlideRoot.curVertexSize;
      1	  17004 
      1	  17005   /* Shift the parameter mask to just write into the packet header. */
      1	  17006   GDBG_INFO(191, "CVG ParamMask: 0x%X\n", gc->cmdTransportInfo.paramMask);
      1	  17007   gc->cmdTransportInfo.paramMask <<= SSTCP_PKT3_PMASK_SHIFT;
      1	  17008 
      1X  17009 #if GLIDE_PACKED_RGB
      1X  17010   if (packedRGB) gc->cmdTransportInfo.paramMask |= SSTCP_PKT3_PACKEDCOLOR;
      1X  17011 #endif /* GLIDE_PACKED_RGB */
      1	  17012 
      1	  17013   /* Update common packet 3 headers */
      1	  17014   _grUpdateTriPacketHdr(gc->cmdTransportInfo.paramMask, gc->state.cull_mode);
      1	  17015 #endif /* GLIDE_HW_TRI_SETUP */
      1	  17016 
      1	  17017 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      1	  17018   gc->regDataList[curTriSize].i    = 1;
      1	  17019   gc->regDataList[curTriSize].addr = (float*)&hw->FtriangleCMD;
      1	  17020 
      1	  17021   /* 6 X,Y values plus AREA = 7, plus parameters */
      1	  17022   _GlideRoot.paramCount = params;
      1	  17023   _GlideRoot.curTriSize = (6 + curTriSize + (params << 1)) << 2;
      1	  17024 
      1	  17025   /* Need to know tri size without gradients for planar polygons */
      1	  17026   _GlideRoot.curTriSizeNoGradient = _GlideRoot.curTriSize - (params << 3);
      1	  17027 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      1	  17028 
      1X  17029 #if GLIDE_FP_CLAMP_TEX
      1	  17030   /* Stick one more 0 in the dataList so that the texture clamping
      1	  17031    * loop does not go one more iteration.
      1X  17032    */
      1X  17033   gc->tsuDataList[++curTriSize]   = 0;
      1X  17034 #endif /* GLIDE_FP_CLAMP_TEX */
      1	  17035   
      1X  17036 #ifdef GDBG_INFO_ON
      1X  17037 #if GLIDE_HW_TRI_SETUP
      1X  17038   for (i = 0; gc->tsuDataList[i]; i++) {
      1X  17039     GDBG_INFO(282,"    tsuDataList[%d] = %2d [%s]\n",

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 45
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

      1X  17040               i, gc->tsuDataList[i] >> 2, p_str[gc->tsuDataList[i] >> 2]);
      1X  17041   }
      1X  17042 #endif /* GLIDE_HW_TRI_SETUP */
      1X  17043 
      1X  17044 #if !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP
      1X  17045   for (i = 0; gc->regDataList[i].i; i++) {
      1X  17046     GDBG_INFO(282,"    dataList[%d] = %2d 0x%x [%s]\n",
      1X  17047               i, gc->regDataList[i].i >> 2, gc->regDataList[i].addr,
      1X  17048               p_str[gc->regDataList[i].i >> 2]);
      1X  17049   }
      1X  17050 #endif /* !GLIDE_HW_TRI_SETUP || !GLIDE_PACKET3_TRI_SETUP */
      1X  17051 #endif /* GDBG_INFO_ON */
      1	  17052 
      1	  17053 #undef FN_NAME
      1	  17054 } /* _grRebuildDataList */
	  17055 
       X  17056 #if GLIDE_MULTIPLATFORM
	  17057 /*
	  17058    _grInitializeGCFuncs - initialize the gcFuncs Structure for this
	  17059         device.
       X  17060 */
       X  17061 GR_DDFUNC(_grInitializeGCFuncs, void, (GrGC *gc))
       X  17062 {
       X  17063   
       X  17064   gc->gcFuncs._grColorCombineDelta0Mode = (void *)
       X  17065     GR_DDNAME(_grColorCombineDelta0Mode); 
       X  17066   gc->gcFuncs._grRebuildDataList = (void *) GR_DDNAME(_grRebuildDataList);
       X  17067   gc->gcFuncs._grTexDetailControl = (void *) GR_DDNAME(_grTexDetailControl);
       X  17068   gc->gcFuncs._grTexDownloadNccTable = (void *)
       X  17069     GR_DDNAME(_grTexDownloadNccTable); 
       X  17070   gc->gcFuncs._grTexDownloadPalette = (void *)
       X  17071     GR_DDNAME(_grTexDownloadPalette); 
       X  17072   gc->gcFuncs._gumpTexCombineFunction = (void *)
       X  17073     GR_DDNAME(_gumpTexCombineFunction); 
       X  17074   gc->gcFuncs._grUpdateParamIndex = (void *)
       X  17075     GR_DDNAME(_grUpdateParamIndex); 
       X  17076   gc->gcFuncs._trisetup = (void *) GR_DDNAME(_trisetup); 
       X  17077   gc->gcFuncs._trisetup_nogradients = (void *)
       X  17078     GR_DDNAME(_trisetup_nogradients); 
       X  17079   gc->gcFuncs.grAADrawLine = (void *) GR_DDNAME(grAADrawLine); 
       X  17080   gc->gcFuncs.grAADrawPoint = (void *) GR_DDNAME(grAADrawPoint); 
       X  17081   gc->gcFuncs.grAADrawPolygon = (void *) GR_DDNAME(grAADrawPolygon); 
       X  17082   gc->gcFuncs.grAADrawPolygonVertexList = (void *)
       X  17083     GR_DDNAME(grAADrawPolygonVertexList); 
       X  17084   gc->gcFuncs.grAADrawTriangle = (void *) GR_DDNAME(grAADrawTriangle); 
       X  17085   gc->gcFuncs.grAlphaBlendFunction = (void *)
       X  17086     GR_DDNAME(grAlphaBlendFunction); 
       X  17087   gc->gcFuncs.grAlphaCombine = (void *) GR_DDNAME(grAlphaCombine); 
       X  17088   gc->gcFuncs.grAlphaControlsITRGBLighting = (void *)
       X  17089     GR_DDNAME(grAlphaControlsITRGBLighting); 
       X  17090   gc->gcFuncs.grAlphaTestFunction = (void *)
       X  17091     GR_DDNAME(grAlphaTestFunction); 
       X  17092   gc->gcFuncs.grAlphaTestReferenceValue = (void *)
       X  17093     GR_DDNAME(grAlphaTestReferenceValue); 
       X  17094   gc->gcFuncs.grBufferClear = (void *) GR_DDNAME(grBufferClear); 
       X  17095   gc->gcFuncs.grBufferNumPending = (void *)
       X  17096     GR_DDNAME(grBufferNumPending); 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 46
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

       X  17097   gc->gcFuncs.grBufferSwap = (void *) GR_DDNAME(grBufferSwap); 
       X  17098   gc->gcFuncs.grChromakeyMode = (void *) GR_DDNAME(grChromakeyMode); 
       X  17099   gc->gcFuncs.grChromakeyValue = (void *) GR_DDNAME(grChromakeyValue); 
       X  17100   gc->gcFuncs.grClipWindow = (void *) GR_DDNAME(grClipWindow); 
       X  17101   gc->gcFuncs.grColorCombine = (void *) GR_DDNAME(grColorCombine); 
       X  17102   gc->gcFuncs.grColorMask = (void *) GR_DDNAME(grColorMask); 
       X  17103   gc->gcFuncs.grConstantColorValue = (void *)
       X  17104     GR_DDNAME(grConstantColorValue); 
       X  17105   gc->gcFuncs.grConstantColorValue4 = (void *)
       X  17106     GR_DDNAME(grConstantColorValue4); 
       X  17107   gc->gcFuncs.grCullMode = (void *) GR_DDNAME(grCullMode); 
       X  17108   gc->gcFuncs.grDepthBiasLevel = (void *) GR_DDNAME(grDepthBiasLevel); 
       X  17109   gc->gcFuncs.grDepthBufferFunction = (void *)
       X  17110     GR_DDNAME(grDepthBufferFunction); 
       X  17111   gc->gcFuncs.grDepthBufferMode = (void *) GR_DDNAME(grDepthBufferMode);
       X  17112   
       X  17113   gc->gcFuncs.grDepthMask = (void *) GR_DDNAME(grDepthMask); 
       X  17114   gc->gcFuncs.grDisableAllEffects = (void *)
       X  17115     GR_DDNAME(grDisableAllEffects); 
       X  17116   gc->gcFuncs.grDitherMode = (void *) GR_DDNAME(grDitherMode); 
       X  17117   gc->gcFuncs.grDrawLine = (void *) GR_DDNAME(grDrawLine); 
       X  17118   gc->gcFuncs.grDrawPlanarPolygon = (void *)
       X  17119     GR_DDNAME(grDrawPlanarPolygon); 
       X  17120   gc->gcFuncs.grDrawPlanarPolygonVertexList = (void *)
       X  17121     GR_DDNAME(grDrawPlanarPolygonVertexList); 
       X  17122   gc->gcFuncs.grDrawPoint = (void *) GR_DDNAME(grDrawPoint); 
       X  17123   gc->gcFuncs.grDrawPolygon = (void *) GR_DDNAME(grDrawPolygon); 
       X  17124   gc->gcFuncs.grDrawPolygonVertexList = (void *)
       X  17125     GR_DDNAME(grDrawPolygonVertexList); 
       X  17126   gc->gcFuncs.grDrawTriangle = (void *) GR_DDNAME(grDrawTriangle); 
       X  17127   gc->gcFuncs.grFogColorValue = (void *) GR_DDNAME(grFogColorValue); 
       X  17128   gc->gcFuncs.grFogMode = (void *) GR_DDNAME(grFogMode); 
       X  17129   gc->gcFuncs.grFogTable = (void *) GR_DDNAME(grFogTable); 
       X  17130   gc->gcFuncs.grGammaCorrectionValue = (void *)
       X  17131     GR_DDNAME(grGammaCorrectionValue); 
       X  17132   gc->gcFuncs.grGlideSetState = (void *) GR_DDNAME(grGlideSetState); 
       X  17133   gc->gcFuncs.grGlideShutdown = (void *) GR_DDNAME(grGlideShutdown); 
       X  17134   gc->gcFuncs.grLfbConstantAlpha = (void *)
       X  17135     GR_DDNAME(grLfbConstantAlpha); 
       X  17136   gc->gcFuncs.grLfbConstantDepth = (void *)
       X  17137     GR_DDNAME(grLfbConstantDepth); 
       X  17138   gc->gcFuncs.grLfbLock = (void *)GR_DDNAME(grLfbLock);
       X  17139   gc->gcFuncs.grLfbUnlock = (void*)GR_DDNAME(grLfbUnlock);
       X  17140   gc->gcFuncs.grLfbWriteColorFormat = (void *)
       X  17141     GR_DDNAME(grLfbWriteColorFormat); 
       X  17142   gc->gcFuncs.grLfbWriteColorSwizzle = (void *)
       X  17143     GR_DDNAME(grLfbWriteColorSwizzle); 
       X  17144   gc->gcFuncs.grRenderBuffer = (void *) GR_DDNAME(grRenderBuffer); 
       X  17145   gc->gcFuncs.grSstConfigPipeline = (void *)
       X  17146     GR_DDNAME(grSstConfigPipeline); 
       X  17147   gc->gcFuncs.grSstIdle = (void *) GR_DDNAME(grSstIdle); 
       X  17148   gc->gcFuncs.grSstIsBusy = (void *) GR_DDNAME(grSstIsBusy); 
       X  17149   gc->gcFuncs.grSstOpen = (void *) GR_DDNAME(grSstOpen); 
       X  17150   gc->gcFuncs.grSstOrigin = (void *) GR_DDNAME(grSstOrigin); 
       X  17151   gc->gcFuncs.grSstPassthruMode = (void *) GR_DDNAME(grSstPassthruMode);
       X  17152   
       X  17153   gc->gcFuncs.grSstPerfStats = (void *) GR_DDNAME(grSstPerfStats); 

GGLIDE                          Source Listing                   9-MAY-2021 23:42:56  VSI C V7.4-002-50R2O              Page 47
V1.0                                                             8-MAY-2021 19:20:18  gglide.c;3

       X  17154   gc->gcFuncs.grSstResetPerfStats = (void *) GR_DDNAME(grSstResetPerfStats);
       X  17155   gc->gcFuncs.grSstStatus = (void *) GR_DDNAME(grSstStatus); 
       X  17156   gc->gcFuncs.grSstVRetraceOn = (void *) GR_DDNAME(grSstVRetraceOn); 
       X  17157   gc->gcFuncs.grSstVideoLine = (void *) GR_DDNAME(grSstVideoLine); 
       X  17158   gc->gcFuncs.grTexClampMode = (void *) GR_DDNAME(grTexClampMode); 
       X  17159   gc->gcFuncs.grTexCombine = (void *) GR_DDNAME(grTexCombine); 
       X  17160   gc->gcFuncs.grTexDownloadMipMapLevelPartial = (void *)
       X  17161     GR_DDNAME(grTexDownloadMipMapLevelPartial); 
       X  17162   gc->gcFuncs.grTexFilterMode = (void *) GR_DDNAME(grTexFilterMode); 
       X  17163   gc->gcFuncs.grTexLodBiasValue = (void *) GR_DDNAME(grTexLodBiasValue);
       X  17164   gc->gcFuncs.grTexMipMapMode = (void *) GR_DDNAME(grTexMipMapMode);
       X  17165   gc->gcFuncs.grTexMultibase = (void *) GR_DDNAME(grTexMultibase); 
       X  17166   gc->gcFuncs.grTexMultibaseAddress = (void *)
       X  17167     GR_DDNAME(grTexMultibaseAddress); 
       X  17168   gc->gcFuncs.grTexNCCTable = (void *) GR_DDNAME(grTexNCCTable); 
       X  17169   gc->gcFuncs.grTexSource = (void *) GR_DDNAME(grTexSource); 
       X  17170   gc->gcFuncs.guMPDrawTriangle = (void *) GR_DDNAME(guMPDrawTriangle); 
       X  17171   gc->gcFuncs.guTexSource = (void *) GR_DDNAME(guTexSource);
       X  17172   gc->gcFuncs.ConvertAndDownloadRle=(void *) GR_DDNAME(ConvertAndDownloadRle); 
       X  17173   gc->gcFuncs.grCheckForRoom=(void *) GR_DDNAME(grCheckForRoom); 
       X  17174 } /* _grInitializeGCFuncs */
       X  17175 #endif


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GGLIDE/OBJECT=[.
OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GGLIDE.OBJ/INCLUDE_DIRECTORY=([.GLIDE
.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GL
IDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TR
ISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_
LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GGLIDE.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:56"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


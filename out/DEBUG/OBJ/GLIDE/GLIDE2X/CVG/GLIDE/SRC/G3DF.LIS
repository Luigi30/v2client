G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.1.1.1.2.2  2006/12/03 04:49:19  guillemj
	     21 ** Backport "sequence point" fix for string upper code from glide3x.
	     22 **
	     23 ** Revision 1.1.1.1.2.1  2004/12/12 15:20:35  koolsmoky
	     24 ** use toupper for __MSC__
	     25 **
	     26 ** Revision 1.1.1.1  1999/12/07 21:49:09  joseph
	     27 ** Initial checkin into SourceForge.
	     28 **
	     29 ** 
	     30 ** 17    2/20/98 11:00a Peter
	     31 ** removed glide3 from glid2 tree
	     32  * 
	     33  * 16    1/13/98 7:48p Atai
	     34  * fixed gu3dfGetInfo, grBufferClear, and GrState size
	     35  * 
	     36  * 15    1/13/98 12:42p Atai
	     37  * fixed grtexinfo, grVertexLayout, and draw triangle
	     38  * 
	     39  * 14    1/09/98 6:48p Atai
	     40  * grTexInfo, GR_LOD_* and GR_ASPECT_*
	     41  * 
	     42  * 12    12/17/97 4:45p Peter
	     43  * groundwork for CrybabyGlide
	     44  * 
	     45  * 11    12/09/97 12:20p Peter
	     46  * mac glide port
	     47  * 
	     48  * 10    6/06/97 5:56p Peter
	     49  * fixed gcc/dural compilation things
	     50  * 
	     51  * 9     6/02/97 4:09p Peter
	     52  * Compile w/ gcc for Dural
	     53  * 
	     54  * 8     5/27/97 1:16p Peter
	     55  * Basic cvg, w/o cmd fifo stuff. 
	     56  * 
	     57  * 7     5/21/97 6:05a Peter

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

	     58  * 
	     59  * 6     3/09/97 10:31a Dow
	     60  * Added GR_DIENTRY for di glide functions
	     61 **
	     62 */
	     63 #include <stdio.h>
	   1674 #include <string.h>
	   2125 #include <3dfx.h>
	   2256 
	   2257 #define FX_DLL_DEFINITION
	   2258 #include <fxdll.h>
	   2379 #include <glide.h>
	   4321 #include "fxglide.h"
	  14603 
	  14604 extern const int _grMipMapHostWH[GR_ASPECT_1x8 + 1][GR_LOD_1 + 1][2];
	  14605 extern FxU32 _gr_aspect_index_table[];
	  14606 extern FxU32 _grMipMapHostSize[4][16];
	  14607 
	  14608 static FxBool ReadDataShort(FILE *, FxU16 *data);
	  14609 static FxBool ReadDataLong(FILE *, FxU32 *data);
	  14610 static FxBool Read8Bit(FxU8 *dst, FILE *image, int small_lod, int large_lod, GrAspectRatio_t aspect);
	  14611 static FxBool Read16Bit(FxU16 *dst, FILE *image, int small_lod, int large_lod, GrAspectRatio_t aspect);
	  14612 
       X  14613 #if ((GLIDE_PLATFORM & (GLIDE_OS_DOS32 | GLIDE_OS_WIN32 | GLIDE_OS_MACOS)) != 0)
       X  14614 static const char *openmode = "rb";
       X  14615 #else
	  14616 static const char *openmode = "r";
	  14617 #endif
	  14618 
	  14619 typedef struct
	  14620 {
	  14621   const char        *name;
	  14622   GrTextureFormat_t  fmt;
	  14623   FxBool             valid;
	  14624 } CfTableEntry;
	  14625 
	  14626 
	  14627 static FxBool 
	  14628 _grGet3dfHeader(FILE* stream, char* const buffer, const FxU32 bufSize)
      1	  14629 {
      1	  14630   int numLines = 0;
      1	  14631   FxU32 bufPos = 0;
      1	  14632   
      2	  14633   while(numLines < 4) {
      2	  14634     /* Handle stream errors */
      2	  14635     if (fgets(buffer + bufPos, bufSize - bufPos, stream) == NULL) break;
      2	  14636     bufPos += strlen(buffer + bufPos);
      2	  14637     
      2	  14638     /* fgets includes the '\n' in the buffer. If this is not there
      2	  14639      * then the buffer is too small so fail.
      2	  14640      */
      2	  14641     if (*(buffer + bufPos - sizeof(char)) != '\n') break;
      2	  14642     numLines++;
      1	  14643   }
      1	  14644 
      1	  14645   return (numLines == 4);
      1	  14646 }

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

	  14647 
	  14648 /*---------------------------------------------------------------------------
	  14649 ** gu3dfGetInfo
	  14650 */
	  14651 GR_DIENTRY(gu3dfGetInfo, FxBool,
	  14652            (const char *FileName, Gu3dfInfo *Info))
      1	  14653 {
      1	  14654   FILE *image_file;
      1	  14655   FxU32 i;
      1	  14656   char  version[5];
      1	  14657   char  color_format[10];
      1	  14658   int   aspect_width, aspect_height;
      1	  14659   char  buffer[100];
      1	  14660   int   small_lod, large_lod;
      1	  14661   FxBool ratio_found = FXFALSE;
      1	  14662   FxBool format_found = FXFALSE;
      1	  14663   GrAspectRatio_t wh_aspect_table[] =
      1	  14664   {
      1	  14665     GR_ASPECT_1x1,
      1	  14666     GR_ASPECT_1x2,
      1	  14667     GR_ASPECT_1x4,
      1	  14668     GR_ASPECT_1x8
      1	  14669   };
      1	  14670   GrAspectRatio_t hw_aspect_table[] =
      1	  14671   {
      1	  14672     GR_ASPECT_1x1,
      1	  14673     GR_ASPECT_2x1,
      1	  14674     GR_ASPECT_4x1,
      1	  14675     GR_ASPECT_8x1
      1	  14676   };
      1	  14677   CfTableEntry cftable[] = 
      1	  14678   {
      1	  14679     { "I8",       GR_TEXFMT_INTENSITY_8,        FXTRUE },
      1	  14680     { "A8",       GR_TEXFMT_ALPHA_8,            FXTRUE },
      1	  14681     { "AI44",     GR_TEXFMT_ALPHA_INTENSITY_44, FXTRUE },
      1	  14682     { "YIQ",      GR_TEXFMT_YIQ_422,            FXTRUE },
      1	  14683     { "RGB332",   GR_TEXFMT_RGB_332,            FXTRUE },
      1	  14684     { "RGB565",   GR_TEXFMT_RGB_565,            FXTRUE },
      1	  14685     { "ARGB8332", GR_TEXFMT_ARGB_8332,          FXTRUE },
      1	  14686     { "ARGB1555", GR_TEXFMT_ARGB_1555,          FXTRUE },
      1	  14687     { "AYIQ8422", GR_TEXFMT_AYIQ_8422,          FXTRUE },
      1	  14688     { "ARGB4444", GR_TEXFMT_ARGB_4444,          FXTRUE },
      1	  14689     { "AI88",     GR_TEXFMT_ALPHA_INTENSITY_88, FXTRUE },
      1	  14690     { "P8",       GR_TEXFMT_P_8,                FXTRUE },
      1	  14691     { "AP88",     GR_TEXFMT_AP_88,              FXTRUE },
      1	  14692     { 0, 0, FXFALSE }
      1	  14693   };
      1	  14694 
      1	  14695   GDBG_INFO(81,"gu3dfGetInfo(%s,0x%x)\n",FileName,Info);
      1	  14696 
      1	  14697   if ((image_file = fopen(FileName, openmode)) == NULL) return FXFALSE;
      1	  14698   if (!_grGet3dfHeader(image_file, buffer, sizeof(buffer))) goto _loc1;
      1	  14699 
      1	  14700   /*
      1	  14701   ** grab statistics out of the header
      1	  14702   */
      1	  14703   if(sscanf(buffer,"3df v%s %s lod range: %i %i aspect ratio: %i %i\n",

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      1	  14704             version,
      1	  14705             color_format,
      1	  14706             &small_lod, &large_lod,
      1	  14707             &aspect_width, &aspect_height) != 6)
      1	  14708     goto _loc1;
      1	  14709 
      1	  14710   /*
      1	  14711   ** determine aspect ratio, height, and width
      1	  14712   */
      1	  14713   i = 0;
      2	  14714   while ((i < 4) && (!ratio_found)) {
      3	  14715     if ((aspect_width << i) == aspect_height) {
      3	  14716       Info->header.aspect_ratio = wh_aspect_table[i];
      3	  14717       ratio_found = FXTRUE;
      2	  14718     }
      2	  14719 
      2	  14720     i++;
      1	  14721   }
      1	  14722 
      1	  14723   i = 0;
      2	  14724   while ((i < 4) && (!ratio_found)) {
      3	  14725     if ((aspect_height << i) == aspect_width) {
      3	  14726       Info->header.aspect_ratio = hw_aspect_table[i];
      3	  14727       ratio_found = FXTRUE;
      2	  14728     }
      2	  14729 
      2	  14730     i++;
      1	  14731   }
      1	  14732   if (!ratio_found) goto _loc1;
      1	  14733 
      1	  14734   /*
      1	  14735   ** determine height and width of the mip map
      1	  14736   */
      2	  14737   if (aspect_width >= aspect_height) {
      2	  14738     Info->header.width  = large_lod;
      2	  14739     Info->header.height = large_lod / aspect_width;
      2	  14740   } else {
      2	  14741     Info->header.height = large_lod;
      2	  14742     Info->header.width  = large_lod / aspect_height;
      1	  14743   }
      1	  14744 
      1	  14745 
      1	  14746   /*
      1	  14747   ** calculate proper LOD values
      1	  14748   */
      1	  14749   /*
      1	  14750   ** note for glide3 lod translation:
      1	  14751   ** we should return the new defines for glide3
      1	  14752   */
      2	  14753   switch (small_lod) {
      2	  14754   case 1:
      2	  14755     Info->header.small_lod = GR_LOD_1;
      2	  14756     break;
      2	  14757 
      2	  14758   case 2:
      2	  14759     Info->header.small_lod = GR_LOD_2;
      2	  14760     break;

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      2	  14761 
      2	  14762   case 4:
      2	  14763     Info->header.small_lod = GR_LOD_4;
      2	  14764     break;
      2	  14765 
      2	  14766   case 8:
      2	  14767     Info->header.small_lod = GR_LOD_8;
      2	  14768     break;
      2	  14769 
      2	  14770   case 16:
      2	  14771     Info->header.small_lod = GR_LOD_16;
      2	  14772     break;
      2	  14773 
      2	  14774   case 32:
      2	  14775     Info->header.small_lod = GR_LOD_32;
      2	  14776     break;
      2	  14777 
      2	  14778   case 64:
      2	  14779     Info->header.small_lod = GR_LOD_64;
      2	  14780     break;
      2	  14781 
      2	  14782   case 128:
      2	  14783     Info->header.small_lod = GR_LOD_128;
      2	  14784     break;
      2	  14785 
      2	  14786   case 256:
      2	  14787     Info->header.small_lod = GR_LOD_256;
      2	  14788     break;
      1	  14789   }
      1	  14790 
      2	  14791   switch (large_lod) {
      2	  14792   case 1:
      2	  14793     Info->header.large_lod = GR_LOD_1;
      2	  14794     break;
      2	  14795 
      2	  14796   case 2:
      2	  14797     Info->header.large_lod = GR_LOD_2;
      2	  14798     break;
      2	  14799 
      2	  14800   case 4:
      2	  14801     Info->header.large_lod = GR_LOD_4;
      2	  14802     break;
      2	  14803 
      2	  14804   case 8:
      2	  14805     Info->header.large_lod = GR_LOD_8;
      2	  14806     break;
      2	  14807 
      2	  14808   case 16:
      2	  14809     Info->header.large_lod = GR_LOD_16;
      2	  14810     break;
      2	  14811 
      2	  14812   case 32:
      2	  14813     Info->header.large_lod = GR_LOD_32;
      2	  14814     break;
      2	  14815 
      2	  14816   case 64:
      2	  14817     Info->header.large_lod = GR_LOD_64;

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      2	  14818     break;
      2	  14819 
      2	  14820   case 128:
      2	  14821     Info->header.large_lod = GR_LOD_128;
      2	  14822     break;
      2	  14823 
      2	  14824   case 256:
      2	  14825     Info->header.large_lod = GR_LOD_256;
      2	  14826     break;
      1	  14827   }
      1	  14828 
      1	  14829   /*
      1	  14830   ** determine the color format of the input image
      1	  14831   */
      2	  14832   {
      2	  14833     char *tempStr = (char*)color_format;
      3	  14834     while (*tempStr != '\0') {
      3	  14835           if (*tempStr >= 'a' && *tempStr <= 'z')
      3	  14836               *tempStr -= ('a'-'A');
      3	  14837           tempStr++;
      2	  14838     }
      1	  14839   }
      1	  14840 
      1	  14841   i = 0;
      2	  14842   while ((cftable[i].name != 0) && (!format_found)) {
      3	  14843     if (strcmp(color_format, cftable[i].name) == 0) {
      3	  14844       Info->header.format = cftable[i].fmt;
      3	  14845       format_found = FXTRUE;
      2	  14846     }
      2	  14847 
      2	  14848     i++;
      1	  14849   }
      1	  14850 
      1	  14851   /*
      1	  14852   ** close the input file
      1	  14853   */
      1	  14854  _loc1:
      1	  14855   fclose(image_file);
      1	  14856 
      2	  14857   if (format_found) {
      2	  14858     FxI32 lod;
      2	  14859     Info->mem_required = 0;
      3	  14860     for(lod = Info->header.large_lod; lod <= Info->header.small_lod; lod++) {
      3	  14861       Info->mem_required += (_grMipMapHostSize[_gr_aspect_index_table[Info->header.aspect_ratio]]
      3	  14862                              [lod] << (Info->header.format >= GR_TEXFMT_16BIT));
      2	  14863     }
      1	  14864   }
      1	  14865 
      1	  14866   return format_found;
      1	  14867 }
	  14868 
	  14869 /*---------------------------------------------------------------------------
	  14870 ** gu3dfLoad
	  14871 */
	  14872 GR_DIENTRY(gu3dfLoad, FxBool, (const char *filename, Gu3dfInfo *info))
      1	  14873 {
      1	  14874   FILE *image_file  = 0;

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      1	  14875   FxU32 index       = 0;
      1	  14876   char  buffer[100] = "";
      1	  14877 
      1	  14878   GDBG_INFO(81,"gu3dfLoad(%s,0x%x)\n",filename,info);
      1	  14879 
      1	  14880   if ((image_file = fopen(filename, openmode)) == NULL) return FXFALSE;
      1	  14881   if (!_grGet3dfHeader(image_file, buffer, sizeof(buffer))) goto _loc1;
      1	  14882 
      1	  14883   /*
      1	  14884   ** If necessary, read in the YIQ decompression table
      1	  14885   */
      1	  14886   if ((info->header.format == GR_TEXFMT_YIQ_422) ||
      1	  14887       (info->header.format == GR_TEXFMT_AYIQ_8422))
      2	  14888   {
      2	  14889     /*
      2	  14890     ** read in Y
      2	  14891     */
      2	  14892     for (index = 0; index < 16; index++)
      3	  14893     {
      3	  14894       FxU16 val;
      3	  14895       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14896       info->table.nccTable.yRGB[index] = val & 0xFF;
      2	  14897     }
      2	  14898 
      2	  14899     /*
      2	  14900     ** read in I
      2	  14901     */
      3	  14902     for (index = 0; index < 4; index++) {
      3	  14903       FxU16 val;
      3	  14904       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14905       info->table.nccTable.iRGB[index][0] = val & 0x1FF;
      3	  14906       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14907       info->table.nccTable.iRGB[index][1] = val & 0x1FF;
      3	  14908       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14909       info->table.nccTable.iRGB[index][2] = val & 0x1FF;
      2	  14910     }
      2	  14911 
      2	  14912     /*
      2	  14913     ** read in Q
      2	  14914     */
      3	  14915     for (index = 0; index < 4; index++) {
      3	  14916       FxU16 val;
      3	  14917       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14918       info->table.nccTable.qRGB[index][0] = val & 0x1FF;
      3	  14919       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14920       info->table.nccTable.qRGB[index][1] = val & 0x1FF;
      3	  14921       if (!ReadDataShort(image_file, &val)) goto _loc1;
      3	  14922       info->table.nccTable.qRGB[index][2] = val & 0x1FF;
      2	  14923     }
      2	  14924 
      2	  14925     /*
      2	  14926     ** pack the table Y entries
      2	  14927     */
      2	  14928     for (index = 0; index < 4; index++)
      3	  14929     {
      3	  14930       FxU32 packedvalue;
      3	  14931 

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      3	  14932       packedvalue  = ((FxU32) info->table.nccTable.yRGB[index*4+0]);
      3	  14933       packedvalue |= ((FxU32) info->table.nccTable.yRGB[index*4+1]) << 8;
      3	  14934       packedvalue |= ((FxU32) info->table.nccTable.yRGB[index*4+2]) << 16;
      3	  14935       packedvalue |= ((FxU32) info->table.nccTable.yRGB[index*4+3]) << 24;
      3	  14936 
      3	  14937       info->table.nccTable.packed_data[index] = packedvalue;
      2	  14938     }
      2	  14939 
      2	  14940     /*
      2	  14941     ** pack the table I entries
      2	  14942     */
      3	  14943     for (index = 0; index < 4; index++) {
      3	  14944       FxU32 packedvalue;
      3	  14945 
      3	  14946       packedvalue  = ((FxU32) info->table.nccTable.iRGB[index][0]) << 18;
      3	  14947       packedvalue |= ((FxU32) info->table.nccTable.iRGB[index][1]) << 9;
      3	  14948       packedvalue |= ((FxU32) info->table.nccTable.iRGB[index][2]) << 0;
      3	  14949 
      3	  14950       info->table.nccTable.packed_data[index+4] = packedvalue;
      2	  14951     }
      2	  14952 
      2	  14953     /*
      2	  14954     ** pack the table Q entries
      2	  14955     */
      3	  14956     for (index = 0; index < 4; index++) {
      3	  14957       FxU32 packedvalue;
      3	  14958 
      3	  14959       packedvalue  = ((FxU32) info->table.nccTable.qRGB[index][0]) << 18;
      3	  14960       packedvalue |= ((FxU32) info->table.nccTable.qRGB[index][1]) << 9;;
      3	  14961       packedvalue |= ((FxU32) info->table.nccTable.qRGB[index][2]) << 0;
      3	  14962 
      3	  14963       info->table.nccTable.packed_data[index+8] = packedvalue;
      2	  14964     }
      1	  14965   }
      1	  14966 
      1	  14967   /*
      1	  14968   ** If necessary, read in the Palette
      1	  14969   */
      1	  14970   if ((info->header.format == GR_TEXFMT_P_8) ||
      2	  14971       (info->header.format == GR_TEXFMT_AP_88)) {
      2	  14972     FxU32 i;
      2	  14973     for(i = 0; i < 256; i++)
      3	  14974     {
      3	  14975       FxU32 val;
      3	  14976       if (!ReadDataLong(image_file, &val)) goto _loc1;
      3	  14977       info->table.palette.data[i] = val;
      2	  14978     }
      1	  14979   }
      1	  14980 
      1	  14981   /*
      1	  14982   ** Read in the image
      1	  14983   */
      1	  14984   switch (info->header.format)
      2	  14985   {
      2	  14986   case GR_TEXFMT_INTENSITY_8:
      2	  14987   case GR_TEXFMT_ALPHA_8:
      2	  14988   case GR_TEXFMT_ALPHA_INTENSITY_44:

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      2	  14989   case GR_TEXFMT_YIQ_422:
      2	  14990   case GR_TEXFMT_RGB_332:
      2	  14991   case GR_TEXFMT_P_8:
      2	  14992     if(!Read8Bit(info->data, image_file, 
      2	  14993              info->header.small_lod, 
      2	  14994              info->header.large_lod, 
      2	  14995              info->header.aspect_ratio))
      2	  14996        goto _loc1;
      2	  14997     break;
      2	  14998 
      2	  14999   case GR_TEXFMT_RGB_565:
      2	  15000   case GR_TEXFMT_ARGB_8332:
      2	  15001   case GR_TEXFMT_ARGB_1555:
      2	  15002   case GR_TEXFMT_AYIQ_8422:
      2	  15003   case GR_TEXFMT_ARGB_4444:
      2	  15004   case GR_TEXFMT_ALPHA_INTENSITY_88:
      2	  15005   case GR_TEXFMT_AP_88:
      2	  15006     if(!Read16Bit(info->data, image_file, 
      2	  15007               info->header.small_lod,
      2	  15008               info->header.large_lod,
      2	  15009               info->header.aspect_ratio))
      2	  15010         goto _loc1;
      2	  15011     break;
      2	  15012 
      2	  15013   default:
      2	  15014  _loc1:
      2	  15015     fclose(image_file);
      2	  15016     return FXFALSE;
      1	  15017   }
      1	  15018 
      1	  15019   fclose(image_file);
      1	  15020   return FXTRUE;
      1	  15021 }
	  15022 
	  15023 /*
	  15024 ** Read8Bit
	  15025 **
	  15026 ** Read in an 8-bit texture map, unpacked.
	  15027 */
	  15028 static FxBool
	  15029 Read8Bit(FxU8 *data, FILE *image_file, 
	  15030          int small_lod, int large_lod, 
	  15031          GrAspectRatio_t aspect_ratio)
      1	  15032 {
      1	  15033   int lod;
      1	  15034   FxU32 cnt;
      1	  15035 
      2	  15036   for (lod = large_lod; lod <= small_lod; lod++) {
      2	  15037     cnt = (FxU32)_grMipMapHostWH[aspect_ratio][lod][0] *
      2	  15038           (FxU32)_grMipMapHostWH[aspect_ratio][lod][1];
      2	  15039 
      2	  15040     if (fread(data, 1, cnt, image_file) != cnt)
      2	  15041       return FXFALSE;
      2	  15042     data += cnt;
      1	  15043   }
      1	  15044   return FXTRUE;
      1	  15045 }

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

	  15046 
	  15047 /*
	  15048 ** Read16Bit
	  15049 **
	  15050 ** Read in a 16-bit texture map, unpacked.
	  15051 */
	  15052 static FxBool Read16Bit(FxU16 *data, FILE *image_file, 
	  15053                       int small_lod, int large_lod, 
	  15054                       GrAspectRatio_t aspect_ratio)
      1	  15055 {
      1	  15056   FxU32 idx, cnt;
      1	  15057   int lod;
      1	  15058 
      2	  15059   for (lod = large_lod; lod <= small_lod; lod++) {
      2	  15060     cnt = (FxU32)_grMipMapHostWH[aspect_ratio][lod][0] *
      2	  15061           (FxU32)_grMipMapHostWH[aspect_ratio][lod][1];
      2	  15062 
      3	  15063     for (idx = 0; idx < cnt; idx++) {
      3	  15064       if (!ReadDataShort(image_file,data))
      3	  15065         return FXFALSE;
      3	  15066       data++;
      2	  15067     }
      1	  15068   }
      1	  15069   return FXTRUE;
      1	  15070 }
	  15071 
	  15072 /*
	  15073 ** FxU16 ReadDataShort
	  15074 */
	  15075 static FxBool ReadDataShort(FILE *fp, FxU16 *data)
      1	  15076 {
      1	  15077   FxU16 value;
      1	  15078   int b;
      1	  15079 
      1	  15080   /*
      1	  15081   ** read in the MSB
      1	  15082   */
      1	  15083   b = getc (fp);
      1	  15084   if (b == EOF) return FXFALSE;
      1	  15085   value = (FxU16) ((b&0xFF)<<8);
      1	  15086 
      1	  15087   /*
      1	  15088   ** read in the LSB
      1	  15089   */
      1	  15090   b = getc (fp);
      1	  15091   if (b == EOF) return FXFALSE;
      1	  15092   value |= (FxU16) (b & 0x00FF);
      1	  15093 
      1	  15094   *data = value;
      1	  15095   return FXTRUE;
      1	  15096 }
	  15097 
	  15098 /*
	  15099 ** ReadDataLong
	  15100 */
	  15101 static FxBool ReadDataLong(FILE *fp, FxU32 *data)
      1	  15102 {

G3DF                            Source Listing                   9-MAY-2021 23:42:50  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  g3df.c;1

      1	  15103   FxU8 byte[4];
      1	  15104 
      1	  15105   if (fread(byte, 1, 4, fp) != 4)
      1	  15106     return FXFALSE;
      1	  15107 
      1	  15108   *data = (((FxU32) byte[0]) << 24) |
      1	  15109     (((FxU32) byte[1]) << 16) |
      1	  15110     (((FxU32) byte[2]) <<  8) |
      1	  15111     ((FxU32) byte[3]);
      1	  15112 
      1	  15113   return FXTRUE;
      1	  15114 }


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]G3DF/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]G3DF.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]G3DF.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:50"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

	      1 /*
	      2  ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3  ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4  ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5  ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6  ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7  ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8  ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9  ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10  ** 
	     11  ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12  ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13  ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14  ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15  ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16  ** THE UNITED STATES.  
	     17  ** 
	     18  ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19  **
	     20  */
	     21 
	     22 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
	     23 #include <assert.h>
	    653 #include <stdlib.h>
	   2748 #include <stdio.h>
	   3811 #include <3dfx.h>
	   3942 #include <glidesys.h>
	   4074 #define FX_DLL_DEFINITION
	   4075 #include <fxdll.h>
	   4196 //#include <fxmemmap.h>
	   4197 #include "fxpci.h"
	   4460 #include "pcilib.h"
       X   4578 #if (GLIDE_PLATFORM & GLIDE_OS_UNIX)
       X   4579 #include "fxlinux.h"
       X   4580 #elif (GLIDE_PLATFORM & GLIDE_OS_OPENVMS)
	   4581 #include "fxovms.h"
	  28399 #endif
	  28400 
	  28401 /* PRIVATE DATA (within the library) */
	  28402 FxU32   pciVxdVer = 0;
	  28403 FxU32   pciErrorCode = PCI_ERR_NOERR;
	  28404 FxBool  pciLibraryInitialized  = FXFALSE;
	  28405 PciHwcCallbacks pciHwcCallbacks = { 1, NULL, NULL, NULL, NULL, NULL, NULL };
	  28406 
	  28407 const FxPlatformIOProcs* gCurPlatformIO = NULL;
	  28408 
	  28409 /* 
	  28410  * linear Address Map List
	  28411  *
	  28412  * This is the new way we keep track of boards which are already mapped 
	  28413  */
	  28414 static struct {
	  28415   FxU32
	  28416     device_bus_func_number;
	  28417   struct {
	  28418     FxBool
	  28419     mapped;

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

	  28420     unsigned long
	  28421     addr;
	  28422   } addrList[MAX_PCI_BASEADDRESSES];
	  28423 } linearAddressMapList[MAX_PCI_DEVICES];
	  28424 
	  28425 typedef struct _PCIErr {
	  28426   FxU32 code;
	  28427   char *string;
	  28428 } PCIErr, *PCIErrPtr;
	  28429 
	  28430 static PCIErr pciError[] = {
	  28431   {PCI_ERR_NOERR, "No errors.\n"},
	  28432   {PCI_ERR_WINRTINIT, "WinRT initialization failure.\n" },
	  28433   {PCI_ERR_MEMMAPVXD, "Memmap VxD initialization failure.\n" },
	  28434   {PCI_ERR_MAPMEMDRV, "Mapmem driver initialization failure.\n" },
	  28435   {PCI_ERR_GENPORT, "Genport I/O initialization failure.\n" },
	  28436   {PCI_ERR_NO_BUS, "No PCI Bus detected.\n"},
	  28437   {PCI_ERR_NOTOPEN, "PCI library not open.\n" },
	  28438   {PCI_ERR_NOTOPEN2, "Closing unopened PCI library.\n" },
	  28439   {PCI_ERR_NOTOPEN3, "pciGetConfigData() on unopened library.\n" }, 
	  28440   {PCI_ERR_OUTOFRANGE, "Device_number is out of range.\n" },
	  28441   {PCI_ERR_NODEV, "Cannot read from a non-existant device.\n" },
	  28442   {PCI_ERR_NODEV2, "Cannot update config regs from non-existant device.\n" },
	  28443   {PCI_ERR_WRITEONLY, "Cannot read a WRITE_ONLY register.\n" },
	  28444   {PCI_ERR_READONLY, "Cannot write a READ_ONLY register.\n" },
	  28445   {PCI_ERR_PHARLAP, "Phar Lap returned an error trying to map memory.\n" },
	  28446   {PCI_ERR_WRONGVXD, "Expected VxD version V%d.%d, got V%d.%d\n"},
	  28447   {PCI_ERR_MEMMAP, "Memmap returned an error trying to map memory.\n" },
	  28448   {PCI_ERR_MAPMEM, "Mapmem returned an error trying to map memory.\n" },
	  28449   {PCI_ERR_WINRT, "Winrt returned an error trying to map memory.\n" },
	  28450   {PCI_ERR_VXDINUSE, "Mutual exclusion prohibits this\n" },
	  28451   {PCI_ERR_NO_IO_PERM, "Permission denied.\n"
	  28452    "Couldn't change I/O priveledge level.\n"},
	  28453   {PCI_ERR_NO_MEM_PERM, "Permission denied.\n"
	  28454    "Couldn't access memory mapp.\n"}
	  28455 };
	  28456 
	  28457 /* -------------------------------------------------- */
	  28458 /* Port IO subroutines - each layer has it's own      */
	  28459 FX_ENTRY FxU8 FX_CALL
	  28460 pioInByte ( unsigned short port )
      1	  28461 {
      1	  28462   FxU8 data = 0;
      1	  28463 
      1	  28464   if (pciHwcCallbacks.pioInByte)
      1	  28465     data = pciHwcCallbacks.pioInByte(port);
      1	  28466   if (pciHwcCallbacks.doHW)
      1	  28467     data = _pioInByte( port );
      1	  28468   return data;
      1	  28469 }
	  28470 
	  28471 FX_ENTRY FxU16 FX_CALL
	  28472 pioInWord ( unsigned short port )
      1	  28473 {
      1	  28474   FxU16 data = 0;
      1	  28475 
      1	  28476   if (pciHwcCallbacks.pioInWord)

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      1	  28477     data = pciHwcCallbacks.pioInWord(port);
      1	  28478   if (pciHwcCallbacks.doHW)
      1	  28479     data = _pioInWord( port );
      1	  28480   return data;
      1	  28481 }
	  28482 
	  28483 FX_ENTRY FxU32 FX_CALL
	  28484 pioInLong ( unsigned short port )
      1	  28485 {
      1	  28486   FxU32 data = 0;
      1	  28487 
      1	  28488   if (pciHwcCallbacks.pioInLong)
      1	  28489     data = pciHwcCallbacks.pioInLong(port);
      1	  28490   if (pciHwcCallbacks.doHW)
      1	  28491     data = _pioInLong( port );
      1	  28492   return data;
      1	  28493 }
	  28494 
	  28495 FX_ENTRY FxBool FX_CALL
	  28496 pioOutByte ( unsigned short port, FxU8 data )
      1	  28497 {
      1	  28498   if (pciHwcCallbacks.pioOutByte)
      1	  28499     pciHwcCallbacks.pioOutByte(port,data);
      1	  28500   if (pciHwcCallbacks.doHW)
      1	  28501     _pioOutByte( port, data );
      1	  28502   return FXTRUE;
      1	  28503 }
	  28504 
	  28505 FX_ENTRY FxBool FX_CALL
	  28506 pioOutWord ( unsigned short port, FxU16 data )
      1	  28507 {
      1	  28508   if (pciHwcCallbacks.pioOutWord)
      1	  28509     pciHwcCallbacks.pioOutWord(port,data);
      1	  28510   if (pciHwcCallbacks.doHW)
      1	  28511     _pioOutWord( port, data );
      1	  28512   return FXTRUE;
      1	  28513 }
	  28514 
	  28515 FX_ENTRY FxBool FX_CALL
	  28516 pioOutLong ( unsigned short port, FxU32 data )
      1	  28517 {
      1	  28518   if (pciHwcCallbacks.pioOutLong)
      1	  28519     pciHwcCallbacks.pioOutLong(port,data);
      1	  28520   if (pciHwcCallbacks.doHW)
      1	  28521     _pioOutLong( port, data );
      1	  28522   return FXTRUE;
      1	  28523 }
	  28524 
	  28525 static PciRegister    baseAddresses[MAX_PCI_BASEADDRESSES];
	  28526 static FxU32          vendorIDs[MAX_PCI_DEVICES];
	  28527 static FxU32          configMechanism     = 0;
	  28528 static FxBool         busDetected         = FXFALSE;
	  28529 static FxBool         deviceExists[MAX_PCI_DEVICES];
	  28530 
	  28531 /* PRIVATE FUNCTIONS */
	  28532 static FxU32
	  28533 _pciCreateConfigAddress( FxU32 bus_number, FxU32 device_number,  

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

	  28534                          FxU32 function_number, FxU32 register_offset )
      1	  28535 { 
      1	  28536   FxU32 retval = CONFIG_ADDRESS_ENABLE_BIT;
      1	  28537   
      1	  28538   retval |= ( bus_number & 0xFF ) << 16;
      1	  28539   retval |= ( device_number & 0x1F ) << 11;
      1	  28540   retval |= ( function_number & 0x7 ) << 8;
      1	  28541   retval |= ( register_offset & 0xFC );
      1	  28542   return retval;
      1	  28543 } /* _pciCreateConfigAddress */
	  28544 
	  28545 
	  28546 
	  28547 static FxU16 
	  28548 _pciCreateConfigSpaceMapping( FxU32 device_number, FxU32
	  28549                               register_offset )
      1	  28550 {
      1	  28551 
      1	  28552   FxU16 retval = 0;
      1	  28553   retval |= ( device_number & 0xFF ) << 8;
      1	  28554   retval |= ( register_offset & 0xFC );
      1	  28555   retval += CONFIG_MAPPING_OFFSET;
      1	  28556   return retval;
      1	  28557 } /* _pciCreateConfigSpaceMapping */
	  28558 
	  28559 
	  28560 
	  28561 static FxU32 FX_CALL
	  28562 _pciFetchRegister( FxU32 offset, FxU32 size_in_bytes, 
	  28563                    FxU32 device_number, FxU32 config_mechanism  )
      1	  28564 { 
      1	  28565   FxU32 retval;
      1	  28566   FxU32 slot, bus, function;
      1	  28567   
      1	  28568   bus  = (device_number >> 5) & 0xFF;
      1	  28569   slot = device_number & 0x1f;
      1	  28570   function = (device_number >> 13) & 7;
      1	  28571   
      2	  28572   if ( config_mechanism == 1 ) {
      2	  28573     pioOutLong( CONFIG_ADDRESS_PORT, _pciCreateConfigAddress( bus, slot, function, offset ) );
      2	  28574     retval = pioInLong( CONFIG_DATA_PORT );
      2	  28575     retval >>= 8 * ( offset & 0x3 );
      2	  28576   } else {                      /* config mechanism 2 */
      2	  28577     pioOutByte( CONFIG_ADDRESS_PORT, CONFIG_MAPPING_ENABLE_BYTE );
      2	  28578     retval = pioInLong( _pciCreateConfigSpaceMapping( device_number, offset ) ); 
      2	  28579     retval >>= 8 * ( offset & 0x3 );
      2	  28580     pioOutByte( CONFIG_ADDRESS_PORT, CONFIG_MAPPING_DISABLE_BYTE );
      1	  28581   }
      1	  28582   
      2	  28583   switch( size_in_bytes ) {
      2	  28584   case 1:
      2	  28585     retval &= 0xFF;
      2	  28586     break;
      2	  28587   case 2:
      2	  28588     retval &= 0xFFFF;
      2	  28589     break;
      2	  28590   default:                      /* 4 bytes */

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      2	  28591     break;
      1	  28592   }
      1	  28593   
      1	  28594   return retval;
      1	  28595 } /* _pciFetchRegister */
	  28596 
	  28597 
	  28598 
	  28599 static void FX_CALL
	  28600 _pciUpdateRegister( FxU32 offset, FxU32 data, FxU32 size_in_bytes,  
	  28601                     FxU32 device_number, FxU32 config_mechanism  ) 
      1	  28602 {
      1	  28603   FxU32
      1	  28604     regval =  _pciFetchRegister( offset & ( ~0x3 ), 4,
      1	  28605                                  device_number, config_mechanism );
      1	  28606   FxU32 mask = (FxU32) ~0l;
      1	  28607   FxU32 bus, slot, function;
      1	  28608   
      1	  28609   bus  = (device_number >> 5) & 0xff;
      1	  28610   slot = device_number & 0x1f;
      1	  28611   function = (device_number >> 13) & 7;
      1	  28612   
      2	  28613   switch( size_in_bytes ) {
      2	  28614   case 1:
      2	  28615     mask &= 0xFF;
      2	  28616     data &= 0xFF;
      2	  28617     break;
      2	  28618   case 2:
      2	  28619     mask &= 0xFFFF;
      2	  28620     data &= 0xFFFF;
      2	  28621     break;
      2	  28622   case 4:
      2	  28623   default:
      2	  28624     break;
      1	  28625   }
      1	  28626   
      1	  28627   data <<= 8 * ( offset & 0x03 );
      1	  28628   mask <<= 8 * ( offset & 0x03 );
      1	  28629   
      1	  28630   regval = ( regval & ~mask ) | data;
      1	  28631   
      2	  28632   if ( config_mechanism == 1 ) {
      2	  28633     pioOutLong( CONFIG_ADDRESS_PORT, _pciCreateConfigAddress( bus, slot, function, offset ) );
      2	  28634     pioOutLong( CONFIG_DATA_PORT, regval );
      2	  28635   } else {                      /* config mechanism 2 */
      2	  28636     pioOutByte( CONFIG_ADDRESS_PORT, CONFIG_MAPPING_ENABLE_BYTE );
      2	  28637     pioOutLong( _pciCreateConfigSpaceMapping( device_number, offset ), regval );
      2	  28638     pioOutByte( CONFIG_ADDRESS_PORT, CONFIG_MAPPING_DISABLE_BYTE );
      1	  28639   }
      1	  28640   
      1	  28641   return;
      1	  28642 } /* _pciUpdateRegister */
	  28643 
	  28644 static unsigned long
	  28645 find_mapped_address(FxU32 device_bus_func_number, FxU32 addrNum) 
      1	  28646 {
      1	  28647   FxU32 

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      1	  28648     i;
      1	  28649   unsigned long
      1	  28650     retVal = 0x00UL;
      1	  28651 
      2	  28652   for(i = 0; i < MAX_PCI_DEVICES; i++) {
      2	  28653     if ((linearAddressMapList[i].device_bus_func_number == device_bus_func_number) &&
      3	  28654         linearAddressMapList[i].addrList[addrNum].mapped) {
      3	  28655       retVal = linearAddressMapList[i].addrList[addrNum].addr;
      3	  28656 
      3	  28657       break;
      2	  28658     }
      1	  28659   }
      1	  28660 
      1	  28661   return retVal;
      1	  28662 }
	  28663 
	  28664 static void 
	  28665 set_mapped_address(FxU32 device_bus_func_number, FxU32 addrNum, unsigned long value) 
      1	  28666 {
      1	  28667   FxU32 i;
      1	  28668   
      2	  28669   for(i = 0; i < MAX_PCI_DEVICES; i++) {
      3	  28670     if (linearAddressMapList[i].device_bus_func_number == device_bus_func_number) {
      3	  28671       FxU32 j;
      3	  28672 
      3	  28673       linearAddressMapList[i].addrList[addrNum].mapped = (value != 0x00UL);
      3	  28674       linearAddressMapList[i].addrList[addrNum].addr = value;
      3	  28675 
      4	  28676       for(j = 0; j < MAX_PCI_BASEADDRESSES; j++) {
      4	  28677         if (linearAddressMapList[i].addrList[j].mapped) break;
      3	  28678       }
      3	  28679       if (j == MAX_PCI_BASEADDRESSES) linearAddressMapList[i].device_bus_func_number = 0x00UL;
      3	  28680 
      3	  28681       break;
      2	  28682     }
      1	  28683   }
      1	  28684   if (i != MAX_PCI_DEVICES) return;
      1	  28685 
      2	  28686   for(i = 0; i < MAX_PCI_DEVICES; i++) {
      3	  28687     if (linearAddressMapList[i].device_bus_func_number == 0) {
      3	  28688       linearAddressMapList[i].device_bus_func_number = device_bus_func_number;
      3	  28689 
      3	  28690       linearAddressMapList[i].addrList[addrNum].mapped = (value != 0x00UL);
      3	  28691       linearAddressMapList[i].addrList[addrNum].addr = value;
      3	  28692 
      3	  28693       break;
      2	  28694     }
      1	  28695   }
      1	  28696 }
	  28697 
	  28698 /* PUBLIC DATA  */
	  28699 
	  28700 const PciRegister PCI_VENDOR_ID       = { 0x0,  2, READ_ONLY };
	  28701 const PciRegister PCI_DEVICE_ID       = { 0x2,  2, READ_ONLY };
	  28702 const PciRegister PCI_COMMAND         = { 0x4,  2, READ_WRITE };
	  28703 const PciRegister PCI_STATUS          = { 0x6,  2, READ_WRITE };
	  28704 const PciRegister PCI_REVISION_ID     = { 0x8,  1, READ_ONLY };

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

	  28705 const PciRegister PCI_CLASS_CODE      = { 0x9,  3, READ_ONLY };
	  28706 const PciRegister PCI_CACHE_LINE_SIZE = { 0xC,  1, READ_WRITE };
	  28707 const PciRegister PCI_LATENCY_TIMER   = { 0xD,  1, READ_WRITE };
	  28708 const PciRegister PCI_HEADER_TYPE     = { 0xE,  1, READ_ONLY };
	  28709 const PciRegister PCI_BIST            = { 0xF,  1, READ_WRITE };
	  28710 const PciRegister PCI_BASE_ADDRESS_0  = { 0x10, 4, READ_WRITE };
	  28711 const PciRegister PCI_BASE_ADDRESS_1  = { 0x14, 4, READ_WRITE };
	  28712 const PciRegister PCI_IO_BASE_ADDRESS = { 0x18, 4, READ_WRITE };
	  28713 const PciRegister PCI_SUBVENDOR_ID    = { 0x2C, 4, READ_ONLY };
	  28714 const PciRegister PCI_SUBSYSTEM_ID    = { 0x2E, 4, READ_ONLY };
	  28715 const PciRegister PCI_ROM_BASE_ADDRESS= { 0x30, 4, READ_WRITE };
	  28716 const PciRegister PCI_CAP_PTR         = { 0x34, 4, READ_WRITE };
	  28717 const PciRegister PCI_INTERRUPT_LINE  = { 0x3C, 1, READ_WRITE };
	  28718 const PciRegister PCI_INTERRUPT_PIN   = { 0x3D, 1, READ_ONLY };
	  28719 const PciRegister PCI_MIN_GNT         = { 0x3E, 1, READ_ONLY };
	  28720 const PciRegister PCI_MAX_LAT         = { 0x3F, 1, READ_ONLY };
	  28721 const PciRegister PCI_FAB_ID          = { 0x40, 1, READ_ONLY };
	  28722 const PciRegister PCI_CONFIG_STATUS   = { 0x4C, 4, READ_WRITE };
	  28723 const PciRegister PCI_CONFIG_SCRATCH  = { 0x50, 4, READ_WRITE };
	  28724 const PciRegister PCI_AGP_CAP_ID      = { 0x54, 4, READ_ONLY };
	  28725 const PciRegister PCI_AGP_STATUS      = { 0x58, 4, READ_ONLY };
	  28726 const PciRegister PCI_AGP_CMD         = { 0x5C, 4, READ_WRITE };
	  28727 const PciRegister PCI_ACPI_CAP_ID     = { 0x60, 4, READ_ONLY };
	  28728 const PciRegister PCI_CNTRL_STATUS    = { 0x64, 4, READ_WRITE };
	  28729 
	  28730 /* sst1 definitions left in for compatability */
	  28731 const PciRegister PCI_SST1_INIT_ENABLE = { 0x40, 4, READ_WRITE }; 
	  28732 const PciRegister PCI_SST1_BUS_SNOOP_0 = { 0x44, 4, READ_WRITE }; 
	  28733 const PciRegister PCI_SST1_BUS_SNOOP_1 = { 0x48, 4, READ_WRITE }; 
	  28734 const PciRegister PCI_SST1_CFG_STATUS  = { 0x4C, 4, READ_WRITE };
	  28735 
	  28736 /* PUBLIC FUNCTIONS */
	  28737 #define   FX_MAJOR_VER          1
	  28738 #define   FX_MINOR_VER          4
	  28739 
	  28740 FX_ENTRY const char * FX_CALL
	  28741 pciGetErrorString( void )
      1	  28742 {
      1	  28743   static char vxdErrString[120];
      2	  28744   if (pciErrorCode == PCI_ERR_WRONGVXD) {
      2	  28745     sprintf(vxdErrString, "Expected VXD version V%d.%d, got V%u.%u\n",
      2	  28746             FX_MAJOR_VER, FX_MINOR_VER,
      2	  28747             (unsigned) BYTE1(pciVxdVer), (unsigned) BYTE0(pciVxdVer));
      2	  28748     return vxdErrString;
      1	  28749   }
      1	  28750   return pciError[pciErrorCode].string;
      1	  28751 } /* pciGetErrorString */
	  28752 
	  28753 
	  28754 
	  28755 FX_ENTRY FxU32 FX_CALL
	  28756 pciGetErrorCode( void )
      1	  28757 {
      1	  28758   return pciError[pciErrorCode].code;
      1	  28759 } /* pciGetErrorCode */
	  28760 
	  28761 

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

	  28762 FX_EXPORT FxBool FX_CSTYLE
	  28763 pciOpenEx( PciHwcCallbacks *cb )
      1	  28764 {
      1	  28765   pciHwcCallbacks = *cb;
      1	  28766   return pciOpen();
      1	  28767 }
	  28768 
	  28769 // internal routine for scanning the PCI bus the first time during a pciOpen
	  28770 static void
	  28771 sampleVendorID(int deviceNumber, int configMode)
      1	  28772 {
      1	  28773   FxU32 regVal;
      1	  28774 
      1	  28775   // set the global mode: this routine is used to determine which mode works
      1	  28776   configMechanism = configMode;
      1	  28777   regVal = _pciFetchRegister( PCI_VENDOR_ID.regAddress,
      1	  28778                               PCI_VENDOR_ID.sizeInBytes, 
      1	  28779                               deviceNumber, configMode );
      1	  28780   regVal &= 0xFFFF;
      1	  28781 
      2	  28782   if ( regVal != 0xFFFF ) {
      2	  28783     busDetected = FXTRUE;
      2	  28784     vendorIDs[deviceNumber] = regVal;
      2	  28785   } else {
      2	  28786     vendorIDs[deviceNumber] = 0;
      1	  28787   }
      1	  28788 }
	  28789 
       X  28790 #ifdef __linux__
       X  28791 FxBool
       X  28792 pciOpenLinux(void)
       X  28793 {
       X  28794   int numDevices, deviceNumber;
       X  28795 
       X  28796   numDevices=getNumDevicesLinux();
       X  28797   for (deviceNumber=0; deviceNumber < MAX_PCI_DEVICES; deviceNumber++) {
       X  28798     if (deviceNumber<numDevices) {
       X  28799       busDetected=FXTRUE;
       X  28800       configMechanism=1;
       X  28801       deviceExists[deviceNumber] = FXTRUE;
       X  28802       vendorIDs[deviceNumber] = 0x121a;
       X  28803     }
       X  28804     else deviceExists[deviceNumber] = FXFALSE;
       X  28805   }
       X  28806   if (numDevices) {
       X  28807     pciLibraryInitialized=FXTRUE;
       X  28808   } else {
       X  28809     pciLibraryInitialized=FXFALSE;
       X  28810   }      
       X  28811   return pciLibraryInitialized;
       X  28812 }
       X  28813 #endif /* defined(__linux__) */
	  28814 
	  28815 FX_EXPORT FxBool FX_CSTYLE
	  28816 pciOpen( void )
      1	  28817 {
      1	  28818   int deviceNumber;

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      1	  28819   
      1	  28820   if ( pciLibraryInitialized ) return FXTRUE;
      1	  28821   
      1	  28822   baseAddresses[0] = PCI_BASE_ADDRESS_0;
      1	  28823   baseAddresses[1] = PCI_BASE_ADDRESS_1;
      1	  28824   baseAddresses[2] = PCI_IO_BASE_ADDRESS;
      1	  28825   baseAddresses[3] = PCI_ROM_BASE_ADDRESS;
      1	  28826   
      1	  28827   busDetected = FXFALSE;
      2	  28828   if (pciHwcCallbacks.doHW) {
      2	  28829     if (!pciPlatformInit() ||
      2	  28830         (gCurPlatformIO == NULL) ||
      2	  28831         !pciInitializeDDio()) return FXFALSE;
      1	  28832   }
      1	  28833   /*
      1	  28834   **      Scan All PCI device numbers
      1	  28835   */ 
      1	  28836 
      1X  28837 #ifdef __linux__
      1X  28838   if (hasDev3DfxLinux()) return pciOpenLinux();
      1X  28839 #endif /* defined(__linux__) */
      1	  28840 
      1	  28841   
      2	  28842   for ( deviceNumber = 0; deviceNumber < MAX_PCI_DEVICES; deviceNumber++ ) {
      2	  28843     FxU32 regVal;
      2	  28844     FxU32 slot;
      2	  28845     FxU32 bus;
      2	  28846         
      2	  28847     sampleVendorID(deviceNumber,1);
      2	  28848 
      2	  28849     bus =   (deviceNumber >> 5) & 0xFF;
      2	  28850     slot = (deviceNumber & 0x1f);
      2	  28851 
      2	  28852     pioOutLong( CONFIG_ADDRESS_PORT, 
      2	  28853                 _pciCreateConfigAddress( bus, slot, 0x0, 0x0 ) );
      2	  28854     regVal = pioInLong( CONFIG_DATA_PORT );
      2	  28855 
      3	  28856     if ( ( regVal & 0xFFFF ) != 0xFFFF ) {
      3	  28857       busDetected = FXTRUE;
      3	  28858       configMechanism = 1;
      3	  28859       deviceExists[deviceNumber] = FXTRUE;
      3	  28860       vendorIDs[deviceNumber] = regVal & 0xffff;
      3	  28861     } else {
      3	  28862       deviceExists[deviceNumber] = FXFALSE;
      2	  28863     }
      2	  28864 
      1	  28865   }
      1	  28866   
      2	  28867   if ( !busDetected )  { 
      2	  28868     /* Try Configuration Mechanism 2 (only 16 devices) */
      2	  28869     /* Since Configuration Mech#2 is obsolete this does not
      2	  28870        support multiple busses */
      2	  28871 
      2	  28872     assert(0); //This stuff looks scary and probably shouldn't be used
      2	  28873 
      3	  28874     for ( deviceNumber = 0; deviceNumber < 16; deviceNumber++ ) {
      3	  28875       sampleVendorID(deviceNumber,2);

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      2	  28876     }
      1	  28877   }
      1	  28878   
      2	  28879   if ( busDetected ) {
      2	  28880     pciLibraryInitialized = FXTRUE;
      2	  28881   } else {
      2	  28882     pciErrorCode = PCI_ERR_NO_BUS;
      2	  28883     return FXFALSE;
      1	  28884   }    
      1	  28885   
      1	  28886   return FXTRUE;
      1	  28887 } /* pciOpen */
	  28888 
	  28889 FX_EXPORT FxBool FX_CSTYLE
	  28890 pciClose( void )
      1	  28891 {
      2	  28892   if ( !pciLibraryInitialized ) {
      2	  28893     pciErrorCode = PCI_ERR_NOTOPEN2;
      2	  28894     return FXFALSE;
      1	  28895   }
      1	  28896   pciLibraryInitialized = FXFALSE;
      1	  28897 
      1	  28898   return pciCloseDDio();
      1	  28899 }
	  28900 
	  28901 
	  28902 FX_EXPORT FxBool FX_CSTYLE
      1	  28903 pciDeviceExists( FxU32 device_number ) {
      2	  28904   if ( !pciLibraryInitialized ) {
      2	  28905     pciErrorCode = PCI_ERR_NOTOPEN;
      2	  28906     return FXFALSE;
      1	  28907   }
      1	  28908   if ( device_number >= MAX_PCI_DEVICES ) return FXFALSE;
      1	  28909   return vendorIDs[device_number];
      1	  28910 } /* pciDeviceExists */
	  28911 
	  28912 
	  28913 
	  28914 FX_EXPORT FxBool FX_CSTYLE
	  28915 pciGetConfigData( PciRegister reg, FxU32 device_bus_func_number, FxU32 *data ) 
      1	  28916 {
      1	  28917   int device_number = (device_bus_func_number) & 0xFFF;
      1	  28918   
      2	  28919   if ( !pciLibraryInitialized ) {
      2	  28920     pciErrorCode = PCI_ERR_NOTOPEN3;
      2	  28921     return FXFALSE;
      1	  28922   }
      2	  28923   if ( device_number >= MAX_PCI_DEVICES ) {
      2	  28924     pciErrorCode = PCI_ERR_OUTOFRANGE;
      2	  28925     return FXFALSE;
      1	  28926   }
      1	  28927   
      2	  28928   if ( !vendorIDs[device_number] ) {
      2	  28929     pciErrorCode = PCI_ERR_NODEV;
      2	  28930     return FXFALSE;
      1	  28931   }
      1	  28932   

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      2	  28933   if ( reg.rwFlag == WRITE_ONLY ) {
      2	  28934     pciErrorCode = PCI_ERR_WRITEONLY;
      2	  28935     return FXFALSE;
      1	  28936   }
      1	  28937 
      1X  28938 #ifdef __linux__  
      1X  28939   if (hasDev3DfxLinux()) {
      1X  28940     *data = pciFetchRegisterLinux(reg.regAddress, reg.sizeInBytes,
      1X  28941 				  device_bus_func_number);
      1X  28942     return FXTRUE;
      1X  28943   }
      1X  28944 #endif
      1	  28945   *data = _pciFetchRegister( reg.regAddress, reg.sizeInBytes,
      1	  28946                              device_bus_func_number, configMechanism );
      1	  28947   
      1	  28948   return FXTRUE;
      1	  28949 } /* pciGetConfigData */
	  28950 
	  28951 
	  28952 
	  28953 FX_EXPORT FxBool FX_CSTYLE
	  28954 pciSetConfigData( PciRegister reg, FxU32 device_bus_func_number, FxU32 *data ) 
      1	  28955 {
      1	  28956   int device_number = (device_bus_func_number) & 0xFFF;
      1	  28957   
      2	  28958   if ( !pciLibraryInitialized ) {
      2	  28959     pciErrorCode = PCI_ERR_NOTOPEN3;
      2	  28960     return FXFALSE;
      1	  28961   }
      2	  28962   if ( device_number >= MAX_PCI_DEVICES ) {
      2	  28963     pciErrorCode = PCI_ERR_OUTOFRANGE;
      2	  28964     return FXFALSE;
      1	  28965   }
      1	  28966   
      2	  28967   if ( !vendorIDs[device_number] ) {
      2	  28968     pciErrorCode = PCI_ERR_NODEV2;
      2	  28969     return FXFALSE;
      1	  28970   }       
      1	  28971   
      2	  28972   if ( reg.rwFlag == READ_ONLY ) {
      2	  28973     pciErrorCode = PCI_ERR_READONLY;
      2	  28974     return FXFALSE;
      1	  28975   }
      1	  28976 
      1	  28977   /*
      1	  28978    * NOTE: This should really be this way, at least for now.
      1	  28979    *
      1	  28980    * Changing this to return the value returned by 
      1	  28981    * pciUpdateRegisterLinux breaks sst1.
      1	  28982    */
      1X  28983 #ifdef __linux__
      1X  28984   if (hasDev3DfxLinux()) {
      1X  28985     pciUpdateRegisterLinux( reg.regAddress, *data, reg.sizeInBytes,
      1X  28986 			    device_bus_func_number);
      1X  28987     
      1X  28988     return FXTRUE;
      1X  28989   }

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      1X  28990 #endif
      1	  28991   _pciUpdateRegister( reg.regAddress, *data, reg.sizeInBytes,
      1	  28992                       device_bus_func_number, configMechanism );
      1	  28993   
      1	  28994   return FXTRUE;
      1	  28995 } /* pciSetConfigData */
	  28996 
	  28997 
	  28998 FX_EXPORT FxBool FX_CSTYLE
	  28999 pciFindCardMulti(FxU32 vendorID, FxU32 deviceID, 
	  29000                  FxU32 *devNum, FxU32 cardNum) 
      1	  29001 {
      1	  29002   FxU32 deviceNumber;
      1	  29003   
      1	  29004   /*      1) open the PCI device and scan it for devices */
      1	  29005   if (!pciOpen()) return FXFALSE;
      1	  29006   
      1	  29007   /*      2) scan the existing devices for a match */
      2	  29008   for ( deviceNumber = 0; deviceNumber < MAX_PCI_DEVICES; deviceNumber++ ) {
      3	  29009     if (pciDeviceExists(deviceNumber)) {
      3	  29010       FxU32 
      3	  29011         vID, dID;
      3	  29012       FxBool
      3	  29013         matchP = FXFALSE;
      3	  29014 
      3	  29015       pciGetConfigData( PCI_VENDOR_ID, deviceNumber, &vID );
      3	  29016       pciGetConfigData( PCI_DEVICE_ID, deviceNumber, &dID );
      3	  29017 
      3	  29018       /* Quick optimization, if there is no device or vendor ID... */
      3	  29019       if ((!dID) || (!vID))
      3	  29020 	  continue;
      3	  29021 
      3	  29022       if (deviceID == 0xFFFF)   /* if special value */
      3	  29023         dID = deviceID;         /* then force a match */
      3	  29024 
      3	  29025       matchP = ((vID == vendorID) && (dID == deviceID));
      4	  29026       if (matchP) {
      5	  29027         if (cardNum == 0) {
      5	  29028           *devNum = deviceNumber;
      5	  29029           return FXTRUE;
      4	  29030         }
      3	  29031       }
      3	  29032 
      3	  29033       /* single board SLI hack! - jeske */
      4	  29034       if ((vID == _3DFX_PCI_ID) && (dID == 0x0002)) {
      4	  29035         pciGetConfigData( PCI_VENDOR_ID, deviceNumber | (1 << 13), &vID);
      4	  29036         pciGetConfigData( PCI_DEVICE_ID, deviceNumber | (1 << 13), &dID);
      4	  29037         
      5	  29038         if ((vID == vendorID) && (dID == deviceID)) {
      5	  29039           matchP = FXTRUE;
      6	  29040           if (cardNum == 0) {
      6	  29041             *devNum = deviceNumber | (1 << 13); /* stuff in function 1 */
      6	  29042             return FXTRUE;
      5	  29043           }
      4	  29044         }
      3	  29045       }
      3	  29046       /* end of single board SLI hack! - jeske */

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      3	  29047 
      3	  29048       if (matchP) cardNum--;
      2	  29049     }
      1	  29050   }
      1	  29051   return FXFALSE;         /* didn't find the card, return false */
      1	  29052 } /* pciFindCardMulti */
	  29053 
	  29054 
	  29055 
	  29056 FX_EXPORT FxBool FX_CSTYLE
      1	  29057 pciFindCard(FxU32 vendorID, FxU32 deviceID, FxU32 *devNum) {
      1	  29058   return pciFindCardMulti(vendorID, deviceID, devNum, 0);
      1	  29059 } /* pciFindCard */
	  29060 
	  29061 
	  29062 
	  29063 /*----------------------------------------------------------------------
	  29064   find and map a PCI card into virtual memory using the following 4
	  29065   steps: 
	  29066       1) open the PCI device and scan it for devices 
	  29067       2) scan the existing devices for a vendorId, deviceId, cardNum match
	  29068       3) find the current physcial address of the card
	  29069       4) map the physical memory to virtual memory
	  29070       ----------------------------------------------------------------------*/
	  29071 FX_EXPORT FxU32 * FX_CSTYLE
	  29072 pciMapCardMulti(FxU32 vendorID, FxU32 deviceID, 
	  29073                 FxI32 length, 
	  29074                 FxU32 *devNum,
	  29075                 FxU32 cardNum, FxU32 addressNum)
      1	  29076 {
      1	  29077   FxU32 physAddress;
      1	  29078   unsigned long virtAddress;
      1	  29079   
      1	  29080   /* 1) open the PCI device and scan it for devices
      1	  29081    * 2) scan the existing devices for a match
      1	  29082    */
      1	  29083   if (!pciFindCardMulti(vendorID, deviceID, devNum, cardNum)) return NULL;
      1	  29084   if (addressNum > MAX_PCI_BASEADDRESSES) return NULL;
      1	  29085 
      1	  29086   /* 3) find the current physcial address of the card */
      1	  29087   pciGetConfigData( baseAddresses[addressNum], *devNum, &physAddress );
      1	  29088   if (length <= 0) return (FxU32*)(long)length;
      1	  29089 
      1	  29090   /* Mask the memory type information bits off.
      1	  29091    *   [0]: Memory type indicator (0 memory/1 i/o)
      1	  29092    *  [12]: Type
      1	  29093    *    00: 32 bits wide and mapable anywhere
      1	  29094    *    01: 32 bits wide, mapped < 1meg
      1	  29095    *    10: 64 bits wide and mappable anywhere
      1	  29096    *    11: reserved
      1	  29097    *   [3]: Prefetcable
      1	  29098    */
      1	  29099   physAddress &= ~0xF;
      1	  29100 
      1	  29101   /* 4) have we mapped this device before? */
      1	  29102   virtAddress = find_mapped_address(*devNum, addressNum);
      2	  29103   if (virtAddress == 0x00UL) {

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      2	  29104     /* 5) map the physical memory to virtual memory 
      2	  29105      *
      2	  29106      * NB: Some systems (notably nt) require a bus # in addition to the
      2	  29107      * physical address in order to map a device. pciMapPhysicalToLinear
      2	  29108      * has an implicit bus0 which works most of the time, but fails
      2	  29109      * across pci bridges and to agp devices. Anyway, recall that the
      2	  29110      * deviceNumber is a tuple w/ the following internal structure:
      2	  29111      *
      2	  29112      *   device_number[0:4]   = slot
      2	  29113      *   device_number[5:12]  = bus
      2	  29114      *   device_number[13:15] = function 
      2	  29115      */
      2	  29116     if (!pciMapPhysicalDeviceToLinear(&virtAddress, 
      2	  29117                                       ((*devNum >> 5UL) & 0xFFUL), physAddress,                                     
      3	  29118                                       (FxU32*) &length)) {
      3	  29119       
      3	  29120       virtAddress = 0x00UL;
      2	  29121     }
      2	  29122     set_mapped_address(*devNum, addressNum, virtAddress);
      1	  29123   }
      1	  29124 
      1	  29125   return (FxU32*)virtAddress;
      1	  29126 } /* pciMapCardMulti */
	  29127 
	  29128 
	  29129 FX_EXPORT FxU32 * FX_CSTYLE
	  29130 pciMapCard(FxU32 vendorID, FxU32 deviceID,
	  29131            FxI32 length, FxU32 *devNum, FxU32 addressNum)
      1	  29132 {
      1	  29133   return pciMapCardMulti(vendorID, deviceID, length, devNum, 0, addressNum);
      1	  29134 } /* pciMapCard */
	  29135 
	  29136 FX_EXPORT FxBool FX_CSTYLE
	  29137 pciMapPhysicalToLinear( unsigned long *linear_addr, FxU32 physical_addr,
	  29138                         FxU32 *length ) 
      1	  29139 { 
      1	  29140   return pciMapPhysicalDeviceToLinear(linear_addr, 
      1	  29141                                       0x00UL, physical_addr,
      1	  29142                                       length);
      1	  29143 } /* pciMapPhysicalToLinear */
	  29144 
	  29145 FX_ENTRY FxBool FX_CALL 
	  29146 pciMapPhysicalDeviceToLinear(unsigned long *linear_addr, 
	  29147                              FxU32 busNumber, FxU32 physical_addr,
	  29148                              FxU32 *length)
      1	  29149 {
      1	  29150   return pciMapLinearDD(busNumber, physical_addr,
      1	  29151                         linear_addr, length);
      1	  29152 }
	  29153 
	  29154 
	  29155 FX_EXPORT void FX_CSTYLE
	  29156 pciUnmapPhysical( unsigned long linear_addr, FxU32 length ) 
      1	  29157 {
      1	  29158   int i,j;
      1	  29159   
      2	  29160   for (i = 0; i < MAX_PCI_DEVICES; i++) {

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

      3	  29161     for (j = 0; j < MAX_PCI_BASEADDRESSES; j++) {
      4	  29162       if(linearAddressMapList[i].addrList[j].addr == linear_addr) { 
      4	  29163         linearAddressMapList[i].addrList[j].addr = 0x00UL;
      4	  29164         linearAddressMapList[i].addrList[j].mapped = FXFALSE;
      4	  29165 
      4	  29166         break;
      3	  29167       }
      2	  29168     }
      1	  29169   }
      1	  29170 
      1	  29171   if (i != MAX_PCI_DEVICES) pciUnmapLinearDD(linear_addr, length);
      1	  29172 }
	  29173 
	  29174 FX_EXPORT FxBool FX_CSTYLE
	  29175 pciSetPassThroughBase(FxU32* baseAddr, FxU32 baseAddrLen)
      1	  29176 {
      1	  29177   FxBool retVal;
      1	  29178 
      2	  29179   if (pciLibraryInitialized) {
      2	  29180     retVal = pciSetPassThroughBaseDD(baseAddr, baseAddrLen);
      2	  29181   } else {
      2	  29182     pciErrorCode = PCI_ERR_NOTOPEN;
      2	  29183     retVal = FXFALSE;
      1	  29184   }
      1	  29185 
      1	  29186   return retVal;
      1	  29187 }
	  29188 
	  29189 FX_EXPORT FxBool FX_CSTYLE
	  29190 pciOutputDebugString(const char* msg)
      1	  29191 {
      1	  29192   return pciOutputDebugStringDD(msg);
      1	  29193 }
	  29194 
	  29195 FX_EXPORT FxBool FX_CSTYLE
	  29196 pciLinearRangeSetPermission(const unsigned long addrBase, const FxU32 addrLen, const FxBool writeableP)
      1	  29197 {
      1	  29198   return pciLinearRangeSetPermissionDD(addrBase, addrLen, writeableP);
      1	  29199 }


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.SWLIBS.NEWPCI.PCILIB]FXPCI/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.SWLIBS.NEWPCI.PCILIB]FXPCI.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.SWLIBS.NEWPCI.PCILIB]FXPCI.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 

FXPCI                           Source Listing                   9-MAY-2021 23:43:30  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             9-MAY-2021 05:04:25  fxpci.c;4

 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:31"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


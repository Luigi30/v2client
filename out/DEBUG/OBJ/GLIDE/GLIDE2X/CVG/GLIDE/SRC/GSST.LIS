GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.2.2.4  2005/01/22 14:52:02  koolsmoky
	     21 ** enabled packed argb for cmd packet type 3
	     22 **
	     23 ** Revision 1.2.2.3  2005/01/13 16:09:06  koolsmoky
	     24 ** Restict calls to pciOpen() pciClose() when compiled with DIRECTX option. this fixes problems with the win32 minip
	     24 ort opened in exclusive mode.
	     25 **
	     26 ** Revision 1.2.2.2  2004/12/23 20:45:56  koolsmoky
	     27 ** converted to nasm syntax
	     28 ** added x86 asm, 3dnow! triangle and mmx, 3dnow! texture download optimizations
	     29 **
	     30 ** Revision 1.2.2.1  2004/12/12 15:26:04  koolsmoky
	     31 ** changes to support new cpuid
	     32 **
	     33 ** Revision 1.2  2000/10/03 18:28:33  mercury
	     34 ** 003-clean_up_cvg-000, cvg tree cleanup.
	     35 **
	     36 ** Revision 1.1.1.1  1999/12/07 21:49:11  joseph
	     37 ** Initial checkin into SourceForge.
	     38 **
	     39 ** 
	     40 ** 168   6/30/98 6:08p Jeske
	     41 ** fixed bug where we tried to setup MTRRs on old (<p6) systems which
	     42 ** didn't have them. 
	     43 ** 
	     44 ** 167   6/25/98 10:40a Peter
	     45 ** more cb checks
	     46 ** 
	     47 ** 166   6/23/98 5:38p Peter
	     48 ** lfb hinting
	     49 ** 
	     50 ** 165   6/04/98 12:13p Peter
	     51 ** splash dll rename
	     52 ** 
	     53 ** 164   5/20/98 4:37p Peter
	     54 ** doh
	     55 ** 
	     56 ** 163   5/20/98 3:51p Peter

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	     57 ** no fifo glide
	     58 ** 
	     59 ** 162   5/18/98 12:16p Peter
	     60 ** culling enabling
	     61 ** 
	     62 ** 161   4/29/98 3:05p Peter
	     63 ** triple buffering vs grLfbReadRegion
	     64 ** 
	     65 ** 160   4/21/98 5:53p Peter
	     66 ** slidetect vs hw pointers
	     67 ** 
	     68 ** 159   4/09/98 5:24p Peter
	     69 ** properly re-cache the hw base addresses after a re-init just in case
	     70 ** the base addresses changed
	     71 ** 
	     72 ** 158   4/08/98 3:53p Peter
	     73 ** allow different base addresses
	     74 ** 
	     75 ** 157   4/06/98 9:55a Peter
	     76 ** sli slave detection for oem dll
	     77 ** 
	     78 ** 156   4/01/98 1:52p Peter
	     79 ** sli origin thing vs grRenderBuffer/synced state when doing dynamic
	     80 ** loading of the glide dll on sli
	     81 ** 
	     82 ** 155   3/31/98 6:09p Peter
	     83 ** sli origin everywhere (I think) and grLfbReadRegion/grRenderBuffer vs
	     84 ** triple buffering
	     85 ** 
	     86 ** 154   3/30/98 2:45p Peter
	     87 ** update default gamma
	     88 ** 
	     89 ** 153   3/29/98 1:07p Peter
	     90 ** yet another sli origin thing
	     91 ** 
	     92 ** 152   3/23/98 5:57p Peter
	     93 ** warning cleanup
	     94 ** 
	     95 ** 151   3/20/98 12:45p Atai
	     96 ** added strapping register in oem boardid field
	     97 ** 
	     98 ** 150   3/20/98 11:01a Peter
	     99 ** sli swap interval thing
	    100 ** 
	    101 ** 149   3/18/98 7:25p Peter
	    102 ** doh! checked in experiment again
	    103 ** 
	    104 ** 148   3/18/98 3:04p Peter
	    105 ** cleaner origin swapping hacks
	    106 ** 
	    107 ** 147   3/17/98 6:50p Peter
	    108 ** sli paired vs active
	    109 ** 
	    110 ** 146   3/17/98 1:57p Atai
	    111 ** added boardid and requireoemdll registry
	    112 ** 
	    113 ** 145   3/14/98 1:07p Peter

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	    114 ** mac port happiness
	    115 ** 
	    116 ** 144   3/13/98 2:57p Atai
	    117 ** update grSstWinOpen to detect tv connection
	    118 ** 
	    119 ** 143   3/13/98 1:27p Peter
	    120 ** removed legacy variables
	    121 ** 
	    122 ** 142   3/10/98 9:20a Peter
	    123 ** fixed checkin
	    124 ** 
	    125 ** 141   3/09/98 2:24p Peter
	    126 ** change for new pci passthrough interface
	    127 ** 
	    128 ** 140   3/03/98 9:37p Peter
	    129 ** more sli origin fun
	    130 ** 
	    131 ** 139   3/02/98 7:23p Peter
	    132 ** clear slop on sli systems when changing y origin
	    133 ** 
	    134 ** 138   2/24/98 10:15a Peter
	    135 ** oem dll muckage
	    136 ** 
	    137 ** 137   2/23/98 7:32p Atai
	    138 ** modify for oem dll
	    139 ** 
	    140 ** 136   2/20/98 2:16p Peter
	    141 ** correct error message when failing video init
	    142 ** 
	    143 ** 135   2/20/98 11:00a Peter
	    144 ** removed glide3 from glid2 tree
	    145 ** 
	    146 ** 134   2/20/98 9:05a Peter
	    147 ** removed remnants of comdex grot
	    148 ** 
	    149 ** 133   2/19/98 5:10p Peter
	    150 ** moved passthrough stuff into glide
	    151 ** 
	    152 ** 132   2/19/98 3:16p Peter
	    153 ** changes for initVideobuffers
	    154 ** 
	    155 ** 131   2/17/98 12:39p Peter
	    156 ** sli monitor detect thing
	    157 ** 
	    158 ** 130   2/12/98 9:42p Peter
	    159 ** fixed typo
	    160 ** 
	    161 ** 129   2/12/98 8:20p Pgj
	    162 ** 
	    163 ** 128   2/12/98 6:47p Atai
	    164 ** fix typo
	    165 ** 
	    166 ** 127   2/12/98 4:01p Atai
	    167 ** change refresh rate if oemdll updated for tv out
	    168 ** 
	    169 ** 126   2/12/98 3:40p Peter
	    170 ** single buffering for opengl

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	    171 ** 
	    172 ** 125   2/11/98 5:25p Peter
	    173 ** properly turn off caching
	    174 ** 
	    175 ** 124   2/10/98 4:45p Pgj
	    176 ** don't require fxoem2x..dll
	    177 ** 
	    178 ** 123   2/04/98 9:21p Pgj
	    179 ** don't require fxoem2x.dll for static builds
	    180 ** 
	    181 ** 122   2/04/98 7:56p Pgj
	    182 ** DOS sanity
	    183 ** 
	    184 ** 121   2/04/98 6:57p Atai
	    185 ** added fxoem2x.dll for cvg
	    186 ** 
	    187 ** 120   2/02/98 4:41p Peter
	    188 ** 
	    189 ** 119   1/30/98 4:23p Peter
	    190 ** renamed curSwapBuf->curRenderBuf for clarity
	    191 ** 
	    192 ** 118   1/24/98 12:29p Peter
	    193 ** more caching fun
	    194 ** 
	    195 ** 117   1/20/98 11:03a Peter
	    196 ** env var to force triple buffering
	    197  * 
	    198  * 116   1/16/98 4:18p Atai
	    199  * fixed lfb and grLoadGammaTable
	    200  * 
	    201  * 115   1/16/98 10:47a Peter
	    202  * fixed idle muckage
	    203  * 
	    204  * 114   1/16/98 10:16a Atai
	    205  * fixed grSstIldle
	    206  * 
	    207  * 113   1/10/98 4:01p Atai
	    208  * inititialize vertex layout, viewport, added defines
	    209  * 
	    210  * 110   1/06/98 6:47p Atai
	    211  * undo grSplash and remove gu routines
	    212  * 
	    213  * 109   1/06/98 3:53p Atai
	    214  * remove grHint, modify grLfbWriteRegion and grGet
	    215  * 
	    216  * 107   12/18/97 2:12p Peter
	    217  * grSstControl on v2
	    218  * 
	    219  * 106   12/17/97 4:48p Peter
	    220  * groundwork for CrybabyGlide
	    221  * 
	    222  * 105   12/17/97 4:06p Atai
	    223  * added grChromaRange(), grGammaCorrecionRGB(), grRest(), and grGet()
	    224  * functions
	    225  * 
	    226  * 104   12/16/97 1:33p Atai
	    227  * added grGammaCorrectionRGB()

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	    228  * 
	    229  * 103   12/16/97 10:03a Atai
	    230  * fixed gutexmemreset for glide2
	    231  * 
	    232  * 101   12/09/97 12:20p Peter
	    233  * mac glide port
	    234  * 
	    235  * 100   12/05/97 4:26p Peter
	    236  * watcom warnings
	    237  * 
	    238  * 99    12/03/97 11:35a Peter
	    239  * is busy thing
	    240  * 
	    241  * 98    11/25/97 12:09p Peter
	    242  * nested calls to grLfbLock vs init code locking on v2
	    243  * 
	    244  * 97    11/21/97 1:02p Peter
	    245  * v^2 supported resolutions
	    246  * 
	    247  * 96    11/21/97 11:19a Dow
	    248  * Added RESOLUTION_NONE hack for Banshee
	    249  * 
	    250  * 95    11/19/97 2:49p Peter
	    251  * env vars in registry for win32
	    252  * 
	    253  * 94    11/19/97 2:22p Dow
	    254  * gsst.c
	    255  * 
	    256  * 93    11/18/97 4:50p Peter
	    257  * chipfield stuff cleanup and w/ direct writes
	    258  * 
	    259  * 92    11/18/97 4:00p Atai
	    260  * fixed the GR_BEGIN and GR_END error in previous check-in
	    261  * 
	    262  * 91    11/18/97 3:27p Atai
	    263  * update vData 
	    264  * optimize state monster
	    265  * 
	    266  * 90    11/17/97 4:55p Peter
	    267  * watcom warnings/chipfield stuff
	    268  * 
	    269  * 89    11/16/97 2:20p Peter
	    270  * cleanup
	    271  * 
	    272  * 88    11/15/97 7:43p Peter
	    273  * more comdex silliness
	    274  * 
	    275  * 87    11/14/97 11:10p Peter
	    276  * open vs hw init confusion
	    277  * 
	    278  * 86    11/14/97 5:02p Peter
	    279  * more comdex stuff
	    280  * 
	    281  * 85    11/14/97 4:47p Dow
	    282  * New splash screen
	    283  * 
	    284  * 84    11/14/97 12:09a Peter

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	    285  * comdex thing and some other stuff
	    286  * 
	    287  * 83    11/12/97 9:37p Dow
	    288  * Banshee crap
	    289  * 
	    290  * 82    11/12/97 2:27p Peter
	    291  * 
	    292  * 81    11/12/97 1:09p Dow
	    293  * H3 Stuf
	    294  * 
	    295  * 80    11/12/97 9:22a Dow
	    296  * H3 Mods
	    297  * 
	    298  * 79    11/06/97 3:46p Peter
	    299  * sli shutdown problem
	    300  * 
	    301  * 78    11/06/97 3:38p Dow
	    302  * More banshee stuff
	    303  * 
	    304  * 77    11/04/97 5:04p Peter
	    305  * cataclysm part deux
	    306  * 
	    307  * 76    11/04/97 3:58p Dow
	    308  * Banshee stuff
	    309  * 
	    310  * 75    11/03/97 3:43p Peter
	    311  * h3/cvg cataclysm
	    312  * 
	    313  * 74    10/29/97 4:59p Peter
	    314  * 
	    315  * 73    10/29/97 2:45p Peter
	    316  * C version of Taco's packing code
	    317  * 
	    318  * 72    10/23/97 5:28p Peter
	    319  * sli fifo thing
	    320  * 
	    321  * 71    10/17/97 3:15p Peter
	    322  * grSstVidMode thingee
	    323  * 
	    324  * 70    10/14/97 2:44p Peter
	    325  * moved close flag set
	    326  * 
	    327  * 69    10/09/97 8:02p Dow
	    328  * State Monster 1st Cut
	    329  * 
	    330 **
	    331 */
	    332 
	    333 #include <stdio.h>
	   1944 #include <string.h>
	   2395 #include <3dfx.h>
	   2526 
	   2527 #include <glidesys.h>
	   2659 
       X   2660 #if (GLIDE_PLATFORM & GLIDE_HW_SST96) 
       X   2661 #include <init.h>
       X   2662 #endif

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	   2663 
	   2664 #define FX_DLL_DEFINITION
	   2665 #include <fxdll.h>
	   2786 #include <glide.h>
	   4597 #include "fxglide.h"
	  14879 #include "fxsplash.h"
	  16707 
       X  16708 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
       X  16709 #define WIN32_LEAN_AND_MEAN
       X  16710 #include <windows.h>
       X  16711 #endif
	  16712 
	  16713 /*-------------------------------------------------------------------
	  16714   Function: grSstWinOpen
	  16715   Date: 3/16
	  16716   Implementor(s): dow, gmt, murali, jdt
	  16717   Mutator: dpc
	  16718   Library: Glide
	  16719   Description:
	  16720 
	  16721   Initialize the selected SST
	  16722 
	  16723   Initialization has 4 Steps 
	  16724 
	  16725   Video Init - 
	  16726      In the full screen case this includes setting the requested
	  16727      resolution/refresh state and allocating any necessary OS 
	  16728      resource for the GC.  
	  16729 
	  16730      In the windowed case, this involves acquiring all necessary
	  16731      surfaces for rendering, back buffer and memory fifo
	  16732 
	  16733      Also perform any work necessary to enable access to 3D 
	  16734      registers
	  16735 
	  16736   Command Transport Init:
	  16737      Assuming video registers are in a reset state, initialize
	  16738      the appropriate command transport mechanism.  All writes
	  16739      to hardware prior to this action are direct writes, 
	  16740      afterwards, most commands will go throught the command
	  16741      transport
	  16742 
	  16743   GC Init - 
	  16744      Initialize the current GC based on the user requested
	  16745      open parameters and command transport data reported
	  16746      during initialization.
	  16747 
	  16748   3D State Init - 
	  16749      Push an initial state onto all of the 3D state registers.   
	  16750      
	  16751   Arguments:
	  16752   hwnd - pointer to a window handle or null.  If NULL, then 
	  16753          the application window handle will be inferred though
	  16754          the GetActiveWindow() api.
	  16755   resolution - either one of the pre-defined glide resolutions,
	  16756                or GR_RESOLUTION_NONE, in which case the window
	  16757                size is inferred from the size application window

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	  16758   refresh - requested fullscreen refresh rate, ignored in a window
	  16759   format  - requested ccolor format for glide packed color values
	  16760   origin  - location of coordinate origin either upper left or
	  16761                     lower right
	  16762   nColBuffers - number of color buffers to attempt to allocate
	  16763                 0 - meaningless
	  16764                 1 - allocate a front buffer only
	  16765                 2 - allocate a front and back buffer
	  16766                 3 - allocate a front, back, aux buffer for tripple buffering
	  16767   nAuxBuffers - number of aux buffers to attempt to allocate
	  16768                 0 - no alpha or z buffers
	  16769                 1 - allocate one aux buffer for alpha/depth buffering
	  16770                 2 - allocate on depth and one alpha buffer (unsup)
	  16771   Return:
	  16772   FXTRUE - glide successfully acquired the necessary resources and a
	  16773            is ready for rendering
	  16774   FXFALSE - glide was unsuccessful in getting the necessary resources, 
	  16775             or the requested configuration is unavailble on the host
	  16776             hardware - any calls to glide rendering routines will result
	  16777             in undefined behavior.
	  16778   -------------------------------------------------------------------*/
	  16779 GR_ENTRY(grSstWinOpen, FxBool, (
	  16780   FxU32                   hWnd,
	  16781   GrScreenResolution_t    resolution, 
	  16782   GrScreenRefresh_t       refresh, 
	  16783   GrColorFormat_t         format, 
	  16784   GrOriginLocation_t      origin, 
	  16785   int                     nColBuffers,
	  16786   int                     nAuxBuffers))
      1	  16787 {
      1	  16788 #define FN_NAME "grSstWinOpen"
      1	  16789   FxBool rv = FXTRUE;
      1	  16790   int tmu;
      1	  16791   int xres = 0, yres = 0, fbStride;
      1	  16792   FxDeviceInfo devInfo;
      1X  16793 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1X  16794   sst1VideoTimingStruct *sstVideoRez = NULL, tvVidtiming;
      1X  16795   FxBool tv_swap_board = FXFALSE;
      1X  16796 #endif
      1	  16797   
      1	  16798   GR_BEGIN_NOFIFOCHECK("grSstWinOpen",80);
      1	  16799   GDBG_INFO_MORE(gc->myLevel,
      1	  16800                  "(rez=%d,ref=%d,cformat=%d,origin=%s,#bufs=%d, #abufs=%d)\n",
      1	  16801                  resolution,refresh,format,
      1	  16802                  origin ? "LL" : "UL",
      1	  16803                  nColBuffers, nAuxBuffers);
      1	  16804   GR_CHECK_F(FN_NAME, !gc, "no SST selected as current (gc==NULL)");
      1	  16805   
      1	  16806 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)  
      1	  16807   /* Voodoo^2 has a bug in sli mode where the video cannot really
      1	  16808    * support resolutions less than 512x384 on pc monitors. Rather than
      1	  16809    * saying sli is not fully compatible w/ single board systems the
      1	  16810    * 'solution' is to just not allow these resolutions.
      1	  16811    * 
      1	  16812    * NB: The current assumption here is taht if the user passes
      1	  16813    * their own video timing structure then they know what the hell
      1	  16814    * they are doing for some weird-ass arcade monitor.

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  16815    */
      1	  16816   rv = !((gc->vidTimings == NULL) &&
      1	  16817          ((resolution < GR_RESOLUTION_512x384) ||
      1	  16818           (resolution == GR_RESOLUTION_512x256) ||
      1	  16819           (resolution == GR_RESOLUTION_400x300) ||
      1	  16820           (resolution == GR_RESOLUTION_NONE)));
      2	  16821   if (!rv) {
      2	  16822     GDBG_INFO(gc->myLevel, "  Incompatible Voodoo^2 resolution.\n");
      2	  16823     goto BAILOUT;
      1	  16824   }
      1	  16825 
      1X  16826 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1X  16827   GR_CHECK_COMPATABILITY(FN_NAME, 
      1X  16828                          ((hWnd == 0x00UL) && (GetActiveWindow() == NULL)),
      1X  16829                          "A valid active window or hWnd parameter is required.");
      1X  16830 #endif /* (GLIDE_PLATFORM & GLIDE_OS_WIN32) */
      1	  16831 #endif /* (GLIDE_PLATFORM & GLODE_HW_CVG) */
      1	  16832   
      1	  16833 #if !GLIDE_INIT_HAL
      1	  16834 __tryReOpen:
      1	  16835   /* If we've been closed via grSstWinClose then we need to re-init
      1	  16836    * the hw registers etc before init-ing video etc or bad ju-ju is
      1	  16837    * in our future.
      1	  16838    *
      1	  16839    * NB: These are in the same order that they are done in the same
      1	  16840    * order as in _grDetectResources. They should match, so don't mess
      1	  16841    * it up.
      1	  16842    */
      2	  16843   if (!gc->hwInitP) {
      2	  16844     FxU32* sstRegs = NULL;
      2	  16845 
      2	  16846 #if !DIRECTX
      2	  16847     rv = pciOpen();
      3	  16848     if (!rv) {
      3	  16849       GDBG_INFO(gc->myLevel, "%s: pci bus could not be opened\n", FN_NAME);
      3	  16850       goto BAILOUT;
      2	  16851     }
      2	  16852 #endif
      2	  16853     
      2	  16854     sstRegs = sst1InitMapBoard(_GlideRoot.current_sst);  
      2	  16855     rv = (sstRegs != NULL);
      3	  16856     if (!rv) {
      3	  16857       GDBG_INFO(gc->myLevel, "%s: re-map of board failed (0x%X : 0x%x)\n",
      3	  16858                 FN_NAME, sstRegs, gc->reg_ptr);
      3	  16859       goto BAILOUT;
      2	  16860     }
      2	  16861     
      2	  16862     /* Re-enabled write combining */
      2	  16863     /*if (_GlideRoot.CPUType.family >= 6) {*/
      2	  16864       sst1InitCaching(sstRegs, FXTRUE);
      2	  16865     /*}*/
      2	  16866 
      2	  16867     rv = sst1InitRegisters(sstRegs);
      3	  16868     if (!rv) {
      3	  16869       GDBG_INFO(gc->myLevel, "%s: Could not re-init hw registers\n", FN_NAME);
      3	  16870       goto BAILOUT;
      2	  16871     }

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2	  16872     
      2	  16873     /* Reset up pointers to the various address spaces within the hw
      2	  16874      * since the hw base address can be different from the original
      2	  16875      * map board.  
      2	  16876      */
      2	  16877     gc->base_ptr  = (FxU32*)HW_BASE_PTR(sstRegs);
      2	  16878     gc->reg_ptr   = (FxU32*)HW_REG_PTR(sstRegs);
      2	  16879     gc->lfb_ptr   = (FxU32*)HW_LFB_PTR(sstRegs);
      2	  16880     gc->tex_ptr   = (FxU32*)HW_TEX_PTR(sstRegs);
      2	  16881     
      2	  16882     /* Make sure that the sli-slave gets re-initted too.
      2	  16883      *
      2	  16884      * NB: This makes the same assumption as the sli-pairing code
      2	  16885      * that the sli slave is the next one discovered in the
      2	  16886      * set of GC's.
      2	  16887      */
      3	  16888     if (gc->scanline_interleaved) {
      3	  16889       sstRegs = sst1InitMapBoard(_GlideRoot.current_sst + 1);
      3	  16890       rv = (sstRegs != NULL);
      4	  16891       if (!rv) {
      4	  16892         GDBG_INFO(gc->myLevel, "%s: Could not re-map slave.\n", FN_NAME);
      4	  16893         goto BAILOUT;
      3	  16894       }
      3	  16895       
      3	  16896       rv = sst1InitRegisters(sstRegs);
      4	  16897       if (!rv) {
      4	  16898         GDBG_INFO(gc->myLevel, "%s: Could not re-init slave registers\n", FN_NAME);
      4	  16899         goto BAILOUT;
      3	  16900       }
      3	  16901       
      3	  16902       /* Reset up pointers to the various address spaces within the hw
      3	  16903        * since the hw base address can be different from the original
      3	  16904        * map board.  
      3	  16905        */
      3	  16906       (gc + 1)->base_ptr  = (FxU32*)HW_BASE_PTR(sstRegs);
      3	  16907       (gc + 1)->reg_ptr   = (FxU32*)HW_REG_PTR(sstRegs);
      3	  16908       (gc + 1)->lfb_ptr   = (FxU32*)HW_LFB_PTR(sstRegs);
      3	  16909       (gc + 1)->tex_ptr   = (FxU32*)HW_TEX_PTR(sstRegs);
      3	  16910 
      3	  16911       gc->slave_ptr = sstRegs;
      2	  16912     }
      2	  16913     
      2	  16914     gc->hwInitP = FXTRUE;
      2	  16915   } else if (gc->open) {
      2	  16916     /* If this device is already open then it is probably an error to
      2	  16917      * call grSstWinOpen again. Rather than letting all hell break
      2	  16918      * loose as we re-init the video and (especially) command fifo
      2	  16919      * shutdown the hw and do a full re-init.
      2	  16920      *
      2	  16921      * NB: This is here for TombRaider which is not going to be reved
      2	  16922      * as far as I know.
      2	  16923      */
      2	  16924     GR_CHECK_COMPATABILITY(FN_NAME, gc->open, "This context is already open");
      2	  16925     grSstWinClose();
      2	  16926     goto __tryReOpen;
      1	  16927   }
      1	  16928 #endif /* !GLIDE_INIT_HAL */

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  16929   
      1X  16930 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1	  16931   /*
      1	  16932   ** load fxoem2x.dll and map board
      1X  16933   */
      1X  16934   { 
      1X  16935     gc->oemInit = NULL;
      1X  16936     rv = sst1InitGetDeviceInfo(gc->reg_ptr, &devInfo);
      1X  16937     if (rv) {
      1X  16938       char* boardIDStr;
      1X  16939       FxU32 boardID;
      1X  16940       char* requireOEMDLLStr;
      1X  16941       FxU32 requireOEMDLL;
      1X  16942 
      1X  16943       gc->oemi.version = OEMINIT_VERSION;
      1X  16944       gc->oemi.vendorID = devInfo.vendorID;
      1X  16945       gc->oemi.subvendorID = OEMINIT_INVALID_BOARD_ID;
      1X  16946       gc->oemi.deviceID = devInfo.deviceID;
      1X  16947       gc->oemi.boardID  = devInfo.fbiBoardID | (devInfo.fbiConfig << FX_OEM_FBI_CONFIG_SHIFT);
      1X  16948       gc->oemi.linearAddress = gc->base_ptr;
      1X  16949       gc->oemi.slaveAddress = gc->slave_ptr;
      1X  16950       gc->oemi.fxoemPciWriteConfig = (PciConfigProc)pciSetConfigData;
      1X  16951       gc->oemi.fxoemPciReadConfig = (PciConfigProc)pciGetConfigData;
      1X  16952       
      1X  16953       boardIDStr = GETENV("FX_GLIDE_BOARDID");
      1X  16954       boardID = (boardIDStr == NULL) ? 0 : atol(boardIDStr);
      1X  16955       if ((boardID) && (devInfo.fbiBoardID != boardID)) {
      1X  16956         /* if boardID is defined and does not match */
      1X  16957         GrErrorCallback("Undefined boardID", FXTRUE);
      1X  16958         grSstWinClose();
      1X  16959         exit(0);
      1X  16960       }
      1X  16961 
      1X  16962       requireOEMDLLStr = GETENV("FX_GLIDE_REQUIREOEMDLL");
      1X  16963       requireOEMDLL = (requireOEMDLLStr == NULL) ? 0 : atol(requireOEMDLLStr);
      1X  16964       if (requireOEMDLL == GR_SKIP_OEMDLL) {
      1X  16965         /* skip oem dll */
      1X  16966         gc->oemInit = NULL;
      1X  16967       }
      1X  16968       else if (requireOEMDLL == GR_NO_OEMDLL) {
      1X  16969         /* no oemdll is allowed */
      1X  16970         gc->oemInit = LoadLibrary("fxoem2x.dll");
      1X  16971         if (gc->oemInit) {
      1X  16972           GrErrorCallback("Please remove fxoem2x.dll", FXTRUE);
      1X  16973           grSstWinClose();
      1X  16974           exit(0);
      1X  16975         }
      1X  16976       }
      1X  16977       else if ( requireOEMDLL == 0) {
      1X  16978         /* FX_GLIDE_REQUIREOEMDLL is not defined, load oemdll if it exist */
      1X  16979         gc->oemInit = LoadLibrary("fxoem2x.dll");
      1X  16980       }
      1X  16981       else {
      1X  16982         /* oem dll is required */
      1X  16983         gc->oemInit = LoadLibrary("fxoem2x.dll");
      1X  16984         if (gc->oemInit == NULL) {
      1X  16985           GrErrorCallback("Missing fxoem2x.dll", FXTRUE);

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1X  16986           grSstWinClose();
      1X  16987           exit(0);
      1X  16988         }
      1X  16989       }
      1X  16990       
      1X  16991       /*
      1X  16992       ** oem map board 
      1X  16993       */
      1X  16994       if (gc->oemInit) {
      1X  16995         FARPROC oemInitMapBoard = GetProcAddress(gc->oemInit, "_fxoemInitMapBoard@4");
      1X  16996         if (oemInitMapBoard != NULL)
      1X  16997           oemInitMapBoard(&gc->oemi);
      1X  16998         else
      1X  16999           gc->oemInit = NULL;
      1X  17000       }
      1X  17001     }
      1X  17002     else {
      1X  17003       GDBG_INFO(gc->myLevel, "  XXXGetDeviceInfo failed. (0x%X)\n", gc->reg_ptr);
      1X  17004       goto BAILOUT;
      1X  17005   }
      1X  17006   }
      1X  17007 #endif /* (GLIDE_PLATFORM & GLIDE_OS_WIN32) */
      1	  17008 
      1	  17009   /*------------------------------------------------------
      1	  17010     Video Init
      1	  17011     ------------------------------------------------------*/  
      1X  17012 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1	  17013   /*
      1	  17014   ** initialize video timing data for oemdll
      1	  17015   ** if tv out component exist, the oem dll need to modify the vidtiming
      1	  17016   ** data in oemi. Glide will take the changes and pass it to 
      1	  17017   ** sst1InitVideoBuffers()
      1X  17018   */
      1X  17019   {
      1X  17020     if((gc->oemInit) && (sstVideoRez = sst1InitFindVideoTimingStruct(resolution, refresh))) {
      1X  17021     tvVidtiming           = *sstVideoRez;
      1X  17022       gc->oemi.vid.res          = resolution;
      1X  17023       gc->oemi.vid.refresh      = refresh;
      1X  17024       gc->oemi.vid.depth        = 16;
      1X  17025       gc->oemi.vid.hSyncOn      = tvVidtiming.hSyncOn;
      1X  17026       gc->oemi.vid.hSyncOff     = tvVidtiming.hSyncOff;
      1X  17027       gc->oemi.vid.vSyncOn      = tvVidtiming.vSyncOn;
      1X  17028       gc->oemi.vid.vSyncOff     = tvVidtiming.vSyncOff;
      1X  17029       gc->oemi.vid.hBackPorch   = tvVidtiming.hBackPorch;
      1X  17030       gc->oemi.vid.vBackPorch   = tvVidtiming.vBackPorch;
      1X  17031       gc->oemi.vid.xDimension   = tvVidtiming.xDimension;
      1X  17032       gc->oemi.vid.yDimension   = tvVidtiming.yDimension;
      1X  17033       gc->oemi.vid.clkFreq16bpp = tvVidtiming.clkFreq16bpp;
      1X  17034       gc->oemi.vid.clkFreq24bpp = tvVidtiming.clkFreq24bpp;
      1X  17035 
      1X  17036     if (gc->oemInit) {
      1X  17037         FARPROC oemInitVideoTiming = GetProcAddress(gc->oemInit, "_fxoemInitVideoTiming@4");
      1X  17038         if (oemInitVideoTiming) {
      1X  17039           if (oemInitVideoTiming(&gc->oemi.vid)) {
      1X  17040       /*
      1X  17041       ** video timing is updated by oem dll
      1X  17042       */

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1X  17043             tvVidtiming.hSyncOn      = gc->oemi.vid.hSyncOn;
      1X  17044             tvVidtiming.hSyncOff     = gc->oemi.vid.hSyncOff;
      1X  17045             tvVidtiming.vSyncOn      = gc->oemi.vid.vSyncOn;
      1X  17046             tvVidtiming.vSyncOff     = gc->oemi.vid.vSyncOff;
      1X  17047             tvVidtiming.hBackPorch   = gc->oemi.vid.hBackPorch;
      1X  17048             tvVidtiming.vBackPorch   = gc->oemi.vid.vBackPorch;
      1X  17049             tvVidtiming.xDimension   = gc->oemi.vid.xDimension;
      1X  17050             tvVidtiming.yDimension   = gc->oemi.vid.yDimension;
      1X  17051             tvVidtiming.clkFreq16bpp = gc->oemi.vid.clkFreq16bpp;
      1X  17052             tvVidtiming.clkFreq24bpp = gc->oemi.vid.clkFreq24bpp;
      1X  17053             refresh = tvVidtiming.refreshRate  = gc->oemi.vid.refresh; 
      1X  17054         grSstVidMode(_GlideRoot.current_sst, &tvVidtiming);
      1X  17055       }
      1X  17056     }
      1X  17057   }
      1X  17058     }
      1X  17059   }
      1X  17060 #endif /* (GLIDE_PLATFORM & GLIDE_OS_WIN32) */
      1	  17061 
      1X  17062 #if GLIDE_INIT_HAL
      1X  17063   {
      1X  17064     GDBG_INFO(gc->myLevel, "  HAL Video Init\n");
      1X  17065     
      1X  17066     rv = fxHalInitVideo((SstRegs*)gc->reg_ptr,
      1X  17067                         ((resolution == GR_RESOLUTION_NONE) 
      1X  17068                          ? GR_RESOLUTION_640x480
      1X  17069                          : resolution), 
      1X  17070                         refresh, 
      1X  17071                         NULL);
      1X  17072     if (!rv) goto BAILOUT;
      1X  17073   }
      1X  17074 #else
      1	  17075   GDBG_INFO(gc->myLevel, "  Video Init\n");
      1	  17076 
      1	  17077 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      1	  17078   /* CVG cannot just do one color buffer (Well, I guess it could, but
      1	  17079    * not if you have the aux buffer too) so just force the allocation
      1	  17080    * of two buffers. This does have consequences for swap since we
      1	  17081    * need to ignore them too.
      1	  17082    */
      1	  17083   gc->hwDep.cvgDep.singleBufferP = (nColBuffers == 1);
      1	  17084   if (gc->hwDep.cvgDep.singleBufferP) nColBuffers = 2;
      1	  17085 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      1	  17086 
      1	  17087   /* If the user has buffer allocation set in their environment. Try
      1	  17088    * those settings before trying the actual program settings.
      1	  17089    *
      1	  17090    * NB: We cannot fail the allocation on the env settings since the
      1	  17091    * user could have messed up and set something ridiculous.  
      1	  17092    */
      2	  17093   {
      2	  17094     FxI32 curColorBuffers = ((_GlideRoot.environment.nColorBuffer == -1L)
      2	  17095                              ? nColBuffers
      2	  17096                              : _GlideRoot.environment.nColorBuffer);
      2	  17097     FxI32 curAuxBuffers   = ((_GlideRoot.environment.nAuxBuffer == -1L)
      2	  17098                              ? nAuxBuffers
      2	  17099                              : _GlideRoot.environment.nAuxBuffer);

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2	  17100     FxBool triedParamsP;
      2	  17101 
      3	  17102     do {
      3	  17103       triedParamsP = ((curColorBuffers == nColBuffers) &&
      3	  17104                       (curAuxBuffers == nAuxBuffers));
      3	  17105 
      3	  17106       rv = sst1InitVideoBuffers(gc->reg_ptr, 
      3	  17107                                 resolution, refresh, 
      3	  17108                                 ((curColorBuffers == 1) ? 2 : curColorBuffers),
      3	  17109                                 curAuxBuffers,
      3	  17110                                 gc->vidTimings,
      3	  17111                                 FXTRUE);
      4	  17112       if (!rv && !triedParamsP) {
      4	  17113         curColorBuffers = nColBuffers;
      4	  17114         curAuxBuffers   = nAuxBuffers;
      3	  17115       }
      2	  17116     } while(!rv && !triedParamsP);
      2	  17117     
      2	  17118     /* Reset the parameters for the possible sli-slave video init and
      2	  17119      * internal bookkeeping.  
      2	  17120      */
      2	  17121     nColBuffers = curColorBuffers;
      2	  17122     nAuxBuffers  = curAuxBuffers;
      1	  17123   }
      1	  17124 
      1	  17125   /* If sli is on then we need to init the slave board's video */
      2	  17126   if (rv && gc->scanline_interleaved) {
      2	  17127     rv = (gc->slave_ptr != NULL);
      3	  17128     if (!rv) {
      3	  17129       GDBG_INFO(gc->myLevel, "  Invalid slave base address.\n");
      3	  17130       goto __errSliExit;
      2	  17131     }
      2	  17132     
      2	  17133     rv = sst1InitVideoBuffers(gc->slave_ptr,
      2	  17134                               resolution, refresh,
      2	  17135                               nColBuffers, nAuxBuffers, 
      2	  17136                               gc->vidTimings,
      2	  17137                               FXTRUE);
      3	  17138     if (!rv) {
      3	  17139       GDBG_INFO(gc->myLevel, "  sst1InitVideoBuffers failed for sli slave.\n");
      3	  17140       goto __errSliExit;
      2	  17141     }
      1	  17142   }
      1	  17143 
      1X  17144 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1	  17145   /*
      1	  17146   ** initialize oem vedio after master and slave board
      1X  17147   */
      1X  17148   if (gc->oemInit) {
      1X  17149     FARPROC oemInitSetVideo = NULL;
      1X  17150     FARPROC oemGet;
      1X  17151     FxI32 tv_connected = 0;
      1X  17152     FxI32 slimaster[2], slislave[2];
      1X  17153     oemInitSetVideo = GetProcAddress(gc->oemInit, "_fxoemInitSetVideo@4");
      1X  17154     if (oemInitSetVideo)
      1X  17155       oemInitSetVideo(&gc->oemi);
      1X  17156     

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1X  17157     oemGet = GetProcAddress(gc->oemInit, "_fxoemGet@12");
      1X  17158     if (oemGet) {
      1X  17159       oemGet(FX_OEM_TVOUT, 4, &tv_connected);
      1X  17160       /* Is tv connected to the board? */
      1X  17161       if (tv_connected) {
      1X  17162         oemGet(FX_OEM_SLIMASTER, 8, slimaster);
      1X  17163         oemGet(FX_OEM_SLISLAVE, 8, slislave);
      1X  17164         if (((FxU32 *)slimaster[1] == gc->slave_ptr) && 
      1X  17165             ((FxU32 *)slislave[1] == gc->base_ptr))
      1X  17166           tv_swap_board = FXTRUE;
      1X  17167         else
      1X  17168           tv_swap_board = FXFALSE;
      1X  17169       }
      1X  17170     }
      1X  17171   }
      1X  17172 #endif
      1	  17173 
      2	  17174   if (rv) {
      2	  17175     /* Check to see that we have a monitor attached to the board taht we
      2	  17176      * expect to be driving the video. There are two cases here: sli and
      2	  17177      * non-sli.
      2	  17178      *
      2	  17179      * In the sli case we expect the master to be driving the video so if
      2	  17180      * the slave has the monitor plugged into it then we swap the sense of
      2	  17181      * the master and slave.
      2	  17182      *
      2	  17183      * In the non-sli case there are two sub-cases: the user does not
      2	  17184      * have a monitor attached at all to the card (read: moron) or that
      2	  17185      * they have explicitly disabled sli with the monitor plugged into
      2	  17186      * the slave. In the moron case there's nothing we can do, except
      2	  17187      * finish up the init and let the user deal w/ the fact that they
      2	  17188      * can't see anything. In the sli-disable case we need to initialize
      2	  17189      * the video of the would be slave (this was not done before since
      2	  17190      * sli was not auto-detected by the init code), swap the sense of
      2	  17191      * the boards and continue w/ the rest of the initialization.
      2	  17192      *
      2	  17193      * NB: The calls to sst1InitGetDeviceInfo *MUST* come after
      2	  17194      * sst1InitVideoBuffers for each card since that is where the
      2	  17195      * monitor detection is done.
      2	  17196      */
      2	  17197     rv = sst1InitGetDeviceInfo(gc->reg_ptr, &devInfo);
      3	  17198     if (!rv) {
      3	  17199       GDBG_INFO(gc->myLevel, 
      3	  17200                 "  sst1InitGetDeviceInfo failed to determine master monitor connectivness.\n");
      3	  17201       goto __errSliExit;
      2	  17202     }
      3	  17203     if (!devInfo.monitorDetected) {
      4	  17204       if (gc->scanline_interleaved) {
      4	  17205         rv = sst1InitGetDeviceInfo(gc->slave_ptr, &devInfo);
      5	  17206         if (!rv) {
      5	  17207           GDBG_INFO(gc->myLevel, 
      5	  17208                     "  sst1InitGetDeviceInfo failed to determine slave monitor connectivness.\n");
      5	  17209           goto __errSliExit;
      4	  17210         }
      4	  17211       
      4	  17212         rv = FXTRUE;
      5	  17213         if (devInfo.monitorDetected) {

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      5	  17214           GDBG_INFO(gc->myLevel, "  Swapping sli slave and master");          
      5	  17215         } else {
      5	  17216           /* no monitors attached.
      5	  17217            * Just do the default init w/o any swapping.
      5	  17218            */
      5X  17219 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      5	  17220           /* 
      5	  17221           ** We need to check the if tv is connected.
      5	  17222           ** If not, then there is no output.
      5X  17223           */
      5X  17224           if (tv_swap_board) 
      5X  17225             GDBG_INFO(gc->myLevel, "  TV is connected. Swapping sli slave and master");          
      5X  17226           else 
      5X  17227 #endif
      6	  17228           {
      6	  17229           GDBG_INFO(gc->myLevel, "  No monitor attached to slave or master.\n");
      6	  17230           goto __errSliExit;
      5	  17231         }
      4	  17232         }
      4	  17233       } else {
      5	  17234         if (!gc->sliPairP) {
      5	  17235           /* If there isn't a next board then there is not output. */
      5	  17236           rv = FXTRUE;
      5	  17237           goto __errSliExit;
      4	  17238         } else 
      4X  17239 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      4X  17240           if (!tv_swap_board)
      4X  17241 #endif
      5	  17242         {
      5	  17243           /* Shutdown the logical master so that the new master will
      5	  17244            * really own the video.
      5	  17245            *
      5	  17246            * NB: We don't have to shutdown the command fifo here since
      5	  17247            * it is not on yet.
      5	  17248            */
      6	  17249           {
      6	  17250             sst1InitIdle(gc->base_ptr);
      6	  17251 
      6	  17252             /* Make sure that the caching is toggled.
      6	  17253              *
      6	  17254              * NB: The order of the caching changes is relevant here since
      6	  17255              * we don't want to waste mtrr's, even briefly.  
      6	  17256              */
      6	  17257             /*if (_GlideRoot.CPUType.family >= 6) {*/
      6	  17258               sst1InitCaching(gc->base_ptr, FXFALSE);
      6	  17259               sst1InitCaching((gc + 1)->base_ptr, FXTRUE);
      6	  17260             /*}*/
      6	  17261 
      6	  17262             sst1InitShutdown(gc->base_ptr);
      6	  17263 
      6	  17264             /* We want to let the oem that video has shutdown here so
      6	  17265              * that they can do the 'right' thing when we re-init
      6	  17266              * video w/ the current slave as the master.
      6	  17267              *
      6	  17268              * NB: However, we don't do this currently because it requires
      6	  17269              * odd semantics to the calling conventions of the oem dll.
      6	  17270              */            

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      6X  17271 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32) && 0
      6X  17272             if (gc->oemInit) {
      6X  17273               FARPROC oemRestoreVideo = GetProcAddress(gc->oemInit, "_fxoemRestoreVideo@4"); 
      6X  17274               if (oemRestoreVideo != NULL) oemRestoreVideo(&gc->oemi);
      6X  17275             }
      6X  17276 #endif /* (GLIDE_PLATFORM & GLIDE_OS_WIN32) */
      6	  17277             
      6	  17278             gc->hwInitP = FXFALSE;
      5	  17279           }
      5	  17280 
      5	  17281 #if !DIRECTX
      5	  17282           /* dpc - 14 feb 1997 - HackAlert!!!!
      5	  17283            * The sst1InitShutdown above will close the pci library which
      5	  17284            * then prevents other pci library calls which we need to init
      5	  17285            * video next.
      5	  17286            */
      5	  17287           pciOpen();
      5	  17288 #endif
      5	  17289           
      5	  17290           /* Re-init the new master */
      6	  17291           {
      6	  17292             FxU32* sstRegs = sst1InitMapBoard(_GlideRoot.current_sst + 1);
      6	  17293             rv = (sstRegs != NULL);
      7	  17294             if (!rv) {
      7	  17295               GDBG_INFO(gc->myLevel, "%s: Could not re-map 'monitor swap slave'.\n", FN_NAME);
      7	  17296               goto __errSliExit;
      6	  17297             }
      6	  17298 
      6	  17299             rv = sst1InitRegisters(sstRegs);
      7	  17300             if (!rv) {
      7	  17301               GDBG_INFO(gc->myLevel, "%s: Could not re-init 'monitor swap slave' registers\n", FN_NAME);
      7	  17302               goto __errSliExit;
      6	  17303             }
      6	  17304             
      6	  17305             /* Reset up pointers to the various address spaces within the hw
      6	  17306              * since the hw base address can be different from the original
      6	  17307              * map board.  
      6	  17308              */
      6	  17309             (gc + 1)->base_ptr  = (FxU32*)HW_BASE_PTR(sstRegs);
      6	  17310             (gc + 1)->reg_ptr   = (FxU32*)HW_REG_PTR(sstRegs);
      6	  17311             (gc + 1)->lfb_ptr   = (FxU32*)HW_LFB_PTR(sstRegs);
      6	  17312             (gc + 1)->tex_ptr   = (FxU32*)HW_TEX_PTR(sstRegs);
      6	  17313             
      6	  17314             /* We're done setting up the new master's hw */
      6	  17315             (gc + 1)->hwInitP = FXTRUE;
      5	  17316           }
      5	  17317 
      5	  17318           rv = sst1InitVideoBuffers((gc + 1)->base_ptr,
      5	  17319                                     resolution, refresh,
      5	  17320                                     nColBuffers, nAuxBuffers,
      5	  17321                                     gc->vidTimings,
      5	  17322                                     FXTRUE);
      6	  17323           if (!rv) {
      6	  17324             GDBG_INFO(gc->myLevel, "  sst1InitVideoBuffers failed for 'monitor swap slave'.\n");
      6	  17325             goto __errSliExit;
      5	  17326           }
      4	  17327         }

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      3	  17328       }
      3	  17329     
      3	  17330       /* Switch the senses of the master and slave in the gc's. 
      3	  17331        * 
      3	  17332        * NB: This only has to swap the hw addresses since the rest of
      3	  17333        * the information has to be the same in order for the boards to
      3	  17334        * be sli-able.  
      3	  17335        */
      3	  17336 #define SwapPtrVal(__a, __b) do { FxU32* temp = (__a); (__a) = (__b); (__b) = temp; } while(0);
      3	  17337       SwapPtrVal(gc->base_ptr,  (gc + 1)->base_ptr);
      3	  17338       SwapPtrVal(gc->reg_ptr,   (gc + 1)->reg_ptr);
      3	  17339       SwapPtrVal(gc->tex_ptr,   (gc + 1)->tex_ptr);
      3	  17340       SwapPtrVal(gc->lfb_ptr,   (gc + 1)->lfb_ptr);
      3	  17341 #undef SwapPtrVal
      3	  17342 
      4	  17343       if (gc->scanline_interleaved) {
      4	  17344         /* The slave pointer, however, needs to be set by hand again. */
      4	  17345         gc->slave_ptr = (gc + 1)->base_ptr;
      4	  17346         (gc + 1)->slave_ptr = NULL;
      4	  17347 
      4	  17348         /* Swap the caching characteristics too. The old master is now
      4	  17349          * the slave, and the old slave is now the master. The caching
      4	  17350          * on the old master was set when the board was mapped the
      4	  17351          * first time.
      4	  17352          *
      4	  17353          * NB: The order of the caching changes is relevant here since
      4	  17354          * we don't want to waste mtrr's, even briefly.  
      4	  17355          */
      4	  17356         /*if (_GlideRoot.CPUType.family >= 6) {*/
      4	  17357           sst1InitCaching(gc->slave_ptr, FXFALSE);
      4	  17358           sst1InitCaching(gc->base_ptr, FXTRUE);
      4	  17359         /*}*/
      3	  17360       }
      3	  17361     
      3	  17362       /* Save that we swapped teh master sense so that we can
      3	  17363        * restore these settings when we shut down.
      3	  17364        */
      3	  17365       gc->swapMasterSenseP = FXTRUE;
      3	  17366 
      3X  17367 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      3	  17368       /* NB: We need to make sure that the oem structure reflects the
      3	  17369        * 'new' sense of the master/slave relationship.  
      3X  17370        */
      3X  17371       gc->oemi.linearAddress = gc->base_ptr;
      3X  17372       gc->oemi.slaveAddress = gc->slave_ptr;      
      3X  17373 
      3X  17374       /* re-initialize oem vedio for the board */
      3X  17375       if (gc->oemInit) {
      3X  17376         FARPROC oemInitSetVideo = GetProcAddress(gc->oemInit, "_fxoemInitSetVideo@4");
      3X  17377         if (oemInitSetVideo != NULL) oemInitSetVideo(&gc->oemi);
      3X  17378       }
      3X  17379 #endif
      2	  17380     }
      1	  17381   }
      1	  17382 
      1	  17383   /* If we have an sli configuration then start it up.
      1	  17384    *

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  17385    * NB: There are two ways to get here. In the case that a monitor
      1	  17386    * was detected we will get here straightline. If no monitors are
      1	  17387    * detected (sli or no) we will get here via an error goto to
      1	  17388    * the label __errSliExit.  
      1	  17389    */
      1	  17390 __errSliExit:
      2	  17391   if (rv && gc->scanline_interleaved) {  
      2	  17392     rv = sst1InitSli(gc->reg_ptr, gc->slave_ptr);
      3	  17393     if (!rv) {
      3	  17394       GDBG_INFO(gc->myLevel, "  sst1InitSli failed.\n");
      3	  17395       goto __errSliExit;
      2	  17396     }
      2	  17397 
      2	  17398     /* If the user has not set FX_GLIDE_SWAPINTERVAL == 0 then
      2	  17399      * override the swapInterval for grBufferSwap so that it always
      2	  17400      * goes w/ vsync. Otherwise it can look bad as the boards swap out
      2	  17401      * of sync w/ each other.  
      2	  17402      */
      2	  17403     if (_GlideRoot.environment.swapInterval < 0) _GlideRoot.environment.swapInterval = 1;
      1	  17404   }
      1	  17405 
      1	  17406   /* Explicitly set the pass through address that the vxd will be
      1	  17407    * using to toggle the passthrough. In sli mode this is the master,
      1	  17408    * and otherwise it is the card driving the monitor's vidoe.  
      1	  17409    * Currently, we set this to be a 16mb address space.
      1	  17410    */
      1X  17411 #if 0
      1X  17412   if (rv) pciSetPassThroughBase(gc->base_ptr, 0x1000000);
      1X  17413 #endif
      1	  17414 #endif
      1	  17415 
      1	  17416   if (!rv) goto BAILOUT;
      1	  17417 
      1	  17418   /* Doh! Don't forget to set the resolution conversions. */
      2	  17419   if (gc->vidTimings == NULL) {
      3	  17420     switch(resolution) {
      3X  17421 #if !(GLIDE_PLATFORM & GLIDE_HW_CVG)
      3X  17422     case GR_RESOLUTION_320x200:
      3X  17423       xres = 320; yres = 200;
      3X  17424       break;
      3X  17425     
      3X  17426     case GR_RESOLUTION_320x240:
      3X  17427       xres = 320; yres = 240;
      3X  17428       break;
      3X  17429     
      3X  17430     case GR_RESOLUTION_400x256:
      3X  17431       xres = 400; yres = 256;
      3X  17432       break;
      3X  17433 #endif /* !(GLIDE_PLATFORM & GLIDE_HW_CVG) */
      3	  17434 
      3	  17435     case GR_RESOLUTION_512x384:
      3	  17436       xres = 512; yres = 384;
      3	  17437       break;
      3	  17438 
      3	  17439     case GR_RESOLUTION_640x200:
      3	  17440       xres = 640; yres = 200;
      3	  17441       break;

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      3	  17442 
      3	  17443     case GR_RESOLUTION_640x350:
      3	  17444       xres = 640; yres = 350;
      3	  17445       break;
      3	  17446 
      3	  17447     case GR_RESOLUTION_640x400:
      3	  17448       xres = 640; yres = 400;
      3	  17449       break;
      3	  17450 
      3	  17451     case GR_RESOLUTION_640x480:
      3	  17452       xres = 640; yres = 480;
      3	  17453       break;
      3	  17454 
      3	  17455     case GR_RESOLUTION_800x600:
      3	  17456       xres = 800; yres = 600;
      3	  17457       break;
      3	  17458 
      3	  17459     case GR_RESOLUTION_960x720:
      3	  17460       xres = 960; yres = 720;
      3	  17461       break;
      3	  17462 
      3	  17463     case GR_RESOLUTION_856x480:
      3	  17464       xres = 856; yres = 480;
      3	  17465       break;
      3	  17466 
      3	  17467     case GR_RESOLUTION_512x256:
      3	  17468       xres = 512; yres = 256;
      3	  17469       break;
      3	  17470 
      3	  17471     case GR_RESOLUTION_1024x768: 
      3	  17472       xres = 1024; yres = 768;
      3	  17473       break;
      3	  17474 
      3	  17475     case GR_RESOLUTION_1280x1024:
      3	  17476       xres = 1280; yres = 1024;
      3	  17477       break;
      3	  17478 
      3	  17479     case GR_RESOLUTION_1600x1200:
      3	  17480       xres = 1600; yres = 1200;
      3	  17481       break;
      3	  17482 
      3	  17483     default:
      3	  17484       GR_ASSERT(0);
      2	  17485     }
      2	  17486   } else {
      2	  17487     xres = gc->vidTimings->xDimension;
      2	  17488     yres = gc->vidTimings->yDimension;
      1	  17489   }
      1	  17490 
      1	  17491   /* Stash these, mostly for error checking type things */
      1	  17492   gc->grColBuf = nColBuffers;
      1	  17493   gc->grAuxBuf = nAuxBuffers;
      1	  17494 
      1	  17495   /* The current init code always sets this to 1024. */
      1	  17496   fbStride = 1024;
      1	  17497 
      1	  17498   GDBG_INFO(gc->myLevel, 

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  17499             "  Video init succeeded. xRes:%.04d yRes:%.04d nCol:%d nAux:%d\n",
      1	  17500             xres, yres, gc->grColBuf, gc->grAuxBuf);
      1	  17501 
      1	  17502   /*------------------------------------------------------
      1	  17503     Command Transport Init
      1	  17504     ------------------------------------------------------*/
      2	  17505   {
      2X  17506 #if !((GLIDE_PLATFORM & GLIDE_HW_CVG))
      2X  17507     InitFIFOData fifoInfo;
      2X  17508      
      2X  17509     GDBG_INFO(gc->myLevel, "  Command Transport Init\n");
      2X  17510     rv = initEnableTransport(&fifoInfo);
      2X  17511     if (!rv) goto BAILOUT;     
      2X  17512 #endif
      2	  17513      
      2	  17514 #if ((GLIDE_PLATFORM & GLIDE_HW_H3) || (GLIDE_PLATFORM & GLIDE_HW_CVG))
      2	  17515     /* Place cmd fifo into fbi memory.  There are actually two
      2	  17516      * 'placements' here, hw memory and virtual address space. In hw
      2	  17517      * memory, the fifo is placed after any buffers that the user has
      2	  17518      * requested (color and aux). If there is any memory left after
      2	  17519      * these buffer allocations, we grab it all, otherwise this is an
      2	  17520      * error. In virtual address space, the fifo is always placed at
      2	  17521      * HW_FIFO_OFFSET.
      2	  17522      */
      3	  17523     {
      3	  17524       FxU32 xTileNum = 0;
      3	  17525       FxU32 fifoSize = 0x00UL;
      3	  17526 
      3X  17527 #if GLIDE_INIT_HAL
      3X  17528       rv = fxHalGetDeviceInfo((SstRegs*)gc->reg_ptr, &devInfo);
      3X  17529 #else
      3	  17530       rv = sst1InitGetDeviceInfo(gc->base_ptr, &devInfo);
      3	  17531 #endif
      4	  17532       if (!rv) {
      4	  17533         GDBG_INFO(gc->myLevel, "  XXXGetDeviceInfo failed. (0x%X)\n", gc->reg_ptr);
      4	  17534         goto BAILOUT;
      3	  17535       }
      3	  17536 
      3	  17537 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      3	  17538       xTileNum = devInfo.fbiVideoTilesInX;
      3	  17539 #endif
      3	  17540        
      3X  17541 #if (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR
      3X  17542       {
      3X  17543         /* Cache the # of pages for video tiles in the x direction
      3X  17544          * for use in grBufferClear (gglide.c).
      3X  17545          */
      3X  17546         gc->hwDep.cvgDep.tileSlopP = ((xTileNum & 0x01) != 0x00);
      3X  17547         gc->hwDep.cvgDep.xTilePages = (xTileNum >> 1);
      3X  17548         
      3X  17549         gc->hwDep.cvgDep.yTileShift = (gc->scanline_interleaved ? 6 : 5);
      3X  17550 
      3X  17551         /* Get the # of pages per buffer. */
      3X  17552         gc->hwDep.cvgDep.numBufferPages = devInfo.fbiVideoMemOffset;
      3X  17553 
      3X  17554         /* Set logical buffer -> physical buffer translations */
      3X  17555         gc->hwDep.cvgDep.frontBuf = 0;

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      3X  17556         gc->hwDep.cvgDep.backBuf  = (gc->scanline_interleaved ? gc->grColBuf - 1 : 1);
      3X  17557 
      3X  17558         /* Initially current buffer == back buffer. */
      3X  17559         gc->hwDep.cvgDep.renderBuf = gc->hwDep.cvgDep.backBuf;
      3X  17560       }
      3X  17561 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) && GLIDE_BLIT_CLEAR */
      3	  17562 
      3X  17563 #if USE_PACKET_FIFO
      3X  17564       /* Place fifo in hw memory */
      3X  17565       {
      3X  17566         /* Init hw */
      3X  17567 #define MB2B(__b) (((FxU32)(__b)) << 20)
      3X  17568 #if GLIDE_INIT_HAL
      3X  17569         /* Allocate the fifo on a page boundary */
      3X  17570 #define kPageBoundarySlop 0x1000UL
      3X  17571 #define kPageBoundaryMask (kPageBoundarySlop - 1)
      3X  17572 
      3X  17573         const FxU32 memEnd = MB2B(gc->fbuf_size);                                 /* size of hw memory */
      3X  17574         FxU32 maxOffset = ((xTileNum * yres) << 6) * (nColBuffers + nAuxBuffers); /* Bytes for buffers */
      3X  17575         
      3X  17576         /* Align on a page boundary */
      3X  17577         if ((maxOffset & kPageBoundaryMask) != 0x00) {
      3X  17578           maxOffset = ((maxOffset + kPageBoundarySlop) & ~kPageBoundaryMask);
      3X  17579         }
      3X  17580         
      3X  17581 #if GLIDE_USE_DEBUG_FIFO
      3X  17582         fifoSize = 0x1000UL;
      3X  17583 #else /* !GLIDE_USE_DEBUG_FIFO */
      3X  17584         /* Too much memory claimed for other stuff? */     
      3X  17585         fifoSize = MIN(memEnd - maxOffset, (0x01 << 18));
      3X  17586         rv = (maxOffset < memEnd);
      3X  17587         if (!rv) {
      3X  17588           GDBG_INFO(0, "Error: Tried to place cmd fifo (0x%X) past end of fbi mem (0x%X).\n",
      3X  17589                     maxOffset, memEnd);
      3X  17590           goto BAILOUT;
      3X  17591         }          
      3X  17592 #endif /* !GLIDE_USE_DEBUG_FIFO */
      3X  17593         
      3X  17594         /* Place fifo in hw. Taking all of the remainging memory up to the
      3X  17595          * byte swizzling bit in the cmd fifo address.
      3X  17596          */          
      3X  17597         gc->cmdTransportInfo.fifoOffset = memEnd - fifoSize;
      3X  17598 
      3X  17599 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      3X  17600         rv = fxHalInitCmdFifo(hw, /* sst */
      3X  17601                               0, /* which fifo - always 0 for cvg */
      3X  17602                               /* V fifoStart - offset from hw base V */
      3X  17603                               gc->cmdTransportInfo.fifoOffset,  
      3X  17604                               fifoSize, /* size - in bytes */
      3X  17605                               FXFALSE, /* directExec */
      3X  17606                               FXFALSE, /* disableHoles */
      3X  17607                               _grSet32);
      3X  17608 #else
      3X  17609 #error "Need HAL command fifo init routine for this hw"
      3X  17610 #endif
      3X  17611 #else /* !GLIDE_INIT_HAL */
      3X  17612         {

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      3X  17613           /* NB: This is a dummy since fifoStart is always hwBase +
      3X  17614            * HW_FIFO_OFFSET (0x200000)
      3X  17615            */
      3X  17616           FxU32 fifoStart = 0;
      3X  17617           
      3X  17618           rv = sst1InitCmdFifo(gc->reg_ptr, FXTRUE,
      3X  17619                                &fifoStart,
      3X  17620                                &gc->cmdTransportInfo.fifoOffset,
      3X  17621                                &fifoSize,
      3X  17622                                _grSet32);
      3X  17623         }
      3X  17624 #if GLIDE_USE_DEBUG_FIFO
      3X  17625         {
      3X  17626           const char* envVar = GETENV("FX_GLIDE_DEBUG_FIFO");
      3X  17627           const FxU32 debugFifoSize = ((envVar == NULL)
      3X  17628                                        ? kDebugFifoSize
      3X  17629                                        : atoi(envVar));
      3X  17630           if (fifoSize > debugFifoSize) fifoSize = debugFifoSize;
      3X  17631         }
      3X  17632 #endif /* GLIDE_USE_DEBUG_FIFO */
      3X  17633         
      3X  17634 #if GLIDE_USE_SHADOW_FIFO
      3X  17635         /* If we're debugging its nice to know what we really wrote
      3X  17636          * into the fifo space, just in case tracing is off.  
      3X  17637          */
      3X  17638         {
      3X  17639           FxU32* shadowPtr = (FxU32*)calloc(fifoSize + kPageBoundarySlop, sizeof(FxU32));
      3X  17640 
      3X  17641           if (shadowPtr == NULL) {
      3X  17642             gdbg_printf("Could not allocate shadow fifo\n");
      3X  17643           } else if (((FxU32)shadowPtr & kPageBoundaryMask) != 0x00) {
      3X  17644             shadowPtr = (FxU32*)(((FxU32)shadowPtr + kPageBoundarySlop) & ~kPageBoundaryMask);
      3X  17645           }
      3X  17646           gc->cmdTransportInfo.fifoShadowBase =
      3X  17647           gc->cmdTransportInfo.fifoShadowPtr  = shadowPtr;
      3X  17648         }
      3X  17649 #endif /* GLIDE_USE_SHADOW_FIFO */
      3X  17650 #endif /* !GLIDE_INIT_HAL */
      3X  17651 
      3X  17652         if (!rv) {
      3X  17653           GDBG_INFO(0, "Error: fxHalInitCmdFifo failed.\n");
      3X  17654           goto BAILOUT;
      3X  17655         }
      3X  17656         GR_ASSERT(fifoSize > 0);
      3X  17657 
      3X  17658         /* Pre-compute the packet to return us back to the start.
      3X  17659          *
      3X  17660          * NB: This is an actual hw address.
      3X  17661          */
      3X  17662         gc->cmdTransportInfo.fifoJmpHdr = (SSTCP_PKT0_JMP_LOCAL |
      3X  17663                                          (gc->cmdTransportInfo.fifoOffset << (SSTCP_PKT0_ADDR_SHIFT - 2)));
      3X  17664       }
      3X  17665 
      3X  17666       /* Setup virtual fifo addressing */
      3X  17667       {
      3X  17668         gc->cmdTransportInfo.fifoStart = (FxU32*)((FxU32)gc->base_ptr + HW_FIFO_OFFSET);
      3X  17669         gc->cmdTransportInfo.fifoEnd   = (FxU32*)((FxU32)gc->cmdTransportInfo.fifoStart + fifoSize);

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      3X  17670         gc->cmdTransportInfo.fifoSize  = fifoSize;
      3X  17671 
      3X  17672         /* Adjust room values. 
      3X  17673          * RoomToEnd needs enough room for the jmp packet since we
      3X  17674          * never allow the hw to auto-wrap. RoomToRead needs to be
      3X  17675          * adjusted so that we never acutally write onto the read ptr.
      3X  17676          *
      3X  17677          * fifoRoom is generally the min of roomToEnd and roomToRead,
      3X  17678          * but we 'know' here that roomToRead < roomToEnd.  
      3X  17679          */
      3X  17680         gc->cmdTransportInfo.roomToEnd       = fifoSize - FIFO_END_ADJUST;
      3X  17681         gc->cmdTransportInfo.fifoRoom        =
      3X  17682         gc->cmdTransportInfo.roomToReadPtr   =
      3X  17683           gc->cmdTransportInfo.roomToEnd - sizeof(FxU32); 
      3X  17684 
      3X  17685         /* Set initial fifo state. hw read and sw write pointers at
      3X  17686          * start of the fifo.
      3X  17687          */
      3X  17688         gc->cmdTransportInfo.fifoPtr  = gc->cmdTransportInfo.fifoStart;
      3X  17689         gc->cmdTransportInfo.fifoRead = HW_FIFO_PTR(FXTRUE);
      3X  17690 
      3X  17691         GDBG_INFO(gc->myLevel, 
      3X  17692                   "Fifo Parameters:\n"
      3X  17693                   "\tStart: 0x%X\n"
      3X  17694                   "\tHW Read: 0x%X\n"
      3X  17695                   "\tHW Offset: 0x%X\n"
      3X  17696                   "\tSW Write: 0x%X\n",
      3X  17697                   gc->cmdTransportInfo.fifoStart,
      3X  17698                   gc->cmdTransportInfo.fifoRead,
      3X  17699                   gc->cmdTransportInfo.fifoOffset,
      3X  17700                   gc->cmdTransportInfo.fifoPtr);
      3X  17701       }
      3X  17702 #endif /* USE_PACKET_FIFO */
      3	  17703 
      3	  17704       /* We expect that lfb writes will *NOT* go through the fifo, and that the
      3	  17705        * fifo is ready for commands.
      3	  17706        */
      3	  17707       gc->cmdTransportInfo.fifoLfbP     = FXFALSE;
      3	  17708       gc->cmdTransportInfo.lfbLockCount = 0;
      3	  17709 #undef MB2B
      2	  17710     }
      2	  17711 
      2X  17712 #if !GLIDE_INIT_HAL && 0
      2	  17713     /* dpc - 24 jan 1998 - FixMe!  
      2	  17714      * This is currently being done in _grDetectResources so that we
      2	  17715      * can match the nt driver semantics in win95.  
      2X  17716      */
      2X  17717     /*if (_GlideRoot.CPUType.family >= 6) {*/
      2X  17718       sst1InitCaching(gc->reg_ptr, FXTRUE);
      2X  17719     /*}*/
      2X  17720 #endif /* !GLIDE_INIT_HAL */
      2X  17721 #else
      2X  17722 #error "Need to write command transport init for glide for this hw"
      2X  17723 #endif
      1	  17724   }
      1	  17725   
      1	  17726   /* We're effectively open now */

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  17727   gc->open = FXTRUE;
      1	  17728 
      1	  17729   /*------------------------------------------------------
      1	  17730     GC Init
      1	  17731     ------------------------------------------------------*/
      1	  17732   GDBG_INFO(gc->myLevel, "  GC Init\n");
      1	  17733   gc->state.screen_width  = xres;
      1	  17734   gc->state.screen_height = yres;
      1	  17735   gc->state.num_buffers   = nColBuffers;
      1	  17736   gc->state.color_format  = format;
      1	  17737   gc->grSstRez            = resolution;
      1	  17738   gc->grSstRefresh        = refresh;
      1	  17739 
      1	  17740   gc->lockPtrs[GR_LFB_READ_ONLY]  = (FxU32)-1;
      1	  17741   gc->lockPtrs[GR_LFB_WRITE_ONLY] = (FxU32)-1;
      1	  17742   gc->fbStride = fbStride;
      1	  17743   
      1	  17744   /* Initialize the read/write registers to all 0 */
      1	  17745   gc->state.fbi_config.fbzColorPath  = 0;
      1	  17746   gc->state.fbi_config.fogMode       = 0;
      1	  17747   gc->state.fbi_config.alphaMode     = 0;
      1	  17748   gc->state.fbi_config.fbzMode       = 0;
      1	  17749   gc->state.fbi_config.lfbMode       = 0;
      1	  17750   gc->state.fbi_config.clipLeftRight = 0;
      1	  17751   gc->state.fbi_config.clipBottomTop = 0;
      1	  17752   gc->state.fbi_config.fogColor      = 0;
      1	  17753   gc->state.fbi_config.zaColor       = 0;
      1	  17754   gc->state.fbi_config.chromaKey     = 0;
      1	  17755   gc->state.fbi_config.stipple       = 0;
      1	  17756   gc->state.fbi_config.color0        = 0;
      1	  17757   gc->state.fbi_config.color1        = 0;
      1	  17758 
      2	  17759   for (tmu = 0; tmu < gc->num_tmu; tmu += 1) {
      2	  17760     const GrHwConfiguration* hwConfig = &_GlideRoot.hwConfig;
      2	  17761     FxU32 textureMode = (FxU32)SST_SEQ_8_DOWNLD;
      2	  17762 
      2	  17763     if ((hwConfig->SSTs[_GlideRoot.current_sst].type == GR_SSTTYPE_VOODOO) && 
      3	  17764         (hwConfig->SSTs[_GlideRoot.current_sst].sstBoard.VoodooConfig.tmuConfig[tmu].tmuRev == 0)) {
      3	  17765       textureMode = 0;
      2	  17766     }
      2	  17767 
      2	  17768     gc->state.tmu_config[tmu].textureMode     = textureMode;
      2	  17769     gc->state.tmu_config[tmu].tLOD            = 0x00000000;
      2	  17770     gc->state.tmu_config[tmu].tDetail         = 0x00000000;
      2	  17771     gc->state.tmu_config[tmu].texBaseAddr     = 0x00000000;
      2	  17772     gc->state.tmu_config[tmu].texBaseAddr_1   = 0x00000000;
      2	  17773     gc->state.tmu_config[tmu].texBaseAddr_2   = 0x00000000;
      2	  17774     gc->state.tmu_config[tmu].texBaseAddr_3_8 = 0x00000000;
      2	  17775     gc->state.tmu_config[tmu].mmMode          = GR_MIPMAP_NEAREST;
      2	  17776     gc->state.tmu_config[tmu].smallLod        = GR_LOD_1;
      2	  17777     gc->state.tmu_config[tmu].largeLod        = GR_LOD_1;
      2	  17778     gc->state.tmu_config[tmu].evenOdd         = GR_MIPMAPLEVELMASK_BOTH;
      2	  17779     gc->state.tmu_config[tmu].nccTable        = GR_NCCTABLE_NCC0;
      1	  17780   } 
      1	  17781 
      1	  17782   /*------------------------------------------------------
      1	  17783     3D State Init 

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 26
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  17784     ------------------------------------------------------*/
      1	  17785   GDBG_INFO(gc->myLevel, "  3D State Init\n");
      1	  17786   gc->state.fbi_config.fbzMode = (SST_ENRECTCLIP | 
      1	  17787                                   SST_ENZBIAS    | 
      1	  17788                                   SST_DRAWBUFFER_BACK);
      1	  17789   
      1	  17790   grHints(GR_HINT_ALLOW_MIPMAP_DITHER, 0);
      1	  17791   grSstOrigin(origin);
      1	  17792   grAlphaBlendFunction(GR_BLEND_ONE , GR_BLEND_ZERO, 
      1	  17793                        GR_BLEND_ONE, GR_BLEND_ZERO);
      1	  17794   grAlphaTestFunction(GR_CMP_ALWAYS);
      1	  17795   grAlphaTestReferenceValue(0);
      1	  17796   grChromakeyMode(GR_CHROMAKEY_DISABLE);
      1	  17797   grConstantColorValue((FxU32) ~0);
      1	  17798   grClipWindow(0, 0, gc->state.screen_width, 
      1	  17799                gc->state.screen_height);
      1	  17800   _grColorCombineDelta0Mode(FXFALSE);
      1	  17801   grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
      1	  17802                  GR_COMBINE_FACTOR_ONE,
      1	  17803                  GR_COMBINE_LOCAL_ITERATED,
      1	  17804                  GR_COMBINE_OTHER_ITERATED,
      1	  17805                  FXFALSE);
      1	  17806   grAlphaCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
      1	  17807                  GR_COMBINE_FACTOR_ONE,
      1	  17808                  GR_COMBINE_LOCAL_NONE,
      1	  17809                  GR_COMBINE_OTHER_CONSTANT,
      1	  17810                  FXFALSE);
      1	  17811   grColorMask(FXTRUE, FXFALSE);
      1	  17812   grCullMode(GR_CULL_DISABLE);
      1	  17813   grDepthBiasLevel(0);
      1	  17814   grDepthMask(FXFALSE);
      1	  17815   grDepthBufferMode(GR_DEPTHBUFFER_DISABLE);
      1	  17816   grDepthBufferFunction(GR_CMP_LESS);
      1	  17817   grDepthBiasLevel(0);
      1	  17818   grDitherMode(GR_DITHER_4x4);
      1	  17819   grFogMode(GR_FOG_DISABLE);
      1	  17820   grFogColorValue(0x00000000);
      1X  17821 #ifdef ENABLE_REGISTRY_GAMMA_RGB_AND_GAMMA_TABLE
      1X  17822   {
      1X  17823     char* gammaRGBTableStr;
      1X  17824     char* gammaRGBStr;
      1X  17825     char* str;
      1X  17826     /*
      1X  17827     ** if we decided to enable gammargb and gammatable, we need to 
      1X  17828     ** bump the buffer size in GETENV
      1X  17829     */
      1X  17830     if (gammaRGBTableStr = GETENV("FX_GLIDE_GAMMATABLE_SIZE")) {
      1X  17831       FxU32 entries, i;
      1X  17832       float red[256], green[256], blue[256];
      1X  17833       FxBool useGammaTable = FXTRUE;
      1X  17834       GR_BEGIN_NOFIFOCHECK("Hack for Gamma Table",80);
      1X  17835       str = strtok(gammaRGBTableStr, " ");
      1X  17836       entries = atol(str);
      1X  17837       if (gammaRGBTableStr = GETENV("FX_GLIDE_GAMMATABLE_RED")) {
      1X  17838         str = strtok(gammaRGBTableStr, " ");
      1X  17839         red[0] = (float)atof(str);
      1X  17840         for (i = 1; i < entries; i++) {

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 27
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1X  17841           str = strtok(NULL, " ");
      1X  17842           red[i] = (float)atof(str);
      1X  17843         }
      1X  17844       }
      1X  17845       else
      1X  17846         useGammaTable = FXFALSE;
      1X  17847       if (gammaRGBTableStr = GETENV("FX_GLIDE_GAMMATABLE_GREEN")) {
      1X  17848         str = strtok(gammaRGBTableStr, " ");
      1X  17849         green[0] = (float)atof(str);
      1X  17850         for (i = 1; i < entries; i++) {
      1X  17851           str = strtok(NULL, " ");
      1X  17852           green[i] = (float)atof(str);
      1X  17853         }
      1X  17854       }
      1X  17855       else
      1X  17856         useGammaTable = FXFALSE;
      1X  17857       if (gammaRGBTableStr = GETENV("FX_GLIDE_GAMMATABLE_BLUE")) {
      1X  17858         str = strtok(gammaRGBTableStr, " ");
      1X  17859         blue[0] = (float)atof(str);
      1X  17860         for (i = 1; i < entries; i++) {
      1X  17861           str = strtok(NULL, " ");
      1X  17862           blue[i] = (float)atof(str);
      1X  17863         }
      1X  17864       }
      1X  17865       else
      1X  17866         useGammaTable = FXFALSE;
      1X  17867       if (useGammaTable)
      1X  17868         sst1InitGammaTable(gc->reg_ptr, entries, (FxU32 *)red, (FxU32 *)green, (FxU32 *)blue);
      1X  17869       else
      1X  17870         grGammaCorrectionValue(GLIDE_DEFAULT_GAMMA);
      1X  17871       GR_END();
      1X  17872     }
      1X  17873     else if (gammaRGBStr = GETENV("FX_GLIDE_GAMMARGB")) {
      1X  17874       float r, g, b;
      1X  17875       GR_BEGIN_NOFIFOCHECK("Hack for Gamma RGB",80);
      1X  17876       str = strtok(gammaRGBStr, " ");
      1X  17877       r = (float)atof(str);
      1X  17878       str = strtok(NULL, " ");
      1X  17879       g = (float)atof(str);
      1X  17880       str = strtok(NULL, " ");
      1X  17881       b = (float)atof(str);
      1X  17882       sst1InitGammaRGB(gc->reg_ptr, r, g, b);
      1X  17883       GR_END();
      1X  17884     }
      1X  17885     else
      1X  17886       grGammaCorrectionValue(GLIDE_DEFAULT_GAMMA);
      1X  17887   }
      1X  17888 #else
      1	  17889   grGammaCorrectionValue(GLIDE_DEFAULT_GAMMA);
      1	  17890 #endif
      1	  17891 
      1	  17892   guTexMemReset();
      1	  17893 
      2	  17894   switch (gc->num_tmu) {
      2	  17895   case 3:
      2	  17896     grTexClampMode(GR_TMU2, GR_TEXTURECLAMP_CLAMP, GR_TEXTURECLAMP_CLAMP);
      2	  17897     grTexDetailControl(GR_TMU2, 0, 1, 1.0F);

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 28
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2	  17898     grTexFilterMode(GR_TMU2, GR_TEXTUREFILTER_POINT_SAMPLED, 
      2	  17899                     GR_TEXTUREFILTER_POINT_SAMPLED);
      2	  17900     grTexLodBiasValue(GR_TMU2, 0.0F);
      2	  17901     grTexMipMapMode(GR_TMU2, GR_MIPMAP_DISABLE, FXFALSE);
      2	  17902     grTexCombineFunction(GR_TMU2, GR_TEXTURECOMBINE_ZERO);
      2	  17903     grTexCombine(GR_TMU2, GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17904                  GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17905                  FXFALSE, FXFALSE);
      2	  17906   case 2:
      2	  17907     grTexClampMode(GR_TMU1, GR_TEXTURECLAMP_CLAMP, GR_TEXTURECLAMP_CLAMP);
      2	  17908     grTexDetailControl(GR_TMU1, 0, 1, 1.0F);
      2	  17909     grTexFilterMode(GR_TMU1, GR_TEXTUREFILTER_POINT_SAMPLED, 
      2	  17910                     GR_TEXTUREFILTER_POINT_SAMPLED);
      2	  17911     grTexLodBiasValue(GR_TMU1, 0.0F);
      2	  17912     grTexMipMapMode(GR_TMU1, GR_MIPMAP_DISABLE, FXFALSE);
      2	  17913     grTexCombine(GR_TMU1, GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17914                  GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17915                  FXFALSE, FXFALSE);
      2	  17916   case 1:
      2	  17917     grTexClampMode(GR_TMU0, GR_TEXTURECLAMP_CLAMP, GR_TEXTURECLAMP_CLAMP);
      2	  17918     grTexDetailControl(GR_TMU0, 0, 1, 1.0F);
      2	  17919     grTexFilterMode(GR_TMU0, GR_TEXTUREFILTER_POINT_SAMPLED, 
      2	  17920                     GR_TEXTUREFILTER_POINT_SAMPLED);
      2	  17921     grTexLodBiasValue(GR_TMU0, 0.0F);
      2	  17922     grTexMipMapMode(GR_TMU0, GR_MIPMAP_DISABLE, FXFALSE);
      2	  17923     grTexCombine(GR_TMU0, GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17924                  GR_COMBINE_FUNCTION_ZERO, GR_COMBINE_FACTOR_NONE,
      2	  17925                  FXFALSE, FXFALSE);
      1	  17926   }
      1	  17927   grLfbConstantAlpha(0xFF);
      1	  17928   grLfbConstantDepth(0);
      1	  17929 
      1	  17930   /* --------------------------------------------------------
      1	  17931      Splash Screen
      1	  17932      --------------------------------------------------------*/
      1X  17933 #ifdef GLIDE_SPLASH
      1X  17934 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      1X  17935   if (!_GlideRoot.environment.noSplash) {
      1X  17936     HMODULE newSplash = LoadLibrary("3dfxspl2.dll");
      1X  17937 
      1X  17938     if (newSplash) {
      1X  17939       GrState glideState;
      1X  17940       FxBool didLoad;
      1X  17941       GrSplashProc fxSplash;
      1X  17942       GrSplashInitProc fxSplashInit;
      1X  17943       GrSplashPlugProc fxSplashPlug;
      1X  17944       GrSplashShutdownProc fxSplashShutdown;
      1X  17945 
      1X  17946       fxSplash = (GrSplashProc)GetProcAddress(newSplash, "_fxSplash@20");
      1X  17947       fxSplashInit = (GrSplashInitProc)GetProcAddress(newSplash, "_fxSplashInit@24");
      1X  17948       fxSplashPlug = (GrSplashPlugProc)GetProcAddress(newSplash, "_fxSplashPlug@16");
      1X  17949       fxSplashShutdown = (GrSplashShutdownProc)GetProcAddress(newSplash, "_fxSplashShutdown@0");
      1X  17950 
      1X  17951       didLoad = ((fxSplash != NULL) &&
      1X  17952                  (fxSplashInit != NULL) &&
      1X  17953                  (fxSplashPlug != NULL) &&
      1X  17954                  (fxSplashShutdown != NULL));

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 29
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1X  17955 
      1X  17956       if (didLoad & 0/* [dBorca] i am evil! harr-harr */) {
      1X  17957         /* new style DLL */
      1X  17958         grGlideGetState(&glideState);
      1X  17959         didLoad = fxSplashInit(hWnd,
      1X  17960                                gc->state.screen_width, gc->state.screen_height,
      1X  17961                                nColBuffers, nAuxBuffers,
      1X  17962                                format);
      1X  17963         if (didLoad) {
      1X  17964           fxSplash(0.0f, 0.0f, 
      1X  17965                    (float)gc->state.screen_width,
      1X  17966                    (float)gc->state.screen_height,
      1X  17967                    0);
      1X  17968           fxSplashShutdown();
      1X  17969           _GlideRoot.environment.noSplash = 1;
      1X  17970         }
      1X  17971         grGlideSetState((const void*)&glideState);
      1X  17972       } else {
      1X  17973         /* old style DLL */
      1X  17974         typedef int (FX_CALL *GrSplashOld) (FxU32 hWind, FxU32 scrWidth, FxU32 scrHeight, FxU32 nAuxBuffers);
      1X  17975         GrSplashOld fxSplashOld = (GrSplashOld)GetProcAddress(newSplash, "_fxSplash@16");
      1X  17976         if (fxSplashOld) {
      1X  17977             grGlideGetState(&glideState);
      1X  17978             fxSplashOld(hWnd, gc->state.screen_width, gc->state.screen_height, nAuxBuffers);
      1X  17979             _GlideRoot.environment.noSplash = 1;
      1X  17980 	    grGlideSetState((const void*)&glideState);
      1X  17981 	}
      1X  17982       }
      1X  17983 
      1X  17984       FreeLibrary(newSplash);
      1X  17985     }
      1X  17986   }
      1X  17987 #endif /* (GLIDE_PLATFORM & GLIDE_OS_WIN32) */
      1X  17988 
      1X  17989         /* If it's still 0, then do the old one */
      1X  17990   if (!_GlideRoot.environment.noSplash) {
      1X  17991     grSplash(0.0f, 0.0f, 
      1X  17992              (float) gc->state.screen_width,
      1X  17993              (float) gc->state.screen_height,
      1X  17994              0);
      1X  17995     _GlideRoot.environment.noSplash = 1;
      1X  17996   }
      1X  17997 #endif
      1	  17998 
      1	  17999   _GlideRoot.windowsInit = FXTRUE; /* to avoid race with grSstControl() */
      1	  18000 
      1	  18001 BAILOUT:
      1	  18002    GR_RETURN(rv);
      1	  18003 #undef FN_NAME
      1	  18004 } /* grSstWinOpen */
	  18005 
	  18006 /*-------------------------------------------------------------------
	  18007   Function: grSstWinClose
	  18008   Date: 3/16
	  18009   Implementor(s): jdt
	  18010   Library: Glide
	  18011   Description:

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 30
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	  18012   Shut down the selected SST
	  18013 
	  18014   Shutdown has 4 steps
	  18015 
	  18016   3D Idle 
	  18017     the 3D engine must be idled to make sure that there are no
	  18018     commands executing in the transport when the registers are
	  18019     reset
	  18020 
	  18021   GC Reset
	  18022     the GC is flagged as unitialized - (nosup)
	  18023 
	  18024   Command Transport Disable
	  18025     the command transport to the 3D device is put in a state
	  18026     of reset.  No further commands may be issued throught the
	  18027     command transport
	  18028 
	  18029   Video Restore
	  18030     video is restored to its pre-open state.
	  18031 
	  18032   Arguments:
	  18033   none
	  18034   Return:
	  18035   none
	  18036   -------------------------------------------------------------------*/
	  18037 GR_ENTRY(grSstWinClose, void, (void))
      1	  18038 {
      1	  18039 #define FN_NAME "grSstWinClose"
      1	  18040   GR_BEGIN_NOFIFOCHECK("grSstWinClose", 80);
      1	  18041   GDBG_INFO_MORE(gc->myLevel,"()\n");
      1	  18042 
      2	  18043   if ((gc != NULL) && gc->open) {
      2X  18044 #if GLIDE_INIT_HAL
      2	  18045     /* dpc - 22 may 1997 - FixMe!
      2	  18046      * We need the equivilant stuff in the hal layer too.
      2X  18047      */
      2X  18048 #else /* !GLIDE_INIT_HAL */
      2X  18049 #if GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY
      2	  18050     /* Make sure that linear memory is back to the 'happy' state
      2	  18051      * before shutting down so that any re-inits are not going to die
      2	  18052      * on access violations.
      2X  18053      */
      2X  18054     grHints(GR_HINT_LFB_RESET, 0);
      2X  18055 #endif /* GLIDE_DEBUG || GLIDE_CHECK_COMPATABILITY */
      2	  18056 
      2	  18057     /*--------------------------
      2	  18058       3D Idle
      2	  18059       --------------------------*/
      2	  18060     GDBG_INFO(gc->myLevel, "  3D Idle");
      2	  18061     /* dpc - 5 sep 1997
      2	  18062      * The old way.
      2	  18063      *
      2	  18064      * initIdle();
      2	  18065      */
      2	  18066     sst1InitIdle(gc->reg_ptr);
      2	  18067     
      2	  18068     /*--------------------------

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 31
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2	  18069       Command Transport Disable
      2	  18070       --------------------------*/
      2	  18071     GDBG_INFO(gc->myLevel, "  Command Transport Disable");
      2	  18072     /* dpc - 5 sep 1997
      2	  18073      * The old way.
      2	  18074      *
      2	  18075      * initDisableTransport();
      2	  18076      */
      2	  18077     /* When disabling all of the parameters other than sstBase and the
      2	  18078      * enable flag are ignored.  
      2	  18079      */
      2	  18080     sst1InitCmdFifo(gc->reg_ptr, FXFALSE, NULL, NULL, NULL, NULL);
      2	  18081     
      2	  18082     /*--------------------------
      2	  18083       Video Restore 
      2	  18084       --------------------------*/
      2	  18085     GDBG_INFO(gc->myLevel, "  Restore Video");
      2	  18086     /* dpc - 5 sep 1997 - FixMe!
      2	  18087      * Uhhh.... what is the new call to do this?
      2	  18088      *
      2	  18089      * initRestoreVideo();
      2	  18090      */
      2	  18091     /* The shutdown takes care of restoring the video etc.  The
      2	  18092      * shutdown also takes care of cleaning up sli now just in case
      2	  18093      * someone (test27) tries to re-open the sli pair later because
      2	  18094      * the init sequence has trouble sometimes re-initting if the
      2	  18095      * boards are still paired.
      2	  18096      *
      2	  18097      * NB: We do have to cleanup any processor caching characteristics
      2	  18098      * here because sst1InitShutdown will unlink the connection
      2	  18099      * between our hw address and its internal structures which keep
      2	  18100      * track of the mtrr's.
      2	  18101      */
      2	  18102     sst1InitIdle(gc->reg_ptr);
      2	  18103     /*if (_GlideRoot.CPUType.family >= 6) {*/
      2	  18104       sst1InitCaching(gc->base_ptr, FXFALSE);
      2	  18105     /*}*/
      2	  18106     sst1InitShutdown(gc->reg_ptr);
      2	  18107 #endif /* !GLIDE_INIT_HAL */
      2	  18108 
      2	  18109     /*--------------------------
      2	  18110       GC Reset
      2	  18111       --------------------------*/
      2	  18112     GDBG_INFO(gc->myLevel, "  GC Reset");
      2	  18113 
      2	  18114     /* open and hwInitP are really two different things.  
      2	  18115      *
      2	  18116      * hwInitP indicates whether the init code mapping/init sequence
      2	  18117      * is active for this hw. 
      2	  18118      *
      2	  18119      * open includes setting up video, command transport, and the
      2	  18120      * initial glide state.
      2	  18121      */
      2	  18122     gc->hwInitP = FXFALSE;
      2	  18123     if (gc->scanline_interleaved) (gc + 1)->hwInitP = FXFALSE;
      2	  18124       
      2	  18125     /* If we swapped the monitor sense on open then switch these

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 32
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2	  18126      * back so that any later re-mappings of the board are in sync
      2	  18127      * w/ the init code's mappings.  
      2	  18128      */
      3	  18129     if (gc->swapMasterSenseP) {
      3	  18130 #define SwapPtrVal(__a, __b) do { FxU32* temp = (__a); (__a) = (__b); (__b) = temp; } while(0);
      3	  18131       SwapPtrVal(gc->base_ptr,  (gc + 1)->base_ptr);
      3	  18132       SwapPtrVal(gc->reg_ptr,   (gc + 1)->reg_ptr);
      3	  18133       SwapPtrVal(gc->tex_ptr,   (gc + 1)->tex_ptr);
      3	  18134       SwapPtrVal(gc->lfb_ptr,   (gc + 1)->lfb_ptr);
      3	  18135 #undef SwapPtrVal
      3	  18136 
      3	  18137       /* Again, reset the slave pointers by hand */
      4	  18138       if (gc->scanline_interleaved) {
      4	  18139         gc->slave_ptr = (gc + 1)->base_ptr;
      4	  18140         (gc + 1)->slave_ptr = NULL;
      3	  18141       }
      3	  18142       
      3	  18143       gc->swapMasterSenseP = FXFALSE;
      2	  18144     }
      2	  18145 
      2X  18146 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      2X  18147     if (gc->oemInit) {
      2X  18148       FARPROC oemRestoreVideo = GetProcAddress(gc->oemInit, "_fxoemRestoreVideo@4");
      2X  18149 
      2X  18150       if (oemRestoreVideo != NULL) oemRestoreVideo(&gc->oemi);
      2X  18151       FreeLibrary(gc->oemInit);
      2X  18152     }
      2X  18153 #endif
      1	  18154   }
      1	  18155   gc->open = FXFALSE;
      1	  18156     
      1	  18157   GR_END();
      1	  18158 #undef FN_NAME
      1	  18159 } /* grSstWinClose */
	  18160 
	  18161 GR_ENTRY(grSstControl, FxBool, (GrControl_t code)) 
      1	  18162 {
      1	  18163   GR_DCL_GC;
      1	  18164 #define FN_NAME "grSstControl"  
      1	  18165   GDBG_INFO(41, "%s:  code = 0x%x, windowsInit = %d\n", FN_NAME,
      1	  18166             code, _GlideRoot.windowsInit);
      1	  18167   
      2	  18168   if (_GlideRoot.windowsInit && gc->open) {
      2X  18169 #if (GLIDE_PLATFORM & GLIDE_HW_SST96)
      2	  18170     /* For VG96, windows haven't been created, so there's no point
      2	  18171      * trying to control it. 
      2X  18172      */
      2X  18173     
      2X  18174     /* Believe it or not, the following code really should be bracketed
      2X  18175        like this.  The reason is that GR_BEGIN_NOFIFOCHECK seg faults
      2X  18176        when grSstControl is called before the Glide window is truly
      2X  18177        initialized.  This is a real concern, as grSstControl is called
      2X  18178        from event loops, which are asynchronous.
      2X  18179        */
      2X  18180     FxU32
      2X  18181       status,
      2X  18182       xRes, yRes,

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 33
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      2X  18183       clipLeftRight, clipBottomTop;
      2X  18184     
      2X  18185     GR_BEGIN_NOFIFOCHECK(FN_NAME,80);
      2X  18186     
      2X  18187     xRes = initControl(code);
      2X  18188     
      2X  18189     GDBG_INFO((80, "%s:  initControl returned 0x%x\n", FN_NAME, xRes));
      2X  18190 
      2X  18191     if (!xRes) return FXFALSE;
      2X  18192   
      2X  18193     yRes = xRes >> 16;
      2X  18194     xRes = xRes & 0xffff;
      2X  18195   
      2X  18196     /* !! FIXME +++ this call should properly update the gc->fbStride,
      2X  18197        this information is known only to the init layer and needs to be
      2X  18198        exposed, it is only really necessary to lfblock right now,
      2X  18199        and therefore is returned by initGetBufferPtr */
      2X  18200   
      2X  18201     gc->state.screen_width = xRes;
      2X  18202     gc->state.screen_height = yRes;
      2X  18203 
      2X  18204     /* Wait for Idle. */
      2X  18205   
      2X  18206     nTries = 0;
      2X  18207     do {
      2X  18208       if (nTries++ > 999) {
      2X  18209         GDBG_INFO((80, "%s:  returning FALSE after %d checks for idle\n", 
      2X  18210                    FN_NAME, nTries));
      2X  18211         return FXFALSE;
      2X  18212       }
      2X  18213 
      2X  18214       status = GET(hw->status);
      2X  18215         
      2X  18216     } while (status & 0x1);
      2X  18217 
      2X  18218     /* Set ClipRect Via direct writes */
      2X  18219     _grClipNormalizeAndGenerateRegValues(0, 0, xRes, yRes,
      2X  18220                                          &clipLeftRight,
      2X  18221                                          &clipBottomTop);
      2X  18222     SET_DIRECT(clipLeftRight1, clipLeftRight);
      2X  18223     SET_DIRECT(clipBottomTop1, clipBottomTop);
      2X  18224 
      2X  18225 #elif (GLIDE_PLATFORM&GLIDE_HW_SST1)
      2X  18226     return initControl(code);
      2X  18227 #elif (GLIDE_PLATFORM & GLIDE_HW_CVG) && !GLIDE_INIT_HAL
      3	  18228     {
      3	  18229       FxBool isValidP = FXTRUE;
      3	  18230       FxBool passFlag = 0;
      3	  18231 
      4	  18232       switch ( code ) {
      4	  18233       case GR_CONTROL_DEACTIVATE:
      4	  18234         passFlag = FXTRUE;
      4	  18235         break;
      4	  18236 
      4	  18237       case GR_CONTROL_ACTIVATE:
      4	  18238         passFlag = FXFALSE;
      4	  18239         break;

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 34
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      4	  18240 
      4	  18241       default:
      4	  18242         isValidP = FXFALSE;
      3	  18243       }
      3	  18244 
      3	  18245       if (isValidP) sst1InitVgaPassCtrl(gc->base_ptr, passFlag);
      3X  18246 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
      3X  18247       {
      3X  18248         if (gc->oemInit) {
      3X  18249           FARPROC oemControl = GetProcAddress(gc->oemInit, "_fxoemControl@4");
      3X  18250           if (oemControl)
      3X  18251             oemControl(code);
      3X  18252         }
      3X  18253       }
      3X  18254 #endif
      3	  18255 
      2	  18256     }
      2	  18257 #endif
      1	  18258   }
      1	  18259 
      1	  18260   GDBG_INFO(41, "%s:  Returning TRUE\n", FN_NAME);
      1	  18261   return FXTRUE;  
      1	  18262 #undef FN_NAME
      1	  18263 } /* grSstControl */
	  18264 
	  18265 /*---------------------------------------------------------------------------
	  18266 **  grSstPerfStats
	  18267 */ 
	  18268 GR_ENTRY(grSstPerfStats, void, (GrSstPerfStats_t *pStats))
      1	  18269 {
      1	  18270 #define FN_NAME "grSstPerfStats"
      1	  18271   GR_BEGIN_NOFIFOCHECK("grSstPerfStats",83);
      1	  18272   GDBG_INFO_MORE(gc->myLevel,"(0x%x)\n",pStats);
      1	  18273   GR_CHECK_F(FN_NAME, !pStats, "NULL pointer");
      1	  18274 
      1	  18275   pStats->pixelsIn   = GR_GET(hw->stats.fbiPixelsIn);
      1	  18276   pStats->chromaFail = GR_GET(hw->stats.fbiChromaFail);
      1	  18277   pStats->zFuncFail  = GR_GET(hw->stats.fbiZfuncFail);
      1	  18278   pStats->aFuncFail  = GR_GET(hw->stats.fbiAfuncFail);
      1	  18279   pStats->pixelsOut  = GR_GET(hw->stats.fbiPixelsOut);
      1	  18280 
      1	  18281   GR_END();
      1	  18282 #undef FN_NAME
      1	  18283 } /* grSstPerfStats */
	  18284 
	  18285 /*---------------------------------------------------------------------------
	  18286 **  grStatsResetPerfStats
	  18287 */
	  18288 
	  18289 GR_ENTRY(grSstResetPerfStats, void, (void))
      1	  18290 {
      1	  18291 #define FN_NAME "grSstResetPerfStats"
      1	  18292   GR_BEGIN("grSstResetPerfStats",83,4, 1);
      1	  18293   GDBG_INFO_MORE(gc->myLevel,"()\n");
      1	  18294   GR_SET(BROADCAST_ID, hw, nopCMD, 1);
      1	  18295   GR_END();
      1	  18296 #undef FN_NAME

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 35
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  18297 } /* grSstResetPerfStats */
	  18298 
	  18299 
	  18300 /*---------------------------------------------------------------------------
	  18301 **  grSstStatus - return contents of status register
	  18302 */
	  18303 
	  18304 GR_ENTRY(grSstStatus, FxU32, (void))
      1	  18305 {
      1	  18306   GR_BEGIN_NOFIFOCHECK("grSstStatus", 85);
      1	  18307 
      2	  18308   {
      2	  18309     const FxU32 stat = GR_GET(hw->status);
      2	  18310     
      2	  18311     GDBG_INFO(84,"grSstStatus() => 0x%x\n", stat);
      2	  18312     
      2	  18313     return stat;
      1	  18314   }
      1	  18315 }/* grSstStatus */
	  18316 
	  18317 /*---------------------------------------------------------------------------
	  18318 **  grSstVideoLine - return current video line number
	  18319 */
	  18320 
	  18321 GR_ENTRY(grSstVideoLine, FxU32, (void))
      1	  18322 {
      1	  18323   FxU32 vline = 1;
      1X  18324 #if (GLIDE_PLATFORM & GLIDE_HW_SST1)
      1X  18325   GR_DCL_GC;
      1X  18326   GR_DCL_HW;
      1X  18327 
      1X  18328   vline = GR_GET(hw->vRetrace);
      1X  18329   GDBG_INFO(84,"grSstVideoLine() => 0x%x (%d)\n",vline,vline);
      1X  18330 #endif
      1	  18331   return vline;
      1	  18332 }/* grSstVideoLine */
	  18333 
	  18334 /*---------------------------------------------------------------------------
	  18335 **  grSstVRetrace - return contents of SST_VRETRACE bit of status register;
	  18336 */
	  18337 
	  18338 GR_ENTRY(grSstVRetraceOn, FxBool, (void))
      1	  18339 {
      1	  18340   return ((grSstStatus() & SST_VRETRACE) == 0);
      1	  18341 }/* grSstVRetrace */
	  18342 
	  18343 /*---------------------------------------------------------------------------
	  18344 ** grSstIdle/grFinish
	  18345 */
	  18346 GR_ENTRY(grSstIdle, void, (void))
	  18347 #define FN_NAME "grSstIdle"
      1	  18348 {
      1	  18349   GR_BEGIN_NOFIFOCHECK(FN_NAME, 83);
      1	  18350   GDBG_INFO_MORE(gc->myLevel,"()\n");
      1	  18351 
      1	  18352   IDLE_HW(hw);
      1	  18353 

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 36
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

      1	  18354   GR_END();
      1	  18355 #undef FN_NAME
      1	  18356 } /* grSstIdle */
	  18357 
	  18358 /*---------------------------------------------------------------------------
	  18359 **  grSstIsBusy - find out if the SST is busy or not
	  18360 */
	  18361 GR_ENTRY(grSstIsBusy, FxBool, (void))
      1	  18362 {
      1	  18363 #define FN_NAME "grSstIsBusy"
      1	  18364   static FxBool nopP = FXTRUE;
      1	  18365   FxBool busy;
      1	  18366   GR_BEGIN_NOFIFOCHECK("grSstIsBusy", 80);
      1	  18367 
      1	  18368   /* dpc - 22 may 1997 - FixMe!
      1	  18369    * Seems like the simplest way to do it, but is this really the way
      1	  18370    * to do it?  
      1	  18371    */
      2	  18372   if (nopP) {
      2	  18373     GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      2	  18374     GR_SET(BROADCAST_ID, hw, nopCMD, 0);
      2	  18375     GR_CHECK_SIZE();
      1	  18376   }
      1	  18377 
      1	  18378   busy = ((grSstStatus() & SST_BUSY) != 0);
      1	  18379   nopP = !busy;
      1	  18380 
      1	  18381   GDBG_INFO(84,"grSstIsBusy() => 0x%x\n", busy);
      1	  18382 
      1	  18383   return busy;
      1	  18384 #undef FN_NAME
      1	  18385 }/* grSstIsBusy */
	  18386 
	  18387 /*---------------------------------------------------------------------------
	  18388 **  grGammaCorrectionValue - set the gamma correction value
	  18389 */
	  18390 
	  18391 GR_ENTRY(grGammaCorrectionValue, void, (float gamma))
      1	  18392 {
      1	  18393   GR_BEGIN_NOFIFOCHECK("grGammaCorrectionValue",80);
      1	  18394   GDBG_INFO_MORE(gc->myLevel,"(%g)\n",gamma);
      1	  18395 
      1X  18396 #if GLIDE_INIT_HAL
      1X  18397   fxHalInitGamma(hw, gamma);
      1X  18398 #else /* !GLIDE_INIT_HAL */
      1	  18399   /* dpc - 5 sep 1997 - FixMe!
      1	  18400    * The old way
      1	  18401    *
      1	  18402    * initGamma(gam);
      1	  18403    */
      1	  18404   sst1InitGamma(gc->reg_ptr, gamma);
      1	  18405 #endif /* !GLIDE_INIT_HAL */
      1	  18406 
      1	  18407   GR_END();
      1	  18408 } /* grGammaCorrectionValue */
	  18409 
	  18410 /*---------------------------------------------------------------------------

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 37
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	  18411 **  grSstOrigin - Set the orgin orientation of the screen.
	  18412 **
	  18413 **  Returns:
	  18414 **
	  18415 **  Notes:
	  18416 **
	  18417 */
	  18418 
	  18419 GR_STATE_ENTRY(grSstOrigin, void, (GrOriginLocation_t origin))
      1	  18420 {
      1	  18421 #define FN_NAME "grSstOrigin"
      1	  18422   FxU32 fbzMode;
      1	  18423   GR_BEGIN_NOFIFOCHECK("grSstOrigin", 83);
      1	  18424   GDBG_INFO_MORE(gc->myLevel, "(%d)\n", origin);
      1	  18425 
      1	  18426   /* Initialize FBZMODE register */
      1	  18427   fbzMode = gc->state.fbi_config.fbzMode;
      1	  18428   if (origin == GR_ORIGIN_LOWER_LEFT)
      1	  18429     fbzMode |= SST_YORIGIN;
      1	  18430   else
      1	  18431     fbzMode &= ~(SST_YORIGIN);
      1	  18432 
      1	  18433   /* dpc - 22 may 1997 - FixMe! 
      1	  18434    * Do we need to do anything here for the HAL?
      1	  18435    */
      1	  18436 #if !GLIDE_INIT_HAL
      1	  18437   /* dpc - 5 sep 1997 - FixMe!
      1	  18438    * This is the old way. Is there anything else we
      1	  18439    * need to do here?
      1	  18440    *
      1	  18441    * initOrigin(origin); 
      1	  18442    */
      1	  18443 #endif
      1	  18444 
      1	  18445 #if (GLIDE_PLATFORM & GLIDE_HW_CVG)
      1	  18446   /* Sli has an 'interesting' feature where the physical scanlines
      1	  18447    * that are being rendered is dependent on the location of the y
      1	  18448    * origin. We always clear the overlap bit to black here so that
      1	  18449    * no one ever notices. This needs to be done for all of the allocated
      1	  18450    * color buffers that could have possibly have been rendered to since
      1	  18451    * the last origin swap. Rather than beeing really tricky I just do
      1	  18452    * it for every allocated color buffer.
      1	  18453    *
      1	  18454    * Origin_Lower_Left: 0:Black [1 .. screenRezY]:Rendered screenRez+1:Black
      1	  18455    * Origin_Upper_Left: [0 .. screenRezY - 1]:Rendered [screenRez-screenRez+1]:Black
      1	  18456    */
      1	  18457   if (gc->scanline_interleaved) gc->hwDep.cvgDep.sliOriginBufCount = gc->grColBuf;
      1	  18458 #endif /* (GLIDE_PLATFORM & GLIDE_HW_CVG) */
      1	  18459 
      1	  18460   gc->state.fbi_config.fbzMode = fbzMode;
      1	  18461 #if !GLIDE3
      1	  18462   GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      1	  18463   GR_SET(BROADCAST_ID, hw, fbzMode, fbzMode);
      1	  18464   GR_CHECK_SIZE();
      1	  18465 #endif
      1	  18466 #undef FN_NAME
      1	  18467 } /* grSstOrigin */

GSST                            Source Listing                   9-MAY-2021 23:43:02  VSI C V7.4-002-50R2O              Page 38
V1.0                                                             2-FEB-2021 02:11:10  gsst.c;1

	  18468 
	  18469 /* GMT: do we really have users for this???
	  18470  * CHD: No.
	  18471  * JDT: Huh?  If you're talking about grSstOrigin, you're smoking crack.
	  18472  *      if you are talking about SstConfigPipeline, it is evil and must
	  18473  *      be destroyed. :)
	  18474  * dpc: There is one user that I know of. This 'Nature' demo that Scott just
	  18475  *      gave me.
	  18476  * chd: It's a stub now.
	  18477  */
	  18478 
	  18479 
	  18480 extern FX_ENTRY void FX_CALL
	  18481 grSstConfigPipeline(GrChipID_t chip, FxU32 reg, FxU32 value);
	  18482 
	  18483 /*---------------------------------------------------------------------------
	  18484 ** grSstConfigPipeline
	  18485 */
	  18486 
	  18487 GR_ENTRY(grSstConfigPipeline, void, (GrChipID_t chip, FxU32 reg, FxU32 value))
      1	  18488 {
      1	  18489 } /* grSstConfigPipeline */
	  18490 


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSST/OBJECT=[.OU
T.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSST.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWL
IBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.
GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISET
UP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=
1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GSST.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:02"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


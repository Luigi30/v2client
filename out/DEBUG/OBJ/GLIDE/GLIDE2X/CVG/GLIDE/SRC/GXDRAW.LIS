GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

	      1 /*
	      2  ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3  ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4  ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5  ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6  ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7  ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8  ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9  ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10  ** 
	     11  ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12  ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13  ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14  ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15  ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16  ** THE UNITED STATES.  
	     17  ** 
	     18  ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19  **
	     20  ** Revision 1.1.1.1.2.2  2007/05/19 08:38:01  koolsmoky
	     21  ** packed rgb fixes
	     22  **
	     23  ** Revision 1.1.1.1.2.1  2005/01/22 14:52:02  koolsmoky
	     24  ** enabled packed argb for cmd packet type 3
	     25  **
	     26  ** Revision 1.1.1.1  1999/12/07 21:49:11  joseph
	     27  ** Initial checkin into SourceForge.
	     28  **
	     29 ** 
	     30 ** 61    3/17/98 3:00p Peter
	     31 ** removed vertex sorting
	     32  * 
	     33  * 60    12/01/97 6:13p Peter
	     34  * non-packet3 tsu triangles ooz vs z
	     35  * 
	     36  * 59    11/21/97 3:20p Peter
	     37  * direct writes tsu registers
	     38  * 
	     39  * 58    11/18/97 4:36p Peter
	     40  * chipfield stuff cleanup and w/ direct writes
	     41  * 
	     42  * 57    11/17/97 4:55p Peter
	     43  * watcom warnings/chipfield stuff
	     44  * 
	     45  * 56    11/12/97 9:54p Peter
	     46  * fixed all the muckage from new config
	     47  * 
	     48  * 55    11/03/97 4:38p Peter
	     49  * yapc fix
	     50  * 
	     51  * 54    11/01/97 10:01a Peter
	     52  * tri dispatch stuff
	     53  * 
	     54  * 53    10/29/97 2:45p Peter
	     55  * C version of Taco's packing code
	     56  * 
	     57  * 52    10/27/97 5:59p Peter

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

	     58  * removed some debugging code
	     59  * 
	     60  * 51    10/21/97 3:22p Peter
	     61  * hand pack rgb
	     62  * 
	     63  * 50    10/19/97 12:51p Peter
	     64  * no tsu happiness
	     65  * 
	     66  * 49    10/19/97 10:59a Peter
	     67  * fixed p1 tsu writes
	     68  * 
	     69  * 48    10/17/97 3:15p Peter
	     70  * removed unused addr field from datalist
	     71  * 
	     72  * 47    10/17/97 10:15a Peter
	     73  * packed rgb state cleanup
	     74  * 
	     75  * 46    10/16/97 5:33p Peter
	     76  * argb != rgba
	     77  * 
	     78  * 45    10/16/97 3:40p Peter
	     79  * packed rgb
	     80  * 
	     81  * 44    10/16/97 10:31a Peter
	     82  * fixed hoopti tsu-subtractor unsorted
	     83  * 
	     84  * 43    10/15/97 5:53p Peter
	     85  * hoopti tri compare code
	     86  * 
	     87  * 42    10/10/97 4:33p Peter
	     88  * non-packet3 tsu triangles
	     89  * 
	     90  * 41    10/08/97 5:19p Peter
	     91  * optinally clamp only texture params
	     92  * 
	     93  * 40    10/08/97 11:32a Peter
	     94  * pre-computed packet headers for packet 3
	     95  * 
	     96  * 39    9/20/97 4:42p Peter
	     97  * tri_setf fixup/big fifo
	     98  * 
	     99  * 38    9/16/97 2:50p Peter
	    100  * fixed watcom unhappiness w/ static initializers
	    101  * 
	    102  * 37    9/15/97 7:31p Peter
	    103  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	    104  * place, lfb's are on, Hmmmm.. probably more
	    105  * 
	    106  * 36    9/10/97 10:13p Peter
	    107  * fifo logic from GaryT, non-normalized fp first cut
	    108  * 
	    109  * 35    9/03/97 2:11p Peter
	    110  * start gdbg_info cleanup, fixed zero area no-tsu triangle muckage
	    111  * 
	    112  * 34    9/01/97 3:19p Peter
	    113  * no-tsu w from vertex not tmuvtx
	    114  * 

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

	    115  * 33    8/31/97 4:06p Peter
	    116  * no tsu fix
	    117  * 
	    118  * 32    8/31/97 12:04p Peter
	    119  * hacked no-tsu code
	    120  * 
	    121  * 31    7/25/97 11:40a Peter
	    122  * removed dHalf, change field name to match real use for cvg
	    123  * 
	    124  * 30    6/30/97 3:22p Peter
	    125  * cmd fifo sanity
	    126  * 
	    127  * 29    6/24/97 4:02p Peter
	    128  * proper cmd fifo placement
	    129  * 
	    130  * 28    6/23/97 4:43p Peter
	    131  * cleaned up #defines etc for a nicer tree
	    132  **
	    133  */
	    134 
	    135 #include <3dfx.h>
	    266 #include <glidesys.h>
	    398 
	    399 #define FX_DLL_DEFINITION
	    400 #include <fxdll.h>
	    521 #include <glide.h>
	   2332 #include "fxglide.h"
	  14224 
       X  14225 #ifdef GDBG_INFO_ON
       X  14226 /* Some debugging information */
       X  14227 static char *indexNames[] = {  
       X  14228   "GR_VERTEX_X_OFFSET",         /* 0 */
       X  14229   "GR_VERTEX_Y_OFFSET",         /* 1 */
       X  14230   "GR_VERTEX_Z_OFFSET",         /* 2 */
       X  14231   "GR_VERTEX_R_OFFSET",         /* 3 */
       X  14232   "GR_VERTEX_G_OFFSET",         /* 4 */
       X  14233   "GR_VERTEX_B_OFFSET",         /* 5 */
       X  14234   "GR_VERTEX_OOZ_OFFSET",       /* 6 */
       X  14235   "GR_VERTEX_A_OFFSET",         /* 7 */
       X  14236   "GR_VERTEX_OOW_OFFSET",       /* 8 */
       X  14237   "GR_VERTEX_SOW_TMU0_OFFSET",  /* 9 */
       X  14238   "GR_VERTEX_TOW_TMU0_OFFSET",  /* 10 */
       X  14239   "GR_VERTEX_OOW_TMU0_OFFSET",  /* 11 */
       X  14240   "GR_VERTEX_SOW_TMU1_OFFSET",  /* 12 */
       X  14241   "GR_VERTEX_TOW_TMU1_OFFSET",  /* 13 */
       X  14242   "GR_VERTEX_OOW_TMU1_OFFSET"	/* 14 */
       X  14243 };  
       X  14244 #endif
	  14245 
	  14246 /*
	  14247  **  _trisetup_nogradients
	  14248  **
	  14249  **  This routine does all the setup needed for drawing a triangle.  It
	  14250  **  is intended to be an exact specification for the mechanisim used
	  14251  **  to pass vertices to the assembly language triangle setup code, and
	  14252  **  as such has no optimizations at all.  Whenever a 'shortcut'
	  14253  **  routine to draw triangles (such as for antialiasing, fast lines,

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

	  14254  **  fast spans, polygons, etc) is needed, this code should be used as
	  14255  **  the starting point.
	  14256  **
	  14257  */
	  14258 GR_DDFUNC(_trisetup_nogradients,
	  14259           FxI32,
	  14260           (const GrVertex *va, const GrVertex *vb, const GrVertex *vc))
      1	  14261 {
      1	  14262 #define FN_NAME "_trisetup_nogradients"
      1	  14263   GR_DCL_GC;
      1	  14264 
      1	  14265   _GlideRoot.stats.trisProcessed++;
      1	  14266 
      1	  14267 #if GLIDE_TRI_CULLING
      2	  14268   {
      2	  14269   const float *fa = &va->x;
      2	  14270   const float *fb = &vb->x;
      2	  14271   const float *fc = &vc->x;
      2	  14272   float dxAB, dxBC, dyAB, dyBC;
      2	  14273 	
      2	  14274     /* Compute Area */
      2	  14275     dxAB = fa[GR_VERTEX_X_OFFSET] - fb[GR_VERTEX_X_OFFSET];
      2	  14276     dxBC = fb[GR_VERTEX_X_OFFSET] - fc[GR_VERTEX_X_OFFSET];
      2	  14277     
      2	  14278     dyAB = fa[GR_VERTEX_Y_OFFSET] - fb[GR_VERTEX_Y_OFFSET];
      2	  14279     dyBC = fb[GR_VERTEX_Y_OFFSET] - fc[GR_VERTEX_Y_OFFSET];
      2	  14280     
      2	  14281     /* Stash the area in the float pool for easy access */
      2	  14282     _GlideRoot.pool.ftemp1 = dxAB * dyBC - dxBC * dyAB;
      2	  14283     
      2	  14284 #define FloatVal(__f) (((__f) < 786432.875) ? (__f) : ((__f) - 786432.875))
      3	  14285     {
      3	  14286       const FxI32 j = *(FxI32*)&_GlideRoot.pool.ftemp1;
      3	  14287       const FxU32 culltest = (gc->state.cull_mode << 31UL);
      3	  14288       
      3	  14289       /* Zero-area triangles are BAD!! */
      4	  14290       if ((j & 0x7FFFFFFF) == 0) {
      4	  14291         GDBG_INFO(291, FN_NAME": Culling (%g %g) (%g %g) (%g %g) : (%g : 0x%X : 0x%X)\n",
      4	  14292                   FloatVal(fa[0]), FloatVal(fa[1]), 
      4	  14293                   FloatVal(fb[0]), FloatVal(fb[1]), 
      4	  14294                   FloatVal(fc[0]), FloatVal(fc[1]), 
      4	  14295                   _GlideRoot.pool.ftemp1, gc->state.cull_mode, culltest);
      4	  14296 
      4	  14297         return 0;
      3	  14298       }
      3	  14299       
      3	  14300       /* Backface culling, use sign bit as test */
      4	  14301       if ((gc->state.cull_mode != GR_CULL_DISABLE) && (((FxI32)(j ^ culltest)) >= 0)) {
      4	  14302         GDBG_INFO(291, FN_NAME": Culling (%g %g) (%g %g) (%g %g) : (%g : 0x%X : 0x%X)\n",
      4	  14303                   FloatVal(fa[0]), FloatVal(fa[1]), 
      4	  14304                   FloatVal(fb[0]), FloatVal(fb[1]), 
      4	  14305                   FloatVal(fc[0]), FloatVal(fc[1]), 
      4	  14306                   _GlideRoot.pool.ftemp1, gc->state.cull_mode, culltest);
      4	  14307         
      4	  14308         return -1;
      3	  14309       }
      2	  14310     }

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      1	  14311   }
      1	  14312 #endif /* GLIDE_TRI_CULLING */
      1	  14313 
      1	  14314   /* Stuff for using hw tsu */
      1	  14315 #if GLIDE_HW_TRI_SETUP
      2	  14316   {
      2	  14317     const float* vectorArray[3];
      2	  14318 
      2	  14319     /* Load up the real vertices */
      2	  14320     vectorArray[0] = &va->x;
      2	  14321     vectorArray[1] = &vb->x;
      2	  14322     vectorArray[2] = &vc->x;
      2	  14323 
      2X  14324 #if GLIDE_PACKET3_TRI_SETUP
      2X  14325     GR_SET_EXPECTED_SIZE(_GlideRoot.curTriSize, 1);
      2X  14326     TRI_BEGIN();
      2X  14327     {
      2X  14328       int vectorIndex;
      2X  14329 
      2X  14330       for(vectorIndex = 0; vectorIndex < sizeof(vectorArray) / sizeof(float*); vectorIndex++) {
      2X  14331         const float* const vector = vectorArray[vectorIndex];
      2X  14332       
      2X  14333         /* Triangle vertex coordinages (x, y) */
      2X  14334         TRI_SETF(vector[GR_VERTEX_X_OFFSET]);
      2X  14335         TRI_SETF(vector[GR_VERTEX_Y_OFFSET]);
      2X  14336       
      2X  14337         /* Other triangle parameters */
      2X  14338         {
      2X  14339           const int* dataList = gc->tsuDataList;
      2X  14340 
      2X  14341 #if GLIDE_PACKED_RGB
      2X  14342           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0)
      2X  14343           {
      2X  14344             FxBool doColorP = FXFALSE;
      2X  14345             FxU32 packedColor = 0x00;
      2X  14346             
      2X  14347             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      2X  14348               packedColor = (RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_B_OFFSET << 2)), B) | 
      2X  14349                              RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_G_OFFSET << 2)), G) |
      2X  14350                              RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_R_OFFSET << 2)), R));
      2X  14351               dataList++;
      2X  14352               doColorP = FXTRUE;
      2X  14353             }
      2X  14354 
      2X  14355             if (*dataList == (GR_VERTEX_A_OFFSET << 2)) {
      2X  14356               packedColor |= RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_A_OFFSET << 2)), A);
      2X  14357               dataList++;
      2X  14358               doColorP = FXTRUE;
      2X  14359             }
      2X  14360             
      2X  14361             if (doColorP) TRI_SET(packedColor);
      2X  14362           }
      2X  14363 #endif /* GLIDE_PACKED_RGB */
      2X  14364 
      2X  14365 #if GLIDE_FP_CLAMP_TEX
      2X  14366           while(*dataList != 0) {
      2X  14367             TRI_SETF(FARRAY(vector, *dataList));

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      2X  14368             dataList++;
      2X  14369           }
      2X  14370 
      2X  14371           dataList++;
      2X  14372 #endif /* GLIDE_FP_CLAMP_TEX */
      2X  14373          
      2X  14374           while(*dataList != 0) {
      2X  14375             TRI_SETF_CLAMP(FARRAY(vector, *dataList));
      2X  14376             dataList++;
      2X  14377           }
      2X  14378         }         
      2X  14379       }
      2X  14380     }
      2X  14381     TRI_END;
      2X  14382     GR_CHECK_SIZE();
      2X  14383 #else /* !GLIDE_PACKET3_TRI_SETUP */
      3	  14384     {
      3	  14385       GR_DCL_HW;
      3	  14386       int vectorIndex;
      3	  14387       FxU32 sMode = (gc->cmdTransportInfo.paramMask >> SSTCP_PKT3_PMASK_SHIFT);
      3	  14388       FxU32 paramMask = (sMode & 0xFF);
      3	  14389       FxU32 paramCount;
      3	  14390 
      3	  14391       /* Convert packet 3 paramMask into sMode format */
      3	  14392       sMode = (paramMask | ((sMode & 0xF000) << 4));
      3	  14393 
      4	  14394       {
      4	  14395         const FxBool hasColor = ((sMode & 0x01) != 0);
      4	  14396         const FxBool hasAlpha = ((sMode & 0x02) != 0);
      4	  14397         const FxBool hasZ = ((sMode & 0x04) != 0);
      4	  14398         const FxBool hasWb = ((sMode & 0x08) != 0);
      4	  14399         const FxBool hasW0 = ((sMode & 0x10) != 0);
      4	  14400         const FxBool hasST0 = ((sMode & 0x20) != 0);
      4	  14401         const FxBool hasW1 = ((sMode & 0x40) != 0);
      4	  14402         const FxBool hasST1 = ((sMode & 0x80) != 0);
      4	  14403 
      4	  14404         /* We always send vertex XY */
      4	  14405         paramCount = 2;
      4	  14406         paramMask = 0x03;
      4	  14407 
      4	  14408         /* Build parameter data for reg group packet */
      4X  14409 #if GLIDE_PACKED_RGB
      4X  14410         if (hasColor || hasAlpha) {
      4X  14411           paramCount += 1;
      4X  14412           paramMask |= 0x04;
      4X  14413         }
      4X  14414 #else /* !GLIDE_PACKED_RGB */
      5	  14415         if (hasColor) {
      5	  14416           paramCount += 3;
      5	  14417           paramMask |= 0x38;
      4	  14418         }
      5	  14419         if (hasAlpha) {
      5	  14420           paramCount += 1;
      5	  14421           paramMask |= 0x40;
      4	  14422         }
      4	  14423 #endif /* !GLIDE_PACKED_RGB */
      4	  14424 

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      5	  14425         if (hasZ) {
      5	  14426           paramCount += 1;
      5	  14427           paramMask |= 0x80;
      4	  14428         }
      5	  14429         if (hasWb) {
      5	  14430           paramCount += 1;
      5	  14431           paramMask |= 0x100;
      4	  14432         }
      5	  14433         if (hasW0) {
      5	  14434           paramCount += 1;
      5	  14435           paramMask |= 0x200;
      4	  14436         }
      5	  14437         if (hasST0) {
      5	  14438           paramCount += 2;
      5	  14439           paramMask |= 0xC00;
      4	  14440         }
      5	  14441         if (hasW1) {
      5	  14442           paramCount += 1;
      5	  14443           paramMask |= 0x1000;
      4	  14444         }
      5	  14445         if (hasST1) {
      5	  14446           paramCount += 2;
      5	  14447           paramMask |= 0x6000;
      4	  14448         }
      4	  14449 
      4	  14450         /* Set mode once for teh whole triangle */
      4	  14451         GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      4	  14452         GR_SET(BROADCAST_ID, hw, sSetupMode, sMode);
      4	  14453         GR_CHECK_SIZE();
      4	  14454         
      5	  14455         for(vectorIndex = 0; vectorIndex < sizeof(vectorArray) / sizeof(float*); vectorIndex++) {
      5	  14456           const GrVertex* curVertex = (const GrVertex*)vectorArray[vectorIndex];
      5	  14457           
      6	  14458           REG_GROUP_BEGIN(BROADCAST_ID, sVx, paramCount, paramMask);
      7	  14459           {
      7	  14460             REG_GROUP_SETF(hw, sVx, curVertex->x);
      7	  14461             REG_GROUP_SETF(hw, sVy, curVertex->y);
      7	  14462 
      7X  14463 #if GLIDE_PACKED_RGB
      7X  14464             if (hasColor || hasAlpha) {
      7X  14465               FxU32 packedVal = 0x00;
      7X  14466 
      7X  14467               if (hasColor) packedVal = ((RGBA_COMP_CLAMP(curVertex->b, B) << 0UL) |
      7X  14468                                          (RGBA_COMP_CLAMP(curVertex->g, G) << 8UL) |
      7X  14469                                          (RGBA_COMP_CLAMP(curVertex->r, R) << 16UL));
      7X  14470               if (hasAlpha) packedVal |= (RGBA_COMP_CLAMP(curVertex->a, A) << 24UL);
      7X  14471               
      7X  14472               REG_GROUP_SET(hw, sARGB, packedVal);
      7X  14473             }
      7X  14474 #else /* !GLIDE_PACKED_RGB */
      8	  14475             if (hasColor) {
      8	  14476               REG_GROUP_SETF(hw, sRed, curVertex->r);
      8	  14477               REG_GROUP_SETF(hw, sGreen, curVertex->g);
      8	  14478               REG_GROUP_SETF(hw, sBlue, curVertex->b);
      7	  14479             }
      7	  14480             if (hasAlpha) REG_GROUP_SETF(hw, sAlpha, curVertex->a);
      7	  14481 #endif /* !GLIDE_PACKED_RGB */

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      7	  14482 
      7	  14483             if (hasZ) REG_GROUP_SETF(hw, sVz, curVertex->ooz);
      7	  14484             if (hasWb) REG_GROUP_SETF(hw, sOowfbi, curVertex->oow);
      7	  14485 
      7	  14486             /* TMU0 */
      7	  14487             if (hasW0) REG_GROUP_SETF(hw, sOow0, curVertex->tmuvtx[0].oow);
      8	  14488             if (hasST0) {
      8	  14489               REG_GROUP_SETF(hw, sSow0, curVertex->tmuvtx[0].sow);
      8	  14490               REG_GROUP_SETF(hw, sTow0, curVertex->tmuvtx[0].tow);
      7	  14491             }
      7	  14492 
      7	  14493             /* TMU1 */
      7	  14494             if (hasW1) REG_GROUP_SETF(hw, sOow1, curVertex->tmuvtx[1].oow);
      8	  14495             if (hasST1) {
      8	  14496               REG_GROUP_SETF(hw, sSow1, curVertex->tmuvtx[1].sow);
      8	  14497               REG_GROUP_SETF(hw, sTow1, curVertex->tmuvtx[1].tow);
      7	  14498             }
      6	  14499           }
      5	  14500           REG_GROUP_END();
      5	  14501 
      5	  14502           GR_SET_EXPECTED_SIZE(sizeof(FxU32), 1);
      6	  14503           if (vectorIndex == 0) {
      6	  14504             GR_SET(BROADCAST_ID, hw, sBeginTriCMD, 0);
      6	  14505           } else {
      6	  14506             GR_SET(BROADCAST_ID, hw, sDrawTriCMD, 0);
      5	  14507           }
      5	  14508           GR_CHECK_SIZE();
      4	  14509         }
      3	  14510       }
      2	  14511     }
      2	  14512 #endif /* !GLIDE_PACKET3_TRI_SETUP */
      2	  14513 
      2	  14514     goto __triDrawn;
      1	  14515   }
      1	  14516 #endif /* GLIDE_HW_TRI_SETUP */
      1	  14517 
      1X  14518 #if !GLIDE_HW_TRI_SETUP
      1X  14519 #if !defined(GLIDE_TRI_CULLING) || !GLIDE_TRI_CULLING
      1X  14520 #error "GLIDE_TRI_CULLING must be enabled to sort vertices"
      1X  14521 #endif
      1X  14522 
      1X  14523   {
      1X  14524     GR_DCL_HW;
      1X  14525 
      1X  14526     TRI_NO_TSU_BEGIN(FXTRUE);
      1X  14527     {
      1X  14528       const float ooa = _GlideRoot.pool.f1 / _GlideRoot.pool.ftemp1;
      1X  14529       volatile FxU32* hwAddr = &hw->FvA.x;
      1X  14530             
      1X  14531       /* Divide the deltas by the area for gradient calculation. */
      1X  14532       dxBC *= ooa;
      1X  14533       dyAB *= ooa;
      1X  14534       dxAB *= ooa;
      1X  14535       dyBC *= ooa;
      1X  14536 	    
      1X  14537       GDBG_INFO(85, FN_NAME": No-TSU Triangle area: (%g %g) : (%g %g %g %g)\n",
      1X  14538                 _GlideRoot.pool.ftemp1, ooa,

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      1X  14539                 dxAB, dxBC, dyAB, dyBC);
      1X  14540       
      1X  14541       /* write out X & Y for vertex A */  
      1X  14542       TRI_NO_TSU_SETF(hwAddr++, fa[GR_VERTEX_X_OFFSET]);
      1X  14543       TRI_NO_TSU_SETF(hwAddr++, fa[GR_VERTEX_Y_OFFSET]);
      1X  14544 
      1X  14545       /* write out X & Y for vertex B */
      1X  14546       TRI_NO_TSU_SETF(hwAddr++, fb[GR_VERTEX_X_OFFSET]);
      1X  14547       TRI_NO_TSU_SETF(hwAddr++, fb[GR_VERTEX_Y_OFFSET]);  
      1X  14548   
      1X  14549       /* write out X & Y for vertex C */
      1X  14550       TRI_NO_TSU_SETF(hwAddr++, fc[GR_VERTEX_X_OFFSET]);
      1X  14551       TRI_NO_TSU_SETF(hwAddr++, fc[GR_VERTEX_Y_OFFSET]);
      1X  14552 
      1X  14553       /* Send down the starting parameter values, these come from
      1X  14554        * the sorted vertex A.
      1X  14555        */
      1X  14556       {
      1X  14557         int i = GR_VERTEX_R_OFFSET;
      1X  14558 
      1X  14559         while(i < GR_VERTEX_OOW_OFFSET) {
      1X  14560           TRI_NO_TSU_SETF(hwAddr++, fa[i++]);
      1X  14561         }
      1X  14562 
      1X  14563         /* Skip fbi oow */
      1X  14564         i++;
      1X  14565 
      1X  14566         /* FixMe? We currently only do one tmu. */
      1X  14567         while(i < GR_VERTEX_OOW_TMU0_OFFSET) {
      1X  14568           TRI_NO_TSU_SETF(hwAddr++, fa[i]);
      1X  14569           i++;
      1X  14570         }
      1X  14571 
      1X  14572         TRI_NO_TSU_SETF(hwAddr++, fa[GR_VERTEX_OOW_OFFSET]);
      1X  14573       }
      1X  14574 
      1X  14575       /* Send the x gradients */
      1X  14576       {
      1X  14577         int i = GR_VERTEX_R_OFFSET;
      1X  14578 
      1X  14579         while(i < GR_VERTEX_OOW_OFFSET) {
      1X  14580           const float curGrad = (((fa[i] - fb[i]) * dyBC) -
      1X  14581                                  ((fb[i] - fc[i]) * dyAB));
      1X  14582 		    
      1X  14583           GDBG_INFO(285, FN_NAME": Gradient 0x%X : %g %g %g : %g\n",
      1X  14584                     ((FxU32)hwAddr - (FxU32)hw) >> 2,
      1X  14585                     fa[i], fb[i], fc[i], curGrad);
      1X  14586 		    
      1X  14587           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14588           i++;
      1X  14589         }
      1X  14590 
      1X  14591         /* Skip fbi oow */
      1X  14592         i++; 
      1X  14593 
      1X  14594         /* FixMe? We currently only do one tmu. */
      1X  14595         while(i < GR_VERTEX_OOW_TMU0_OFFSET) {

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      1X  14596           const float curGrad = (((fa[i] - fb[i]) * dyBC) -
      1X  14597                                  ((fb[i] - fc[i]) * dyAB));
      1X  14598 		    
      1X  14599           GDBG_INFO(285, FN_NAME": Gradient 0x%X : %g %g %g : %g\n",
      1X  14600                     ((FxU32)hwAddr - (FxU32)hw) >> 2,
      1X  14601                     fa[i], fb[i], fc[i], curGrad);
      1X  14602 		    
      1X  14603           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14604           i++;
      1X  14605         }
      1X  14606 
      1X  14607         {
      1X  14608           const float curGrad = (((fa[GR_VERTEX_OOW_OFFSET] - fb[GR_VERTEX_OOW_OFFSET]) * dyBC) -
      1X  14609                                  ((fb[GR_VERTEX_OOW_OFFSET] - fc[GR_VERTEX_OOW_OFFSET]) * dyAB));
      1X  14610                     
      1X  14611           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14612         }
      1X  14613       }
      1X  14614 
      1X  14615       /* Send the y gradients */
      1X  14616       {
      1X  14617         int i = GR_VERTEX_R_OFFSET;
      1X  14618 
      1X  14619         while(i < GR_VERTEX_OOW_OFFSET) {
      1X  14620           const float curGrad = (((fb[i] - fc[i]) * dxAB) -
      1X  14621                                  ((fa[i] - fb[i]) * dxBC));
      1X  14622 		    
      1X  14623           GDBG_INFO(285, FN_NAME": Gradient 0x%X : %g %g %g : %g\n",
      1X  14624                     ((FxU32)hwAddr - (FxU32)hw) >> 2,
      1X  14625                     fa[i], fb[i], fc[i], curGrad);
      1X  14626 
      1X  14627           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14628           i++;
      1X  14629         }
      1X  14630 
      1X  14631         /* Skip fbi oow */
      1X  14632         i++;
      1X  14633 
      1X  14634         /* FixMe? We currently only do one tmu. */
      1X  14635         while(i < GR_VERTEX_OOW_TMU0_OFFSET) {
      1X  14636           const float curGrad = (((fb[i] - fc[i]) * dxAB) -
      1X  14637                                  ((fa[i] - fb[i]) * dxBC));
      1X  14638 		    
      1X  14639           GDBG_INFO(285, FN_NAME": Gradient 0x%X : %g %g %g : %g\n",
      1X  14640                     ((FxU32)hwAddr - (FxU32)hw) >> 2,
      1X  14641                     fa[i], fb[i], fc[i], curGrad);
      1X  14642 		    
      1X  14643           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14644           i++;
      1X  14645         }
      1X  14646 
      1X  14647         {
      1X  14648           const float curGrad = (((fb[GR_VERTEX_OOW_OFFSET] - fc[GR_VERTEX_OOW_OFFSET]) * dxAB) -
      1X  14649                                  ((fa[GR_VERTEX_OOW_OFFSET] - fb[GR_VERTEX_OOW_OFFSET]) * dxBC));
      1X  14650                     
      1X  14651           TRI_NO_TSU_SETF(hwAddr++, curGrad);
      1X  14652         }                

GXDRAW                          Source Listing                   9-MAY-2021 23:43:11  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  gxdraw.c;1

      1X  14653       }      
      1X  14654 	  
      1X  14655       /* Draw the triangle by writing the area to the triangleCMD register */
      1X  14656       TRI_NO_TSU_SETF(hwAddr, _GlideRoot.pool.ftemp1);
      1X  14657       _GlideRoot.stats.trisDrawn++;
      1X  14658     }
      1X  14659     TRI_NO_TSU_END();
      1X  14660   }
      1X  14661 
      1X  14662   goto __triDrawn;
      1X  14663 #endif /* !GLIDE_HW_TRI_SETUP */
      1	  14664 
      1	  14665 __triDrawn:
      1	  14666   /* If we made it this far then we drew the triangle */
      1	  14667   _GlideRoot.stats.trisDrawn++;
      1	  14668   GR_CHECK_SIZE();
      1	  14669 
      1	  14670   return 1;
      1	  14671     
      1	  14672 #undef FN_NAME
      1	  14673 } /* _trisetup_nogradients */


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GXDRAW/OBJECT=[.
OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GXDRAW.OBJ/INCLUDE_DIRECTORY=([.GLIDE
.SWLIBS.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GL
IDE.GLIDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TR
ISETUP,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_
LIB=1) [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GXDRAW.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:11"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

	      1 #include "vxd.h"
	     37 
	     38 /*
	     39 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	     40 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	     41 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	     42 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	     43 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	     44 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	     45 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	     46 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     47 ** 
	     48 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     49 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     50 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     51 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     52 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     53 ** THE UNITED STATES.  
	     54 ** 
	     55 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     56 */
	     57 
	     58 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
	     59 #include <stdio.h>
	   1670 #include <stdlib.h>
	   3765 #include <stdarg.h>
	   3940 #include <string.h>
	   4391 
	   4392 #include <3dfx.h>
	   4523 
       X   4524 #if __MWERKS__
       X   4525 /* Dork w/ the console window */
       X   4526 #include <sioux.h>
       X   4527 
       X   4528 /* So the debug level comes from the right place */
       X   4529 #include <cvg.h>
       X   4530 #include <sst1init.h>
       X   4531 #endif /* __MWERKS__ */
	   4532 
	   4533 #define FX_DLL_DEFINITION
	   4534 #include <fxdll.h>
	   4655 #include <fxpci.h>
	   4918 #include <gdebug.h>
	   5173 
       X   5174 #if defined(__WIN32__) && !defined(KERNEL)
       X   5175 #include <windows.h>
       X   5176 #endif /* defined(__WIN32__) && !defined(KERNEL) */
	   5177 
	   5178 #define USE_DEBUG_STRING (__DOS32__ || __WIN32__)
       X   5179 #if USE_DEBUG_STRING
       X   5180 static FxBool UseDebugString = 0;
       X   5181 #endif /* USE_DEBUG_STRING */
	   5182 
       X   5183 #ifdef KERNEL_NT
       X   5184 
       X   5185 void __stdcall
       X   5186 EngDebugPrint(

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

       X   5187     char * StandardPrefix,
       X   5188     const char * DebugMessage,
       X   5189     va_list ap
       X   5190     );
       X   5191 
       X   5192 #endif
	   5193 
	   5194 static char *gdbg_myname = "gd";		// default library name
	   5195 static char gdbg_debuglevel[GDBG_MAX_LEVELS];	// array of debuglevel controls
	   5196 
	   5197 static int gdbg_errors = 0;
	   5198 
	   5199 
       X   5200 #ifdef KERNEL
       X   5201 // gdbgout is array to store strings for debug output
       X   5202 //#include <windows.h>
       X   5203 static char gdbgout[512];
       X   5204 
       X   5205 // for setting levels interactively through the debugger while you're
       X   5206 // running in the KERNEL mode
       X   5207 void setLevel(int level, int value)
       X   5208 {
       X   5209     if (level >= GDBG_MAX_LEVELS)
       X   5210 	level = GDBG_MAX_LEVELS - 1;
       X   5211 
       X   5212     gdbg_debuglevel[level] = value;
       X   5213 }
       X   5214 
       X   5215 
       X   5216 #ifndef KERNEL_NT
       X   5217 // when the simulator runs in kernal mode there is no C runtime library
       X   5218 // so we need to call a kernal printf.
       X   5219 extern int __cdecl klvfprintf(FILE        *stream,
       X   5220                               const char  *format,
       X   5221                               va_list      arg    ) ;
       X   5222 #endif
       X   5223 
       X   5224 static FILE *gdbg_msgfile;	// GDBG info/error file
       X   5225 #else /* #ifdef KERNEL */
	   5226 
	   5227 static FILE *gdbg_msgfile = NULL; /* stdout; */	// GDBG info/error file
	   5228 
	   5229 //----------------------------------------------------------------------
	   5230 // initialize gdbg_level from an environment variable
	   5231 //----------------------------------------------------------------------
	   5232 static const char *setRange(const char *buf, int val)
      1	   5233 {
      1	   5234     int r0,r1,pos=0;
      1	   5235 
      1	   5236     if (sscanf(buf,"%i%n",&r0,&pos) >= 1)       // parse the first integer
      2	   5237     {
      3	   5238       if (buf[pos]=='-' || buf[pos]==':') {     // if there's a second
      3	   5239           buf += pos+1;
      3	   5240           if (sscanf(buf,"%i%n",&r1,&pos) < 1)  // then parse it
      4	   5241           {
      4	   5242              r1 = r0;
      4	   5243              pos = 0;

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

      3	   5244           }
      2	   5245       }
      2	   5246       else
      2	   5247           r1 = r0;
      2	   5248 
      2	   5249       if (r0 < 0) r0 = 0;                         // sanity checks
      2	   5250       if (r1 >= GDBG_MAX_LEVELS) r1 = GDBG_MAX_LEVELS-1;
      2	   5251       if (r1 < r0) r1 = r0;
      2	   5252 
      2	   5253       while (r0 <= r1)                            // now set the debuglevel levels
      2	   5254           gdbg_debuglevel[r0++] = val;
      1	   5255     }
      1	   5256 
      1	   5257     return buf + pos;				// and return rest of string
      1	   5258 }
	   5259 
	   5260 FX_EXPORT void FX_CSTYLE
	   5261 gdbg_parse(const char *env)
      1	   5262 {
      1	   5263     int level, pos;
      1	   5264 
      2	   5265     do {
      2	   5266 	if (env[0] == ',')		// advance past commas
      2	   5267 	    env++;
      2	   5268 	if (env[0] == '+')		// if + then enable a range
      2	   5269 	    env = setRange(env+1,1);
      2	   5270 	else if (env[0] == '-')		// if - then disable a range
      2	   5271 	    env = setRange(env+1,0);
      3	   5272 	else {				// else just a number
      3	   5273 	    if (sscanf(env,"%i%n",&level,&pos) <= 0) return;
      3	   5274 	    if (pos==0) return;		// oops, guess not
      3	   5275 	    if (level >= GDBG_MAX_LEVELS) level = GDBG_MAX_LEVELS-1;
      3	   5276 	    while (level >= 0)		// enable the range [0,#]
      3	   5277 		gdbg_debuglevel[level--] = 1;
      3	   5278 	    env += pos;
      2	   5279 	}
      1	   5280     } while (env[0] == ',');
      1	   5281 }
	   5282 
	   5283 #endif /* #ifndef KERNEL */
	   5284 
	   5285 FX_EXPORT void FX_CSTYLE
	   5286 gdbg_init(void)
      1	   5287 {
      1	   5288     static int done=0;			// only execute once
      1	   5289     char *env;
      1	   5290 
      1	   5291     if (done) return;
      1	   5292 
      1	   5293     /* I can't init gdbg_msgfile to stdout since it isn't constant so
      1	   5294      * I do it now */
      1	   5295     gdbg_msgfile = stdout;
      1	   5296 
      1X   5297 #if __MWERKS__
      1X   5298 	SIOUXSettings.standalone 				= false;
      1X   5299 	SIOUXSettings.setupmenus 				= false;
      1X   5300 	SIOUXSettings.autocloseonquit 	= true;

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

      1X   5301 	SIOUXSettings.asktosaveonclose 	= false;
      1X   5302 #endif
      1	   5303 
      1X   5304 #ifdef KERNEL
      1X   5305 	// put code in here to set the default level
      1X   5306     gdbg_debuglevel[0] = 1;		// always enable level 0
      1X   5307     gdbg_debuglevel[120] = 1;		// always enable level 0
      1X   5308     done = 1;
      1X   5309     env = 0;
      1X   5310     return;
      1X   5311 #else /* #ifdef KERNEL */
      1	   5312     done = 1;
      1	   5313     gdbg_debuglevel[0] = 1;		// always enable level 0
      1	   5314     env = GETENV("GDBG_FILE");
      1	   5315     if (env != NULL) GDBG_SET_FILE(env);
      1	   5316     env = GETENV("GDBG_LEVEL");
      1	   5317     if (env == NULL) env = "0";
      1	   5318     gdbg_parse(env);
      1	   5319     gdbg_info(1,"gdbg_init(): debug level = %s\n",env);
      1	   5320 #endif /* #ifndef KERNEL */
      1	   5321 }
	   5322 
	   5323 FX_EXPORT void FX_CSTYLE
	   5324 gdbg_shutdown(void)
      1	   5325 {
      1	   5326   gdbg_info(1,"gdbg_shutdown()\n");
      1	   5327 #ifndef KERNEL
      2	   5328   if (gdbg_msgfile != stdout) {	// close any existing output file
      2X   5329 #if USE_DEBUG_STRING
      2X   5330     if (!UseDebugString)
      2X   5331 #endif /* USE_DEBUG_STRING */
      2	   5332       fclose(gdbg_msgfile);
      2	   5333     gdbg_msgfile = stdout;
      1	   5334   }
      1	   5335 #endif /* #ifndef KERNEL */
      1	   5336 }
	   5337 
       X   5338 #if defined(KERNEL) && !defined(KERNEL_NT)
       X   5339     extern void MyPrintf();
       X   5340 #endif /* #ifdef KERNEL */
	   5341 
       X   5342 #ifdef KERNEL_NT
       X   5343 //----------------------------------------------------------------------
       X   5344 // NT Debug print helper routine
       X   5345 //----------------------------------------------------------------------
       X   5346 static void gdbg_NTPrint( const char *format, ... )
       X   5347 {
       X   5348     va_list arglist;
       X   5349 
       X   5350     va_start(arglist, format);
       X   5351     EngDebugPrint( "\nHAL:  ", format, arglist );
       X   5352     va_end(arglist);
       X   5353 }
       X   5354 #endif  // KERNEL_NT
	   5355 
	   5356 static GDBGKeepAliveProc keepAliveProc;
	   5357 

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

	   5358 FX_EXPORT void FX_CSTYLE gdbg_set_keepalive(GDBGKeepAliveProc p)
      1	   5359 {
      1	   5360    keepAliveProc = p;
      1	   5361 }
	   5362 
	   5363 //----------------------------------------------------------------------
	   5364 // the MAIN message display suboutine - ALL messages come thru here
	   5365 //----------------------------------------------------------------------
	   5366 FX_EXPORT void FX_CSTYLE
	   5367 gdbg_vprintf (const char *format,va_list args)
      1	   5368 {
      2	   5369   if (gdbg_msgfile != NULL) {
      2X   5370 #ifdef KERNEL
      2X   5371     // shouldn't get here now
      2X   5372     //commented out for now -KMW
      2X   5373     //nwvsprintf(gdbgout,format,args);
      2X   5374     //OutputDebugString("\n");
      2X   5375     //OutputDebugString("HAL:  ");
      2X   5376     //OutputDebugString(gdbgout);
      2X   5377 #else
      2X   5378 #if USE_DEBUG_STRING
      2X   5379     if (UseDebugString) {
      2X   5380       static char msgBuf[1024];
      2X   5381 
      2X   5382       vsprintf(msgBuf, format, args);
      2X   5383 
      2X   5384 #if __DOS32__
      2X   5385       pciOutputDebugString(msgBuf);
      2X   5386 #elif __WIN32__
      2X   5387       OutputDebugString(msgBuf);
      2X   5388 #else
      2X   5389       fprintf(stderr, msgBuf);
      2X   5390 #endif /* !__DOS32__ */
      2X   5391     } else
      2X   5392 #endif /* USE_DEBUG_STRING */
      3	   5393     {
      3	   5394       vfprintf(gdbg_msgfile,format,args);
      3	   5395       // if there is a keepAlive callback, then call it
      3	   5396       fflush(gdbg_msgfile);
      2	   5397     }
      2	   5398 
      2	   5399     if (keepAliveProc) keepAliveProc(100);
      2	   5400 #endif /* !KERNEL */
      1	   5401   }
      1	   5402 }
	   5403 
	   5404 FX_EXPORT void FX_CSTYLE
	   5405 gdbg_printf (const char *format, ...)
      1	   5406 {
      1	   5407 #ifndef KERNEL
      1	   5408     va_list args;
      1	   5409 
      1	   5410     va_start(args, format);
      1	   5411     gdbg_vprintf(format,args);
      1	   5412     va_end(args);
      1X   5413 #elif defined( KERNEL_NT )
      1X   5414     va_list args;

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

      1X   5415 
      1X   5416     va_start(args, format);
      1X   5417     EngDebugPrint( "\nHAL:  ", format, args );
      1X   5418     va_end(args);
      1X   5419 #else
      1X   5420     __asm lea   eax, (format+4);
      1X   5421     __asm mov   ebx, format;
      1X   5422     MyPrintf();
      1X   5423 #endif /* #ifndef KERNEL */
      1	   5424 
      1	   5425 }
	   5426 
	   5427 //----------------------------------------------------------------------
	   5428 // INFO message subroutines
	   5429 //----------------------------------------------------------------------
	   5430 
	   5431 //----------------------------------------------------------------------
	   5432 // display an INFO message if level <= debug level and return whether
	   5433 // debug level high enough to allow display
	   5434 //----------------------------------------------------------------------
	   5435 FX_EXPORT int FX_CSTYLE
	   5436 gdbg_info (const int level, const char *format, ...)
      1	   5437 {
      1	   5438     va_list args;
      1	   5439 #ifndef KERNEL_NT
      1	   5440     char newformat[4095];
      1	   5441 #endif
      1	   5442 
      1	   5443     if (!gdbg_debuglevel[level>=GDBG_MAX_LEVELS ? GDBG_MAX_LEVELS-1 : level])
      1	   5444 	return(0);
      1	   5445 #ifndef KERNEL
      1	   5446     va_start(args, format);
      1	   5447     sprintf(newformat, "%s.%d:\t", gdbg_myname,level);
      1	   5448     strcat(newformat,format);
      1	   5449     gdbg_vprintf(newformat,args);
      1	   5450     va_end(args);
      1X   5451 #elif defined( KERNEL_NT )
      1X   5452     gdbg_NTPrint( "%s.%d:\t", gdbg_myname, level );
      1X   5453     va_start(args, format);
      1X   5454     EngDebugPrint( "", format, args );
      1X   5455     va_end(args);
      1X   5456 #else /* #ifndef KERNEL */
      1X   5457     Debug_Printf("%s.%d:\t", gdbg_myname, level);
      1X   5458     __asm lea   eax, (format+4);
      1X   5459     __asm mov   ebx, format;
      1X   5460     MyPrintf();
      1X   5461     FXUNUSED(args);
      1X   5462     FXUNUSED(newformat[0]);
      1X   5463 #endif /* #ifndef KERNEL */
      1	   5464 
      1	   5465     return (1);
      1	   5466 }
	   5467 
	   5468 
	   5469 //----------------------------------------------------------------------
	   5470 // same as gdbg_info but does not display INFO header
	   5471 //----------------------------------------------------------------------

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

	   5472 FX_EXPORT int FX_CSTYLE
	   5473 gdbg_info_more (const int level, const char *format, ...)
      1	   5474 {
      1	   5475     va_list args;
      1	   5476 
      1	   5477     if (!gdbg_debuglevel[level>=GDBG_MAX_LEVELS ? GDBG_MAX_LEVELS-1 : level])
      1	   5478 	return(0);
      1	   5479 #ifndef KERNEL
      1	   5480     va_start(args, format);
      1	   5481     gdbg_vprintf(format,args);
      1	   5482     va_end(args);
      1X   5483 #elif defined( KERNEL_NT )
      1X   5484     va_start(args, format);
      1X   5485     EngDebugPrint( "\nHAL:  ", format, args );
      1X   5486     va_end(args);
      1X   5487 #else
      1X   5488     __asm lea   eax, (format+4);
      1X   5489     __asm mov   ebx, format;
      1X   5490     MyPrintf();
      1X   5491     FXUNUSED(args);
      1X   5492 #endif /* #ifndef KERNEL */
      1	   5493     return (1);
      1	   5494 }
	   5495 
	   5496 static GDBGErrorProc errorProcList[3];
	   5497 
	   5498 FX_EXPORT int FX_CSTYLE gdbg_error_set_callback(GDBGErrorProc p)
      1	   5499 {
      1	   5500    int i;
      1	   5501    const int count = sizeof(errorProcList) / sizeof(errorProcList[0]);
      1	   5502 
      2	   5503    for(i = 0; i < count; i++) {
      3	   5504       if (errorProcList[i] == p) {
      3	   5505          break;
      3	   5506       } else if (errorProcList[i] == NULL) {
      3	   5507          errorProcList[i] = p;
      3	   5508          break;
      2	   5509       }
      1	   5510    }
      1	   5511 
      1	   5512    return (i < count);
      1	   5513 }
	   5514 
	   5515 FX_EXPORT void FX_CSTYLE gdbg_error_clear_callback(GDBGErrorProc p)
      1	   5516 {
      1	   5517    int i;
      1	   5518    const int count = sizeof(errorProcList) / sizeof(errorProcList[0]);
      1	   5519 
      2	   5520    for(i = 0; i < count; i++) {
      3	   5521       if (errorProcList[i] == p) {
      3	   5522          errorProcList[i] = NULL;
      3	   5523          break;
      2	   5524       }
      1	   5525    }
      1	   5526 }
	   5527 
	   5528 //----------------------------------------------------------------------

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

	   5529 // ALL errors must come thru here, this subroutine adds a preamble
	   5530 // and then displays the message and increments the error counter
	   5531 //----------------------------------------------------------------------
	   5532 FX_EXPORT void FX_CSTYLE
	   5533 gdbg_error (const char *kind, const char *format, ...)
      1	   5534 {
      1	   5535 #ifndef KERNEL
      1	   5536     va_list args;
      1	   5537 
      1	   5538     char newformat[1024];
      1	   5539 
      1	   5540     va_start(args, format);
      1	   5541     sprintf(newformat, "%s error (%s): ", gdbg_myname,kind);
      1	   5542     strcat(newformat,format);		// add a preamble to message
      1	   5543     gdbg_vprintf(newformat,args);
      1	   5544     gdbg_errors++;			// increment the error counter
      1	   5545     va_end(args);
      1	   5546     
      2	   5547     {
      2	   5548        int i;
      2	   5549        const int count = sizeof(errorProcList) / sizeof(errorProcList[0]);
      2	   5550        
      3	   5551        for(i = 0; i < count; i++) {
      4	   5552           if (errorProcList[i] != NULL) {
      4	   5553              va_start(args, format);
      4	   5554              (*errorProcList[i])(kind, newformat, args);
      4	   5555              va_end(args);
      3	   5556           }
      2	   5557        }
      1	   5558     }
      1X   5559 #elif defined( KERNEL_NT )
      1X   5560     va_list args;
      1X   5561 
      1X   5562     gdbg_NTPrint( "%s error (%s): ", gdbg_myname, kind);
      1X   5563     va_start(args, format);
      1X   5564     EngDebugPrint( "", format, args );
      1X   5565     va_end(args);
      1X   5566 #else
      1X   5567     Debug_Printf("%s error (%s): ", gdbg_myname, kind);
      1X   5568     __asm lea   eax, (format+4);
      1X   5569     __asm mov   ebx, format;
      1X   5570     MyPrintf();
      1X   5571 #endif /* #ifndef KERNEL */
      1	   5572 }
	   5573 
	   5574 // return the error counter
	   5575 FX_EXPORT int FX_CSTYLE
	   5576 gdbg_get_errors(void)
      1	   5577 {
      1	   5578     return gdbg_errors;
      1	   5579 }
	   5580 
	   5581 // return a debuglevel level
	   5582 FX_EXPORT int FX_CSTYLE
	   5583 gdbg_get_debuglevel(const int level)
      1	   5584 {
      1	   5585     return gdbg_debuglevel[level>=GDBG_MAX_LEVELS ? GDBG_MAX_LEVELS-1 : level];

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

      1	   5586 }
	   5587 
	   5588 // set a debuglevel level
	   5589 FX_EXPORT void FX_CSTYLE
	   5590 gdbg_set_debuglevel(const int level, const int value)
      1	   5591 {
      1	   5592     gdbg_debuglevel[level>=GDBG_MAX_LEVELS ? GDBG_MAX_LEVELS-1 : level] = value;
      1	   5593 }
	   5594 
	   5595 // open up a new output file
	   5596 FX_EXPORT int FX_CSTYLE
	   5597 gdbg_set_file(const char *name)
      1	   5598 {
      1	   5599 #ifndef KERNEL
      1	   5600   FILE *outf;
      1	   5601 
      2	   5602   if (gdbg_msgfile != stdout) {	// close any existing output file
      2	   5603     fclose(gdbg_msgfile);
      2	   5604     gdbg_msgfile = stdout;
      1	   5605   }
      1	   5606 
      1X   5607 #if USE_DEBUG_STRING
      1X   5608   if (!strcmp(name, "DEBUG")) {
      1X   5609     gdbg_msgfile = (FILE *) 1;
      1X   5610     UseDebugString = 1;
      1X   5611   } else
      1X   5612 #endif /* USE_DEBUG_STRING */
      2	   5613   {
      2	   5614     outf = fopen(name,"w");		// open up a new one
      2	   5615     if (outf) gdbg_msgfile = outf;
      2	   5616     return (outf != NULL);
      1	   5617   }
      1	   5618 
      1	   5619   return 1;
      1X   5620 #else /* #ifndef KERNEL */
      1X   5621   return 0;
      1X   5622 #endif /* #ifndef KERNEL */
      1	   5623 }


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]GDEBUG/OBJECT=[.OUT.D
EBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]GDEBUG.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FX
MISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2
X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLI
DE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.G
LIDE.GLIDE2X.CVG.INIT]GDEBUG.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 

GDEBUG                          Source Listing                   9-MAY-2021 23:43:16  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gdebug.c;1

 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:17"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


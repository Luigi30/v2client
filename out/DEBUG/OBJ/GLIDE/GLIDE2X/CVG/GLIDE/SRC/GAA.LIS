GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Revision 1.1.1.1.2.3  2007/05/19 08:29:25  koolsmoky
	     21 ** packed rgb fixes
	     22 **
	     23 ** Revision 1.1.1.1.2.1  2005/01/22 14:52:01  koolsmoky
	     24 ** enabled packed argb for cmd packet type 3
	     25 **
	     26 ** Revision 1.1.1.1  1999/12/07 21:49:09  joseph
	     27 ** Initial checkin into SourceForge.
	     28 **
	     29 ** 
	     30 ** 64    5/18/98 12:15p Peter
	     31 ** crybaby check for alpha enable
	     32 ** 
	     33 ** 63    4/22/98 6:18p Jdt
	     34 ** Optimized AA Lines.
	     35 ** 
	     36 ** 62    2/20/98 11:00a Peter
	     37 ** removed glide3 from glid2 tree
	     38  * 
	     39  * 61    1/15/98 2:46p Atai
	     40  * fixed grDrawPoint and grDrawLine in aa mode
	     41  * 
	     42  * 60    12/17/97 4:45p Peter
	     43  * groundwork for CrybabyGlide
	     44  * 
	     45  * 59    12/12/97 12:43p Atai
	     46  * move i and dateElem into the set up loop
	     47  * 
	     48  * 57    12/08/97 10:40a Atai
	     49  * modify draw vertex primitive routines to do grDrawVertexArrayLinear()
	     50  * 
	     51  * 56    12/05/97 4:26p Peter
	     52  * watcom warnings
	     53  * 
	     54  * 55    11/24/97 4:40p Peter
	     55  * aa prims vs packing
	     56  * 
	     57  * 54    11/21/97 6:05p Atai

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

	     58  * use one datalist (tsuDataList) in glide3
	     59  * 
	     60  * 53    11/21/97 3:20p Peter
	     61  * direct writes tsu registers
	     62  * 
	     63  * 52    11/18/97 6:11p Peter
	     64  * fixed glide3 muckage
	     65  * 
	     66  * 51    11/18/97 4:36p Peter
	     67  * chipfield stuff cleanup and w/ direct writes
	     68  * 
	     69  * 50    11/18/97 3:26p Atai
	     70  * update vData 
	     71  * optimize state monster
	     72  * 
	     73  * 49    11/17/97 4:55p Peter
	     74  * watcom warnings/chipfield stuff
	     75  * 
	     76  * 48    11/06/97 6:10p Atai
	     77  * update GrState size
	     78  * rename grDrawArray to grDrawVertexArray
	     79  * update _grDrawPoint and _grDrawVertexList
	     80  * 
	     81  * 47    11/04/97 6:35p Atai
	     82  * 1. sync with data structure changes
	     83  * 2. break up aa triangle routine
	     84  * 
	     85  * 46    11/04/97 5:04p Peter
	     86  * cataclysm part deux
	     87  * 
	     88  * 45    11/04/97 4:57p Atai
	     89  * use byte offset
	     90  * 
	     91  * 44    11/03/97 3:43p Peter
	     92  * h3/cvg cataclysm
	     93  * 
	     94  * 43    11/03/97 3:19p Atai
	     95  * optimization
	     96  * 
	     97  * 42    10/29/97 2:45p Peter
	     98  * C version of Taco's packing code
	     99  * 
	    100  * 41    10/29/97 2:24p Atai
	    101  * re-work aa draw routines to increase sbench number
	    102  * 
	    103  * 40    10/21/97 8:38p Atai
	    104  * added lines routine for grDrawArray
	    105  * 
	    106  * 39    10/21/97 3:22p Peter
	    107  * hand pack rgb
	    108  * 
	    109  * 38    10/19/97 12:51p Peter
	    110  * no tsu happiness
	    111  * 
	    112  * 37    10/17/97 3:15p Peter
	    113  * removed unused addr field from datalist
	    114  * 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

	    115  * 36    10/17/97 10:15a Peter
	    116  * packed rgb state cleanup
	    117  * 
	    118  * 35    10/16/97 5:33p Peter
	    119  * argb != rgba
	    120  * 
	    121  * 34    10/16/97 3:40p Peter
	    122  * packed rgb
	    123  * 
	    124  * 33    10/16/97 1:50p Atai
	    125  * fix drawarray bugs
	    126  * 
	    127  * 32    10/14/97 7:33p Atai
	    128  * fix compiler error
	    129  * 
	    130  * 31    10/14/97 5:40p Atai
	    131  * added grculltest
	    132  * 
	    133  * 30    10/14/97 4:36p Atai
	    134  * added aa points, strip line and trianlges for drawarray
	    135  * 
	    136  * 29    10/09/97 8:02p Dow
	    137  * State Monster 1st Cut
	    138  * 
	    139  * 28    10/08/97 5:19p Peter
	    140  * optinally clamp only texture params
	    141  * 
	    142  * 27    10/08/97 11:32a Peter
	    143  * pre-computed packet headers for packet 3
	    144  * 
	    145  * 26    9/20/97 4:42p Peter
	    146  * tri_setf fixup/big fifo
	    147  * 
	    148  * 25    9/16/97 2:49p Peter
	    149  * fixed watcom unhappiness w/ static initializers
	    150  * 
	    151  * 24    9/15/97 7:31p Peter
	    152  * more cmdfifo cleanup, fixed normal buffer clear, banner in the right
	    153  * place, lfb's are on, Hmmmm.. probably more
	    154  * 
	    155  * 23    9/10/97 10:13p Peter
	    156  * fifo logic from GaryT, non-normalized fp first cut
	    157  * 
	    158  * 22    8/30/97 5:58p Tarolli
	    159  * cleanups
	    160  * 
	    161  * 21    7/29/97 4:31p Atai
	    162  * replace old edge sense routine
	    163  * 
	    164  * 19    7/28/97 2:42p Peter
	    165  * aa points?
	    166  * 
	    167  * 18    7/26/97 3:04p Peter
	    168  * cleanup
	    169  * 
	    170  * 17    7/25/97 11:40a Peter
	    171  * removed dHalf, change field name to match real use for cvg

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

	    172  * 
	    173  * 16    6/30/97 3:21p Peter
	    174  * more aa through cmd fifo
	    175  * 
	    176  * 15    6/20/97 1:17p Peter
	    177  * changes for new CVG_TRI macros
	    178 **
	    179 */
	    180 
	    181 #include <3dfx.h>
	    312 #define FX_DLL_DEFINITION
	    313 #include <fxdll.h>
	    434 #include <glide.h>
	   2376 #include "fxglide.h"
	  14268 
	  14269 /*
	  14270 ** -----------------------------------------------------------------------
	  14271 **
	  14272 ** Antialiasing rendering functions
	  14273 **
	  14274 ** -----------------------------------------------------------------------
	  14275 */
	  14276 
	  14277 /*---------------------------------------------------------------------------
	  14278 ** grAADrawPoint
	  14279 **
	  14280 **   |-w-|
	  14281 **   A---B -
	  14282 **   |\ /| |
	  14283 **   | E | h
	  14284 **   |/ \| |
	  14285 **   D --C -
	  14286 **   w = h = 2pixels
	  14287 */
	  14288 GR_ENTRY(grAADrawPoint, void, (const GrVertex *e)) 
      1	  14289 {
      1	  14290 #define FN_NAME "grAADrawPoint"
      1	  14291   GR_DCL_GC;
      1	  14292   GrCullMode_t cullSave;
      1	  14293   
      1X  14294 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  14295   const FxU32 vertexParamOffset = _GlideRoot.curVertexSize;
      1X  14296 #endif /* GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP */
      1	  14297 
      1	  14298   GDBG_INFO(94,"grAADrawPoint(0x%x)\n",e);
      1	  14299 
      1	  14300   /* turn off culling so triangles unconditionally draw */
      1	  14301   cullSave = gc->state.cull_mode;
      1	  14302   gc->state.cull_mode = GR_CULL_DISABLE;
      1	  14303 
      1	  14304   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  14305                          ((gc->cmdTransportInfo.paramMask & (SST_SETUP_A << SSTCP_PKT3_PMASK_SHIFT)) == 0),
      1	  14306                          "Antialiasing require enabling alpha");
      1	  14307 
      1X  14308 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  14309   /* We draw this as a 4 triangle fan centered around E. */
      1X  14310   GR_SET_EXPECTED_SIZE(vertexParamOffset * 6, 1);

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1X  14311   TRI_STRIP_BEGIN(kSetupFan, 
      1X  14312                   0x06UL, vertexParamOffset, 
      1X  14313                   SSTCP_PKT3_BDDDDD);
      1X  14314 
      1X  14315   {
      1X  14316     const float ptX = e->x;
      1X  14317     const float ptY = e->y;
      1X  14318     const float* const fp = (const float* const)e;
      1X  14319 
      1X  14320     /* Send down the original point center */
      1X  14321     TRI_SETF(ptX);
      1X  14322     TRI_SETF(ptY);
      1X  14323 
      1X  14324     {
      1X  14325       const int* dataList = gc->tsuDataList;
      1X  14326 
      1X  14327 #if GLIDE_PACKED_RGB
      1X  14328       if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  14329         FxU32 packedColor = 0x00;
      1X  14330         
      1X  14331         if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  14332           packedColor = (RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_B_OFFSET << 2)), B) |
      1X  14333                          RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  14334                          RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  14335           
      1X  14336           dataList++;
      1X  14337         }
      1X  14338 
      1X  14339         packedColor |= RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_A_OFFSET << 2)), A);
      1X  14340         dataList++;
      1X  14341 
      1X  14342         TRI_SET(packedColor);
      1X  14343       }
      1X  14344 #endif /* GLIDE_PACKED_RGB */
      1X  14345 
      1X  14346 #if GLIDE_FP_CLAMP_TEX
      1X  14347       while(*dataList != 0) {
      1X  14348         TRI_SETF(FARRAY(fp, *dataList));
      1X  14349         dataList++;
      1X  14350       }
      1X  14351 
      1X  14352       dataList++;
      1X  14353 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  14354       
      1X  14355       while(*dataList != 0) {
      1X  14356         TRI_SETF_CLAMP(FARRAY(fp, *dataList));
      1X  14357         dataList++;
      1X  14358       }
      1X  14359     }
      1X  14360 
      1X  14361     /* Send the 'surrounding' vertices w/ alpha == 0.0f.  To avoid
      1X  14362      * the vertex copying from the previous version we carry around
      1X  14363      * a table of offsets that we add into the original point to get
      1X  14364      * the new points.
      1X  14365      */
      1X  14366     {
      1X  14367       int v;

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1X  14368       static const float xAdjust[] = {  1.0f, -1.0f, -1.0f, 1.0f,  1.0f };
      1X  14369       static const float yAdjust[] = { -1.0f, -1.0f,  1.0f, 1.0f, -1.0f };
      1X  14370          
      1X  14371       ASSERT(ArraySize(xAdjust) == ArraySize(yAdjust));
      1X  14372          
      1X  14373       for(v = 0; v < ArraySize(xAdjust); v++) {
      1X  14374         TRI_SETF(ptX + xAdjust[v]);
      1X  14375         TRI_SETF(ptY + yAdjust[v]);
      1X  14376            
      1X  14377         {
      1X  14378           const int* dataList = gc->tsuDataList;
      1X  14379 
      1X  14380 #if GLIDE_PACKED_RGB
      1X  14381           if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
      1X  14382             FxU32 packedColor = 0x00;
      1X  14383             
      1X  14384             if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
      1X  14385               packedColor = (RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_B_OFFSET << 2)), B) |
      1X  14386                              RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_G_OFFSET << 2)), G) |
      1X  14387                              RGBA_COMP_CLAMP(FARRAY(fp, (GR_VERTEX_R_OFFSET << 2)), R));
      1X  14388               
      1X  14389               dataList++;
      1X  14390             }
      1X  14391 
      1X  14392             /* Alpha set to 0.0 */
      1X  14393             
      1X  14394             TRI_SET(packedColor);
      1X  14395           } else {
      1X  14396 #endif /* !GLIDE_PACKED_RGB */
      1X  14397           /* Parameters up to alpha.
      1X  14398            *
      1X  14399            * NB: It is up to the user to correctly set this up
      1X  14400            * so that the alpha is sent.
      1X  14401            */
      1X  14402           while(*dataList != (GR_VERTEX_A_OFFSET << 2)) {
      1X  14403             TRI_SETF(FARRAY(fp, *dataList));
      1X  14404             dataList++;
      1X  14405           }
      1X  14406           
      1X  14407           /* Send constant Alpha == 0.0f */
      1X  14408           TRI_SETF(0.0f);
      1X  14409 #if GLIDE_PACKED_RGB
      1X  14410           }
      1X  14411 #endif /* !GLIDE_PACKED_RGB */
      1X  14412 
      1X  14413           /* Skip the actual alpha value in the data list */
      1X  14414           dataList++;
      1X  14415 
      1X  14416 #if GLIDE_FP_CLAMP_TEX
      1X  14417           while(*dataList != 0) {
      1X  14418             TRI_SETF(FARRAY(fp, *dataList));
      1X  14419             dataList++;
      1X  14420           }
      1X  14421 
      1X  14422           dataList++;
      1X  14423 #endif /* GLIDE_FP_CLAMP_TEX */
      1X  14424           

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1X  14425           /* Anything else in the dataList */
      1X  14426           while(*dataList != 0) {                  
      1X  14427             TRI_SETF_CLAMP(FARRAY(fp, *dataList));
      1X  14428             dataList++;
      1X  14429           }
      1X  14430         }
      1X  14431       }
      1X  14432     }
      1X  14433   }
      1X  14434   
      1X  14435   TRI_END;
      1X  14436   GR_CHECK_SIZE();
      1X  14437 #else
      2	  14438   {
      2	  14439     GrVertex a, b;      
      2	  14440 
      2	  14441     /*
      2	  14442     ** make corners of a square
      2	  14443     */
      2	  14444     a = 
      2	  14445     b = *e;
      2	  14446       
      2	  14447     a.tmuvtx[0].oow =
      2	  14448     b.tmuvtx[0].oow = _GlideRoot.pool.f1;
      2	  14449       
      2	  14450     a.x -= _GlideRoot.pool.f1;
      2	  14451     a.y -= _GlideRoot.pool.f1;
      2	  14452 
      2	  14453     b.x += _GlideRoot.pool.f1;
      2	  14454     b.y -= _GlideRoot.pool.f1;
      2	  14455 
      2	  14456     a.a =  
      2	  14457       b.a =  _GlideRoot.pool.f0;
      2	  14458       
      2	  14459     grDrawTriangle(&a, &b, e);    /* A B E */
      2	  14460       
      2	  14461     b.x -= 2.0F;                  /* compute point D */
      2	  14462     b.y += 2.0F;
      2	  14463     grDrawTriangle(&a, e, &b);    /* A E D */
      2	  14464       
      2	  14465     a.x += 2.0F;                  /* compute point C */
      2	  14466     a.y += 2.0F;
      2	  14467     grDrawTriangle(&b, e, &a);    /* D E C */
      2	  14468       
      2	  14469     b.x += 2.0F;
      2	  14470     b.y -= 2.0F;
      2	  14471     grDrawTriangle(&a, e, &b);    /* C E B */
      1	  14472   }
      1	  14473 #endif /* GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP */
      1	  14474   
      1	  14475   /* Restore culling mode */
      1	  14476   gc->state.cull_mode = cullSave;
      1	  14477 #undef FN_NAME
      1	  14478 } /* grAADrawPoint */
	  14479 
       X  14480 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
       X  14481 static void

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14482 grAADrawStrip(const FxU32 cullMode, const float* const vectorList[], const FxU32 vectorNum)
       X  14483 {
       X  14484 #define FN_NAME "grAADrawStrip"
       X  14485   const FxU32 vertexParamOffset = _GlideRoot.curVertexSize;
       X  14486    
       X  14487   GR_BEGIN_NOFIFOCHECK(FN_NAME, gc->myLevel);
       X  14488   GDBG_INFO_MORE(gc->myLevel, "(): 0x%X\n", vectorNum);
       X  14489 
       X  14490   GR_FLUSH_STATE();
       X  14491 
       X  14492   GR_SET_EXPECTED_SIZE(vertexParamOffset * vectorNum, 1);
       X  14493   TRI_PACKET_BEGIN(cullMode, gc->cmdTransportInfo.paramMask,
       X  14494                    vectorNum, vertexParamOffset, 
       X  14495                    SSTCP_PKT3_BDDDDD);
       X  14496   {
       X  14497     FxU32 v;
       X  14498 
       X  14499     for(v = 0; v < vectorNum; v++) {
       X  14500       const float* const vector = vectorList[v];
       X  14501          
       X  14502       TRI_SETF(vector[GR_VERTEX_X_OFFSET]);
       X  14503       TRI_SETF(vector[GR_VERTEX_Y_OFFSET]);
       X  14504 
       X  14505       {
       X  14506         const int* dataList = gc->tsuDataList;
       X  14507 
       X  14508 #if GLIDE_PACKED_RGB
       X  14509         if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14510           FxU32 packedColor = 0x00;
       X  14511           
       X  14512           if (*dataList == (GR_VERTEX_R_OFFSET << 2)) {
       X  14513             packedColor = (RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_B_OFFSET << 2)), B) |
       X  14514                            RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14515                            RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14516             
       X  14517             dataList++;
       X  14518           }
       X  14519 
       X  14520           packedColor |= RGBA_COMP_CLAMP(FARRAY(vector, (GR_VERTEX_A_OFFSET << 2)), A);
       X  14521           dataList++;
       X  14522           
       X  14523           TRI_SET(packedColor);
       X  14524         }
       X  14525 #endif /* GLIDE_PACKED_RGB */
       X  14526         
       X  14527 #if GLIDE_FP_CLAMP_TEX
       X  14528         while(*dataList != 0) {
       X  14529           TRI_SETF(FARRAY(vector, *dataList));
       X  14530           dataList++;
       X  14531         }
       X  14532 
       X  14533         dataList++;
       X  14534 #endif /* GLIDE_FP_CLAMP_TEX */
       X  14535         
       X  14536         while(*dataList != 0) {
       X  14537           TRI_SETF_CLAMP(FARRAY(vector, *dataList));
       X  14538           dataList++;

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14539         }
       X  14540       }
       X  14541     }
       X  14542   }
       X  14543   TRI_END;
       X  14544   GR_CHECK_SIZE();
       X  14545 #undef FN_NAME
       X  14546 }
       X  14547 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
	  14548 /*
	  14549 **  grAADrawEdgeTriangle
	  14550 */
	  14551 static void
	  14552 grAADrawEdgeTriangle(float *va, float *vb, float *vc)
      1	  14553 {
      1	  14554   float
      1	  14555     *fa = va,
      1	  14556     *fb = vb,
      1	  14557     *fc = vc,
      1	  14558     dpAB, dpBC,
      1	  14559     dpdx, dpdy,                 /* Change in parameter WRT x & y */
      1	  14560     area;
      1	  14561   float
      1	  14562     ooa, dxAB, dxBC, dyAB, dyBC;
      1	  14563   float negateArea = -1.f;
      1	  14564  
      1	  14565   GR_BEGIN_NOFIFOCHECK("grAADrawEdgeTriangle",gc->myLevel);
      1	  14566   GDBG_INFO_MORE(gc->myLevel,"()\n");
      1	  14567   GR_FLUSH_STATE();
      1	  14568 
      1	  14569   /*
      1	  14570   **  Sort the vertices.
      1	  14571   **  Whenever the radial order is reversed (from counter-clockwise to
      1	  14572   **  clockwise), we need to change the area of the triangle.  Note
      1	  14573   **  that we know the first two elements are X & Y by looking at the
      1	  14574   **  grVertex structure.  
      1	  14575   */
      2	  14576   if (va[1] < vb[1]) {
      3	  14577     if (vb[1] > vc[1]) {        /* acb */
      4	  14578       if (va[1] < vc[1]) {
      4	  14579         fa = va;
      4	  14580         fb = vc;
      4	  14581         fc = vb;
      4	  14582         negateArea *= -1.f;
      4	  14583       } else {                  /* cab */
      4	  14584         fa = vc;
      4	  14585         fb = va;
      4	  14586         fc = vb;
      3	  14587       }
      3	  14588       /* else it's already sorted */
      2	  14589     }
      2	  14590   } else {
      3	  14591     if (vb[1] < vc[1]) {        /* bac */
      4	  14592       if (va[1] < vc[1]) {
      4	  14593         fa = vb;
      4	  14594         fb = va;
      4	  14595         fc = vc;

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      4	  14596         negateArea *= -1.f;
      4	  14597       } else {                  /* bca */
      4	  14598         fa = vb;
      4	  14599         fb = vc;
      4	  14600         fc = va;
      3	  14601       }
      3	  14602     } else {                    /* cba */
      3	  14603       fa = vc;
      3	  14604       fb = vb;
      3	  14605       fc = va;
      3	  14606       negateArea *= -1.f;
      2	  14607     }
      1	  14608   }
      1	  14609 
      1	  14610   /* Compute Area */
      1	  14611   dxAB = fa[0] - fb[0];
      1	  14612   dxBC = fb[0] - fc[0];
      1	  14613 
      1	  14614   dyAB = fa[1] - fb[1];
      1	  14615   dyBC = fb[1] - fc[1];
      1	  14616 
      1	  14617   area = dxAB * dyBC - dxBC * dyAB;
      1	  14618 
      1	  14619   /* Zero-area triangles are BAD!! */
      1	  14620   if (area == 0.0f) goto all_done;
      1	  14621 
      1	  14622   ooa = 1.0f / area;
      1	  14623 
      1	  14624   /*
      1	  14625   ** Divide the deltas by the area for gradient calculation.
      1	  14626   */
      1	  14627   dxBC *= ooa;
      1	  14628   dyAB *= ooa;
      1	  14629   dxAB *= ooa;
      1	  14630   dyBC *= ooa;
      1	  14631 
      1	  14632   GR_SET_EXPECTED_SIZE(((10 + (_GlideRoot.paramCount - 1)) << 2), 
      1	  14633                        10 + (_GlideRoot.paramCount - 1));
      1	  14634 
      1	  14635   /* write out X & Y  for vertex A */
      1	  14636   GR_SETF(BROADCAST_ID, hw, FvA.x, fa[0]);
      1	  14637   GR_SETF(BROADCAST_ID, hw, FvA.y, fa[1]);
      1	  14638 
      1	  14639   /* write out X & Y  for vertex B */
      1	  14640   GR_SETF(BROADCAST_ID, hw, FvB.x, fb[0]);
      1	  14641   GR_SETF(BROADCAST_ID, hw, FvB.y, fb[1]);
      1	  14642 
      1	  14643   /* write out X & Y  for vertex C */
      1	  14644   GR_SETF(BROADCAST_ID, hw, FvC.x, fc[0]);
      1	  14645   GR_SETF(BROADCAST_ID, hw, FvC.y, fc[1]);
      1	  14646 
      1	  14647   dpAB = (fa[GR_VERTEX_A_OFFSET] - fb[GR_VERTEX_A_OFFSET]);
      1	  14648   dpBC = (fb[GR_VERTEX_A_OFFSET] - fc[GR_VERTEX_A_OFFSET]);
      1	  14649   dpdx = dpAB * dyBC - dpBC * dyAB;
      1	  14650   dpdy = dpBC * dxAB - dpAB * dxBC;
      1	  14651 
      1	  14652   /* Write the alpha data */

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1	  14653   GR_SETF(BROADCAST_ID, hw, Fa, fa[GR_VERTEX_A_OFFSET]);
      1	  14654   GR_SETF(BROADCAST_ID, hw, Fdadx , dpdx);
      1	  14655   GR_SETF(BROADCAST_ID, hw, Fdady , dpdy);
      1	  14656 
      2	  14657   {
      2	  14658     const struct dataList_s* dlp = gc->regDataList; 
      2	  14659     int i = dlp->i;
      2	  14660     
      2	  14661     /* We already put the alpha out, and this is guaranteed to
      2	  14662      * be included in the dataList via convention.
      2	  14663      */
      3	  14664     while (i != (GR_VERTEX_A_OFFSET << 2)) {
      3	  14665       GR_SETF_INDEX(BROADCAST_ID, hw, ((FxU32*)dlp->addr - (FxU32*)hw), FARRAY(fa, i));
      3	  14666       dlp++;
      3	  14667       i = dlp->i;
      2	  14668     }
      2	  14669     
      2	  14670     dlp++;
      2	  14671     i = dlp->i;
      2	  14672     
      3	  14673     while (i != 0) {
      3	  14674       GR_SETF_INDEX(BROADCAST_ID, hw, ((FxU32*)dlp->addr - (FxU32*)hw), FARRAY(fa, i));
      3	  14675       dlp++;
      3	  14676       i = dlp->i;
      2	  14677     }
      2	  14678     
      2	  14679     /* Draw the triangle by writing the area to the triangleCMD register */
      2	  14680     GR_SETF(BROADCAST_ID, hw, FtriangleCMD, area);
      1	  14681   }
      1	  14682 
      1	  14683 all_done:
      1	  14684   GR_END();
      1	  14685 } /* grAADrawEdgeTriangle */
	  14686 #endif  /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
	  14687 
	  14688 
       X  14689 #if (GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP)
       X  14690 #define FUCAST( X ) (*(unsigned long*)&(X))
       X  14691 #define FN_NAME "grAADrawLine"
       X  14692 GR_ENTRY(grAADrawLine, void, (const GrVertex *v1, const GrVertex *v2)) 
       X  14693 {
       X  14694     GR_DCL_GC;
       X  14695     GrVertex *_v1, *_v2;
       X  14696     const FxU32 vertexParamOffset = _GlideRoot.curVertexSize;  
       X  14697     const int* datalist;
       X  14698     float xoff, yoff;
       X  14699     float alpha;
       X  14700     float dx, dy;  /* delta X and Y */
       X  14701     float adx, ady;/* |dX| and |dY| */
       X  14702 
       X  14703   GR_CHECK_COMPATABILITY(FN_NAME,
       X  14704                          ((gc->cmdTransportInfo.paramMask & (SST_SETUP_A << SSTCP_PKT3_PMASK_SHIFT)) == 0),
       X  14705                          "Antialiasing require enabling alpha");
       X  14706 
       X  14707     GR_SET_EXPECTED_SIZE( vertexParamOffset * 6, 1 );
       X  14708     TRI_PACKET_BEGIN( 0, 
       X  14709                       gc->cmdTransportInfo.paramMask,

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14710                       6, 
       X  14711                       vertexParamOffset, 
       X  14712                       SSTCP_PKT3_BDDDDD );
       X  14713     
       X  14714     /* y sort*/
       X  14715     if (v2->y < v1->y) {
       X  14716         _v1 = (void*) v2;
       X  14717         _v2 = (void*) v1;
       X  14718     } else {
       X  14719         _v1 = (void*) v1;
       X  14720         _v2 = (void*) v2;
       X  14721     }
       X  14722 #define v1 _v1
       X  14723 #define v2 _v2
       X  14724     /* compute deltas and absolute deltas */
       X  14725     
       X  14726     dx  = v2->x - v1->x;
       X  14727     dy  = v2->y - v1->y;
       X  14728     
       X  14729     adx = (float)(FUCAST( dx ) & 0x7fffffff);
       X  14730     ady = (float)(FUCAST( dy ) & 0x7fffffff);
       X  14731     
       X  14732     if ( adx >= ady ) {
       X  14733         xoff = 0.0f;
       X  14734         yoff = 1.0f;
       X  14735     } else {
       X  14736         xoff = 1.0f;
       X  14737         yoff = 0.0f;
       X  14738     }
       X  14739     
       X  14740     /*  A---B  Alpha = 0.0
       X  14741         | \ |  
       X  14742         V1-V2  Alpha = 1.0 ( user )
       X  14743         | \ |  
       X  14744         E---F  Alpha = 0.0
       X  14745 */
       X  14746     
       X  14747     /* B Vertex */
       X  14748     TRI_SETF( v2->x + xoff );
       X  14749     TRI_SETF( v2->y - yoff );
       X  14750 
       X  14751     alpha = v2->a;
       X  14752     v2->a = 0.0f;
       X  14753     datalist = gc->tsuDataList;
       X  14754 
       X  14755 #if GLIDE_PACKED_RGB
       X  14756     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14757       FxU32 packedColor = 0x00;
       X  14758       
       X  14759       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14760         packedColor = (RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14761                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14762                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14763         
       X  14764         datalist++;
       X  14765       }
       X  14766 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14767       /* Alpha set to 0.0 */
       X  14768 
       X  14769       TRI_SET(packedColor);
       X  14770 
       X  14771       /* Skip the actual alpha value in the data list */
       X  14772       datalist++;
       X  14773     }
       X  14774 #endif /* GLIDE_PACKED_RGB */
       X  14775 
       X  14776     while( *datalist != 0 ) {
       X  14777         TRI_SETF(FARRAY(v2, *datalist));
       X  14778         datalist++;
       X  14779     }
       X  14780 
       X  14781     v2->a = alpha;
       X  14782 
       X  14783     /* A Vertex */
       X  14784     datalist = gc->tsuDataList;
       X  14785 
       X  14786     TRI_SETF( v1->x + xoff );
       X  14787     TRI_SETF( v1->y - yoff );
       X  14788 
       X  14789     alpha = v1->a;
       X  14790     v1->a = 0.0f;
       X  14791     datalist = gc->tsuDataList;
       X  14792 
       X  14793 #if GLIDE_PACKED_RGB
       X  14794     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14795       FxU32 packedColor = 0x00;
       X  14796       
       X  14797       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14798         packedColor = (RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14799                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14800                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14801         
       X  14802         datalist++;
       X  14803       }
       X  14804 
       X  14805       /* Alpha set to 0.0 */
       X  14806 
       X  14807       TRI_SET(packedColor);
       X  14808 
       X  14809       /* Skip the actual alpha value in the data list */
       X  14810       datalist++;
       X  14811     }
       X  14812 #endif /* GLIDE_PACKED_RGB */
       X  14813 
       X  14814     while( *datalist != 0 ) {
       X  14815         TRI_SETF(FARRAY(v1, *datalist));
       X  14816         datalist++;
       X  14817     }
       X  14818 
       X  14819     v1->a = alpha;
       X  14820       
       X  14821       /* V2 Vertex */
       X  14822     datalist = gc->tsuDataList;
       X  14823 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14824     TRI_SETF( v2->x );
       X  14825     TRI_SETF( v2->y );
       X  14826 
       X  14827 #if GLIDE_PACKED_RGB
       X  14828     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14829       FxU32 packedColor = 0x00;
       X  14830       
       X  14831       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14832         packedColor = (RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14833                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14834                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14835         
       X  14836         datalist++;
       X  14837       }
       X  14838       
       X  14839       packedColor |= RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_A_OFFSET << 2)), A);
       X  14840       datalist++;
       X  14841       
       X  14842       TRI_SET(packedColor);
       X  14843     }
       X  14844 #endif /* GLIDE_PACKED_RGB */
       X  14845       
       X  14846     while( *datalist != 0 ) {
       X  14847         TRI_SETF(FARRAY(v2, *datalist));
       X  14848         datalist++;
       X  14849     }
       X  14850       
       X  14851     /* V1 Vertex */
       X  14852     datalist = gc->tsuDataList;
       X  14853 
       X  14854     TRI_SETF( v1->x );
       X  14855     TRI_SETF( v1->y );
       X  14856 
       X  14857 #if GLIDE_PACKED_RGB
       X  14858     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14859       FxU32 packedColor = 0x00;
       X  14860       
       X  14861       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14862         packedColor = (RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14863                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14864                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14865         
       X  14866         datalist++;
       X  14867       }
       X  14868       
       X  14869       packedColor |= RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_A_OFFSET << 2)), A);
       X  14870       datalist++;
       X  14871       
       X  14872       TRI_SET(packedColor);
       X  14873     }
       X  14874 #endif /* GLIDE_PACKED_RGB */
       X  14875       
       X  14876     while( *datalist != 0 ) {
       X  14877         TRI_SETF(FARRAY(v1, *datalist));
       X  14878         datalist++;
       X  14879     }
       X  14880       

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14881     /* F Vertex */
       X  14882     datalist = gc->tsuDataList;
       X  14883 
       X  14884     TRI_SETF( v2->x - xoff );
       X  14885     TRI_SETF( v2->y + yoff );
       X  14886 
       X  14887     alpha = v2->a;
       X  14888     v2->a = 0.0f;
       X  14889     datalist = gc->tsuDataList;
       X  14890 
       X  14891 #if GLIDE_PACKED_RGB
       X  14892     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14893       FxU32 packedColor = 0x00;
       X  14894       
       X  14895       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14896         packedColor = (RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14897                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14898                        RGBA_COMP_CLAMP(FARRAY(v2, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14899         
       X  14900         datalist++;
       X  14901       }
       X  14902 
       X  14903       /* Alpha set to 0.0 */
       X  14904 
       X  14905       TRI_SET(packedColor);
       X  14906 
       X  14907       /* Skip the actual alpha value in the data list */
       X  14908       datalist++;
       X  14909     }
       X  14910 #endif /* GLIDE_PACKED_RGB */
       X  14911 
       X  14912     while( *datalist != 0 ) {
       X  14913         TRI_SETF(FARRAY(v2, *datalist));
       X  14914         datalist++;
       X  14915     }
       X  14916 
       X  14917     v2->a = alpha;
       X  14918 
       X  14919     /* E Vertex */
       X  14920     datalist = gc->tsuDataList;
       X  14921 
       X  14922     TRI_SETF( v1->x - xoff );
       X  14923     TRI_SETF( v1->y + yoff );
       X  14924 
       X  14925     alpha = v1->a;
       X  14926     v1->a = 0.0f;
       X  14927     datalist = gc->tsuDataList;
       X  14928 
       X  14929 #if GLIDE_PACKED_RGB
       X  14930     if ((gc->cmdTransportInfo.paramMask & SSTCP_PKT3_PACKEDCOLOR) != 0) {
       X  14931       FxU32 packedColor = 0x00;
       X  14932       
       X  14933       if (*datalist == (GR_VERTEX_R_OFFSET << 2)) {
       X  14934         packedColor = (RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_B_OFFSET << 2)), B) | 
       X  14935                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_G_OFFSET << 2)), G) |
       X  14936                        RGBA_COMP_CLAMP(FARRAY(v1, (GR_VERTEX_R_OFFSET << 2)), R));
       X  14937         

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

       X  14938         datalist++;
       X  14939       }
       X  14940 
       X  14941       /* Alpha set to 0.0 */
       X  14942 
       X  14943       TRI_SET(packedColor);
       X  14944 
       X  14945       /* Skip the actual alpha value in the data list */
       X  14946       datalist++;
       X  14947     }
       X  14948 #endif /* GLIDE_PACKED_RGB */
       X  14949 
       X  14950     while( *datalist != 0 ) {
       X  14951         TRI_SETF(FARRAY(v1, *datalist));
       X  14952         datalist++;
       X  14953     }
       X  14954     v1->a = alpha;
       X  14955       
       X  14956 #undef v1
       X  14957 #undef v2
       X  14958     TRI_END;
       X  14959     GR_CHECK_SIZE();
       X  14960 }
       X  14961 #undef FN_NAME
       X  14962 #else /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP */
	  14963 GR_ENTRY(grAADrawLine, void, (const GrVertex *v1, const GrVertex *v2)) 
      1	  14964 {
      1	  14965   float           dx, dy;           /* delta X and Y */
      1	  14966   float           adx, ady;         /* |dX| and |dY| */
      1	  14967   GrVertex        a, b, e, f;       /* four vertices outlining the line */
      1	  14968   GR_DCL_GC;
      1	  14969 
      1	  14970   /* turn off culling so triangles unconditionally draw.
      1	  14971    *
      1	  14972    * NB: On cvg we control this via the command packet.
      1	  14973    */
      1	  14974   GrCullMode_t cullSave = gc->state.cull_mode;
      1	  14975   gc->state.cull_mode = GR_CULL_DISABLE;
      1	  14976   
      1	  14977   GDBG_INFO(95, "grAADrawLine (%f %f) -> (%f %f)\n",
      1	  14978             v1->x, v1->y, v2->x, v2->y);
      1	  14979 
      1	  14980   GR_FLUSH_STATE();
      1	  14981 
      1	  14982   /* draw from low Y to high Y */
      2	  14983   if (v2->y < v1->y) {
      2	  14984     const GrVertex* tv = v1; v1 = v2; v2 = tv;
      1	  14985   }
      1	  14986   
      1	  14987   /* compute deltas and absolute deltas */
      1	  14988   dx = adx = v2->x - v1->x;
      1	  14989   dy = ady = v2->y - v1->y;
      1	  14990   if (adx < 0)
      1	  14991     adx = -adx;
      1	  14992   if (ady < 0)
      1	  14993     ady = -ady;
      1	  14994   

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1	  14995   a = *v1;
      1	  14996   e = *v1;
      1	  14997   b = *v2;
      1	  14998   f = *v2;
      1	  14999 
      2	  15000   if (adx >= ady) {           /* X major line */
      2	  15001     a.y -= _GlideRoot.pool.f1;
      2	  15002     a.a = 0.F;
      2	  15003     b.y -= _GlideRoot.pool.f1;
      2	  15004     b.a = 0.F;
      2	  15005     e.y += _GlideRoot.pool.f1;
      2	  15006     e.a = 0.F;
      2	  15007     f.y += _GlideRoot.pool.f1;
      2	  15008     f.a = 0.F;
      2	  15009 
      2	  15010     grDrawTriangle(&a, v2, &b);
      2	  15011     grDrawTriangle(&a, v2, v1);
      2	  15012     grDrawTriangle(v1, &f, &e);
      2	  15013     grDrawTriangle(v1, v2, &f);
      2	  15014   } else {                      /* Y major line */
      2	  15015     a.x += _GlideRoot.pool.f1;
      2	  15016     a.a = 0.F;
      2	  15017     b.x += _GlideRoot.pool.f1;
      2	  15018     b.a = 0.F;
      2	  15019     e.x -= _GlideRoot.pool.f1;
      2	  15020     e.a = 0.F;
      2	  15021     f.x -= _GlideRoot.pool.f1;
      2	  15022     f.a = 0.F;
      2	  15023 
      2	  15024     grDrawTriangle(&a, &b, v2);
      2	  15025     grDrawTriangle(v1, &a, v2);
      2	  15026     grDrawTriangle(v1, &f, &e);
      2	  15027     grDrawTriangle(v1, v2, &f);
      1	  15028   }
      1	  15029 
      1	  15030   gc->state.cull_mode = cullSave;
      1	  15031 } /* grAADrawLine */
	  15032 #endif /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
	  15033 
	  15034 typedef enum {
	  15035   aaEdgeSenseTop,
	  15036   aaEdgeSenseLeft,
	  15037   aaEdgeSenseBottom,
	  15038   aaEdgeSenseRight
	  15039 } aaEdgeSense;
	  15040 
	  15041 /*
	  15042 **  grAADrawTriEdge
	  15043 */
	  15044 static void
	  15045 grAADrawTriEdge(const GrVertex *a, const GrVertex *b, aaEdgeSense sense)
      1	  15046 {
      1	  15047   GrVertex c = *a, d = *b;
      1	  15048 
      1	  15049   c.a = 0.f;
      1	  15050   d.a = 0.f;
      1	  15051 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      2	  15052   switch (sense) {
      2	  15053   case aaEdgeSenseTop:
      2	  15054     c.y += _GlideRoot.pool.f1;
      2	  15055     d.y += _GlideRoot.pool.f1;
      2	  15056     break;
      2	  15057 
      2	  15058   case aaEdgeSenseLeft:
      2	  15059     c.x -= _GlideRoot.pool.f1;
      2	  15060     d.x -= _GlideRoot.pool.f1;
      2	  15061     break;
      2	  15062 
      2	  15063   case aaEdgeSenseBottom:
      2	  15064     c.y -= _GlideRoot.pool.f1;
      2	  15065     d.y -= _GlideRoot.pool.f1;
      2	  15066     break;
      2	  15067 
      2	  15068   case aaEdgeSenseRight:
      2	  15069     c.x += _GlideRoot.pool.f1;
      2	  15070     d.x += _GlideRoot.pool.f1;
      2	  15071     break;
      1	  15072   }
      1	  15073 
      1X  15074 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
      1X  15075   {
      1X  15076     /* Maintain the same culling mode that we would have used for
      1X  15077      * the inner triangle.
      1X  15078      */
      1X  15079     GR_DCL_GC;      
      1X  15080     const FxU32 cullMode = gc->state.cull_mode;
      1X  15081     const FxU32 sMode = ((cullMode != GR_CULL_DISABLE)
      1X  15082                          ? (kSetupCullEnable | ((cullMode == GR_CULL_POSITIVE)
      1X  15083                                                 ? kSetupCullPositive
      1X  15084                                                 : kSetupCullNegative))
      1X  15085                          : kSetupCullDisable);
      1X  15086     const float* lVertexList[4];
      1X  15087 
      1X  15088     lVertexList[0] = &c.x;
      1X  15089     lVertexList[1] = &d.x;
      1X  15090     lVertexList[2] = &a->x;
      1X  15091     lVertexList[3] = &b->x;
      1X  15092 
      1X  15093     grAADrawStrip(kSetupStrip | sMode,
      1X  15094                   lVertexList,
      1X  15095                   sizeof(lVertexList) / sizeof(lVertexList[0]));
      1X  15096   }
      1X  15097 #else  /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      2	  15098   if (a->y < b->y) {
      2	  15099     grAADrawEdgeTriangle((float *) a, (float *) &c, (float *) &d);
      2	  15100     grAADrawEdgeTriangle((float *) a, (float *) &d, (float *) b);
      2	  15101   } else {
      2	  15102     grAADrawEdgeTriangle((float *) b, (float *) &d, (float *) &c);
      2	  15103     grAADrawEdgeTriangle((float *) b, (float *) &c, (float *) a);
      1	  15104   }
      1	  15105 #endif  /* !(GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP) */
      1	  15106 } /* grAADrawTriEdge */
	  15107 
	  15108 #define DXSQUARED(i,j) ((i->x - j->x) * (i->x - j->x))

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

	  15109 #define DYSQUARED(i,j) ((i->y - j->y) * (i->y - j->y))  
	  15110   
	  15111 /*
	  15112 **
	  15113 */
	  15114 static aaEdgeSense
	  15115 aaCalcEdgeSense(const GrVertex *a, const GrVertex *b, const GrVertex *c)
      1	  15116 {
      1	  15117   const GrVertex *tv;
      1	  15118   float dx, dy;
      1	  15119 
      2	  15120   if (a->y >= b->y) {
      2	  15121     tv = a; a = b; b = tv;
      1	  15122   }
      1	  15123   dx = a->x - b->x;
      1	  15124   dy = a->y - b->y;
      1	  15125 
      2	  15126   if (dx == 0.f) {
      2	  15127     return ((c->x > a->x) ? aaEdgeSenseLeft : aaEdgeSenseRight);
      1	  15128   }
      2	  15129   else if (dy == 0.0f) {
      2	  15130     return ((c->y > a->y) ? aaEdgeSenseBottom : aaEdgeSenseTop);
      1	  15131   }
      2	  15132   else {
      2	  15133     float dcax, dcay, dcbx, dcby, cp;
      2	  15134     dcax = a->x - c->x;
      2	  15135     dcay = a->y - c->y;
      2	  15136     dcbx = b->x - c->x;
      2	  15137     dcby = b->y - c->y;
      2	  15138     cp = dcax * dcby - dcay * dcbx;
      2	  15139 
      3	  15140     if (dx > 0.0f) {
      3	  15141       if (dx >= -dy)    /* X-major line */
      3	  15142         return ((cp > 0.0f) ? aaEdgeSenseTop : aaEdgeSenseBottom);
      3	  15143       else              /* Y-major line */
      3	  15144         return ((cp > 0.0f) ? aaEdgeSenseRight : aaEdgeSenseLeft);
      2	  15145     }
      3	  15146     else {
      3	  15147       if (dx <= dy)     /* X-major line */
      3	  15148         return ((cp < 0.0f) ? aaEdgeSenseTop : aaEdgeSenseBottom);
      3	  15149       else              /* Y-major line */
      3	  15150         return ((cp < 0.0f) ? aaEdgeSenseLeft : aaEdgeSenseRight);
      2	  15151     }
      1	  15152   }
      1	  15153 } /* aaCalcEdgeSense */
	  15154 
	  15155 /*---------------------------------------------------------------------------
	  15156 ** grAADrawTriangle
	  15157 **
	  15158 **  NOTE:  This doesn't quite work yet
	  15159 */
	  15160 GR_ENTRY(grAADrawTriangle,
	  15161          void,
	  15162          (const GrVertex *a, const GrVertex *b, const GrVertex *c,
	  15163           FxBool ab_antialias, FxBool bc_antialias, FxBool ca_antialias)) 
      1	  15164 {
      1	  15165 #define FN_NAME "grAADrawTriangle"

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1	  15166   FxU32
      1	  15167     fbzMode,                    /* What we write to fbzMode */
      1	  15168     fbzModeOld;                 /* Squirrel away current fbzMode */
      1	  15169   aaEdgeSense
      1	  15170     sense;                      /* Edge sense for edge polygons */
      1	  15171 
      1	  15172   GR_BEGIN_NOFIFOCHECK(FN_NAME, 96);
      1	  15173   GDBG_INFO_MORE(gc->myLevel,"(0x%x,0x%x,0x%x,%d,%d,%d)\n",
      1	  15174                  a,b,c,ab_antialias,bc_antialias,ca_antialias);
      1	  15175 
      1	  15176   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15177                          ((gc->cmdTransportInfo.paramMask & (SST_SETUP_A << SSTCP_PKT3_PMASK_SHIFT)) == 0),
      1	  15178                          "Antialiasing require enabling alpha");
      1	  15179   
      1	  15180   GR_FLUSH_STATE();
      1	  15181 
      1	  15182   fbzModeOld = gc->state.fbi_config.fbzMode;
      1	  15183   
      1	  15184   /* backfaced or zero area */
      1	  15185   if (TRISETUP(a, b, c) <= 0) return;
      1	  15186    
      1	  15187   /* Disable depth buffer writes for edge triangles */
      1	  15188   fbzMode = fbzModeOld;
      1	  15189   fbzMode &= ~(SST_ZAWRMASK);
      1	  15190 
      1	  15191   GR_SET_EXPECTED_SIZE(4, 1);
      1	  15192   GR_SET(BROADCAST_ID, hw, fbzMode, fbzMode);
      1	  15193   GR_CHECK_SIZE();
      1	  15194 
      2	  15195   if (ab_antialias) {
      2	  15196     sense = aaCalcEdgeSense(a, b, c);
      2	  15197     grAADrawTriEdge(a, b, sense);
      1	  15198   }
      1	  15199   
      2	  15200   if (bc_antialias) {
      2	  15201     sense = aaCalcEdgeSense(b, c, a);
      2	  15202     grAADrawTriEdge(b, c, sense);
      1	  15203   }
      1	  15204   
      2	  15205   if (ca_antialias) {
      2	  15206     sense = aaCalcEdgeSense(c, a, b);
      2	  15207     grAADrawTriEdge(c, a, sense);
      1	  15208   }
      1	  15209 
      1	  15210   /* Restore the old fbzMode */
      1	  15211   GR_SET_EXPECTED_SIZE(4, 1);
      1	  15212   GR_SET(BROADCAST_ID, hw, fbzMode, fbzModeOld);
      1	  15213   GR_END();
      1	  15214 #undef FN_NAME
      1	  15215 } /* grAADrawTriangle */
	  15216 
	  15217 /*---------------------------------------------------------------------------
	  15218 **  grAADrawPolygon
	  15219 **  NOTE:  This routine does not do backface culling!!!
	  15220 */
	  15221 
	  15222 GR_ENTRY(grAADrawPolygon, void, (const int nverts, const int ilist[], const GrVertex vlist[])) 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1	  15223 {
      1	  15224 #define FN_NAME "grAADrawPolygon"
      1	  15225   int
      1	  15226     i = 1;                      /* index into ilist */
      1	  15227   const GrVertex
      1	  15228     *a, *b, *c;                 /* What we end up sending */
      1	  15229   aaEdgeSense
      1	  15230     sense;                      /* Edge sense for edge polygons */
      1	  15231 
      1	  15232   GR_BEGIN_NOFIFOCHECK("grAADrawPolygon",97);
      1	  15233   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x,0x%x)\n",nverts,ilist,vlist);
      1	  15234 
      1	  15235   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15236                          ((gc->cmdTransportInfo.paramMask & (SST_SETUP_A << SSTCP_PKT3_PMASK_SHIFT)) == 0),
      1	  15237                          "Antialiasing require enabling alpha");
      1	  15238 
      1	  15239   GR_FLUSH_STATE();
      1	  15240 
      2	  15241   for (i=1; i < nverts - 1; i++) {
      2	  15242     a = &vlist[ilist[0]];
      2	  15243     b = &vlist[ilist[i]];
      2	  15244     c = &vlist[ilist[i+1]];
      2	  15245     if (TRISETUP (a, b, c) <= 0) /* backfaced or zero area */
      2	  15246       continue;
      2	  15247 
      2	  15248     /*
      2	  15249     **  Always draw the BC edge.
      2	  15250     **  On the first triangle, additionally draw the AB edge.
      2	  15251     **  On the last triangle, draw the CA edge.
      2	  15252     */
      3	  15253     if (i == 1) {
      3	  15254       sense = aaCalcEdgeSense(a, b, c);
      3	  15255       grAADrawTriEdge(a, b, sense);
      3	  15256 
      3	  15257     } else if (i == (nverts - 2)) {
      3	  15258       sense = aaCalcEdgeSense(c, a, b);
      3	  15259       grAADrawTriEdge(c, a, sense);
      2	  15260     } 
      2	  15261 
      2	  15262     sense = aaCalcEdgeSense(b, c, a);
      2	  15263     grAADrawTriEdge(b, c, sense);
      1	  15264   }
      1	  15265 
      1	  15266   GR_END();
      1	  15267 #undef FN_NAME
      1	  15268 } /* grAADrawPolygon */
	  15269 
	  15270 /*---------------------------------------------------------------------------
	  15271 **  grAADrawPolygonVertexList
	  15272 **  NOTE:  This routine does not do backface culling!!!
	  15273 */
	  15274 
	  15275 GR_ENTRY(grAADrawPolygonVertexList, void, (const int nverts, const GrVertex vlist[])) 
      1	  15276 {
      1	  15277 #define FN_NAME "grAADrawPolygonVertexList"
      1	  15278   int
      1	  15279     i = 1;                      /* index into ilist */

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

      1	  15280   const GrVertex
      1	  15281     *a, *b, *c;                 /* What we end up sending */
      1	  15282   aaEdgeSense
      1	  15283     sense;                      /* Edge sense for edge polygons */
      1	  15284   FxI32
      1	  15285     res;
      1	  15286 
      1	  15287   GR_BEGIN_NOFIFOCHECK("grAADrawPolygonVertexList",97);
      1	  15288   GDBG_INFO_MORE(gc->myLevel,"(%d,0x%x)\n",nverts,vlist);
      1	  15289 
      1	  15290   GR_CHECK_COMPATABILITY(FN_NAME,
      1	  15291                          ((gc->cmdTransportInfo.paramMask & (SST_SETUP_A << SSTCP_PKT3_PMASK_SHIFT)) == 0),
      1	  15292                          "Antialiasing require enabling alpha");
      1	  15293 
      1	  15294   GR_FLUSH_STATE();
      1	  15295 
      2	  15296   for (i=1; i < nverts - 1; i++) {
      2	  15297     a = &vlist[0];
      2	  15298     b = &vlist[i];
      2	  15299     c = &vlist[i+1];
      2	  15300 
      2	  15301     res = TRISETUP (a, b, c);
      2	  15302     if (res <= 0)               /* backfaced or zero area */
      2	  15303       continue;
      2	  15304 
      2	  15305     /*
      2	  15306     **  Always draw the BC edge.
      2	  15307     **  On the first triangle, additionally draw the AB edge.
      2	  15308     **  On the last triangle, draw the CA edge.
      2	  15309     */
      3	  15310     if (i == 1) {
      3	  15311       sense = aaCalcEdgeSense(a, b, c);
      3	  15312       grAADrawTriEdge(a, b, sense);
      3	  15313 
      3	  15314     } else if (i == (nverts - 2)) {
      3	  15315       sense = aaCalcEdgeSense(c, a, b);
      3	  15316       grAADrawTriEdge(c, a, sense);
      2	  15317     } 
      2	  15318 
      2	  15319     sense = aaCalcEdgeSense(b, c, a);
      2	  15320     grAADrawTriEdge(b, c, sense);
      2	  15321 
      1	  15322   }
      1	  15323   GR_END();
      1	  15324 
      1	  15325 #undef FN_NAME
      1	  15326 } /* grAADrawPolygonVertexList */
	  15327 
	  15328 

GAA                             Source Listing                   9-MAY-2021 23:42:51  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             2-FEB-2021 02:11:10  gaa.c;1

Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GAA/OBJECT=[.OUT
.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GAA.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIB
S.FXMISC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GL
IDE2X.CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP
,GLIDE_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1)
 [.GLIDE.GLIDE2X.CVG.GLIDE.SRC]GAA.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:42:51"  __Alpha_AXP=1  __VMS_VER=80421222 
 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 


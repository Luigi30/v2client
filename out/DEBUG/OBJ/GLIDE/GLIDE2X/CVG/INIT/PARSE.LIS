PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 1
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

	      1 /*
	      2 ** THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
	      3 ** PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
	      4 ** TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
	      5 ** INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
	      6 ** DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
	      7 ** THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
	      8 ** EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
	      9 ** FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
	     10 ** 
	     11 ** USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
	     12 ** RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
	     13 ** TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
	     14 ** AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
	     15 ** SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
	     16 ** THE UNITED STATES.  
	     17 ** 
	     18 ** COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
	     19 **
	     20 ** Parsing code for grabbing information from "voodoo2.ini" initialization file
	     21 **
	     22 */
	     23 #undef FX_DLL_ENABLE /* so that we don't dllexport the symbols */
       X     24 #ifdef _MSC_VER
       X     25 #pragma optimize ("",off)
       X     26 #endif
	     27 #include <stdio.h>
	   1638 #include <stdlib.h>
	   3733 #include <string.h>
	   4184 
       X   4185 #if __WIN32__
       X   4186 #include <windows.h>
       X   4187 
       X   4188 /* Path relative to HKEY_LOCAL_MACHINE */
       X   4189 #define REGSTR_PATH_3DFXSW              "Software\\3Dfx Interactive\\Voodoo2"
       X   4190 #define REGSTR_PATH_GLIDE               REGSTR_PATH_3DFXSW"\\Glide"
       X   4191 #endif /* __WIN32__ */
	   4192 
	   4193 #include <3dfx.h>
	   4324 #include <cvgregs.h>
	   4552 #include <cvgdefs.h>
	   5493 #define FX_DLL_DEFINITION
	   5494 #include <fxdll.h>
	   5615 #include <sst1vid.h>
	   5725 #include <sst1init.h>
	   8363 
	   8364 static int sst1InitFgets(char *, FILE *);
	   8365 static int sst1InitFgetc(FILE *);
	   8366 static int sst1InitParseFieldCfg(char *);
	   8367 static void sst1InitToLower(char *string);
	   8368 #if TEST || (!defined(INIT_LINUX) && !defined(DIRECTX))
	   8369 static int sst1InitParseFieldDac(char *);
	   8370 static int sst1InitParseDacRdWrString(char *, sst1InitDacStruct *);
	   8371 static int sst1InitParseDacRdWr(char *, sst1InitDacRdWrStruct *);
	   8372 static int sst1InitParseSetVideoString(char *, sst1InitDacStruct *);
	   8373 static int sst1InitParseSetMemClkString(char *, sst1InitDacStruct *);
	   8374 static int sst1InitParseSetVideoModeString(char *, sst1InitDacStruct *);

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 2
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

	   8375 #endif
       X   8376 #if !defined(INIT_LINUX) && !defined(DIRECTX) && __DOS32__
       X   8377 static void sst1InitFixFilename(char *dst, char *src);
       X   8378 #endif
       X   8379 #if TEST
       X   8380 static void sst1InitPrintDacRdWr(sst1InitDacRdWrStruct *, char *);
       X   8381 #endif
	   8382 
	   8383 static FxBool checkedFileP = FXFALSE;
	   8384 
	   8385 #ifndef INIT_LINUX
	   8386 /*
	   8387 ** sst1InitVoodooFile():
	   8388 **  Find and setup "voodoo2.ini" file if possible
	   8389 **
	   8390 **    Returns:
	   8391 **      FxTRUE if "voodoo2.ini" file is found, opened with no errors, and
	   8392 **             constains the dac programming data.
	   8393 **      FXFALSE if cannot find file, error opening file, or has no dac data in it.
	   8394 **
	   8395 */
	   8396 FX_ENTRY FxBool FX_CALL sst1InitVoodooFile()
      1	   8397 {
      1	   8398   static FxBool retVal = FXFALSE;
      1	   8399 
      1	   8400 #ifndef DIRECTX
      1	   8401   int inCfg, inDac;
      1	   8402   FILE *file = NULL;
      1	   8403   char buffer[1024], filename[256];
      1	   8404   int helper = (getenv(("SSTV2_DEBUGDAC"))) ? 1 : 0;
      1	   8405 
      1	   8406 	filename[0] = '\0';
      1	   8407 	if (checkedFileP) goto __errExit;
      1	   8408 	
      1X   8409 #if __DOS32__
      1X   8410 	{
      1X   8411 	  char fixedFilename[512], *tmpPtr;
      1X   8412 	  char path[512];
      1X   8413 	  int i;
      1X   8414 
      1X   8415 
      1X   8416 	  if(getenv("VOODOO2_FILE")) {
      1X   8417 	    /* Override voodoo2.ini name */
      1X   8418 	    strncpy(filename, getenv("VOODOO2_FILE"), 255);
      1X   8419 	    if(!(file = fopen(filename, "r"))) goto __errExit;
      1X   8420 	  } else {
      1X   8421 	    /* Override path setting */
      1X   8422 	    if(getenv("VOODOO2_PATH"))
      1X   8423 	      strncpy(path, getenv("VOODOO2_PATH"), 511);
      1X   8424 	    else if(getenv("PATH")) {
      1X   8425 	      strcpy(path, ".;");
      1X   8426 	      strncat(path, getenv("PATH"), 511 - strlen (path));
      1X   8427 	    } else
      1X   8428 	      strcpy(path, ".;");
      1X   8429 
      1X   8430 	    i = 0;
      1X   8431 	    while(1) {

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 3
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1X   8432 	      if(!i) {
      1X   8433 	        if((tmpPtr = strtok(path, ";")) == NULL)
      1X   8434 	          break;
      1X   8435 	      } else {
      1X   8436 	        if((tmpPtr = strtok(NULL, ";")) == NULL)
      1X   8437 	          break;
      1X   8438 	      }
      1X   8439 	      strcpy(filename, tmpPtr);
      1X   8440 	      sst1InitFixFilename(fixedFilename, filename);
      1X   8441 	      if(fixedFilename[strlen(fixedFilename)-1] == '\\')
      1X   8442 	        sprintf(filename, "%svoodoo2.var", filename);
      1X   8443 	      else
      1X   8444 	        sprintf(filename, "%s\\voodoo2.var", filename);
      1X   8445 	      i++;
      1X   8446 	      if((file = fopen(filename, "r")))
      1X   8447 	        break;
      1X   8448 	    }
      1X   8449 	  }
      1X   8450 	}
      1X   8451 #elif __MWERKS__
      1X   8452 	{
      1X   8453 		FSSpec iniSpec = {
      1X   8454 			0, 0,
      1X   8455 			"\pvoodoo2.var"
      1X   8456 		};
      1X   8457 		Boolean foundP = false;
      1X   8458 		
      1X   8459 		/* Check the app's directory */
      1X   8460 		if (!foundP) {
      1X   8461 			ProcessSerialNumber curApp;
      1X   8462 			ProcessInfoRec appInfo;
      1X   8463 			FSSpec appSpec;
      1X   8464 			
      1X   8465 			if (GetCurrentProcess(&curApp) != noErr) goto __errAppDir;
      1X   8466 
      1X   8467 			/* We only care about the app's location */
      1X   8468 			appInfo.processInfoLength = sizeof(ProcessInfoRec);
      1X   8469 			appInfo.processName = NULL;
      1X   8470 			appInfo.processAppSpec = &appSpec;
      1X   8471 			if (GetProcessInformation(&curApp, &appInfo) != noErr) goto __errAppDir;
      1X   8472 			
      1X   8473 			{
      1X   8474 				CInfoPBRec thePB;
      1X   8475 
      1X   8476 				thePB.hFileInfo.ioCompletion = NULL;
      1X   8477 				thePB.hFileInfo.ioNamePtr = iniSpec.name;
      1X   8478 				thePB.hFileInfo.ioVRefNum = appSpec.vRefNum;
      1X   8479 				thePB.hFileInfo.ioDirID = appSpec.parID;
      1X   8480 
      1X   8481 				thePB.hFileInfo.ioFDirIndex = 0;
      1X   8482 
      1X   8483 				foundP = ((PBGetCatInfoSync(&thePB) == noErr) &&
      1X   8484 									((thePB.hFileInfo.ioFlAttrib & (0x01 << 4)) 
      1X   8484 == 0));
      1X   8485 				if (foundP) {
      1X   8486 					iniSpec.vRefNum = appSpec.vRefNum;
      1X   8487 					iniSpec.parID = appSpec.parID;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 4
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1X   8488 				}
      1X   8489 			}			
      1X   8490 			
      1X   8491 		__errAppDir:
      1X   8492 			;
      1X   8493 		}
      1X   8494 		
      1X   8495 		/* Check the mac's version of the 'search path' */
      1X   8496 		if (!foundP) {
      1X   8497 			OSType folderList[] = { kPreferencesFolderType, kExtensionFolderType };
      1X   8498 			int i;
      1X   8499 
      1X   8500 			for(i = 0; i < sizeof(folderList) / sizeof(folderList[0]); i++) {
      1X   8501 				short vRefNum;
      1X   8502 				long dirId;
      1X   8503 				
      1X   8504 				if (FindFolder(kOnSystemDisk, folderList[i], false, 
      1X   8505 											 &vRefNum, &dirId) == noErr)
      1X   8505  {
      1X   8506 				
      1X   8507 					CInfoPBRec thePB;
      1X   8508 					
      1X   8509 					thePB.hFileInfo.ioCompletion = NULL;
      1X   8510 					thePB.hFileInfo.ioNamePtr = iniSpec.name;
      1X   8511 					thePB.hFileInfo.ioVRefNum = vRefNum;
      1X   8512 					thePB.hFileInfo.ioDirID = dirId;
      1X   8513 					
      1X   8514 					thePB.hFileInfo.ioFDirIndex = 0;
      1X   8515 					
      1X   8516 					foundP = ((PBGetCatInfoSync(&thePB) == noErr) &&
      1X   8517 										((thePB.hFileInfo.ioFlAttrib & (0x01
      1X   8517  << 4)) == 0));
      1X   8518 					if (foundP) {
      1X   8519 						iniSpec.vRefNum = vRefNum;
      1X   8520 						iniSpec.parID = dirId;
      1X   8521 						
      1X   8522 						break;
      1X   8523 					}
      1X   8524 				}
      1X   8525 			}
      1X   8526 		}
      1X   8527 		
      1X   8528 		if (foundP) {
      1X   8529 			short wdRefNum;
      1X   8530 			long  wdDirId;
      1X   8531 			
      1X   8532 			/* Change working directories, just in case the app did something else */
      1X   8533 			if (HGetVol(NULL, &wdRefNum, &wdDirId) != noErr) goto __errFile;
      1X   8534 			if (HSetVol(NULL, iniSpec.vRefNum, iniSpec.parID) != noErr) goto __errFile;
      1X   8535 			
      1X   8536 			/* NB: We leave the name trashed after this */
      1X   8537 			p2cstr(iniSpec.name);
      1X   8538 			file = fopen((const char*)iniSpec.name, "r");
      1X   8539 			
      1X   8540 			HSetVol(NULL, wdRefNum, wdDirId);
      1X   8541 			
      1X   8542 		__errFile:

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 5
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1X   8543 			;
      1X   8544 		}
      1X   8545 	}
      1X   8546 #endif
      1	   8547 
      1	   8548   if(file == NULL) goto __errExit;
      1	   8549 
      1	   8550   inCfg = inDac = 0;
      2	   8551   while(sst1InitFgets(buffer, file)) {
      2	   8552     buffer[strlen(buffer)-1] = 0;
      3	   8553     if(!strcmp(buffer, "[VOODOO2]")) {
      3	   8554       inCfg = 1; inDac = 0;
      3	   8555       continue;
      3	   8556     } else if (!strcmp(buffer, "[DAC]")) {
      3	   8557       inCfg = 0; inDac = 1;
      3	   8558       retVal = FXTRUE;
      3	   8559       continue;
      3	   8560     } else if(buffer[0] == '[') {
      3	   8561       inCfg = 0; inDac = 0;
      3	   8562       continue;
      2	   8563     }
      2	   8564 
      3	   8565     if(inCfg) {
      4	   8566       if(!sst1InitParseFieldCfg(buffer)) {
      4	   8567         if(helper) INIT_PRINTF(("ERROR in %s section of .ini file.\n", "[CFG]"));
      4	   8568         retVal = FXFALSE;
      4	   8569         break;
      3	   8570       }
      3	   8571     } else if(inDac) {
      4	   8572       if(!sst1InitParseFieldDac(buffer)) {
      4	   8573         if(helper) INIT_PRINTF(("ERROR in %s section of .ini file.\n", "[DAC]"));
      4	   8574         retVal = FXFALSE;
      4	   8575         break;
      3	   8576       }
      2	   8577     }
      1	   8578   }
      1	   8579   fclose(file);
      1	   8580   INIT_PRINTF(("INIT: Using .ini file '%s'\n", filename));
      1	   8581 
      1	   8582 __errExit:
      1	   8583   checkedFileP = FXTRUE;
      1	   8584 #endif /* !DIRECTX */
      1	   8585 
      1	   8586   return retVal;
      1	   8587 }
	   8588 
       X   8589 #else
       X   8590 
       X   8591 /*
       X   8592 ** sst1InitVoodooFile():
       X   8593 **  Find and setup "voodoo2.ini" file if possible
       X   8594 **
       X   8595 **    Returns:
       X   8596 **      FxTRUE if "voodoo2.ini" file is found, opened with no errors, and
       X   8597 **             constains the dac programming data.
       X   8598 **      FXFALSE if cannot find file, error opening file, or has no dac data in it.
       X   8599 **

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 6
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8600 */
       X   8601 FX_ENTRY FxBool FX_CALL sst1InitVoodooFile() {
       X   8602   static FxBool retVal = FXFALSE;
       X   8603   FILE *file = 0;
       X   8604   char buffer[1024], filename[256];
       X   8605   char *tmpPtr;
       X   8606   char path[512];
       X   8607   int i;
       X   8608 
       X   8609   filename[0] = '\0';
       X   8610   if (checkedFileP) goto __errExit;
       X   8611 
       X   8612   if (getenv("VOODOO2_FILE")) {
       X   8613     /* Override voodoo2.ini name */
       X   8614     strncpy(filename, getenv("VOODOO2_FILE"), 255);
       X   8615     if (!(file = fopen(filename, "r"))) 
       X   8616       goto __errExit;
       X   8617   } else {
       X   8618     /* Override path setting */
       X   8619     if (getenv("VOODOO2_PATH")) {
       X   8620       strncpy(path, getenv("VOODOO2_PATH"), 511);
       X   8621     } else {
       X   8622       strcpy(path, "/etc/conf.3dfx");
       X   8623     }
       X   8624 
       X   8625     i = 0;
       X   8626     while(1) {
       X   8627       if (!i) {
       X   8628 	if ((tmpPtr = strtok(path, ":")) == NULL)
       X   8629 	  break;
       X   8630       } else {
       X   8631 	if ((tmpPtr = strtok(NULL, ":")) == NULL)
       X   8632 	  break;
       X   8633       }
       X   8634       strncpy(filename, tmpPtr, 255);
       X   8635       if (filename[strlen(filename)-1] == '\\')
       X   8636 	snprintf(filename, 255, "%s/voodoo2", filename);
       X   8637       else
       X   8638 	snprintf(filename, 255, "%s/voodoo2", filename);
       X   8639       i++;
       X   8640       if ((file = fopen(filename, "r")))
       X   8641 	break;
       X   8642     }
       X   8643   }
       X   8644   if (!file) {
       X   8645     retVal = FXFALSE;
       X   8646     goto __errExit;
       X   8647   }
       X   8648   while(sst1InitFgets(buffer, file)) {
       X   8649     buffer[strlen(buffer)-1] = 0;
       X   8650     if (buffer[0]=='#') continue;
       X   8651     if (!sst1InitParseFieldCfg(buffer)) {
       X   8652       retVal = FXFALSE;
       X   8653       break;
       X   8654     }
       X   8655   }
       X   8656   INIT_PRINTF(("INIT: Using .ini file '%s'\n", filename));

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 7
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8657 
       X   8658 __errExit:
       X   8659   if (file) fclose(file);
       X   8660   checkedFileP = FXTRUE;
       X   8661 
       X   8662   return retVal;
       X   8663 }
       X   8664 #endif
	   8665 
       X   8666 #if defined(INIT_DOS) || defined(INIT_LINUX) || defined(__WIN32__)
       X   8667 
       X   8668 #if TEST
       X   8669 /* void main(int argc, char **argv) */
       X   8670 static void foo(int argc, char **argv)
       X   8671 {
       X   8672     char buffer[2048]; /* buffer for command line inputs */
       X   8673     int inCfg, inDac;
       X   8674     sst1InitEnvVarStruct *envVarsPtr;
       X   8675     sst1InitDacStruct *dacPtr;
       X   8676     sst1InitDacSetVideoStruct *setVideo;
       X   8677     sst1InitDacSetMemClkStruct *setMemClk;
       X   8678     FILE *file = fopen(argv[1], "r");
       X   8679 
       X   8680     inCfg = inDac = 0;
       X   8681     while(sst1InitFgets(buffer, file)) {
       X   8682         buffer[strlen(buffer)-1] = 0;
       X   8683         if(!strcmp(buffer, "[CFG]")) {
       X   8684             inCfg = 1; inDac = 0;
       X   8685             continue;
       X   8686         } else if (!strcmp(buffer, "[DAC]")) {
       X   8687             inCfg = 0; inDac = 1;
       X   8688             continue;
       X   8689         } else if(buffer[0] == '[') {
       X   8690             inCfg = 0; inDac = 0;
       X   8691             continue;
       X   8692         }
       X   8693         if(inCfg) {
       X   8694             if(!sst1InitParseFieldCfg(buffer))
       X   8695                 /* Error processing .ini file */
       X   8696                 exit(1);
       X   8697         } else if(inDac) {
       X   8698             if(!sst1InitParseFieldDac(buffer))
       X   8699                 /* Error processing .ini file */
       X   8700                 exit(1);
       X   8701         }
       X   8702     }
       X   8703 
       X   8704     /* Dump CFG Data... */
       X   8705     envVarsPtr = envVarsBase;
       X   8706     while(envVarsPtr) {
       X   8707         printf("ENV VAR:%s  VALUE:%s\n", envVarsPtr->envVariable,
       X   8708             envVarsPtr->envValue);
       X   8709         envVarsPtr = (sst1InitEnvVarStruct *) envVarsPtr->nextVar;
       X   8710     }
       X   8711 
       X   8712     /* Dump Dac Data... */
       X   8713     dacPtr = dacStructBase;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 8
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8714     while(dacPtr) {
       X   8715         printf("DAC MANU:%s  DEVICE:%s\n", dacPtr->dacManufacturer,
       X   8716             dacPtr->dacDevice);
       X   8717         if(dacPtr->detect) {
       X   8718             printf("\tDetect:\n");
       X   8719             sst1InitPrintDacRdWr(dacPtr->detect, "\t\t");
       X   8720         }
       X   8721         if(dacPtr->setVideo) {
       X   8722             setVideo = dacPtr->setVideo;
       X   8723             while(1) {
       X   8724                 printf("\tsetVideo (%dx%d @ %d Hz)\n",
       X   8725                   setVideo->width, setVideo->height, setVideo->refresh);
       X   8726                 sst1InitPrintDacRdWr(setVideo->setVideoRdWr, "\t\t");
       X   8727                 if(!setVideo->nextSetVideo)
       X   8728                     break;
       X   8729                 else
       X   8730                     setVideo = setVideo->nextSetVideo;
       X   8731             }
       X   8732         }
       X   8733         if(dacPtr->setMemClk) {
       X   8734             setMemClk = dacPtr->setMemClk;
       X   8735             while(1) {
       X   8736                 printf("\tsetMemClk (%d MHz)\n", setMemClk->frequency);
       X   8737                 sst1InitPrintDacRdWr(setMemClk->setMemClkRdWr, "\t\t");
       X   8738                 if(!setMemClk->nextSetMemClk)
       X   8739                     break;
       X   8740                 else
       X   8741                     setMemClk = setMemClk->nextSetMemClk;
       X   8742             }
       X   8743         }
       X   8744         dacPtr = dacPtr->nextDac;
       X   8745     }
       X   8746     fclose(file);
       X   8747 }
       X   8748 #endif
       X   8749 
       X   8750 #if !defined(INIT_LINUX) && !defined(DIRECTX) && __DOS32__
       X   8751 static void sst1InitFixFilename(char *dst, char *src)
       X   8752 {
       X   8753     while(*src) {
       X   8754         *dst++ = *src;
       X   8755         if(*src == '\\')
       X   8756             *dst++ = *src;
       X   8757         src++;
       X   8758     }
       X   8759     *dst = 0;
       X   8760 }
       X   8761 #endif
       X   8762 
       X   8763 static int sst1InitFgets(char *string, FILE *stream)
       X   8764 {
       X   8765     int validChars = 0;
       X   8766     char *ptr = string;
       X   8767     int charRead;
       X   8768 
       X   8769     while(0 != ((charRead = sst1InitFgetc(stream)))) {
       X   8770         *ptr++ = (char) charRead;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 9
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8771         validChars++;
       X   8772         if(charRead == '\n') {
       X   8773             *ptr++ = 0;
       X   8774             break;
       X   8775         }
       X   8776     }
       X   8777     return(validChars);
       X   8778 }
       X   8779 
       X   8780 static __inline int sst1_isspace (int c)
       X   8781 {
       X   8782     switch(c) {
       X   8783     case ' ':  case '\t':
       X   8784     case '\n': case '\r':
       X   8785     case '\f': case '\v': return 1;
       X   8786     }
       X   8787     return 0;
       X   8788 }
       X   8789 
       X   8790 static int sst1InitFgetc(FILE *stream)
       X   8791 {
       X   8792     static int column = 0;
       X   8793     static int validChars = 0;
       X   8794     int charRead, charReadL;
       X   8795     int inComment;
       X   8796 
       X   8797     inComment = 0;
       X   8798     while(1) {
       X   8799         charRead = fgetc(stream);
       X   8800         if(inComment == 1) {
       X   8801             if(charRead <= 0)
       X   8802                 return(0);
       X   8803             else if(charRead == '\n')
       X   8804                 inComment = 0;
       X   8805             column = 0;
       X   8806             validChars = 0;
       X   8807             continue;
       X   8808         } else if(column == 0 && charRead == '#') {
       X   8809             /* Comment line */
       X   8810             inComment = 1;
       X   8811             column = 0;
       X   8812             validChars = 0;
       X   8813         } else if(charRead <= 0) {
       X   8814                 return(0);
       X   8815         } else {
       X   8816             if(charRead == '\n') {
       X   8817                 if(validChars > 0) {
       X   8818                     validChars = 0;
       X   8819                     column = 0;
       X   8820                     return(charRead);
       X   8821                 } else
       X   8822                     continue;
       X   8823             } else {
       X   8824                 if(sst1_isspace(charRead))
       X   8825                     continue;
       X   8826                 validChars++;
       X   8827                 column++;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 10
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8828                 charReadL = charRead;
       X   8829                 if (charReadL >= 'a' && charReadL <= 'z')
       X   8830                     charReadL -= ('a'-'A');
       X   8831                 return(charReadL);
       X   8832             }
       X   8833         }
       X   8834     }
       X   8835 }
       X   8836 
       X   8837 static int sst1InitParseFieldCfg(char *string)
       X   8838 {
       X   8839     char *envName, *envVal;
       X   8840     sst1InitEnvVarStruct *envVarsPtr;
       X   8841 
       X   8842     if((envName = strtok(string, "=")) == NULL)
       X   8843         return(0);
       X   8844     if((envVal = strtok(NULL, "=")) == NULL)
       X   8845         /* Valid environment variable, NULL value */
       X   8846         return(1);
       X   8847 
       X   8848     /* .ini canonical form is now lower case */
       X   8849     sst1InitToLower(envName);
       X   8850     sst1InitToLower(envVal);
       X   8851 
       X   8852     if(envVarsBase == NULL) {
       X   8853         if((envVarsPtr = malloc(sizeof(sst1InitEnvVarStruct))) == NULL)
       X   8854             return(0);
       X   8855         envVarsBase = envVarsPtr;
       X   8856     } else {
       X   8857         envVarsPtr = envVarsBase;
       X   8858         while(1) {
       X   8859             if(envVarsPtr->nextVar == NULL)
       X   8860                 break;
       X   8861             else
       X   8862                envVarsPtr = envVarsPtr->nextVar;
       X   8863         }
       X   8864         if((envVarsPtr->nextVar = malloc(sizeof(sst1InitEnvVarStruct))) == NULL)
       X   8865             return(0);
       X   8866         envVarsPtr = envVarsPtr->nextVar;
       X   8867     }
       X   8868     envVarsPtr->nextVar = NULL;
       X   8869     strcpy(envVarsPtr->envVariable, envName);
       X   8870     strcpy(envVarsPtr->envValue, envVal);
       X   8871 
       X   8872     return(1);
       X   8873 }
       X   8874 
       X   8875 #if TEST || (!defined(INIT_LINUX) && !defined(DIRECTX))
       X   8876 static int sst1InitParseFieldDac(char *string)
       X   8877 {
       X   8878     char *dacFieldReference, *dacFieldValue;
       X   8879     static sst1InitDacStruct *dacPtr = NULL;
       X   8880 
       X   8881     if((dacFieldReference = strtok(string, "=")) == NULL)
       X   8882         return(0);
       X   8883     if(!strcmp(dacFieldReference, "MANUFACTURER")) {
       X   8884         /* Add new dac device */

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 11
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8885         if(dacStructBase == NULL) {
       X   8886             if((dacPtr = malloc(sizeof(sst1InitDacStruct))) == NULL)
       X   8887                 return(0);
       X   8888             dacStructBase = dacPtr;
       X   8889         } else {
       X   8890             dacPtr = dacStructBase;
       X   8891             while(1) {
       X   8892                 if(dacPtr->nextDac == NULL)
       X   8893                     break;
       X   8894                 else
       X   8895                    dacPtr = dacPtr->nextDac;
       X   8896             }
       X   8897             if((dacPtr->nextDac = malloc(sizeof(sst1InitDacStruct))) == NULL)
       X   8898                 return(0);
       X   8899             dacPtr = dacPtr->nextDac;
       X   8900         }
       X   8901         dacPtr->nextDac = NULL;
       X   8902         dacPtr->dacManufacturer[0] = 0;
       X   8903         dacPtr->dacDevice[0] = 0;
       X   8904         dacPtr->detect = NULL;
       X   8905         dacPtr->setVideo = NULL;
       X   8906         dacPtr->setMemClk = NULL;
       X   8907         dacPtr->setVideoMode = NULL;
       X   8908         if((dacFieldValue = strtok((char *) NULL, "=")) == NULL)
       X   8909             return(0);
       X   8910         strcpy(dacPtr->dacManufacturer, dacFieldValue);
       X   8911     } else if(!strcmp(dacFieldReference, "DEVICE")) {
       X   8912         if((dacFieldValue = strtok(NULL, "=")) == NULL)
       X   8913             return(0);
       X   8914         strcpy(dacPtr->dacDevice, dacFieldValue);
       X   8915     } else if(!strcmp(dacFieldReference, "DETECT")) {
       X   8916         if((dacFieldValue = strtok(NULL, "=")) == NULL)
       X   8917             return(0);
       X   8918         sst1InitToLower(dacFieldValue);
       X   8919         if(!sst1InitParseDacRdWrString(dacFieldValue, dacPtr))
       X   8920             return(0);
       X   8921     } else if(!strcmp(dacFieldReference, "SETVIDEO")) {
       X   8922         if((dacFieldValue = strtok(NULL, "=")) == NULL)
       X   8923             return(0);
       X   8924         sst1InitToLower(dacFieldValue);
       X   8925         if(!sst1InitParseSetVideoString(dacFieldValue, dacPtr))
       X   8926             return(0);
       X   8927     } else if(!strcmp(dacFieldReference, "SETMEMCLK")) {
       X   8928         if((dacFieldValue = strtok(NULL, "=")) == NULL)
       X   8929             return(0);
       X   8930         sst1InitToLower(dacFieldValue);
       X   8931         if(!sst1InitParseSetMemClkString(dacFieldValue, dacPtr))
       X   8932             return(0);
       X   8933     } else if(!strcmp(dacFieldReference, "SETVIDEOMODE")) {
       X   8934         if((dacFieldValue = strtok(NULL, "=")) == NULL)
       X   8935             return(0);
       X   8936         sst1InitToLower(dacFieldValue);
       X   8937         if(!sst1InitParseSetVideoModeString(dacFieldValue, dacPtr))
       X   8938             return(0);
       X   8939     } else
       X   8940         return(0);
       X   8941 

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 12
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8942     return(1);
       X   8943 }
       X   8944 
       X   8945 static int sst1InitParseDacRdWrString(char *string, sst1InitDacStruct *dacBase)
       X   8946 {
       X   8947     int cntr = 0;
       X   8948     int i;
       X   8949     sst1InitDacRdWrStruct *dacRdWrPtr;
       X   8950     char *dacRdWrCmd;
       X   8951     char stringCpy[2048];
       X   8952 
       X   8953     while(1) {
       X   8954         strcpy(stringCpy, string);
       X   8955         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
       X   8956             return(0);
       X   8957         if(cntr == 0) {
       X   8958             if(!(dacBase->detect = malloc(sizeof(sst1InitDacRdWrStruct))))
       X   8959                 return(0);
       X   8960             dacRdWrPtr = dacBase->detect;
       X   8961         } else {
       X   8962             for(i=0; i<(cntr-1); i++) {
       X   8963                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   8964                     return(0);
       X   8965             }
       X   8966             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
       X   8967                 break;
       X   8968             }
       X   8969             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct)))) 
       X   8970                 return(0);
       X   8971 
       X   8972             dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   8973         }
       X   8974         dacRdWrPtr->nextRdWr = NULL;
       X   8975         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
       X   8976             return(0);
       X   8977         cntr++;
       X   8978     }
       X   8979     return(1);
       X   8980 }
       X   8981 
       X   8982 static int sst1InitParseDacRdWr(char *string, sst1InitDacRdWrStruct *dacRdWrPtr)
       X   8983 {
       X   8984     char *addr, *data, *mask, *addrDataCmd;
       X   8985     char stringCpy[2048];
       X   8986     int i1, i2, i3;
       X   8987 
       X   8988     strcpy(stringCpy, string);
       X   8989 
       X   8990     if(stringCpy[5] == '(') {
       X   8991         stringCpy[5] = 0;
       X   8992         addrDataCmd = &stringCpy[6];
       X   8993     } else if(stringCpy[7] == '(') {
       X   8994         stringCpy[7] = 0;
       X   8995         addrDataCmd = &stringCpy[8];
       X   8996     } else if(stringCpy[8] == '(') {
       X   8997         stringCpy[8] = 0;
       X   8998         addrDataCmd = &stringCpy[9];

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 13
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   8999     } else if(stringCpy[9] == '(') {
       X   9000         stringCpy[9] = 0;
       X   9001         addrDataCmd = &stringCpy[10];
       X   9002     } else
       X   9003         return(0);
       X   9004 
       X   9005     if(!strcmp(stringCpy, "dacwr")) {
       X   9006         if((addr = strtok(addrDataCmd, ",")) == NULL)
       X   9007             return(0);
       X   9008         if((data = strtok(NULL, ",")) == NULL)
       X   9009             return(0);
       X   9010         if(data[strlen(data)-1] != ')')
       X   9011             return(0);
       X   9012         data[strlen(data)-1] = '\0';
       X   9013         dacRdWrPtr->type = DACRDWR_TYPE_WR;
       X   9014         if (SSCANF(addr, "%i", &i1) != 1)
       X   9015             return(0);
       X   9016         if (SSCANF(data, "%i", &i2) != 1)
       X   9017             return(0);
       X   9018         dacRdWrPtr->addr = i1;
       X   9019         dacRdWrPtr->data = i2;
       X   9020     } else if(!strcmp(stringCpy, "dacwrpop")) {
       X   9021         if((addr = strtok(addrDataCmd, ",")) == NULL)
       X   9022             return(0);
       X   9023         if((mask = strtok(NULL, ",")) == NULL)
       X   9024             return(0);
       X   9025         if((data = strtok(NULL, ",")) == NULL)
       X   9026             return(0);
       X   9027         if(data[strlen(data)-1] != ')')
       X   9028             return(0);
       X   9029         data[strlen(data)-1] = 0;
       X   9030         dacRdWrPtr->type = DACRDWR_TYPE_WRMOD_POP;
       X   9031         if (SSCANF(addr, "%i", &i1) != 1)
       X   9032             return(0);
       X   9033         if (SSCANF(mask, "%i", &i2) != 1)
       X   9034             return(0);
       X   9035         if (SSCANF(data, "%i", &i3) != 1)
       X   9036             return(0);
       X   9037         dacRdWrPtr->addr = i1;
       X   9038         dacRdWrPtr->mask = i2;
       X   9039         dacRdWrPtr->data = i3;
       X   9040     } else if(!strcmp(stringCpy, "dacrdwr")) {
       X   9041         if((addr = strtok(addrDataCmd, ",")) == NULL)
       X   9042             return(0);
       X   9043         if((mask = strtok(NULL, ",")) == NULL)
       X   9044             return(0);
       X   9045         if((data = strtok(NULL, ",")) == NULL)
       X   9046             return(0);
       X   9047         if(data[strlen(data)-1] != ')')
       X   9048             return(0);
       X   9049         data[strlen(data)-1] = 0;
       X   9050         dacRdWrPtr->type = DACRDWR_TYPE_RDMODWR;
       X   9051         if (SSCANF(addr, "%i", &i1) != 1)
       X   9052             return(0);
       X   9053         if (SSCANF(mask, "%i", &i2) != 1)
       X   9054             return(0);
       X   9055         if (SSCANF(data, "%i", &i3) != 1)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 14
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9056             return(0);
       X   9057         dacRdWrPtr->addr = i1;
       X   9058         dacRdWrPtr->mask = i2;
       X   9059         dacRdWrPtr->data = i3;
       X   9060     } else if(!strcmp(stringCpy, "dacrd")) {
       X   9061         if((addr = strtok(addrDataCmd, ",")) == NULL)
       X   9062             return(0);
       X   9063         if(addr[strlen(addr)-1] == ')') {
       X   9064             dacRdWrPtr->type = DACRDWR_TYPE_RDNOCHECK;
       X   9065             if (SSCANF(addr, "%i", &i1) != 1)
       X   9066                 return(0);
       X   9067             dacRdWrPtr->addr = i1;
       X   9068         } else {
       X   9069             dacRdWrPtr->type = DACRDWR_TYPE_RDCHECK;
       X   9070             if((data = strtok(NULL, ",")) == NULL)
       X   9071                 return(0);
       X   9072             if(data[strlen(data)-1] != ')')
       X   9073                 return(0);
       X   9074             data[strlen(data)-1] = 0;
       X   9075             if (SSCANF(addr, "%i", &i1) != 1)
       X   9076                 return(0);
       X   9077             if (SSCANF(data, "%i", &i2) != 1)
       X   9078                 return(0);
       X   9079             dacRdWrPtr->addr = i1;
       X   9080             dacRdWrPtr->data = i2;
       X   9081         }
       X   9082     } else if(!strcmp(stringCpy, "dacrdpush")) {
       X   9083         if((addr = strtok(addrDataCmd, ",")) == NULL)
       X   9084             return(0);
       X   9085         if(addr[strlen(addr)-1] == ')') {
       X   9086             dacRdWrPtr->type = DACRDWR_TYPE_RDPUSH;
       X   9087             if (SSCANF(addr, "%i", &i1) != 1)
       X   9088                 return(0);
       X   9089             dacRdWrPtr->addr = i1;
       X   9090         } else
       X   9091             return(0);
       X   9092     } else {
       X   9093         return(0);
       X   9094     }
       X   9095 
       X   9096     return(1);
       X   9097 }
       X   9098 
       X   9099 #if TEST
       X   9100 static void sst1InitPrintDacRdWr(sst1InitDacRdWrStruct *dacRdWrBase,
       X   9101   char *prefix)
       X   9102 {
       X   9103     sst1InitDacRdWrStruct *dacRdWrPtr = dacRdWrBase;
       X   9104 
       X   9105     while(dacRdWrPtr) {
       X   9106         if(dacRdWrPtr->type == DACRDWR_TYPE_WR) {
       X   9107             printf("%sDacWR", prefix);
       X   9108             printf("(0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->data);
       X   9109         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDMODWR) {
       X   9110             printf("%sDacRD-MOD-WR", prefix);
       X   9111             printf("(0x%x,0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->mask,
       X   9112               dacRdWrPtr->data);

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 15
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9113         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDNOCHECK) {
       X   9114             printf("%sDacRD-NOCHECK", prefix);
       X   9115             printf("(0x%x)\n", dacRdWrPtr->addr);
       X   9116         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDCHECK) {
       X   9117             printf("%sDacRD-CHECK", prefix);
       X   9118             printf("(0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->data);
       X   9119         } else
       X   9120             printf("%sDAC???", prefix);
       X   9121         dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   9122     }
       X   9123 }
       X   9124 #endif /* TEST */
       X   9125 
       X   9126 static int sst1InitParseSetVideoString(char *string, sst1InitDacStruct *dacBase)
       X   9127 {
       X   9128     int cntr = 0;
       X   9129     int i;
       X   9130     sst1InitDacRdWrStruct *dacRdWrPtr;
       X   9131     sst1InitDacSetVideoStruct *dacSetVideoPtr;
       X   9132     char *dacRdWrCmd;
       X   9133     char stringCpy[2048];
       X   9134 
       X   9135     while(1) {
       X   9136         strcpy(stringCpy, string);
       X   9137         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
       X   9138             return(0);
       X   9139         if(cntr == 0) {
       X   9140             if(!dacBase->setVideo) {
       X   9141                 if(!(dacBase->setVideo =
       X   9142                   malloc(sizeof(sst1InitDacSetVideoStruct))))
       X   9143                     return(0);
       X   9144                 dacSetVideoPtr = dacBase->setVideo;
       X   9145             } else {
       X   9146                 dacSetVideoPtr = dacBase->setVideo;
       X   9147                 while(1) {
       X   9148                     if(!dacSetVideoPtr->nextSetVideo)
       X   9149                         break;
       X   9150                     dacSetVideoPtr = dacSetVideoPtr->nextSetVideo;
       X   9151                 }
       X   9152                 if(!(dacSetVideoPtr->nextSetVideo =
       X   9153                    malloc(sizeof(sst1InitDacSetVideoStruct))))
       X   9154                     return(0);
       X   9155                 dacSetVideoPtr = dacSetVideoPtr->nextSetVideo;
       X   9156             }
       X   9157             dacSetVideoPtr->nextSetVideo = NULL;
       X   9158             /* Width */
       X   9159             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->width) != 1)
       X   9160                 return(0);
       X   9161             /* Height */
       X   9162             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9163                 return(0);
       X   9164             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->height) != 1)
       X   9165                 return(0);
       X   9166             /* Refresh */
       X   9167             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9168                 return(0);
       X   9169             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->refresh) != 1)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 16
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9170                 return(0);
       X   9171             /* video16BPP */
       X   9172             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9173                 return(0);
       X   9174             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->video16BPP) != 1)
       X   9175                 return(0);
       X   9176             /* First DacRdWr */
       X   9177             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9178                 return(0);
       X   9179             if(!(dacSetVideoPtr->setVideoRdWr =
       X   9180                malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9181                 return(0);
       X   9182             dacRdWrPtr = dacSetVideoPtr->setVideoRdWr;
       X   9183         } else {
       X   9184             for(i=0; i<(cntr+3); i++) {
       X   9185                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9186                     return(0);
       X   9187             }
       X   9188             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
       X   9189                 break;
       X   9190             }
       X   9191             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9192                 return(0);
       X   9193             dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   9194         }
       X   9195         dacRdWrPtr->nextRdWr = NULL;
       X   9196         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
       X   9197             return(0);
       X   9198         cntr++;
       X   9199     }
       X   9200     return(1);
       X   9201 }
       X   9202 
       X   9203 static int sst1InitParseSetMemClkString(char *string,
       X   9204   sst1InitDacStruct *dacBase)
       X   9205 {
       X   9206     int cntr = 0;
       X   9207     int i;
       X   9208     sst1InitDacRdWrStruct *dacRdWrPtr;
       X   9209     sst1InitDacSetMemClkStruct *dacSetMemClkPtr;
       X   9210     char *dacRdWrCmd;
       X   9211     char stringCpy[2048];
       X   9212 
       X   9213     while(1) {
       X   9214         strcpy(stringCpy, string);
       X   9215         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
       X   9216             return(0);
       X   9217         if(cntr == 0) {
       X   9218             if(!dacBase->setMemClk) {
       X   9219                 if(!(dacBase->setMemClk =
       X   9220                   malloc(sizeof(sst1InitDacSetMemClkStruct))))
       X   9221                     return(0);
       X   9222                 dacSetMemClkPtr = dacBase->setMemClk;
       X   9223             } else {
       X   9224                 dacSetMemClkPtr = dacBase->setMemClk;
       X   9225                 while(1) {
       X   9226                     if(!dacSetMemClkPtr->nextSetMemClk)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 17
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9227                         break;
       X   9228                     dacSetMemClkPtr = dacSetMemClkPtr->nextSetMemClk;
       X   9229                 }
       X   9230                 if(!(dacSetMemClkPtr->nextSetMemClk =
       X   9231                    malloc(sizeof(sst1InitDacSetMemClkStruct))))
       X   9232                     return(0);
       X   9233                 dacSetMemClkPtr = dacSetMemClkPtr->nextSetMemClk;
       X   9234             }
       X   9235             dacSetMemClkPtr->nextSetMemClk = NULL;
       X   9236             /* Frequency */
       X   9237             if (SSCANF(dacRdWrCmd, "%i", &dacSetMemClkPtr->frequency) != 1)
       X   9238               return(0);
       X   9239 
       X   9240             /* First DacRdWr */
       X   9241             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9242                 return(0);
       X   9243             if(!(dacSetMemClkPtr->setMemClkRdWr =
       X   9244                malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9245                 return(0);
       X   9246             dacRdWrPtr = dacSetMemClkPtr->setMemClkRdWr;
       X   9247         } else {
       X   9248             for(i=0; i<(cntr); i++) {
       X   9249                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9250                     return(0);
       X   9251             }
       X   9252             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
       X   9253                 break;
       X   9254             }
       X   9255             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9256                 return(0);
       X   9257             dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   9258         }
       X   9259         dacRdWrPtr->nextRdWr = NULL;
       X   9260         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
       X   9261             return(0);
       X   9262         cntr++;
       X   9263     }
       X   9264     return(1);
       X   9265 }
       X   9266 
       X   9267 static int sst1InitParseSetVideoModeString(char *string,
       X   9268   sst1InitDacStruct *dacBase)
       X   9269 {
       X   9270     int cntr = 0;
       X   9271     int i;
       X   9272     sst1InitDacRdWrStruct *dacRdWrPtr;
       X   9273     sst1InitDacSetVideoModeStruct *dacSetVideoModePtr;
       X   9274     char *dacRdWrCmd;
       X   9275     char stringCpy[2048];
       X   9276 
       X   9277     while(1) {
       X   9278         strcpy(stringCpy, string);
       X   9279         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
       X   9280             return(0);
       X   9281         if(cntr == 0) {
       X   9282             if(!dacBase->setVideoMode) {
       X   9283                 if(!(dacBase->setVideoMode =

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 18
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9284                   malloc(sizeof(sst1InitDacSetVideoModeStruct))))
       X   9285                     return(0);
       X   9286                 dacSetVideoModePtr = dacBase->setVideoMode;
       X   9287             } else {
       X   9288                 dacSetVideoModePtr = dacBase->setVideoMode;
       X   9289                 while(1) {
       X   9290                     if(!dacSetVideoModePtr->nextSetVideoMode)
       X   9291                         break;
       X   9292                     dacSetVideoModePtr = dacSetVideoModePtr->nextSetVideoMode;
       X   9293                 }
       X   9294                 if(!(dacSetVideoModePtr->nextSetVideoMode =
       X   9295                    malloc(sizeof(sst1InitDacSetVideoModeStruct))))
       X   9296                     return(0);
       X   9297                 dacSetVideoModePtr = dacSetVideoModePtr->nextSetVideoMode;
       X   9298             }
       X   9299             dacSetVideoModePtr->nextSetVideoMode = NULL;
       X   9300             /* video16BPP */
       X   9301             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoModePtr->video16BPP) != 1)
       X   9302               return(0);
       X   9303 
       X   9304             /* First DacRdWr */
       X   9305             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9306                 return(0);
       X   9307             if(!(dacSetVideoModePtr->setVideoModeRdWr =
       X   9308                malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9309                 return(0);
       X   9310             dacRdWrPtr = dacSetVideoModePtr->setVideoModeRdWr;
       X   9311         } else {
       X   9312             for(i=0; i<(cntr); i++) {
       X   9313                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
       X   9314                     return(0);
       X   9315             }
       X   9316             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
       X   9317                 break;
       X   9318             }
       X   9319             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
       X   9320                 return(0);
       X   9321             dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   9322         }
       X   9323         dacRdWrPtr->nextRdWr = NULL;
       X   9324         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
       X   9325             return(0);
       X   9326         cntr++;
       X   9327     }
       X   9328     return(1);
       X   9329 }
       X   9330 #endif /* !defined(INIT_LINUX) && !defined(DIRECTX) */
       X   9331 
       X   9332 static void sst1InitToLower(char *string)
       X   9333 {
       X   9334     char *ptr = string;
       X   9335 
       X   9336     while(*ptr) {
       X   9337         if (*ptr >= 'A' && *ptr <= 'Z')
       X   9338             *ptr += ('a'-'A');
       X   9339         ptr++;
       X   9340     }

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 19
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9341 }
       X   9342 
       X   9343 #if __WIN32__
       X   9344 static
       X   9345 FxBool GetRegistryKey(HKEY hKey, const char* keyName, 
       X   9346                       char* regValBuf, FxU32 bufSize)
       X   9347 {
       X   9348   DWORD type;
       X   9349   DWORD tsize = bufSize;
       X   9350   FxBool retVal = FXFALSE;
       X   9351 
       X   9352   // Don't worry about default if query fails, its handled higher up
       X   9353   if(!RegQueryValueEx(hKey, keyName, NULL, &type, (CONST LPBYTE)regValBuf, &tsize)) {
       X   9354     switch(type) {
       X   9355     case REG_DWORD:
       X   9356     {
       X   9357       DWORD dValue = *(DWORD*)regValBuf;
       X   9358       sprintf(regValBuf, "%lu", dValue);
       X   9359     }
       X   9360     /* Fall through */
       X   9361 
       X   9362     case REG_SZ:
       X   9363       retVal = FXTRUE;
       X   9364       break;
       X   9365     }
       X   9366   }
       X   9367   
       X   9368   return retVal;
       X   9369 } 
       X   9370 #endif /* __WIN32__ */
       X   9371 
       X   9372 static const char*
       X   9373 myGetenv(const char* envKey)
       X   9374 {
       X   9375   FxBool callRealGetenvP = FXTRUE;
       X   9376 
       X   9377 #if __WIN32__
       X   9378   /* NB: If were being called from cya code in
       X   9379    * DllMain(DLL_PROCESS_DETACH) because the current app has called
       X   9380    * exit() or dropped off of the end of main the per dll environ
       X   9381    * string table has been freed by the c runtime but has not been set
       X   9382    * to NULL. Bad things happen if this memory has been unmapped by
       X   9383    * the system or if the string cannot be found.  
       X   9384    */
       X   9385   {
       X   9386     HANDLE curProcessHandle = GetCurrentProcess();
       X   9387     DWORD exitCode = STILL_ACTIVE;
       X   9388 
       X   9389     callRealGetenvP = ((curProcessHandle != NULL) &&
       X   9390                        GetExitCodeProcess(curProcessHandle, &exitCode) &&
       X   9391                        (exitCode == STILL_ACTIVE));
       X   9392   }
       X   9393 #endif /* __WIN32__ */
       X   9394 
       X   9395   return (callRealGetenvP
       X   9396           ? getenv(envKey)
       X   9397           : NULL);

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 20
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9398 }
       X   9399 
       X   9400 /*
       X   9401 ** sst1InitGetenv():
       X   9402 **  Getenv() for INIT routines.
       X   9403 **
       X   9404 **  If the actual environment variable exists (determined by a call to
       X   9405 **  the system getenv() routine), then that pointer is returned.  Otherwise,
       X   9406 **  if the variable is defined in the [CFG] section of "voodoo2.ini", then
       X   9407 **  a pointer to the value defined in "voodoo2.ini" is returned.  Otherwise,
       X   9408 **  NULL is returned
       X   9409 **
       X   9410 */
       X   9411 FX_ENTRY char* FX_CALL sst1InitGetenv(char *string)
       X   9412 {
       X   9413   const char* retVal;
       X   9414   
       X   9415   /* Does the real environment variable exist?
       X   9416    * This overrides everything for glide.
       X   9417    */
       X   9418   retVal = myGetenv(string);
       X   9419   if (retVal == NULL) {
       X   9420 #if __WIN32__
       X   9421     /* On windows check to see if the control panel thingee
       X   9422      * has added entries for glide or voodoo^2.
       X   9423      */
       X   9424     {
       X   9425       /* List of the various registry paths to check. These
       X   9426        * should be in the order that you want them checked in.
       X   9427        */
       X   9428       static const char* regPathList[] = {
       X   9429         REGSTR_PATH_GLIDE,
       X   9430         REGSTR_PATH_3DFXSW
       X   9431       };
       X   9432       HKEY hKey;
       X   9433       int i;
       X   9434 
       X   9435       for(i = 0; (retVal == NULL) && (i < sizeof(regPathList) / sizeof(regPathList[0])); i++) {
       X   9436         if (!RegOpenKey(HKEY_LOCAL_MACHINE, regPathList[i], &hKey)) {
       X   9437 #define kRegKeyBufSize 256
       X   9438           static char regKeyBuf[kRegKeyBufSize];
       X   9439 
       X   9440           regKeyBuf[0] = '\0';
       X   9441           if (GetRegistryKey(hKey, string, regKeyBuf, kRegKeyBufSize)) retVal = regKeyBuf;
       X   9442           RegCloseKey(hKey);
       X   9443         }
       X   9444       }
       X   9445     }
       X   9446 #endif /* __WIN32__ */
       X   9447   
       X   9448     /* Does the requested environment variable exist in "voodoo2.ini"? */
       X   9449     /* Dump CFG Data... */
       X   9450     if (!checkedFileP) {
       X   9451     	static FxBool inProc = FXFALSE;
       X   9452     	
       X   9453     	if (!inProc) {
       X   9454     		inProc = FXTRUE;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 21
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9455 	    	sst1InitVoodooFile();
       X   9456 	    	inProc = FXFALSE;
       X   9457 	    }
       X   9458     }
       X   9459     
       X   9460     {
       X   9461       sst1InitEnvVarStruct *envVarsPtr = envVarsBase;
       X   9462       char tempSearchString[kMaxEnvVarLen];
       X   9463 
       X   9464       /* Put the search into canonical form */
       X   9465       strcpy(tempSearchString, string);
       X   9466       sst1InitToLower(tempSearchString);
       X   9467 
       X   9468       while(envVarsPtr) {
       X   9469         if(!strcmp(tempSearchString, envVarsPtr->envVariable)) {
       X   9470           retVal = envVarsPtr->envValue;
       X   9471           break;
       X   9472         }
       X   9473         envVarsPtr = (sst1InitEnvVarStruct *) envVarsPtr->nextVar;
       X   9474       }
       X   9475     }
       X   9476   }
       X   9477 
       X   9478   return (char*)retVal;
       X   9479 }
       X   9480 #endif  /* INIT_DOS */
	   9481 
       X   9482 #ifdef _MSC_VER
       X   9483 #pragma optimize ("",on)
       X   9484 #endif
	   9485 
	   9486 static int sst1InitFgets(char *string, FILE *stream)
      1	   9487 {
      1	   9488     int validChars = 0;
      1	   9489     char *ptr = string;
      1	   9490     int charRead;
      1	   9491 
      2	   9492     while(0 != ((charRead = sst1InitFgetc(stream)))) {
      2	   9493         *ptr++ = (char) charRead;
      2	   9494         validChars++;
      3	   9495         if(charRead == '\n') {
      3	   9496             *ptr++ = 0;
      3	   9497             break;
      2	   9498         }
      1	   9499     }
      1	   9500     return(validChars);
      1	   9501 }
	   9502 
	   9503 static __inline int sst1_isspace (int c)
      1	   9504 {
      2	   9505     switch(c) {
      2	   9506     case ' ':  case '\t':
      2	   9507     case '\n': case '\r':
      2	   9508     case '\f': case '\v': return 1;
      1	   9509     }
      1	   9510     return 0;
      1	   9511 }

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 22
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

	   9512 
	   9513 static int sst1InitFgetc(FILE *stream)
      1	   9514 {
      1	   9515     static int column = 0;
      1	   9516     static int validChars = 0;
      1	   9517     int charRead, charReadL;
      1	   9518     int inComment;
      1	   9519 
      1	   9520     inComment = 0;
      2	   9521     while(1) {
      2	   9522         charRead = fgetc(stream);
      3	   9523         if(inComment == 1) {
      3	   9524             if(charRead <= 0)
      3	   9525                 return(0);
      3	   9526             else if(charRead == '\n')
      3	   9527                 inComment = 0;
      3	   9528             column = 0;
      3	   9529             validChars = 0;
      3	   9530             continue;
      3	   9531         } else if(column == 0 && charRead == '#') {
      3	   9532             /* Comment line */
      3	   9533             inComment = 1;
      3	   9534             column = 0;
      3	   9535             validChars = 0;
      3	   9536         } else if(charRead <= 0) {
      3	   9537                 return(0);
      3	   9538         } else {
      4	   9539             if(charRead == '\n') {
      5	   9540                 if(validChars > 0) {
      5	   9541                     validChars = 0;
      5	   9542                     column = 0;
      5	   9543                     return(charRead);
      4	   9544                 } else
      4	   9545                     continue;
      4	   9546             } else {
      4	   9547                 if(sst1_isspace(charRead))
      4	   9548                     continue;
      4	   9549                 validChars++;
      4	   9550                 column++;
      4	   9551                 charReadL = charRead;
      4	   9552                 if (charReadL >= 'a' && charReadL <= 'z')
      4	   9553                     charReadL -= ('a'-'A');
      4	   9554                 return(charReadL);
      3	   9555             }
      2	   9556         }
      1	   9557     }
      1	   9558 }
	   9559 
	   9560 static int sst1InitParseFieldCfg(char *string)
      1	   9561 {
      1	   9562     char *envName, *envVal;
      1	   9563     sst1InitEnvVarStruct *envVarsPtr;
      1	   9564 
      1	   9565     if((envName = strtok(string, "=")) == NULL)
      1	   9566         return(0);
      1	   9567     if((envVal = strtok(NULL, "=")) == NULL)
      1	   9568         /* Valid environment variable, NULL value */

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 23
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1	   9569         return(1);
      1	   9570 
      1	   9571     /* .ini canonical form is now lower case */
      1	   9572     sst1InitToLower(envName);
      1	   9573     sst1InitToLower(envVal);
      1	   9574 
      2	   9575     if(envVarsBase == NULL) {
      2	   9576         if((envVarsPtr = malloc(sizeof(sst1InitEnvVarStruct))) == NULL)
      2	   9577             return(0);
      2	   9578         envVarsBase = envVarsPtr;
      2	   9579     } else {
      2	   9580         envVarsPtr = envVarsBase;
      3	   9581         while(1) {
      3	   9582             if(envVarsPtr->nextVar == NULL)
      3	   9583                 break;
      3	   9584             else
      3	   9585                envVarsPtr = envVarsPtr->nextVar;
      2	   9586         }
      2	   9587         if((envVarsPtr->nextVar = malloc(sizeof(sst1InitEnvVarStruct))) == NULL)
      2	   9588             return(0);
      2	   9589         envVarsPtr = envVarsPtr->nextVar;
      1	   9590     }
      1	   9591     envVarsPtr->nextVar = NULL;
      1	   9592     strcpy(envVarsPtr->envVariable, envName);
      1	   9593     strcpy(envVarsPtr->envValue, envVal);
      1	   9594 
      1	   9595     return(1);
      1	   9596 }
	   9597 
	   9598 static void sst1InitToLower(char *string)
      1	   9599 {
      1	   9600     char *ptr = string;
      1	   9601 
      2	   9602     while(*ptr) {
      2	   9603         if (*ptr >= 'A' && *ptr <= 'Z')
      2	   9604             *ptr += ('a'-'A');
      2	   9605         ptr++;
      1	   9606     }
      1	   9607 }
	   9608 
	   9609 static int sst1InitParseFieldDac(char *string)
      1	   9610 {
      1	   9611     char *dacFieldReference, *dacFieldValue;
      1	   9612     static sst1InitDacStruct *dacPtr = NULL;
      1	   9613 
      1	   9614     if((dacFieldReference = strtok(string, "=")) == NULL)
      1	   9615         return(0);
      2	   9616     if(!strcmp(dacFieldReference, "MANUFACTURER")) {
      2	   9617         /* Add new dac device */
      3	   9618         if(dacStructBase == NULL) {
      3	   9619             if((dacPtr = malloc(sizeof(sst1InitDacStruct))) == NULL)
      3	   9620                 return(0);
      3	   9621             dacStructBase = dacPtr;
      3	   9622         } else {
      3	   9623             dacPtr = dacStructBase;
      4	   9624             while(1) {
      4	   9625                 if(dacPtr->nextDac == NULL)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 24
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      4	   9626                     break;
      4	   9627                 else
      4	   9628                    dacPtr = dacPtr->nextDac;
      3	   9629             }
      3	   9630             if((dacPtr->nextDac = malloc(sizeof(sst1InitDacStruct))) == NULL)
      3	   9631                 return(0);
      3	   9632             dacPtr = dacPtr->nextDac;
      2	   9633         }
      2	   9634         dacPtr->nextDac = NULL;
      2	   9635         dacPtr->dacManufacturer[0] = 0;
      2	   9636         dacPtr->dacDevice[0] = 0;
      2	   9637         dacPtr->detect = NULL;
      2	   9638         dacPtr->setVideo = NULL;
      2	   9639         dacPtr->setMemClk = NULL;
      2	   9640         dacPtr->setVideoMode = NULL;
      2	   9641         if((dacFieldValue = strtok((char *) NULL, "=")) == NULL)
      2	   9642             return(0);
      2	   9643         strcpy(dacPtr->dacManufacturer, dacFieldValue);
      2	   9644     } else if(!strcmp(dacFieldReference, "DEVICE")) {
      2	   9645         if((dacFieldValue = strtok(NULL, "=")) == NULL)
      2	   9646             return(0);
      2	   9647         strcpy(dacPtr->dacDevice, dacFieldValue);
      2	   9648     } else if(!strcmp(dacFieldReference, "DETECT")) {
      2	   9649         if((dacFieldValue = strtok(NULL, "=")) == NULL)
      2	   9650             return(0);
      2	   9651         sst1InitToLower(dacFieldValue);
      2	   9652         if(!sst1InitParseDacRdWrString(dacFieldValue, dacPtr))
      2	   9653             return(0);
      2	   9654     } else if(!strcmp(dacFieldReference, "SETVIDEO")) {
      2	   9655         if((dacFieldValue = strtok(NULL, "=")) == NULL)
      2	   9656             return(0);
      2	   9657         sst1InitToLower(dacFieldValue);
      2	   9658         if(!sst1InitParseSetVideoString(dacFieldValue, dacPtr))
      2	   9659             return(0);
      2	   9660     } else if(!strcmp(dacFieldReference, "SETMEMCLK")) {
      2	   9661         if((dacFieldValue = strtok(NULL, "=")) == NULL)
      2	   9662             return(0);
      2	   9663         sst1InitToLower(dacFieldValue);
      2	   9664         if(!sst1InitParseSetMemClkString(dacFieldValue, dacPtr))
      2	   9665             return(0);
      2	   9666     } else if(!strcmp(dacFieldReference, "SETVIDEOMODE")) {
      2	   9667         if((dacFieldValue = strtok(NULL, "=")) == NULL)
      2	   9668             return(0);
      2	   9669         sst1InitToLower(dacFieldValue);
      2	   9670         if(!sst1InitParseSetVideoModeString(dacFieldValue, dacPtr))
      2	   9671             return(0);
      1	   9672     } else
      1	   9673         return(0);
      1	   9674 
      1	   9675     return(1);
      1	   9676 }
	   9677 
	   9678 static int sst1InitParseDacRdWrString(char *string, sst1InitDacStruct *dacBase)
      1	   9679 {
      1	   9680     int cntr = 0;
      1	   9681     int i;
      1	   9682     sst1InitDacRdWrStruct *dacRdWrPtr;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 25
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1	   9683     char *dacRdWrCmd;
      1	   9684     char stringCpy[2048];
      1	   9685 
      2	   9686     while(1) {
      2	   9687         strcpy(stringCpy, string);
      2	   9688         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
      2	   9689             return(0);
      3	   9690         if(cntr == 0) {
      3	   9691             if(!(dacBase->detect = malloc(sizeof(sst1InitDacRdWrStruct))))
      3	   9692                 return(0);
      3	   9693             dacRdWrPtr = dacBase->detect;
      3	   9694         } else {
      4	   9695             for(i=0; i<(cntr-1); i++) {
      4	   9696                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      4	   9697                     return(0);
      3	   9698             }
      4	   9699             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
      4	   9700                 break;
      3	   9701             }
      3	   9702             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct)))) 
      3	   9703                 return(0);
      3	   9704 
      3	   9705             dacRdWrPtr = dacRdWrPtr->nextRdWr;
      2	   9706         }
      2	   9707         dacRdWrPtr->nextRdWr = NULL;
      2	   9708         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
      2	   9709             return(0);
      2	   9710         cntr++;
      1	   9711     }
      1	   9712     return(1);
      1	   9713 }
	   9714 
	   9715 static int sst1InitParseDacRdWr(char *string, sst1InitDacRdWrStruct *dacRdWrPtr)
      1	   9716 {
      1	   9717     char *addr, *data, *mask, *addrDataCmd;
      1	   9718     char stringCpy[2048];
      1	   9719     int i1, i2, i3;
      1	   9720 
      1	   9721     strcpy(stringCpy, string);
      1	   9722 
      2	   9723     if(stringCpy[5] == '(') {
      2	   9724         stringCpy[5] = 0;
      2	   9725         addrDataCmd = &stringCpy[6];
      2	   9726     } else if(stringCpy[7] == '(') {
      2	   9727         stringCpy[7] = 0;
      2	   9728         addrDataCmd = &stringCpy[8];
      2	   9729     } else if(stringCpy[8] == '(') {
      2	   9730         stringCpy[8] = 0;
      2	   9731         addrDataCmd = &stringCpy[9];
      2	   9732     } else if(stringCpy[9] == '(') {
      2	   9733         stringCpy[9] = 0;
      2	   9734         addrDataCmd = &stringCpy[10];
      1	   9735     } else
      1	   9736         return(0);
      1	   9737 
      2	   9738     if(!strcmp(stringCpy, "dacwr")) {
      2	   9739         if((addr = strtok(addrDataCmd, ",")) == NULL)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 26
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      2	   9740             return(0);
      2	   9741         if((data = strtok(NULL, ",")) == NULL)
      2	   9742             return(0);
      2	   9743         if(data[strlen(data)-1] != ')')
      2	   9744             return(0);
      2	   9745         data[strlen(data)-1] = '\0';
      2	   9746         dacRdWrPtr->type = DACRDWR_TYPE_WR;
      2	   9747         if (SSCANF(addr, "%i", &i1) != 1)
      2	   9748             return(0);
      2	   9749         if (SSCANF(data, "%i", &i2) != 1)
      2	   9750             return(0);
      2	   9751         dacRdWrPtr->addr = i1;
      2	   9752         dacRdWrPtr->data = i2;
      2	   9753     } else if(!strcmp(stringCpy, "dacwrpop")) {
      2	   9754         if((addr = strtok(addrDataCmd, ",")) == NULL)
      2	   9755             return(0);
      2	   9756         if((mask = strtok(NULL, ",")) == NULL)
      2	   9757             return(0);
      2	   9758         if((data = strtok(NULL, ",")) == NULL)
      2	   9759             return(0);
      2	   9760         if(data[strlen(data)-1] != ')')
      2	   9761             return(0);
      2	   9762         data[strlen(data)-1] = 0;
      2	   9763         dacRdWrPtr->type = DACRDWR_TYPE_WRMOD_POP;
      2	   9764         if (SSCANF(addr, "%i", &i1) != 1)
      2	   9765             return(0);
      2	   9766         if (SSCANF(mask, "%i", &i2) != 1)
      2	   9767             return(0);
      2	   9768         if (SSCANF(data, "%i", &i3) != 1)
      2	   9769             return(0);
      2	   9770         dacRdWrPtr->addr = i1;
      2	   9771         dacRdWrPtr->mask = i2;
      2	   9772         dacRdWrPtr->data = i3;
      2	   9773     } else if(!strcmp(stringCpy, "dacrdwr")) {
      2	   9774         if((addr = strtok(addrDataCmd, ",")) == NULL)
      2	   9775             return(0);
      2	   9776         if((mask = strtok(NULL, ",")) == NULL)
      2	   9777             return(0);
      2	   9778         if((data = strtok(NULL, ",")) == NULL)
      2	   9779             return(0);
      2	   9780         if(data[strlen(data)-1] != ')')
      2	   9781             return(0);
      2	   9782         data[strlen(data)-1] = 0;
      2	   9783         dacRdWrPtr->type = DACRDWR_TYPE_RDMODWR;
      2	   9784         if (SSCANF(addr, "%i", &i1) != 1)
      2	   9785             return(0);
      2	   9786         if (SSCANF(mask, "%i", &i2) != 1)
      2	   9787             return(0);
      2	   9788         if (SSCANF(data, "%i", &i3) != 1)
      2	   9789             return(0);
      2	   9790         dacRdWrPtr->addr = i1;
      2	   9791         dacRdWrPtr->mask = i2;
      2	   9792         dacRdWrPtr->data = i3;
      2	   9793     } else if(!strcmp(stringCpy, "dacrd")) {
      2	   9794         if((addr = strtok(addrDataCmd, ",")) == NULL)
      2	   9795             return(0);
      3	   9796         if(addr[strlen(addr)-1] == ')') {

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 27
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      3	   9797             dacRdWrPtr->type = DACRDWR_TYPE_RDNOCHECK;
      3	   9798             if (SSCANF(addr, "%i", &i1) != 1)
      3	   9799                 return(0);
      3	   9800             dacRdWrPtr->addr = i1;
      3	   9801         } else {
      3	   9802             dacRdWrPtr->type = DACRDWR_TYPE_RDCHECK;
      3	   9803             if((data = strtok(NULL, ",")) == NULL)
      3	   9804                 return(0);
      3	   9805             if(data[strlen(data)-1] != ')')
      3	   9806                 return(0);
      3	   9807             data[strlen(data)-1] = 0;
      3	   9808             if (SSCANF(addr, "%i", &i1) != 1)
      3	   9809                 return(0);
      3	   9810             if (SSCANF(data, "%i", &i2) != 1)
      3	   9811                 return(0);
      3	   9812             dacRdWrPtr->addr = i1;
      3	   9813             dacRdWrPtr->data = i2;
      2	   9814         }
      2	   9815     } else if(!strcmp(stringCpy, "dacrdpush")) {
      2	   9816         if((addr = strtok(addrDataCmd, ",")) == NULL)
      2	   9817             return(0);
      3	   9818         if(addr[strlen(addr)-1] == ')') {
      3	   9819             dacRdWrPtr->type = DACRDWR_TYPE_RDPUSH;
      3	   9820             if (SSCANF(addr, "%i", &i1) != 1)
      3	   9821                 return(0);
      3	   9822             dacRdWrPtr->addr = i1;
      2	   9823         } else
      2	   9824             return(0);
      2	   9825     } else {
      2	   9826         return(0);
      1	   9827     }
      1	   9828 
      1	   9829     return(1);
      1	   9830 }
	   9831 
       X   9832 #if TEST
       X   9833 static void sst1InitPrintDacRdWr(sst1InitDacRdWrStruct *dacRdWrBase,
       X   9834   char *prefix)
       X   9835 {
       X   9836     sst1InitDacRdWrStruct *dacRdWrPtr = dacRdWrBase;
       X   9837 
       X   9838     while(dacRdWrPtr) {
       X   9839         if(dacRdWrPtr->type == DACRDWR_TYPE_WR) {
       X   9840             printf("%sDacWR", prefix);
       X   9841             printf("(0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->data);
       X   9842         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDMODWR) {
       X   9843             printf("%sDacRD-MOD-WR", prefix);
       X   9844             printf("(0x%x,0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->mask,
       X   9845               dacRdWrPtr->data);
       X   9846         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDNOCHECK) {
       X   9847             printf("%sDacRD-NOCHECK", prefix);
       X   9848             printf("(0x%x)\n", dacRdWrPtr->addr);
       X   9849         } else if(dacRdWrPtr->type == DACRDWR_TYPE_RDCHECK) {
       X   9850             printf("%sDacRD-CHECK", prefix);
       X   9851             printf("(0x%x,0x%x)\n", dacRdWrPtr->addr, dacRdWrPtr->data);
       X   9852         } else
       X   9853             printf("%sDAC???", prefix);

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 28
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

       X   9854         dacRdWrPtr = dacRdWrPtr->nextRdWr;
       X   9855     }
       X   9856 }
       X   9857 #endif /* TEST */
	   9858 
	   9859 static int sst1InitParseSetVideoString(char *string, sst1InitDacStruct *dacBase)
      1	   9860 {
      1	   9861     int cntr = 0;
      1	   9862     int i;
      1	   9863     sst1InitDacRdWrStruct *dacRdWrPtr;
      1	   9864     sst1InitDacSetVideoStruct *dacSetVideoPtr;
      1	   9865     char *dacRdWrCmd;
      1	   9866     char stringCpy[2048];
      1	   9867 
      2	   9868     while(1) {
      2	   9869         strcpy(stringCpy, string);
      2	   9870         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
      2	   9871             return(0);
      3	   9872         if(cntr == 0) {
      4	   9873             if(!dacBase->setVideo) {
      4	   9874                 if(!(dacBase->setVideo =
      4	   9875                   malloc(sizeof(sst1InitDacSetVideoStruct))))
      4	   9876                     return(0);
      4	   9877                 dacSetVideoPtr = dacBase->setVideo;
      4	   9878             } else {
      4	   9879                 dacSetVideoPtr = dacBase->setVideo;
      5	   9880                 while(1) {
      5	   9881                     if(!dacSetVideoPtr->nextSetVideo)
      5	   9882                         break;
      5	   9883                     dacSetVideoPtr = dacSetVideoPtr->nextSetVideo;
      4	   9884                 }
      4	   9885                 if(!(dacSetVideoPtr->nextSetVideo =
      4	   9886                    malloc(sizeof(sst1InitDacSetVideoStruct))))
      4	   9887                     return(0);
      4	   9888                 dacSetVideoPtr = dacSetVideoPtr->nextSetVideo;
      3	   9889             }
      3	   9890             dacSetVideoPtr->nextSetVideo = NULL;
      3	   9891             /* Width */
      3	   9892             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->width) != 1)
      3	   9893                 return(0);
      3	   9894             /* Height */
      3	   9895             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      3	   9896                 return(0);
      3	   9897             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->height) != 1)
      3	   9898                 return(0);
      3	   9899             /* Refresh */
      3	   9900             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      3	   9901                 return(0);
      3	   9902             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->refresh) != 1)
      3	   9903                 return(0);
      3	   9904             /* video16BPP */
      3	   9905             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      3	   9906                 return(0);
      3	   9907             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoPtr->video16BPP) != 1)
      3	   9908                 return(0);
      3	   9909             /* First DacRdWr */
      3	   9910             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 29
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      3	   9911                 return(0);
      3	   9912             if(!(dacSetVideoPtr->setVideoRdWr =
      3	   9913                malloc(sizeof(sst1InitDacRdWrStruct))))
      3	   9914                 return(0);
      3	   9915             dacRdWrPtr = dacSetVideoPtr->setVideoRdWr;
      3	   9916         } else {
      4	   9917             for(i=0; i<(cntr+3); i++) {
      4	   9918                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      4	   9919                     return(0);
      3	   9920             }
      4	   9921             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
      4	   9922                 break;
      3	   9923             }
      3	   9924             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
      3	   9925                 return(0);
      3	   9926             dacRdWrPtr = dacRdWrPtr->nextRdWr;
      2	   9927         }
      2	   9928         dacRdWrPtr->nextRdWr = NULL;
      2	   9929         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
      2	   9930             return(0);
      2	   9931         cntr++;
      1	   9932     }
      1	   9933     return(1);
      1	   9934 }
	   9935 static int sst1InitParseSetMemClkString(char *string,
	   9936   sst1InitDacStruct *dacBase)
      1	   9937 {
      1	   9938     int cntr = 0;
      1	   9939     int i;
      1	   9940     sst1InitDacRdWrStruct *dacRdWrPtr;
      1	   9941     sst1InitDacSetMemClkStruct *dacSetMemClkPtr;
      1	   9942     char *dacRdWrCmd;
      1	   9943     char stringCpy[2048];
      1	   9944 
      2	   9945     while(1) {
      2	   9946         strcpy(stringCpy, string);
      2	   9947         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
      2	   9948             return(0);
      3	   9949         if(cntr == 0) {
      4	   9950             if(!dacBase->setMemClk) {
      4	   9951                 if(!(dacBase->setMemClk =
      4	   9952                   malloc(sizeof(sst1InitDacSetMemClkStruct))))
      4	   9953                     return(0);
      4	   9954                 dacSetMemClkPtr = dacBase->setMemClk;
      4	   9955             } else {
      4	   9956                 dacSetMemClkPtr = dacBase->setMemClk;
      5	   9957                 while(1) {
      5	   9958                     if(!dacSetMemClkPtr->nextSetMemClk)
      5	   9959                         break;
      5	   9960                     dacSetMemClkPtr = dacSetMemClkPtr->nextSetMemClk;
      4	   9961                 }
      4	   9962                 if(!(dacSetMemClkPtr->nextSetMemClk =
      4	   9963                    malloc(sizeof(sst1InitDacSetMemClkStruct))))
      4	   9964                     return(0);
      4	   9965                 dacSetMemClkPtr = dacSetMemClkPtr->nextSetMemClk;
      3	   9966             }
      3	   9967             dacSetMemClkPtr->nextSetMemClk = NULL;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 30
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      3	   9968             /* Frequency */
      3	   9969             if (SSCANF(dacRdWrCmd, "%i", &dacSetMemClkPtr->frequency) != 1)
      3	   9970               return(0);
      3	   9971 
      3	   9972             /* First DacRdWr */
      3	   9973             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      3	   9974                 return(0);
      3	   9975             if(!(dacSetMemClkPtr->setMemClkRdWr =
      3	   9976                malloc(sizeof(sst1InitDacRdWrStruct))))
      3	   9977                 return(0);
      3	   9978             dacRdWrPtr = dacSetMemClkPtr->setMemClkRdWr;
      3	   9979         } else {
      4	   9980             for(i=0; i<(cntr); i++) {
      4	   9981                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      4	   9982                     return(0);
      3	   9983             }
      4	   9984             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
      4	   9985                 break;
      3	   9986             }
      3	   9987             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
      3	   9988                 return(0);
      3	   9989             dacRdWrPtr = dacRdWrPtr->nextRdWr;
      2	   9990         }
      2	   9991         dacRdWrPtr->nextRdWr = NULL;
      2	   9992         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
      2	   9993             return(0);
      2	   9994         cntr++;
      1	   9995     }
      1	   9996     return(1);
      1	   9997 }
	   9998 
	   9999 static int sst1InitParseSetVideoModeString(char *string,
	  10000   sst1InitDacStruct *dacBase)
      1	  10001 {
      1	  10002     int cntr = 0;
      1	  10003     int i;
      1	  10004     sst1InitDacRdWrStruct *dacRdWrPtr;
      1	  10005     sst1InitDacSetVideoModeStruct *dacSetVideoModePtr;
      1	  10006     char *dacRdWrCmd;
      1	  10007     char stringCpy[2048];
      1	  10008 
      2	  10009     while(1) {
      2	  10010         strcpy(stringCpy, string);
      2	  10011         if((dacRdWrCmd = strtok(stringCpy, ";")) == NULL)
      2	  10012             return(0);
      3	  10013         if(cntr == 0) {
      4	  10014             if(!dacBase->setVideoMode) {
      4	  10015                 if(!(dacBase->setVideoMode =
      4	  10016                   malloc(sizeof(sst1InitDacSetVideoModeStruct))))
      4	  10017                     return(0);
      4	  10018                 dacSetVideoModePtr = dacBase->setVideoMode;
      4	  10019             } else {
      4	  10020                 dacSetVideoModePtr = dacBase->setVideoMode;
      5	  10021                 while(1) {
      5	  10022                     if(!dacSetVideoModePtr->nextSetVideoMode)
      5	  10023                         break;
      5	  10024                     dacSetVideoModePtr = dacSetVideoModePtr->nextSetVideoMode;

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 31
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      4	  10025                 }
      4	  10026                 if(!(dacSetVideoModePtr->nextSetVideoMode =
      4	  10027                    malloc(sizeof(sst1InitDacSetVideoModeStruct))))
      4	  10028                     return(0);
      4	  10029                 dacSetVideoModePtr = dacSetVideoModePtr->nextSetVideoMode;
      3	  10030             }
      3	  10031             dacSetVideoModePtr->nextSetVideoMode = NULL;
      3	  10032             /* video16BPP */
      3	  10033             if (SSCANF(dacRdWrCmd, "%i", &dacSetVideoModePtr->video16BPP) != 1)
      3	  10034               return(0);
      3	  10035 
      3	  10036             /* First DacRdWr */
      3	  10037             if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      3	  10038                 return(0);
      3	  10039             if(!(dacSetVideoModePtr->setVideoModeRdWr =
      3	  10040                malloc(sizeof(sst1InitDacRdWrStruct))))
      3	  10041                 return(0);
      3	  10042             dacRdWrPtr = dacSetVideoModePtr->setVideoModeRdWr;
      3	  10043         } else {
      4	  10044             for(i=0; i<(cntr); i++) {
      4	  10045                 if((dacRdWrCmd = strtok(NULL, ";")) == NULL)
      4	  10046                     return(0);
      3	  10047             }
      4	  10048             if((dacRdWrCmd = strtok(NULL, ";")) == NULL) {
      4	  10049                 break;
      3	  10050             }
      3	  10051             if(!(dacRdWrPtr->nextRdWr = malloc(sizeof(sst1InitDacRdWrStruct))))
      3	  10052                 return(0);
      3	  10053             dacRdWrPtr = dacRdWrPtr->nextRdWr;
      2	  10054         }
      2	  10055         dacRdWrPtr->nextRdWr = NULL;
      2	  10056         if(!sst1InitParseDacRdWr(dacRdWrCmd, dacRdWrPtr))
      2	  10057             return(0);
      2	  10058         cntr++;
      1	  10059     }
      1	  10060     return(1);
      1	  10061 }
	  10062 
	  10063 
	  10064 static const char*
	  10065 myGetenv(const char* envKey)
      1	  10066 {
      1	  10067   FxBool callRealGetenvP = FXTRUE;
      1	  10068 
      1X  10069 #if __WIN32__
      1	  10070   /* NB: If were being called from cya code in
      1	  10071    * DllMain(DLL_PROCESS_DETACH) because the current app has called
      1	  10072    * exit() or dropped off of the end of main the per dll environ
      1	  10073    * string table has been freed by the c runtime but has not been set
      1	  10074    * to NULL. Bad things happen if this memory has been unmapped by
      1	  10075    * the system or if the string cannot be found.  
      1X  10076    */
      1X  10077   {
      1X  10078     HANDLE curProcessHandle = GetCurrentProcess();
      1X  10079     DWORD exitCode = STILL_ACTIVE;
      1X  10080 
      1X  10081     callRealGetenvP = ((curProcessHandle != NULL) &&

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 32
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      1X  10082                        GetExitCodeProcess(curProcessHandle, &exitCode) &&
      1X  10083                        (exitCode == STILL_ACTIVE));
      1X  10084   }
      1X  10085 #endif /* __WIN32__ */
      1	  10086 
      1	  10087   return (callRealGetenvP
      1	  10088           ? getenv(envKey)
      1	  10089           : NULL);
      1	  10090 }
	  10091 
	  10092 /*
	  10093 ** sst1InitGetenv():
	  10094 **  Getenv() for INIT routines.
	  10095 **
	  10096 **  If the actual environment variable exists (determined by a call to
	  10097 **  the system getenv() routine), then that pointer is returned.  Otherwise,
	  10098 **  if the variable is defined in the [CFG] section of "voodoo2.ini", then
	  10099 **  a pointer to the value defined in "voodoo2.ini" is returned.  Otherwise,
	  10100 **  NULL is returned
	  10101 **
	  10102 */
	  10103 FX_ENTRY char* FX_CALL sst1InitGetenv(char *string)
      1	  10104 {
      1	  10105   const char* retVal;
      1	  10106   
      1	  10107   /* Does the real environment variable exist?
      1	  10108    * This overrides everything for glide.
      1	  10109    */
      1	  10110   retVal = myGetenv(string);
      2	  10111   if (retVal == NULL) {
      2X  10112 #if __WIN32__
      2	  10113     /* On windows check to see if the control panel thingee
      2	  10114      * has added entries for glide or voodoo^2.
      2X  10115      */
      2X  10116     {
      2X  10117       /* List of the various registry paths to check. These
      2X  10118        * should be in the order that you want them checked in.
      2X  10119        */
      2X  10120       static const char* regPathList[] = {
      2X  10121         REGSTR_PATH_GLIDE,
      2X  10122         REGSTR_PATH_3DFXSW
      2X  10123       };
      2X  10124       HKEY hKey;
      2X  10125       int i;
      2X  10126 
      2X  10127       for(i = 0; (retVal == NULL) && (i < sizeof(regPathList) / sizeof(regPathList[0])); i++) {
      2X  10128         if (!RegOpenKey(HKEY_LOCAL_MACHINE, regPathList[i], &hKey)) {
      2X  10129 #define kRegKeyBufSize 256
      2X  10130           static char regKeyBuf[kRegKeyBufSize];
      2X  10131 
      2X  10132           regKeyBuf[0] = '\0';
      2X  10133           if (GetRegistryKey(hKey, string, regKeyBuf, kRegKeyBufSize)) retVal = regKeyBuf;
      2X  10134           RegCloseKey(hKey);
      2X  10135         }
      2X  10136       }
      2X  10137     }
      2X  10138 #endif /* __WIN32__ */

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 33
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

      2	  10139   
      2	  10140     /* Does the requested environment variable exist in "voodoo2.ini"? */
      2	  10141     /* Dump CFG Data... */
      3	  10142     if (!checkedFileP) {
      3	  10143     	static FxBool inProc = FXFALSE;
      3	  10144     	
      4	  10145     	if (!inProc) {
      4	  10146     		inProc = FXTRUE;
      4	  10147 	    	sst1InitVoodooFile();
      4	  10148 	    	inProc = FXFALSE;
      3	  10149 	    }
      2	  10150     }
      2	  10151     
      3	  10152     {
      3	  10153       sst1InitEnvVarStruct *envVarsPtr = envVarsBase;
      3	  10154       char tempSearchString[kMaxEnvVarLen];
      3	  10155 
      3	  10156       /* Put the search into canonical form */
      3	  10157       strcpy(tempSearchString, string);
      3	  10158       sst1InitToLower(tempSearchString);
      3	  10159 
      4	  10160       while(envVarsPtr) {
      5	  10161         if(!strcmp(tempSearchString, envVarsPtr->envVariable)) {
      5	  10162           retVal = envVarsPtr->envValue;
      5	  10163           break;
      4	  10164         }
      4	  10165         envVarsPtr = (sst1InitEnvVarStruct *) envVarsPtr->nextVar;
      3	  10166       }
      2	  10167     }
      1	  10168   }
      1	  10169 
      1	  10170   return (char*)retVal;
      1	  10171 }


Command Line
------- ----

CC/DEBUG/NOOP/LIST=[.OUT.DEBUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]PARSE/OBJECT=[.OUT.DE
BUG.OBJ.GLIDE.GLIDE2X.CVG.INIT]PARSE.OBJ/INCLUDE_DIRECTORY=([.GLIDE.SWLIBS.FXMI
SC],[.GLIDE.GLIDE2X.CVG.INCSRC],[.GLIDE.GLIDE2X.CVG.GLIDE.SRC],[.GLIDE.GLIDE2X.
CVG.INIT],[.GLIDE.SWLIBS.NEWPCI.PCILIB])/DEFINE=(CVG,GLIDE_USE_C_TRISETUP,GLIDE
_HW_TRI_SETUP=1,GLIDE_TRI_CULLING=1,GLIDE_DEFAULT_GAMMA=1.3F,GLIDE_LIB=1) [.GLI
DE.GLIDE2X.CVG.INIT]PARSE.C

Hardware: /ARCHITECTURE=GENERIC /OPTIMIZE=TUNE=GENERIC

These macros are in effect at the start of the compilation.
----- ------ --- -- ------ -- --- ----- -- --- ------------

 __G_FLOAT=1  __DECC=1  vms=1  VMS=1  __32BITS=1  __PRAGMA_ENVIRONMENT=1 
 __CRTL_VER=80400000  __vms_version="V8.4-2L1"  CC$gfloat=1  __X_FLOAT=1 
 GLIDE_HW_TRI_SETUP=1  GLIDE_USE_C_TRISETUP=1  vms_version="V8.4-2L1" 
 __DATE__="May  9 2021"  __STDC_VERSION__=199901L  __DECC_MODE_RELAXED=1 
 __DECC_VER=70490002  __VMS=1  GLIDE_DEFAULT_GAMMA=1.3F  GLIDE_LIB=1 
 __ALPHA=1  VMS_VERSION="V8.4-2L1"  __IEEE_FLOAT=0  __VMS_VERSION="V8.4-2L1" 
 __TIME__="23:43:18"  __Alpha_AXP=1  __VMS_VER=80421222 

PARSE                           Source Listing                   9-MAY-2021 23:43:18  VSI C V7.4-002-50R2O              Page 34
V1.0                                                             9-MAY-2021 05:19:40  parse.c;6

 __BIASED_FLT_ROUNDS=2  CVG=1  __INITIAL_POINTER_SIZE=0  __STDC__=2 
 __LANGUAGE_C__=1  __vms=1  __alpha=1  __D_FLOAT=0  GLIDE_TRI_CULLING=1 

